IA-32 インテル
R アーキテクチャ ?
ソフトウェア ? デベロッパーズ ?
マニュアル
中巻：
命令セット・リファレンス
注記：
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル』は、
次の3 巻から構成されています。
上巻：基本アーキテクチャ（資料番号245470J)
中巻：命令セット・リファレンス（資料番号245471J)
下巻：システム・プログラミング・ガイド（資料番号245472J)
設計する際は、これら3 巻すべてを参照してください。
2002
【輸出規制に関する告知と注意事項】
本資料に掲載されている製品のうち、外国為替および外国為替管理法に定める戦略物資等または役務に該当するもの
については、輸出または再輸出する場合、同法に基づく日本政府の輸出許可が必要です。また、米国産品である当社
製品は日本からの輸出または再輸出に際し、原則として米国政府の事前許可が必要です。
【資料内容に関する注意事項】
・ 本ドキュメントの内容を予告なしに変更することがあります。
・インテルでは、この資料に掲載された内容について、市販製品に使用した場合の保証あるいは特別な目的に合うこ
との保証等は、いかなる場合についてもいたしかねます。また、このドキュメント内の誤りについても責任を負いか
ねる場合があります。
・インテルでは、インテル製品の内部回路以外の使用にて責任を負いません。また、外部回路の特許についても関知
いたしません。
・本書の情報はインテル製品を使用できるようにする目的でのみ記載されています。
インテルは、製品について「取引条件」で提示されている場合を除き、インテル製品の販売や使用に関して、いかな
る特許または著作権の侵害をも含み、あらゆる責任を負わないものとします。
・いかなる形および方法によっても、インテルの文書による許可なく、この資料の一部またはすべてを複写すること
は禁じられています。
インテル、Intel ロゴ、Intel386、Intel486、Celeron、MMX、OverDrive、Pentium、NetBurst、Xeon は、アメリカ合衆国および
その他の国におけるIntel Corporation またはその子会社の商標、登録商標です。
c 1997-2003 Intel Corporation
※一般にブランド名または商品名は、各社の商標または登録商標です。
i
目次
第 1 章
本書について
1.1. 本書の対象となるIA-32 プロセッサ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-1
1.2. 『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・
マニュアル、中巻：命令セット・リファレンス・マニュアル』の概要 . . . . . . . . . 1-1
1.3. 『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・
マニュアル、上巻：基本アーキテクチャ』の概要 . . . . . . . . . . . . . . . . . . . . . . . . . 1-2
1.4. 『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・
マニュアル、下巻：システム・プログラミング・ガイド』の概要 . . . . . . . . . . . . 1-4
1.5. 表記法 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6
1.5.1. ビット・オーダとバイト・オーダ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6
1.5.2. 予約ビットとソフトウェア互換性 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6
1.5.3. 命令オペランド . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-7
1.5.4. 16進数と2 進数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-7
1.5.5. セグメント化アドレス指定 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-8
1.5.6. 例外 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-8
1.6. 参考文献 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-9
1.7. 参考URL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-9
第 2 章
命令フォーマット
2.1. 一般的命令フォーマット . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-1
2.2. 命令プリフィックス . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-1
2.3. オペコード . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-3
2.4. ModR/M およびSIB バイト . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-3
2.5. ディスプレースメント・バイトと即値バイト . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-4
2.6. ModR/M およびSIB バイトのアドレス指定モードのコード化 . . . . . . . . . . . . . . . . 2-4
第 3 章
命令セット・リファレンス
3.1. 命令リファレンス・ページの読み方 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1
3.1.1. 命令フォーマット . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1
3.1.1.1. オペコード欄 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-1
3.1.1.2. 命令欄 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-2
3.1.1.3. 説明欄 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-5
3.1.1.4. 説明 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-5
3.1.2. 操作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-5
3.1.3. インテルC/C++ コンパイラ組み込み関数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-8
3.1.3.1. 組み込み関数のAPI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-8
3.1.3.2. MMXR テクノロジ組み込み関数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-8
3.1.3.3. SSEおよびSSE 2 の組み込み関数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-9
3.1.4. 影響を受けるフラグ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-10
3.1.5. 影響を受けるFPU フラグ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-11
3.1.6. 保護モード例外 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-11
3.1.7. 実アドレス・モード例外 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-12
3.1.8. 仮想8086 モード例外 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-13
3.1.9. 浮動小数点例外 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-13
3.1.10. SIMD 浮動小数点例外 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-13
3.2. 命令リファレンス . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-14
目次
ii
AAA?ASCII Adjust After Addition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-15
AAD?ASCII Adjust AX Before Division . . . . . . . . . . . . . . . . . . . . . . . . . 3-16
AAM?ASCII Adjust AX After Multiply . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-17
AAS?ASCII Adjust AL After Subtraction . . . . . . . . . . . . . . . . . . . . . . . . 3-18
ADC?Add with Carry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-19
ADD?Add . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21
ADDPD?Add Packed Double-Precision Floating-Point Values . . . . . . . 3-23
ADDPS?Add Packed Single-Precision Floating-Point Values . . . . . . . 3-25
ADDSD?Add Scalar Double-Precision Floating-Point Values . . . . . . . . 3-27
ADDSS?Add Scalar Single-Precision Floating-Point Values . . . . . . . . 3-29
AND?Logical AND . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-31
ANDPD?Bitwise Logical AND of Packed Double-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-33
ANDPS?Bitwise Logical AND of Packed Single-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-35
ANDNPD?Bitwise Logical AND NOT of Packed Double-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-37
ANDNPS?Bitwise Logical AND NOT of Packed Single-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-39
ARPL?Adjust RPL Field of Segment Selector . . . . . . . . . . . . . . . . . . . . 3-41
BOUND?Check Array Index Against Bounds . . . . . . . . . . . . . . . . . . . . 3-43
BSF?Bit Scan Forward . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-45
BSR?Bit Scan Reverse . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-47
BSWAP?Byte Swap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-49
BT?Bit Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-50
BTC?Bit Test and Complement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-52
BTR?Bit Test and Reset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-54
BTS?Bit Test and Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-56
CALL?Call Procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-58
CBW/CWDE?Convert Byte to Word/Convert Word to Doubleword . . . 3-69
CDQ?Convert Double to Quad . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-70
CLC?Clear Carry Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-71
CLD?Clear Direction Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-72
CLFLUSH?Cache Line Flush . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-73
CLI?Clear Interrupt Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-75
CLTS?Clear Task-Switched Flag in CR0 . . . . . . . . . . . . . . . . . . . . . . . 3-77
CMC?Complement Carry Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-78
CMOVcc?Conditional Move . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-79
CMP?Compare Two Operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-83
CMPPD?Compare Packed Double-Precision Floating-Point Values . . 3-85
CMPPS?Compare Packed Single-Precision Floating-Point Values . . . 3-89
CMPS/CMPSB/CMPSW/CMPSD?Compare String Operands . . . . . . . 3-93
CMPSD?Compare Scalar Double-Precision Floating-Point Value . . . . 3-96
CMPSS?Compare Scalar Single-Precision Floating-Point Values . . . 3-100
CMPXCHG?Compare and Exchange . . . . . . . . . . . . . . . . . . . . . . . . . 3-104
CMPXCHG8B?Compare and Exchange 8 Bytes . . . . . . . . . . . . . . . . 3-106
COMISD?Compare Scalar Ordered Double-Precision
iii
目次
Floating-Point Values and Set EFLAGS . . . . . . . . . . . . . . . . . . . . . . . . 3-108
COMISS?Compare Scalar Ordered Single-Precision
Floating-Point Values and Set EFLAGS . . . . . . . . . . . . . . . . . . . . . . . . 3-111
CPUID?CPU Identification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-114
CVTDQ2PD?Convert Packed Doubleword Integers to
Packed Double-Precision Floating-Point Values . . . . . . . . . . . . . . . . . . 3-128
CVTDQ2PS?Convert Packed Doubleword Integers to
Packed Single-Precision Floating-Point Values . . . . . . . . . . . . . . . . . . 3-130
CVTPD2DQ?Convert Packed Double-Precision Floating-Point
Values to Packed Doubleword Integers . . . . . . . . . . . . . . . . . . . . . . . . 3-132
CVTPD2PI?Convert Packed Double-Precision Floating-Point to
Packed Doubleword Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-134
CVTPD2PS?Covert Packed Double-Precision Floating-Point
Values to Packed Single-Precision Floating-Point Values . . . . . . . . . . 3-136
CVTPI2PD?Convert Packed Doubleword Integers to Packed
Double-Precision Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . 3-138
CVTPI2PS?Convert Packed Doubleword Integers to Packed
Single-Precision Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . 3-140
CVTPS2DQ?Convert Packed Single-Precision Floating-Point
Values to Packed Doubleword Integers . . . . . . . . . . . . . . . . . . . . . . . . 3-142
CVTPS2PD?Covert Packed Single-Precision Floating-Point
Values to Packed Double-Precision Floating-Point Values . . . . . . . . . . 3-144
CVTPS2PI?Convert Packed Single-Precision Floating-Point
Values to Packed Doubleword Integers . . . . . . . . . . . . . . . . . . . . . . . . 3-146
CVTSD2SI?Convert Scalar Double-Precision Floating-Point
Value to Doubleword Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-148
CVTSD2SS?Convert Scalar Double-Precision Floating-Point
Value to Scalar Single-Precision Floating-Point Value . . . . . . . . . . . . . 3-150
CVTSI2SD?Convert Doubleword Integer to Scalar
Double-Precision Floating-Point Value . . . . . . . . . . . . . . . . . . . . . . . . . 3-152
CVTSI2SS?Convert Doubleword Integer to Scalar
Single-Precision Floating-Point Value . . . . . . . . . . . . . . . . . . . . . . . . . . 3-154
CVTSS2SD?Convert Scalar Single-Precision Floating-Point
Value to Scalar Double-Precision Floating-Point Value . . . . . . . . . . . . 3-156
CVTSS2SI?Convert Scalar Single-Precision Floating-Point
Value to Doubleword Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-158
CVTTPD2PI?Convert with Truncation Packed Double-Precision
Floating-Point Values to Packed Doubleword Integers . . . . . . . . . . . . . 3-160
CVTTPD2DQ?Convert with Truncation Packed Double-Precision
Floating-Point Values to Packed Doubleword Integers . . . . . . . . . . . . . 3-162
CVTTPS2DQ?Convert with Truncation Packed Single-Precision
Floating-Point Values to Packed Doubleword Integers . . . . . . . . . . . . . 3-164
CVTTPS2PI?Convert with Truncation Packed Single-Precision
Floating-Point Values to Packed Doubleword Integers . . . . . . . . . . . . . 3-166
CVTTSD2SI?Convert with Truncation Scalar Double-Precision
Floating-Point Value to Signed Doubleword Integer . . . . . . . . . . . . . . . 3-168
CVTTSS2SI?Convert with Truncation Scalar Single-Precision
目次
iv
Floating-Point Value to Doubleword Integer . . . . . . . . . . . . . . . . . . . . . 3-170
CWD/CDQ?Convert Word to Doubleword/Convert Doubleword
to Quadword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-172
CWDE?Convert Word to Doubleword . . . . . . . . . . . . . . . . . . . . . . . . . 3-173
DAA?Decimal Adjust AL after Addition . . . . . . . . . . . . . . . . . . . . . . . . 3-174
DAS?Decimal Adjust AL after Subtraction . . . . . . . . . . . . . . . . . . . . . 3-176
DEC?Decrement by 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-177
DIV?Unsigned Divide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-179
DIVPD?Divide Packed Double-Precision Floating-Point Values . . . . . 3-182
DIVPS?Divide Packed Single-Precision Floating-Point Values . . . . . 3-184
DIVSD?Divide Scalar Double-Precision Floating-Point Values . . . . . . 3-186
DIVSS?Divide Scalar Single-Precision Floating-Point Values . . . . . . 3-188
EMMS?Empty MMX State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-190
ENTER?Make Stack Frame for Procedure Parameters . . . . . . . . . . . 3-191
F2XM1?Compute 2x?1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-194
FABS?Absolute Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-196
FADD/FADDP/FIADD?Add . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-198
FBLD?Load Binary Coded Decimal . . . . . . . . . . . . . . . . . . . . . . . . . . 3-201
FBSTP?Store BCD Integer and Pop . . . . . . . . . . . . . . . . . . . . . . . . . . 3-203
FCHS?Change Sign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-206
FCLEX/FNCLEX?Clear Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . 3-208
FCMOVcc?Floating-Point Conditional Move . . . . . . . . . . . . . . . . . . . . 3-210
FCOM/FCOMP/FCOMPP?Compare Floating Point Values . . . . . . . . 3-212
FCOMI/FCOMIP/ FUCOMI/FUCOMIP?Compare Floating Point
Values and Set EFLAGS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-215
FCOS?Cosine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-218
FDECSTP?Decrement Stack-Top Pointer . . . . . . . . . . . . . . . . . . . . . 3-220
FDIV/FDIVP/FIDIV?Divide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-221
FDIVR/FDIVRP/FIDIVR?Reverse Divide . . . . . . . . . . . . . . . . . . . . . . 3-225
FFREE?Free Floating-Point Register . . . . . . . . . . . . . . . . . . . . . . . . . 3-229
FICOM/FICOMP?Compare Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-230
FILD?Load Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-232
FINCSTP?Increment Stack-Top Pointer . . . . . . . . . . . . . . . . . . . . . . . 3-234
FINIT/FNINIT?Initialize Floating-Point Unit . . . . . . . . . . . . . . . . . . . . . 3-235
FIST/FISTP?Store Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-237
FLD?Load Floating Point Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-240
FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ?Load
Constant . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-242
FLDCW?Load x87 FPU Control Word . . . . . . . . . . . . . . . . . . . . . . . . 3-244
FLDENV?Load x87 FPU Environment . . . . . . . . . . . . . . . . . . . . . . . . 3-246
FMUL/FMULP/FIMUL?Multiply . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-248
FNOP?No Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-251
FPATAN?Partial Arctangent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-252
FPREM?Partial Remainder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-254
FPREM1?Partial Remainder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-257
FPTAN?Partial Tangent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-260
FRNDINT?Round to Integer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-262
v
目次
FRSTOR?Restore x87 FPU State . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-263
FSAVE/FNSAVE?Store x87 FPU State . . . . . . . . . . . . . . . . . . . . . . . 3-265
FSCALE?Scale . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-268
FSIN?Sine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-270
FSINCOS?Sine and Cosine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-272
FSQRT?Square Root . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-274
FST/FSTP?Store Floating Point Value . . . . . . . . . . . . . . . . . . . . . . . . 3-276
FSTCW/FNSTCW?Store x87 FPU Control Word . . . . . . . . . . . . . . . . 3-279
FSTENV/FNSTENV?Store x87 FPU Environment . . . . . . . . . . . . . . . 3-281
FSTSW/FNSTSW?Store x87 FPU Status Word . . . . . . . . . . . . . . . . . 3-284
FSUB/FSUBP/FISUB?Subtract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-286
FSUBR/FSUBRP/FISUBR?Reverse Subtract . . . . . . . . . . . . . . . . . . . 3-289
FTST?TEST . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-292
FUCOM/FUCOMP/FUCOMPP?Unordered Compare Floating
Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-294
FWAIT?Wait . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-297
FXAM?Examine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-298
FXCH?Exchange Register Contents . . . . . . . . . . . . . . . . . . . . . . . . . . 3-300
FXRSTOR?Restore x87 FPU, MMX, SSE, and SSE2 State . . . . . . . . 3-302
FXSAVE?Save x87 FPU, MMX, SSE, and SSE2 State . . . . . . . . . . . 3-304
FXTRACT?Extract Exponent and Significand . . . . . . . . . . . . . . . . . . . 3-310
FYL2X?Compute y ? log2x . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-312
FYL2XP1?Compute y ? log2(x +1) . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-314
HLT?Halt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-316
IDIV?Signed Divide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-317
IMUL?Signed Multiply . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-320
IN?Input from Port . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-323
INC?Increment by 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-325
INS/INSB/INSW/INSD?Input from Port to String . . . . . . . . . . . . . . . . . 3-327
INT n/INTO/INT 3?Call to Interrupt Procedure . . . . . . . . . . . . . . . . . . 3-330
INVD?Invalidate Internal Caches . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-342
INVLPG?Invalidate TLB Entry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-343
IRET/IRETD?Interrupt Return . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-344
Jcc?Jump if Condition Is Met . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-352
JMP?Jump . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-356
LAHF?Load Status Flags into AH Register . . . . . . . . . . . . . . . . . . . . . 3-363
LAR?Load Access Rights Byte . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-364
LDMXCSR?Load MXCSR Register . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-367
LDS/LES/LFS/LGS/LSS?Load Far Pointer . . . . . . . . . . . . . . . . . . . . . 3-369
LEA?Load Effective Address . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-372
LEAVE?High Level Procedure Exit . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-374
LES?Load Full Pointer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-376
LFENCE?Load Fence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-377
LFS?Load Full Pointer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-378
LGDT/LIDT?Load Global/Interrupt Descriptor Table Register . . . . . . . 3-379
LGS?Load Full Pointer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-381
LLDT?Load Local Descriptor Table Register . . . . . . . . . . . . . . . . . . . 3-382
目次
vi
LIDT?Load Interrupt Descriptor Table Register . . . . . . . . . . . . . . . . . 3-384
LMSW?Load Machine Status Word . . . . . . . . . . . . . . . . . . . . . . . . . . 3-385
LOCK?Assert LOCK# Signal Prefix . . . . . . . . . . . . . . . . . . . . . . . . . . 3-387
LODS/LODSB/LODSW/LODSD?Load String . . . . . . . . . . . . . . . . . . . 3-389
LOOP/LOOPcc?Loop According to ECX Counter . . . . . . . . . . . . . . . . 3-392
LSL?Load Segment Limit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-394
LSS?Load Full Pointer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-397
LTR?Load Task Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-398
MASKMOVDQU?Store Selected Bytes of Double Quadword . . . . . . 3-400
MASKMOVQ?Store Selected Bytes of Quadword . . . . . . . . . . . . . . . 3-402
MAXPD?Return Maximum Packed Double-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-405
MAXPS?Return Maximum Packed Single-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-407
MAXSD?Return Maximum Scalar Double-Precision
Floating-Point Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-409
MAXSS?Return Maximum Scalar Single-Precision
Floating-Point Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-411
MFENCE?Memory Fence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-413
MINPD?Return Minimum Packed Double-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-414
MINPS?Return Minimum Packed Single-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-416
MINSD?Return Minimum Scalar Double-Precision
Floating-Point Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-418
MINSS?Return Minimum Scalar Single-Precision
Floating-Point Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-420
MOV?Move . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-422
MOV?Move to/from Control Registers . . . . . . . . . . . . . . . . . . . . . . . . 3-427
MOV?Move to/from Debug Registers . . . . . . . . . . . . . . . . . . . . . . . . . 3-429
MOVAPD?Move Aligned Packed Double-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-431
MOVAPS?Move Aligned Packed Single-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-433
MOVD?Move Doubleword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-435
MOVDQA?Move Aligned Double Quadword . . . . . . . . . . . . . . . . . . . . 3-437
MOVDQU?Move Unaligned Double Quadword . . . . . . . . . . . . . . . . . 3-439
MOVDQ2Q?Move Quadword from XMM to MMX Register . . . . . . . . 3-441
MOVHLPS?Move Packed Single-Precision Floating-Point
Values High to Low . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-442
MOVHPD?Move High Packed Double-Precision Floating-Point
Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-443
MOVHPS?Move High Packed Single-Precision Floating-Point
Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-445
MOVLHPS?Move Packed Single-Precision Floating-Point
Values Low to High . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-447
MOVLPD?Move Low Packed Double-Precision Floating-Point
vii
目次
Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-448
MOVLPS?Move Low Packed Single-Precision Floating-Point
Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-450
MOVMSKPD?Extract Packed Double-Precision Floating-Point
Sign Mask . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-452
MOVMSKPS?Extract Packed Single-Precision Floating-Point
Sign Mask . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-453
MOVNTDQ?Store Double Quadword Using Non-Temporal Hint . . . . 3-454
MOVNTI?Store Doubleword Using Non-Temporal Hint . . . . . . . . . . . 3-456
MOVNTPD?Store Packed Double-Precision Floating-Point
Values Using Non-Temporal Hint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-458
MOVNTPS?Store Packed Single-Precision Floating-Point
Values Using Non-Temporal Hint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-460
MOVNTQ?Store of Quadword Using Non-Temporal Hint . . . . . . . . . . 3-462
MOVQ?Move Quadword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-464
MOVQ2DQ?Move Quadword from MMX to XMM Register . . . . . . . . . 3-466
MOVS/MOVSB/MOVSW/MOVSD?Move Data from String to String . . 3-467
MOVSD?Move Scalar Double-Precision Floating-Point Value . . . . . . 3-470
MOVSS?Move Scalar Single--Precision Floating-Point Values . . . . . 3-472
MOVSX?Move with Sign-Extension . . . . . . . . . . . . . . . . . . . . . . . . . . 3-474
MOVUPD?Move Unaligned Packed Double-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-475
MOVUPS?Move Unaligned Packed Single-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-477
MOVZX?Move with Zero-Extend . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-479
MUL?Unsigned Multiply . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-480
MULPD?Multiply Packed Double-Precision Floating-Point Values . . . 3-482
MULPS?Multiply Packed Single-Precision Floating-Point Values . . . . 3-484
MULSD?Multiply Scalar Double-Precision Floating-Point Values . . . . 3-486
MULSS?Multiply Scalar Single-Precision Floating-Point Values . . . . . 3-488
NEG?Two's Complement Negation . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-490
NOP?No Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-492
NOT?One's Complement Negation . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-493
OR?Logical Inclusive OR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-495
ORPD?Bitwise Logical OR of Packed Double-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-497
ORPS?Bitwise Logical OR of Packed Single-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-499
OUT?Output to Port . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-501
OUTS/OUTSB/OUTSW/OUTSD?Output String to Port . . . . . . . . . . . . 3-503
PACKSSWB/PACKSSDW?Pack with Signed Saturation . . . . . . . . . . 3-506
PACKUSWB?Pack with Unsigned Saturation . . . . . . . . . . . . . . . . . . . 3-510
PADDB/PADDW/PADDD?Add Packed Integers . . . . . . . . . . . . . . . . . 3-513
PADDQ?Add Packed Quadword Integers . . . . . . . . . . . . . . . . . . . . . . 3-516
PADDSB/PADDSW?Add Packed Signed Integers with
Signed Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-518
PADDUSB/PADDUSW?Add Packed Unsigned Integers with
目次
viii
Unsigned Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-521
PAND?Logical AND . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-524
PANDN?Logical AND NOT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-526
PAUSE?Spin Loop Hint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-528
PAVGB/PAVGW?Average Packed Integers . . . . . . . . . . . . . . . . . . . . 3-529
PCMPEQB/PCMPEQW/PCMPEQD?Compare Packed Data for
Equal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-532
PCMPGTB/PCMPGTW/PCMPGTD?Compare Packed Signed
Integers for Greater Than . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-536
PEXTRW?Extract Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-540
PINSRW?Insert Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-542
PMADDWD?Multiply and Add Packed Integers . . . . . . . . . . . . . . . . . 3-545
PMAXSW?Maximum of Packed Signed Word Integers . . . . . . . . . . . 3-548
PMAXUB?Maximum of Packed Unsigned Byte Integers . . . . . . . . . . 3-551
PMINSW?Minimum of Packed Signed Word Integers . . . . . . . . . . . . 3-554
PMINUB?Minimum of Packed Unsigned Byte Integers . . . . . . . . . . . 3-557
PMOVMSKB?Move Byte Mask . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-560
PMULHUW?Multiply Packed Unsigned Integers and Store
High Result . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-562
PMULHW?Multiply Packed Signed Integers and Store High Result . . 3-565
PMULLW?Multiply Packed Signed Integers and Store Low Result . . 3-568
PMULUDQ?Multiply Packed Unsigned Doubleword Integers . . . . . . . 3-571
POP?Pop a Value from the Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-573
POPA/POPAD?Pop All General-Purpose Registers . . . . . . . . . . . . . . 3-578
POPF/POPFD?Pop Stack into EFLAGS Register . . . . . . . . . . . . . . . 3-580
POR?Bitwise Logical OR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-583
PREFETCHh?Prefetch Data Into Caches . . . . . . . . . . . . . . . . . . . . . . 3-585
PSADBW?Compute Sum of Absolute Differences . . . . . . . . . . . . . . . 3-587
PSHUFD?Shuffle Packed Doublewords . . . . . . . . . . . . . . . . . . . . . . . 3-590
PSHUFHW?Shuffle Packed High Words . . . . . . . . . . . . . . . . . . . . . . 3-592
PSHUFLW?Shuffle Packed Low Words . . . . . . . . . . . . . . . . . . . . . . . 3-594
PSHUFW?Shuffle Packed Words . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-596
PSLLDQ?Shift Double Quadword Left Logical . . . . . . . . . . . . . . . . . . 3-598
PSLLW/PSLLD/PSLLQ?Shift Packed Data Left Logical . . . . . . . . . . . 3-599
PSRAW/PSRAD?Shift Packed Data Right Arithmetic . . . . . . . . . . . . . 3-603
PSRLDQ?Shift Double Quadword Right Logical . . . . . . . . . . . . . . . . . 3-607
PSRLW/PSRLD/PSRLQ?Shift Packed Data Right Logical . . . . . . . . . 3-608
PSUBB/PSUBW/PSUBD?Subtract Packed Integers . . . . . . . . . . . . . 3-613
PSUBQ?Subtract Packed Quadword Integers . . . . . . . . . . . . . . . . . . 3-616
PSUBSB/PSUBSW?Subtract Packed Signed Integers with
Signed Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-618
PSUBUSB/PSUBUSW?Subtract Packed Unsigned Integers with
Unsigned Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-621
PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ?
Unpack High Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-624
PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ?
Unpack Low Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-628
ix
目次
PUSH?Push Word or Doubleword onto the Stack . . . . . . . . . . . . . . . 3-632
PUSHA/PUSHAD?Push All General-Purpose Registers . . . . . . . . . . . 3-635
PUSHF/PUSHFD?Push EFLAGS Register onto the Stack . . . . . . . . . 3-637
PXOR?Logical Exclusive OR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-639
RCL/RCR/ROL/ROR?Rotate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-641
RCPPS?Compute Reciprocals of Packed Single-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-645
RCPSS?Compute Reciprocal of Scalar Single-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-647
RDMSR?Read from Model Specific Register . . . . . . . . . . . . . . . . . . . 3-649
RDPMC?Read Performance-Monitoring Counters . . . . . . . . . . . . . . . 3-651
RDTSC?Read Time-Stamp Counter . . . . . . . . . . . . . . . . . . . . . . . . . . 3-653
REP/REPE/REPZ/REPNE /REPNZ?Repeat String Operation
Prefix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-654
RET?Return from Procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-657
ROL/ROR?Rotate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-663
RSM?Resume from System Management Mode . . . . . . . . . . . . . . . . 3-664
RSQRTPS?Compute Reciprocals of Square Roots of Packed
Single-Precision Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . 3-665
RSQRTSS?Compute Reciprocal of Square Root of Scalar
Single-Precision Floating-Point Value . . . . . . . . . . . . . . . . . . . . . . . . . . 3-667
SAHF?Store AH into Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-669
SAL/SAR/SHL/SHR?Shift . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-670
SBB?Integer Subtraction with Borrow . . . . . . . . . . . . . . . . . . . . . . . . . 3-674
SCAS/SCASB/SCASW/SCASD?Scan String . . . . . . . . . . . . . . . . . . . 3-676
SETcc?Set Byte on Condition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-679
SFENCE?Store Fence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-682
SGDT/SIDT?Store Global/Interrupt Descriptor Table Register . . . . . . 3-683
SHL/SHR?Shift Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-685
SHLD?Double Precision Shift Left . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-686
SHRD?Double Precision Shift Right . . . . . . . . . . . . . . . . . . . . . . . . . . 3-688
SHUFPD?Shuffle Packed Double-Precision Floating-Point Values . . 3-690
SHUFPS?Shuffle Packed Single-Precision Floating-Point Values . . . 3-693
SIDT?Store Interrupt Descriptor Table Register . . . . . . . . . . . . . . . . . 3-696
SLDT?Store Local Descriptor Table Register . . . . . . . . . . . . . . . . . . . 3-697
SMSW?Store Machine Status Word . . . . . . . . . . . . . . . . . . . . . . . . . . 3-699
SQRTPD?Compute Square Roots of Packed Double-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-701
SQRTPS?Compute Square Roots of Packed Single-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-703
SQRTSS?Compute Square Root of Scalar Single-Precision
Floating-Point Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-707
STC?Set Carry Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-709
STD?Set Direction Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-710
STI?Set Interrupt Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-711
STMXCSR?Store MXCSR Register State . . . . . . . . . . . . . . . . . . . . . . 3-713
STOS/STOSB/STOSW/STOSD?Store String . . . . . . . . . . . . . . . . . . . 3-715
目次
x
STR?Store Task Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-718
SUB?Subtract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-719
SUBPD?Subtract Packed Double-Precision Floating-Point Values . . 3-721
SUBPS?Subtract Packed Single-Precision Floating-Point Values . . . 3-723
SUBSD?Subtract Scalar Double-Precision Floating-Point Values . . . 3-725
SUBSS?Subtract Scalar Single-Precision Floating-Point Values . . . . 3-727
SYSENTER?Fast System Call . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-729
SYSEXIT?Fast Return from Fast System Call . . . . . . . . . . . . . . . . . . 3-733
TEST?Logical Compare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-736
UCOMISD?Unordered Compare Scalar Double-Precision
Floating-Point Values and Set EFLAGS . . . . . . . . . . . . . . . . . . . . . . . . 3-738
UCOMISS?Unordered Compare Scalar Single-Precision
Floating-Point Values and Set EFLAGS . . . . . . . . . . . . . . . . . . . . . . . . 3-740
UD2?Undefined Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-742
UNPCKHPD?Unpack and Interleave High Packed
Double-Precision Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . 3-743
UNPCKHPS?Unpack and Interleave High Packed
Single-Precision Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . 3-745
UNPCKLPD?Unpack and Interleave Low Packed
Double-Precision Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . 3-747
UNPCKLPS?Unpack and Interleave Low Packed
Single-Precision Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . 3-749
VERR, VERW?Verify a Segment for Reading or Writing . . . . . . . . . . 3-751
WAIT/FWAIT?Wait . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-753
WBINVD?Write Back and Invalidate Cache . . . . . . . . . . . . . . . . . . . . 3-754
WRMSR?Write to Model Specific Register . . . . . . . . . . . . . . . . . . . . . 3-756
XADD?Exchange and Add . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-758
XCHG?Exchange Register/Memory with Register . . . . . . . . . . . . . . . 3-760
XLAT/XLATB?Table Look-up Translation . . . . . . . . . . . . . . . . . . . . . . 3-762
XOR?Logical Exclusive OR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-764
XORPD?Bitwise Logical XOR for Double-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-766
XORPS?Bitwise Logical XOR for Single-Precision
Floating-Point Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-768
付録A
オペコード・マップ
A.1. 略語の説明 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-1
A.1.1. アドレス指定方式のコード . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-1
A.1.2. オペランド・タイプのコード . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-3
A.1.3. レジスタ・コード . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-3
A.2. オペコードの見つけ方の例 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-3
A.2.1. 1バイト・オペコード命令 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-4
A.2.2. 2バイト・オペコード命令 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-4
A.2.3. オペコード・マップの注意事項 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-5
A.2.4. 1バイトと2 バイトのオペコードのオペコード拡張 . . . . . . . . . . . . . . . . . . . . A-10
A.2.5. エスケープ・オペコード命令 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A-12
A.2.5.1. ModR/M バイトが00H 〜 BFH の範囲内にある場合のオペコード . . . . . . . A-12
xi
目次
A.2.5.2. ModR/M バイトが00H 〜 BFH の範囲外にある場合のオペコード . . . . . . . A-12
A.2.5.3. 第1 バイトとしてD8 をもつエスケープ・オペコード . . . . . . . . . . . . . . . . A-13
A.2.5.4. 第1 バイトとしてD9 をもつエスケープ・オペコード . . . . . . . . . . . . . . . . A-14
A.2.5.5. 第1 バイトとしてDA をもつエスケープ・オペコード . . . . . . . . . . . . . . . . A-15
A.2.5.6. 第1 バイトとしてDB をもつエスケープ・オペコード . . . . . . . . . . . . . . . . A-16
A.2.5.7. 第1 バイトとしてDC をもつエスケープ・オペコード . . . . . . . . . . . . . . . . A-17
A.2.5.8. 第1 バイトとしてDD をもつエスケープ・オペコード . . . . . . . . . . . . . . . . A-18
A.2.5.9. 第1 バイトとしてDE をもつエスケープ・オペコード . . . . . . . . . . . . . . . . A-19
A.2.5.10. 第1 バイトとしてDF をもつエスケープ・オペコード . . . . . . . . . . . . . . . . A-20
付録B
命令フォーマットおよびエンコーディング
B.1. マシン命令フォーマット . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B-1
B.1.1. regフィールド(reg) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B-2
B.1.2. オペランド・サイズ・ビット(w) のエンコーディング . . . . . . . . . . . . . . . . . . . B-3
B.1.3. 符号拡張(s) ビット . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B-3
B.1.4. セグメント・レジスタ・フィールド(sreg) . . . . . . . . . . . . . . . . . . . . . . . . . . . . B-4
B.1.5. 特殊目的レジスタ(eee) フィールド . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B-4
B.1.6. 条件テスト・フィールド(tttn) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B-5
B.1.7. 方向(d) ビット . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B-5
B.2. 汎用命令のフォーマットおよびエンコーディング . . . . . . . . . . . . . . . . . . . . . . . . . B-6
B.3. MMX 命令のフォーマットおよびエンコーディング . . . . . . . . . . . . . . . . . . . . . . . B-19
B.3.1. グラニュラリティ・フィールド(gg) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B-19
B.3.2. MMXR テクノロジおよび汎用レジスタ・フィールド(mmxreg およびreg) . . B-19
B.3.3. MMXR 命令のフォーマットおよびエンコーディングの表 . . . . . . . . . . . . . . . . B-19
B.4. P6 ファミリ命令のフォーマットとエンコーディング . . . . . . . . . . . . . . . . . . . . . B-22
B.5. SSE 命令のフォーマットとエンコーディング . . . . . . . . . . . . . . . . . . . . . . . . . . . B-23
B.6. SSE2 命令のフォーマットとエンコーディング . . . . . . . . . . . . . . . . . . . . . . . . . . B-31
B.6.1. グラニュラリティ・フィールド(gg) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B-31
B.7. 浮動小数点命令のフォーマットおよびエンコーディング . . . . . . . . . . . . . . . . . . . B-45
付録C
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
C.1. 簡単な組み込み関数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C-3
C.2. 複合組み込み関数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C-23
目次
xii
xiii
図目次
図1-1. ビット・オーダとバイト・オーダ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6
図2-1. IA-32 プロセッサの命令フォーマット . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-1
図3-1. BIT[EAX,21] のビット・オフセット . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-7
図3-2. メモリ・ビットのインデックス操作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-11
図3-3. EAX レジスタのバージョン情報 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-116
図3-4. EDX レジスタの機能情報 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-118
図3-5. 64 ビット・オペランドを使用してのPACKSSDW 命令の操作 . . . . . . . . 3-506
図3-6. 64 ビット・オペランドを使用したPMADDWD 実行モデル . . . . . . . . . . . 3-545
図3-7. 64 ビット・オペランドを使用したPMULHUW 命令および
PMULHW 命令の動作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-562
図3-8. 64 ビット・オペランドを使用したPMULLW 命令の動作 . . . . . . . . . . . . 3-568
図3-9. 64 ビット・オペランドを使用したPSADBW 命令の操作 . . . . . . . . . . . . 3-587
図3-10. PSHUFD 命令の操作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-590
図3-11. 64 ビット・オペランドを使用したPSLLW 命令、PSLLD 命令、
PSLLQ 命令の動作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-600
図3-12. 64 ビット・オペランドを使用したPSRAW 命令とPSRAD 命令の動作 . 3-603
図3-13. 64 ビット・オペランドを使用したPSRLW 命令、PSRLD 命令、
PSRLQ 命令の動作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-609
図3-14. 64 ビット・オペランドを使用したPUNPCKHBW 命令の動作 . . . . . . . . 3-624
図3-15. 64 ビット・オペランドを使用したPUNPCKLBW 命令の動作 . . . . . . . . . 3-628
図3-16. SHUFPD のシャッフル操作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-690
図3-17. SHUFPS 命令の動作 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-693
図3-18. UNPCKHPD 命令の上位アンパックとインタリーブ操作 . . . . . . . . . . . . . 3-743
図3-19. UNPCKHPS 命令の上位アンパックとインタリーブ操作 . . . . . . . . . . . . . 3-745
図3-20. UNPCKLPD 命令の下位アンパックとインタリーブ操作 . . . . . . . . . . . . . 3-747
図3-21. UNPCKLPS 命令の下位アンパックとインタリーブ操作 . . . . . . . . . . . . . 3-749
図A-1. ModR/M バイトのnnn フィールド( ビット5、4、3) . . . . . . . . . . . . . . . . . A-10
図B-1. 汎用マシン命令フォーマット . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B-1
図目次
xiv
xv
表目次
表2-1. ModR/M バイトによる16 ビット・アドレス指定形式 ............................................ 2-5
表2-2. ModR/M バイトによる32 ビット・アドレス指定形式 ............................................ 2-6
表2-3. SIB バイトによる32 ビット・アドレス指定形式 .................................................... 2-7
表3-1. +rb、+rw、および+rd に対応するレジスタのコード化 ........................................... 3-2
表3-2. IA-32 の一般例外 .................................................................................................... 3-12
表3-3. x87 FPU の浮動小数点例外 .................................................................................... 3-13
表3-4. SIMD 浮動小数点例外 ............................................................................................ 3-14
表3-5. CMPPD 命令とCMPPS 命令の比較プレディケート ............................................. 3-85
表3-6. CPUID 命令から返される情報 ............................................................................. 3-115
表3-7. IA-32 プロセッサに対するCPUID 命令のソース・オペランドの最大値 ............. 3-116
表3-8. プロセッサ・タイプ・フィールド ....................................................................... 3-117
表3-9. EDX レジスタに返されるCPUID 機能フラグ ...................................................... 3-119
表3-10. キャッシュおよびTLB 記述子のコード化 ........................................................... 3-121
表3-11. ブランド・インデックスとIA-32 プロセッサ・ブランド・ストリングの
対応関係 ............................................................................................................... 3-124
表3-12. 最初のPentiumR 4 プロセッサに関して返されるプロセッサ・ブランド・
ストリング ........................................................................................................... 3-125
表3-13. FXSAVE とFXRSTOR メモリ領域のレイアウト ................................................ 3-304
表3-14. SYSENTER 命令およびSYSEXIT 命令によって使用されるMSR ...................... 3-729
表A-1. 命令セット・エンコーディング表についての注意事項 .......................................... A-5
表A-2. 1 バイトのオペコード・マップ( 左側) .................................................................. A-6
表A-3. 1 バイトのオペコード・マップ( 右側) .................................................................. A-7
表A-4. 2 バイトのオペコード・マップ( 左側)( 第1 バイトは0FH) ................................. A-8
表A-5. 2 バイトのオペコード・マップ( 右側)( 第1 バイトは0FH) ................................. A-9
表A-6. グループ番号による1 バイトと2 バイトのオペコードのオペコード拡張 ........... A-11
表A-7. ModR/M バイトが00H 〜 BFH 内にあるときのD8 オペコード・マップ1 .......... A-13
表A-8. ModR/M バイトが00H 〜 BFH 外にあるときのD8 オペコード・マップ1 .......... A-13
表A-9. ModR/M バイトが00H 〜 BFH 内にあるときのD9 オペコード・マップ1 .......... A-14
表A-10. ModR/M バイトが00H 〜 BFH 外にあるときのD9 オペコード・マップ1 .......... A-14
表A-11. ModR/M バイトが00H 〜 BFH 内にあるときのDA オペコード・マップ1 ......... A-15
表A-12. ModR/M バイトが00H 〜 BFH 外にあるときのDA オペコード・マップ1 ......... A-15
表A-13. ModR/M バイトが00H 〜 BFH 内にあるときのDB オペコード・マップ1 ......... A-16
表A-14. ModR/M バイトが00H 〜 BFH 外にあるときのDB オペコード・マップ1 ......... A-16
表A-15. ModR/M バイトが00H 〜 BFH 内にあるときのDC オペコード・マップ1 ......... A-17
表A-16. ModR/M バイトが00H 〜 BFH 外にあるときのDC オペコード・マップ1 ......... A-17
表A-17. ModR/M バイトが00H 〜 BFH 内にあるときのDD オペコード・マップ1 ......... A-18
表A-18. ModR/M バイトが00H 〜 BFH 外にあるときのDD オペコード・マップ1 ......... A-18
表A-19. ModR/M バイトが00H 〜 BFH 内にあるときのDE オペコード・マップ1 ......... A-19
表A-20. ModR/M バイトが00H 〜 BFH 外にあるときのDE オペコード・マップ1 ......... A-19
表A-21. ModR/M バイトが00H 〜 BFH 内にあるときのDF オペコード・マップ1 ......... A-20
表A-22. ModR/M バイトが00H 〜 BFH 外にあるときのDF オペコード・マップ1 ......... A-20
表B-1. 命令エンコーディング内の特殊フィールド ............................................................ B-2
表B-2. w フィールドが命令に存在していないときのreg フィールドのエンコーディング B-2
表B-3. w フィールドが命令に存在しているときのreg フィールドのエンコーディング ... B-3
表B-4. オペランド・サイズ(w) ビットのエンコーディング .............................................. B-3
表B-5. 符号拡張(s) ビットのエンコーディング ................................................................. B-3
表B-6. セグメント・レジスタ(sreg) フィールドのエンコーディング ............................... B-4
表B-7. 特殊目的レジスタ(eee) フィールドのエンコーディング ....................................... B-4
表B-8. 条件付きテスト(tttn) フィールドのエンコーディング ........................................... B-5
表B-9. 操作方向(d) ビットのエンコーディング ................................................................ B-6
表B-10. 汎用命令のフォーマットおよびエンコーディング ................................................. B-6
表B-11. データ・フィールドのグラニュラリティ(gg) のエンコーディング ..................... B-19
表B-12. MMXR 命令のフォーマットおよびエンコーディング ........................................... B-19
表B-13. P6 ファミリ命令のフォーマットとエンコーディング .......................................... B-22
表目次
xvi
表B-14. SSE SIMD 浮動小数点命令のフォーマットとエンコーディング ......................... B-23
表B-15. SSE SIMD 整数命令のフォーマットとエンコーディング .................................... B-29
表B-16. SSE キャッシュ可能/ メモリ順序付け命令のフォーマットとエンコーディング B-30
表B-17. データ・フィールドのグラニュラリティ(gg) のエンコーディング ..................... B-31
表B-18. SSE2 SIMD 浮動小数点命令のフォーマットとエンコーディング ....................... B-31
表B-19. SSE2 SIMD 整数命令のフォーマットとエンコーディング .................................. B-38
表B-20. SSE2 キャッシュ可能命令のフォーマットとエンコーディング .......................... B-44
表B-21. 汎用浮動小数点命令フォーマット ........................................................................ B-45
表B-22. 浮動小数点命令のフォーマットおよびエンコーディング .................................... B-46
表C-1. 簡単な組み込み関数 ................................................................................................ C-3
表C-2. 複合組み込み関数 .................................................................................................. C-23
1
本書について

1-1
第 1 章
本書について
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、中巻：命令セッ
ト・リファレンス』（資料番号 245471J）は、IA-32 インテル?プロセッサ全般のアーキテクチャとプ
ログラミング環境を説明している全3 巻のうちの1 巻である。他の2 巻を次に示す。
? 『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻：基本
アーキテクチャ』（資料番号 245470J）
? 『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、下巻：シス
テム・プログラミング・ガイド』（資料番号 245472J）
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル』の「上巻：基本
アーキテクチャ」は、IA-32 プロセッサの基本的なアーキテクチャとプログラミング環境について説
明している。「中巻：命令セット・リファレンス・マニュアル」は、プロセッサの命令セットとオペ
コードの構造について説明している。上巻と中巻は、既存のオペレーティング・システムやエグゼ
クティブの下で実行するプログラムを開発しているアプリケーション・プログラマを対象としてい
る。「下巻：システム・プログラミング・ガイド」は、IA-32 プロセッサのオペレーティング・シス
テム・サポート環境について説明している。これには、メモリ管理、保護、タスク管理、割り込み/
例外処理、システム管理モードの説明が含まれる。また、IA-32 プロセッサの互換性に関する情報も
掲載している。下巻が対象とするのは、オペレーティング・システムやBIOSの開発者ならびにプロ
グラマである。
1.1. 本書の対象となるIA -32 プロセッサ
本書には、主に最近のIA-32 プロセッサに関する情報が記載されている。これには、Pentium?プロ
セッサ、P6 ファミリ・プロセッサ、Pentium 4 プロセッサが含まれる。P6 ファミリ・プロセッサと
は、P6 ファミリ・マイクロアーキテクチャに基づくIA-32 プロセッサである。P6 ファミリには、
Pentium Pro プロセッサ、Pentium II プロセッサ、Pentium III プロセッサが含まれる。Pentium 4 プロセッ
サは、新しいインテル? NetBurst?マイクロアーキテクチャに基づくIA-32 プロセッサ・ファミリの
最初の製品である。
1.2. 『IA -32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、中巻：命令セット・リファレンス・マニュアル』
の概要
本書は、次の内容で構成されている。
第1 章 − 本書について。『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュ
アル』の3 巻それぞれの内容を簡単に説明する。また、これらのマニュアルで使用されている表記法
について説明するとともに、インテルのマニュアルやドキュメンテーションのなかでプログラマや
ハードウェア設計者に関係する関連資料を併記している。
1-2
本書について
第2 章 − 命令フォーマット。IA-32 の全命令が使用するマシン・レベル命令のフォーマットについ
て説明し、許可されるプレフィックスのエンコーディング、オペランド識別子バイト（ModR/M バ
イト）、アドレッシング・モード指示子バイト（SIBバイト）、ディスプレースメント・バイトと即値
バイトについても説明する。
第3 章 − 命令セット・リファレンス。IA-32 各命令を詳細に説明している。これには、演算アルゴ
リズムの説明、フラグの影響、オペランド・サイズとアドレス・サイズ属性の効果、および発生し
うる例外などを詳細に説明する。命令は、アルファベット順に記載している。汎用命令、x87 FPU命
令、MMXR命令、SSE、SSE2、システム命令の説明も本章に含まれる。
付録A − オペコード・マップ。IA-32 命令セットのオペコード・マップを示す。
付録B − 命令フォーマットおよびエンコーディング。IA-32 命令の各フォームのバイナリ・エンコー
ディングを示す。
付録C − 機能的に同等のインテルC/C++ コンパイラ組み込み関数。IA-32 MMX命令、SSE、および
SSE2のそれぞれと機能的に同等のインテルR C/C++コンパイラ組み込み関数およびアセンブリ・コー
ドを示す。
1.3. 『IA -32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻：基本アーキテクチャ』の概要
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』は以下の
内容で構成されている。
第1 章− 本書について。『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マ
ニュアル』の全3 巻それぞれの内容を簡単に説明する。また、これらのマニュアルで使用されている
表記法について説明するとともに、インテルのマニュアルやドキュメンテーションのなかでプログ
ラマやハードウェア設計者に関係する関連資料を併記している。
第2 章− IA-32 インテルR アーキテクチャの概説。IA-32 アーキテクチャと、このアーキテクチャ
を基礎とするインテル・プロセッサのファミリについて概説する。また、これらのプロセッサに見
られる共通の特徴や、IA-32 アーキテクチャの変遷について簡単に説明する。
第3 章− IA-32 基本実行環境。メモリ構成のモデルを概説するとともに、アプリケーション上で使
用するレジスタ・セットについて説明する。
第4 章− データ型。プロセッサが認識するデータ型とアドレス指定モードについて説明する。実数、
浮動小数点形式、および浮動小数点例外の概要も示す。
第5 章− 命令セットの要約。すべてのIA-32 アーキテクチャ命令の一覧を、テクノロジ・グループ
( 汎用命令、x87 FPU命令、MMX テクノロジ命令、ストリーミングSIMD拡張命令(SSE)、ストリー
ミングSIMD拡張命令2 (SSE2)、システム命令) ごとに分けて示す。各グループの命令は、機能的に
関連のあるグループごとに記載されている。
1-3
本書について
第6 章− プロシージャ・コール、割り込み、例外。プロシージャ・スタックと、プロシージャ・
コールの実行のメカニズム、割り込みと例外処理のメカニズムについて説明する。
第7 章− 汎用命令によるプログラミング。汎用レジスタおよびセグメント・レジスタ上で基本デー
タ型を操作する、基本的なロード命令とストア命令、プログラム制御命令、算術命令、ストリング
命令について説明する。プロテクト・モードで実行されるシステム命令についても説明する。
第8 章− x87 FPUによるプログラミング。x87 の浮動小数点ユニット（FPU）について説明し、浮
動小数点レジスタとデータ型、浮動小数点命令セット、プロセッサの浮動小数点例外条件について
説明する。
第9 章− インテルR MMXR テクノロジ・レジスタによるプログラミング。インテル MMXテクノ
ロジについて説明する。これには、MMXテクノロジ・レジスタとデータ型、MMX命令セットの概
要についての説明が含まれる。
第10 章− ストリーミングSIMD拡張命令 (SSE) によるプログラミング。SSE について説明する。
これには、XMMレジスタ、MXCSRレジスタ、パックド単精度浮動小数点データ型についての説明
が含まれる。また、SSE 命令セットの概要と、SSEにアクセスするコードを作成する際のガイドライ
ンについても説明する。
第11 章− ストリーミングSIMD拡張命令2 (SSE2) によるプログラミング。 SSE2 について説明す
る。これには、XMMレジスタ、パックド倍精度浮動小数点データ型についての説明が含まれる。ま
た、SSE2 の命令セットの概要と、SSE2 にアクセスするコードを作成する際のガイドラインについて
も説明する。この章では、SSE とSSE2 によって生成されるSIMD浮動小数点例外についても説明す
る。また、オペレーティング・システムとアプリケーション・コードにSSEとSSE2 のサポート機能
を組み込むための一般的なガイドラインを示す。
第12 章− 入出力。I/O ポートのアドレス指定、I/O命令、I/O保護メカニズムなど、プロセッサのI/O
アーキテクチャについて説明する。
第13 章− プロセッサの識別と機能の判定。プロセッサが備えているCPUタイプおよび機能を判定
する方法について説明する。
付録A − EFLAGSクロス・リファレンス。IA-32 の命令がEFLAGSレジスタの各フラグに及ぼす影
響を要約している。
付録B − EFLAGS条件コード。条件付きのジャンプ、移動、条件コード命令でのバイト・セットに
おいてEFLAGS レジスタの条件コード・フラグ（OF、CF、ZF、SF、PF）がどのように使用される
かを説明する。
付録C − 浮動小数点例外の要約。x87 FPU浮動小数点、SSEおよびSSE2 のSIMD 浮動小数点命令で
発生する例外を一覧で示す。
付録D − x87 FPU例外ハンドラを作成する際のガイドライン。FPU例外に対してMS-DOS* 互換の
例外処理機能を設計し開発する方法について説明する。これには、ソフトウェアとハードウェアの
要件、アセンブリ言語コードの例が含まれる。また、信頼性の高いFPU 例外ハンドラを開発するた
めの一般的な技法について説明する。
付録E − SIMD浮動小数点例外ハンドラを作成する際のガイドライン。SSE およびSSE2 の浮動小
数点命令で発生する例外と、これらの例外を処理する例外ハンドラを作成する際のガイドラインに
ついて説明する。
1-4
本書について
1.4. 『IA -32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、下巻：システム・プログラミング・ガイド』の
概要
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、下巻』は以下の
内容で構成されている。
第1 章 − 本書について。『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュ
アル』の3 巻それぞれの内容を簡単に説明する。また、これらのマニュアルで使用されている表記法
について説明するとともに、インテルのマニュアルやドキュメントのなかでプログラマやハード
ウェア設計者に関係する関連資料を併記している。
第2 章 − システム・アーキテクチャの概要。IA-32 プロセッサの動作モード、オペレーティング・シ
ステムやエグゼクティブをサポートするためIA-32 アーキテクチャに用意されているメカニズムに
ついて説明する。これには、システム関連のレジスタとデータ構造の説明や、システム関連の命令
の説明が含まれる。また、実アドレス・モードと保護モード間の切り替えに必要なステップについ
ても説明する。
第3 章 − 保護モードにおけるメモリ管理。セグメンテーションとページングをサポートするデータ
構造、レジスタ、命令について説明し、それらを使用して「フラット」（セグメント化されていない）
メモリ・モデルまたはセグメント化されたメモリ・モデルを使用する方法を説明する。
第4 章 − 保護。IA-32 アーキテクチャのページ保護とセグメント保護のサポートについて説明する。
この章はまた、特権規則、スタックの切り替え、ポインタの検証、およびユーザ・モードとスーパ
バイザ・モードの使用方法を説明する。
第5 章 − 割り込みと例外の処理。IA-32 アーキテクチャで定義されている基本的な割り込みメカニ
ズムについて説明し、割り込みや例外と保護との関係を示し、アーキテクチャが各例外タイプをど
のように処理するかについて説明する。章の最後には、それぞれのIA-32 の例外に対する参照情報を
掲載している。
第6 章 − タスク管理。マルチタスキングやタスク間保護を提供するためIA-32 アーキテクチャに用
意されているメカニズムについて説明する。
第7 章 − マルチ・プロセッサ管理。共有メモリ、メモリ・オーダリング、ハイパー・スレッディン
グ・テクノロジを使用してマルチ・プロセッサをサポートする命令やフラグについて説明する。
第8 章 - APIC（Advanced Programmable Interrupt Controller）。ローカルAPIC のプログラミング・イ
ンターフェイスについて説明し、ローカルAPICとI/O APIC間のインターフェイスの概要を示す。
第9 章 − プロセッサの管理と初期化。リセット初期化後のIA-32 プロセッサ、浮動小数点ユニット
およびSIMD浮動小数点ユニットのステートを定義する。この章ではさらに、実アドレス・モード動
作や保護モード動作向けのセットアップ手順、両モード間の切り替え手順を説明する。
第10 章 − メモリ・キャッシュ制御。キャッシングの一般的な概念と、IA-32 アーキテクチャがサ
ポートするキャッシュ・メカニズムについて説明する。この章ではさらに、メモリ・タイプ・レン
ジ・レジスタ（MTRR）や、これらのレジスタを使用して物理メモリの各メモリ・タイプをマッピン
グする方法についても説明する。また、Pentium III プロセッサ、Pentium 4 プロセッサ、インテルR
Xeon? プロセッサで新たに導入されたキャッシュ制御命令とメモリ・ストリーミング命令の使用方
法についても説明する。
1-5
本書について
第11章 − インテルR MMXR テクノロジ・システム・プログラミング。システム・プログラミング・
レベルで処理し、かつ配慮しなければならないインテルMMX テクノロジの各局面について説明す
る。これには、タスク・スイッチング、例外処理、既存システム環境との互換性の説明が含まれる。
インテルMMXテクノロジは、PentiumプロセッサでIA-32 アーキテクチャに導入された。
第12 章 − SSE およびSSE2 システム・プログラミング。システム・プログラミング・レベルで取
り扱い、考慮に入れる必要がある、ストリーミングSIMD拡張命令の機能について説明する。これに
は、タスク・スイッチング、例外処理、および既存のシステム環境との互換性の説明も含む。
第13 章 − システム管理 。 IA-32 アーキテクチャのシステム管理モード（SMM）と温度モニタ機能
について説明する。
第14章 − マシン・チェック・アーキテクチャ。Pentiumプロセッサでインテル・アーキテクチャに
導入されたマシン・チェック・アーキテクチャについて説明する。
第15章 − デバッグと性能モニタリング。インテル・アーキテクチャに用意されているデバッグ・レ
ジスタおよびその他のデバッグ・メカニズムについて説明する。この章ではまた、タイム・スタン
プ・カウンタと性能モニタリング・カウンタについても説明する。
第16 章 − 8086 エミュレーション。IA-32 アーキテクチャの実アドレス・モードと仮想8086 モード
について説明する。
第17 章 − 16 ビット・コードと32 ビット・コードの混在。同一プログラムまたは同一タスク内で、
16ビット・コードと32 ビット・コードのモジュールを混在させる方法について説明する。
第18 章 − IA-32の互換性。各種のIA-32 プロセッサの互換性について説明する。これには、IntelR
286 プロセッサ、Intel386?プロセッサ、Intel486?プロセッサ、Pentiumプロセッサ、P6 ファミリ、
Pentium 4 プロセッサ、インテルXeon プロセッサが含まれる。P6 ファミリとは、Pentium Pro プロ
セッサ、Pentium II プロセッサ、Pentium III プロセッサを指す。32 ビットのIA-32 プロセッサ（Intel386
プロセッサ、Intel486 プロセッサ、Pentium プロセッサ、P6 ファミリ・プロセッサ）間の違いは、
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル』の全3 巻を通じ
てアーキテクチャの特定の機能に関連する箇所で説明する。この章では、すべてのIA-32 プロセッ
サに当てはまる互換情報を提供し、16 ビットのIA-32 プロセッサ（Intel 8086 プロセッサとIntel 286
プロセッサ）に関する基本的な違いについても説明する。
付録A − 性能モニタリング・イベント。性能モニタリング・カウンタでカウント可能なイベントを
併記するとともに、これらのイベントを選択する際に使用できるコードを併記する。Pentium プロ
セッサおよびP6 ファミリ・プロセッサ両方のイベントについて説明する。
付録B − モデル固有レジスタ（MSR）。Pentium プロセッサ、P6 ファミリ・プロセッサ、Pentium 4
プロセッサ、インテルXeon プロセッサで使用可能なMSRと、それらの機能の一覧を示す。
付録C − P6 ファミリ・プロセッサのMP初期化。MPシステムでP6 ファミリ・プロセッサをブート
するためのMPプロトコルの使用法の例を示す。
付録D − LINT0 およびLINT1 入力のプログラミング。特定の割り込みベクタに対するLINT0 および
LINT1 ピンのプログラミング方法の例を示す。
付録E − マシン・チェック・エラー・コードの解釈。P6 ファミリ・プロセッサ上で発生したマシ
ン・チェック・エラーのエラー・コードの解釈方法の例を示す。
付録F − APICバス・メッセージの形式。P6 ファミリおよびPentium プロセッサのAPICバス上に送
信されるメッセージの形式について説明する。
1-6
本書について
1.5. 表記法
本書では、データ構造フォーマット、命令のシンボリック表現、16 進数に対して特別な表記法を使
用している。この表記法を理解しておけば、本書を理解しやすくなる。
1.5.1. ビット・オーダとバイト・オーダ
メモリ内のデータ構造図では、小さい方のアドレスが図の下の方に示され、上に行くほど大きくな
る。ビット位置は、右から左に番号が付けられている。セットされたビットの数値は、2 をビット位
置を表す数で累乗した値に等しくなる。IA-32 プロセッサは「リトル・エンディアン」マシンであり、
ワードのバイトは最下位バイトから順に番号が付けられている。図1-1. にこれらの規則を示す。
1.5.2. 予約ビットとソフトウェア互換性
レジスタやメモリのレイアウトの説明で、特定のビットが「予約済み」と記されていることがある。
ビットが予約済みとして記されている場合は、将来のプロセッサとの互換性を維持するため、これ
らのビットが将来的に何らかの機能を持つものとみなした上で、ソフトウェア上でこれらのビット
を取り扱わなければならない。予約ビットの動作は、未定義としてだけではなく、予測不可能とみ
なさなければならない。予約ビットを処理する場合は、ソフトウェア上で、次に示すガイドライン
に従わなければならない。
? 予約ビットを含むレジスタの値をテストするときは、予約ビットのステートに依存してはなら
ない。テストする前に、予約ビットをマスクアウトする。
? メモリまたはレジスタに格納するときは、予約ビットのステートに依存してはならない。
? 予約ビットに書き込まれた情報が保存されるものとみなしてはならない。
? レジスタにロードするときは、マニュアル上で予約ビットに対して値を指定している場合には、
その値を予約ビットにロードしなければならない。マニュアルになければ、同じレジスタから
前に読まれた値を再ロードする。
図1-1. ビット・オーダとバイト・オーダ
バイト 3
データ構造
バイト 2 バイト 1 バイト 0
上位アドレス31 24 23 16 15 8 7 0 ビット・オフセット
28
24
20
16
12
8
4
0 下位アドレス
バイト・オフセット
1-7
本書について
注記
ソフトウェアを、IA-32 レジスタの予約ビットのステートに依存させることは絶対
に避けること。予約ビットの値に依存すると、プロセッサが予約ビットを処理す
る方法が決定されていないにもかかわらず、その未決定の方法にソフトウェアが
依存することになる。予約ビットの値に依存したプログラムを作成すると、将来
のプロセッサとの互換性を損なう危険がある。
1.5.3. 命令オペランド
命令をシンボルで表現する場合は、IA-32 のアセンブリ言語のサブセットを使用する。このサブセッ
トでは、命令は次の形式をとる。
label: mnemonic argument1, argument2, argument3
上記の形式において：
? label は識別子で、後にコロンが続く。
? mnemonic は、同じ機能を持つ命令オペコードの予約名である。
? オペランドargument1、argument2、argument3 はオプションである。オペコードに応じて、0 〜3
つのオペランドを使用する。オペランドを使用する場合、オペランドはリテラルかデータ項目
の識別子のいずれかの形式をとる。オペランド識別子は、レジスタの予約名であるか、または
プログラムの別の箇所（例には示されていないことがある）で宣言されたデータ項目に割り当
てられているものとみなされる。
演算命令や論理命令にオペランドが2 つある場合は、右側のオペランドがソースであり、左側がデス
ティネーションになる。
例：
LOADREG: MOV EAX, SUBTOTAL
この例では、LOADREGはラベル、MOVはオペコードのニーモニック識別子、EAXはデスティネー
ション・オペランド、SUBTOTAL はソース・オペランドになる。アセンブリ言語によっては、ソー
スとデスティネーションの順序が逆になることがある。
1.5.4. 16 進数と2 進数
16 をベースとする数（16 進数）は、末尾に文字H を付けた16 進数字の文字列で表す（たとえば、
F82EH）。16 進数字は、0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、Fのいずれかである。
1-8
本書について
ベースを2 とする数（2 進数）は、1 と0 の文字列で表し、場合によって末尾に文字B を付ける（た
とえば、1010B）。「B」を付けるのは、数値のタイプに混乱が生じるような場合に限られる。
1.5.5. セグメント化アドレス指定
インテル・アーキテクチャ・プロセッサでは、バイトによるアドレス指定を採用している。つまり、
メモリはバイトの連続として構成されアクセスされる。1 バイトをアクセスするのか複数バイトをア
クセスするのかにかかわらず、そのバイトを格納しているメモリへのアクセスには、1 つのバイト・
アドレスを使用する。アドレス指定が可能なメモリの範囲を、アドレス空間と呼ぶ。
プロセッサは、セグメント化アドレス指定もサポートしている。これは、プログラムがセグメント
と呼ばれる多数の独立したアドレス空間を持つ場合のアドレス指定の一形式である。たとえば、プ
ログラムはコード（命令）とスタックを別々のセグメントに保持できる。これにより、コード・ア
ドレスは常にコード空間を、スタック・アドレスは常にスタック空間を参照することが可能になる。
セグメント内のバイト・アドレスを指定するには、次の表記法を使用する。
Segment-register:Byte-address
たとえば、次のセグメント・アドレスは、DSレジスタがポイントするセグメント内のアドレスFF79H
にあるバイトを指す。
DS:FF79H
また、次のセグメント・アドレスは、コード・セグメントの命令アドレスを指す。CS レジスタは
コード・セグメントをポイントし、EIP レジスタは命令のアドレスを格納する。
CS:EIP
1.5.6. 例外
例外とは、命令がエラーを引き起こした場合に一般的に発生するイベントである。例えば、0 で除算
しようとすると例外が発生する。ただし、ブレークポイントのように、エラー以外の条件で発生す
る例外もある。例外によっては、エラー・コードを提示するものもある。エラー・コードによって、
エラーに関する追加情報が示される。例外とエラー・コードを示すために使用する表記例を次に示
す。
#PF(fault code)
この例が示すのは、フォルトのタイプを指すエラー・コードが報告される条件でのページ・フォル
ト例外である。ある種の条件では、エラー・コードが発生する例外でも、正確なコードを報告でき
ない場合がある。このような場合、一般保護例外の例が次に示すように、エラー・コードは0 になる。
#GP(0)
例外のニーモニックと、その説明については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デ
ベロッパーズ・マニュアル、下巻』の第5 章「割り込みと例外の処理」を参照のこと。
1-9
本書について
1.6. 参考文献
インテル・プロセッサに関連する資料の一覧は、以下のインテル・ウェブ・サイトに記載されている。
http://www.intel.co.jp/jp/developer/design/processor/index.htm ( 日本語)
http://developer.intel.com/design/processor/index.htm ( 英語)
このウェブ・サイトに記載されている資料には、オンラインで表示できるものと、オンラインで注
文できるものがある。入手可能な資料は、まずインテル・プロセッサ別に、次に資料のタイプ( アプ
リケーション・ノート、データ・シート、マニュアル、論文、仕様のアップデート) 別に記載されて
いる。関連する資料には、以下のものがある。
? 特定のインテルIA-32 プロセッサのデータ・シート
? 特定のインテルIA-32 プロセッサの仕様のアップデート
? 『AP-485, Intel Processor Identification and the CPUID Instruction』（資料番号241618）
? 『AP-485、インテルR プロセッサの識別とCPUID命令』（資料番号241618J）
? 『AP-578, Software and Hardware Considerations for FPU Exception Handlers for Intel Architecture
Processors』（資料番号243291）
? 『IntelR PentiumR 4 Optimization Reference Manual』（資料番号248966）
? 『インテル? Pentium? 4 最適化リファレンス・マニュアル』（資料番号248966J）
1.7. 参考URL
? http://developer.intel.com/sites/developer/index.htm（英語）
? http://www.intel.co.jp/jp/develover/design/develop.htm（日本語）
1-10
本書について
2
命令フォーマット

2-1
第 2 章
命令フォーマット
本章では、すべてのIA-32 プロセッサの命令フォーマットについて説明する。
2.1. 一般的命令フォーマット
IA-32 の命令のコード化は、すべて図2-1. に示す一般的命令フォーマットのサブセットである。命令
は、任意指定の命令プリフィックス ( 順序は任意)、1 つまたは2 つの基本オペコード・バイト、( 必
要な場合) ModR/Mバイトおよび場合によりSIB ( スケール・インデックス・ベース) バイトからなる
アドレス指定形式指定子、( 必要な場合) ディスプレースメント、および ( 必要な場合) 即値データ・
フィールドからなる。
2.2. 命令プリフィックス
命令プリフィックスは、それぞれ一連の使用可能なプリフィックス・コードからなる4 つのグループ
に分かれている。
? グループ1
? ロックおよびリピート・プリフィックス
? F0H − LOCK
? F2H − REPNE/REPNZ ( ストリング命令に対してのみ使用)
? F3H − REP ( ストリング命令に対してのみ使用)
? F3H − REPE/REPZ ( ストリング命令に対してのみ使用)
? グループ2
? セグメント・オーバライド・プリフィックス
図2-1. IA-32 プロセッサの命令フォーマット
命令
プリフィックス
オペコードModR/M SIB ディスプレース
即値
Mod R/M
7 65 3 2 0
スケールベース
7 65 32 0
インデックス
0、1、2、または
4 バイトの
即値データ
0、1、2、または
4 バイトの
アドレス・ディス
プレースメント
1 バイト
( 必要な場合)
1 バイト
( 必要な場合)
1 または2 バイト
のオペコード
最大4 つのプリ
フィックス - そ
れぞれ1バイト
( 任意指定)
メント
レジスタ/
オペコード
2-2
命令フォーマット
? 2EH − CS セグメント・オーバライド( 分岐命令に対する使用は予約されている)
? 36H-SS セグメント・オーバライド・プリフィックス( 分岐命令に対する使用は予約さ
れている)
? 3EH − DS セグメント・オーバライド・プリフィックス( 分岐命令に対する使用は予
約されている)
? 26H − ES セグメント・オーバライド・プリフィックス( 分岐命令に対する使用は予約
されている)
? 64H − FS セグメント・オーバライド・プリフィックス( 分岐命令に対する使用は予約
されている)
? 65H − GS セグメント・オーバライド・プリフィックス( 分岐命令に対する使用は予約
されている)
? 分岐のヒント:
? 2EH − 分岐が成立しない(Jcc 命令に対してのみ使用)
? 分岐が成立する(Jcc 命令に対してのみ使用)
? グループ3
? 66H − オペランド・サイズ・オーバライド・プリフィックス
? グループ4
? 67H − アドレス・サイズ・オーバライド・プリフィックス
各々の命令は、これら各グループから一つずつのプリフィックスをどのような順序でも使うことが
できる。冗長プリフィックス(1 つのグループからの複数のプリフィックス) の使用は予約されてい
る。冗長プリフィックスを使用すると、予期せぬ動作が起きることがある。
LOCK プリフィックスを使用すると、強制的にアトミック操作を実行し、マルチプロセッサ環境に
おいて共用メモリが排他的に使用されるように指定できる。LOCK プリフィックスおよびそれと共
に使用する命令については、第3 章「命令セット・リファレンス」の「LOCK?Assert LOCK# Signal
Prefix」を参照のこと。
リピート・プリフィックスを使用すると、ストリングの要素ごとに命令が繰り返される。リピート・
プリフィックスは、MOVS、CMPS、SCAS、LODS、STOS の各ストリング命令に対してのみ使用で
きる。これら以外のIA-32 命令に対するリピート・プリフィックスの使用は予約されている。これら
以外のIA-32 命令に対してリピート・プリフィックスを使用すると、予期せぬ動作が起きることがあ
る( 下記の注意を参照のこと)。
分岐ヒント・プリフィックスを使用すると、プログラムは、分岐で最も使われる可能性の高いコー
ド・パスについてのヒントをプロセッサに提供することができる。分岐ヒント・プリフィックスは、
条件付き分岐命令(Jcc) に対してのみ使用できる。Jcc 以外のIA-32 命令に対する分岐ヒント・プリ
フィックスの使用は予約されている。Jcc 以外のIA-32 命令に対して分岐ヒント・プリフィックスを
使用すると、予期せぬ動作が起きることがある。分岐ヒント・プリフィックスは、SSE2 拡張命令の
一部として、Pentium 4 プロセッサで導入されたものである。
オペランド・サイズ・オーバーライド・プリフィックスを使用すると、プログラムにおいて、オペ
ランド・サイズを16 ビットと32 ビットのいずれかに切り替えることができる。どちらのオペラン
ド・サイズも、デフォルトに設定することが可能である。このプリフィックスを使用すると、デフォ
ルトでないサイズが選択される。MMXテクノロジ、SSE、SSE2 の各命令に対するオペランド・サイ
ズ・オーバーライド・プリフィックスの使用は予約されている。これらの命令に対してこのプリ
フィックスを使用すると、予期せぬ動作が起きることがある( 下記の注意を参照のこと)。
アドレス・サイズ・オーバーライド・プリフィックスを使用すると、プログラムにおいて、アドレ
ス指定を16 ビットと32ビットのいずれかに切り替えることができる。どちらのアドレス・サイズも、
2-3
命令フォーマット
デフォルトに設定することが可能である。このプリフィックスを使用すると、デフォルトでないサ
イズが選択される。命令オペランドがメモリに常駐していない場合のアドレス・サイズ・オーバー
ライド・プリフィックスの使用は予約されている。この場合にこのプリフィックスを使用すると、予
期せぬ動作が起きることがある。
注記
SSE 命令およびSSE2 命令の中には、3 バイトのオペコードを持つものがある。こ
れらの3 バイトのオペコードの場合、第3 バイトはF2H、F3H、66Hのいずれかに
なる場合がある。例えば、SSE2 命令のCVTDQ2PD は、3 バイトのオペコードF3
OF E6 を持つ。この3 バイト・オペコードの第3 バイトは、オペランド・サイズ・
プリフィックス(66H)、またはリピート・プリフィックスのいずれか(F2H および
F3H) と同じエンコード方式を持っているが、これらはプリフィックスと見なして
はならない。前述したように、SSE命令およびSSE2 命令に対するオペランド・サ
イズ・プリフィックスとリピート・プリフィックスの使用は予約されている。
2.3. オペコード
基本オペコードは1 または2 バイトである。場合によって、ModR/M バイト内の3 ビットの追加オペ
コード・フィールドがコード化される。小さなコード化フィールドは基本オペコードの中で定義さ
れる。これらのフィールドは、操作の方向、ディスプレースメントのサイズ、レジスタのコード化、
条件コード、または符号拡張を定義する。オペコード内のフィールドのコード化は、操作のクラス
によって異なる。
2.4. ModR/M およびSIB バイト
メモリ内のオペランドを参照するほとんどの命令には、基本オペコードの次にアドレス指定形式指定
子バイト (ModR/Mバイトという) がある。ModR/M バイトには、以下の3 つの情報フィールドがある。
? mod フィールドは、r/m フィールドと合わせて、存在可能な32 通りの値、すなわち8 個のレジ
スタと24 個のアドレス指定モードを構成する。
? reg/opcode フィールドは、レジスタ番号3 ビットの追加オペコード情報を指定する。reg/opecode
フィールドの目的は、基本オペコードの中で指定される。
? r/mフィールドは、オペランドとしてレジスタを指定するか、またはmod フィールドと組み合わ
せてアドレス指定モードをコード化することができる。
ModR/Mバイトの特定のコード化には、アドレス指定形式を完全に指定するために、第2 のアドレス
指定バイト、すなわちSIB バイトが必要である。32 ビットの " ベース + インデックス" および " ス
ケール + インデックス" の両形式のアドレス指定には、SIB バイトが必要である。SIB バイトには、
以下のフィールドがある。
? scale フィールドはスケーリング・ファクタを指定する。
? index フィールドはインデックス・レジスタのレジスタ番号を指定する。
? base フィールドはベース・レジスタのレジスタ番号を指定する。
ModR/M およびSIB バイトのコード化については、2.6. 節「ModR/MおよびSIB バイトのアドレス指
定モードのコード化」を参照のこと。
2-4
命令フォーマット
2.5. ディスプレースメント・バイトと即値バイト
一部のアドレス指定形式は、ModR/M バイトやSIB バイトの直後にディスプレースメントを含む。
ディスプレースメントは、必要な場合、1、2、または4 バイトをもつことができる。
命令が即値オペランドを指定する場合、そのオペランドは常にディスプレースメント・バイトの次
の位置を占める。即値オペランドは、1、2、または4 バイトをもつことができる。
2.6. ModR/M およびSIB バイトのアドレス指定モードのコード化
ModR/M およびSIBバイトの値と対応するアドレス指定形式を表2-1. から表2-3. に示す。ModR/Mバ
イトによって指定される16 ビットのアドレス指定形式を表2-1. に示し、ModR/M バイトによって指
定される32 ビットのアドレス指定形式を表2-2. に示す。表2-3. には、SIBバイトによって指定される
32 ビットのアドレス指定形式を示す。
表2-1. および表2-2. では、最初の (「実効アドレス」という見出しの) 欄には、ModR/MバイトのMod
およびR/Mの両フィールドを使用して命令のオペランドに割り当てることができる、32 個の異なる
実効アドレスを一覧している。最初の24 個の実効アドレスは、それぞれ異なるメモリ・ロケーショ
ンの指定方法であり、残りの8 個 (Mod フィールドのコード化11B によって指定される) は、汎用、
MMXテクノロジ、XMMレジスタの指定方法である。レジスタのコード化は、それぞれ、指定可能
な4 つのレジスタを示している。例えば、最初のレジスタのコード化 (R/M フィールドのコード化
000Bによって選択される) は、汎用レジスタEAX、AX、AL、MMXテクノロジ・レジスタMM0、ま
たはXMMテクノロジ・レジスタMM0 を示す。これら5 つのレジスタのどれが使用されるかは、オ
ペコード・バイトとオペランド・サイズ属性によって決まる。これらはEAXレジスタ (32 ビット) か
AXレジスタ (16 ビット) かを選択する。
表2-1. および表2-2. の2 番目と3 番目の欄は、最初の欄に示されている対応する実効アドレスを得る
ために必要なそれぞれModM/RバイトのMod およびR/Mフィールドの2 進コード化を示す。すなわ
ち、ModおよびR/Mフィールドの存在可能な32 通りすべての組み合わせが示されている。
表2-1. および表2-2. の両方に、3 ビットのReg/Opcode フィールドの存在可能な8 つの値が10進 ( 上か
ら6 行目) および2 進 ( 上から7 行目) で示してある。7 行目には "REG=" という見出しが付いており、
これはそれら3 ビットを使用して第2 のオペランドのロケーションを指定することを表している。た
だし、そのロケーションは汎用レジスタ、MMXテクノロジ・レジスタ、またはXMMレジスタでな
ければならない。命令が第2 のオペランドの指定を必要としない場合は、Reg/Opcode フィールドの3
ビットをオペコードの拡張として使用することができ、それは "/digit (Opcode)" という見出しの6 行
目によって表される。その上の5 行目は、レジスタ番号に対応するバイト、ワード、およびダブル
ワードの汎用レジスタ、MMXテクノロジ・レジスタ、およびXMMレジスタを示す。レジスタ番号
の割り当ては、Mod フィールドのコードが11B であるときのR/M フィールドの場合と同じである。
R/Mフィールド・レジスタ・オプションの場合と同様に、5 つの指定可能なレジスタのどれが使用さ
れるかは、オペコード・バイトとオペランド・サイズ属性の組み合わせによって決まる。
表2-1. および表2-2. の本体 (「ModR/M バイトの値 (16 進表現)」という見出しの下) は、32 x 8 の配列
になっており、ModR/Mバイトの256 個のすべての値を16 進で示している。ビット3、4、5 はバイト
が存在する表の欄によって指定され、行はビット0、1、2、6、7 を指定する。
2-5
命令フォーマット
注:
1. デフォルト・セグメント・レジスタは、BP インデックスを含む実効アドレスに対してはSS であり、それ以
外の実効アドレスに対してはDS である。
2. "disp16" は、ModR/M バイトの次の、インデックスに加算される16 ビットのディスプレースメントを示す。
3. "disp8" は、ModR/M バイトの次の、符号拡張され、インデックスに加算される8 ビットのディスプレースメ
ントを示す。
表2-1. ModR/M バイトによる16 ビット・アドレス指定形式
r8(/r)
r16(/r)
r32(/r)
mm(/r)
xmm(/r)
/digit (Opcode)
REG =
AL
AX
EAX
MM0
XMM0
0
000
CL
CX
ECX
MM1
XMM1
1
001
DL
DX
EDX
MM2
XMM2
2
010
BL
BX
EBX
MM3
XMM3
3
011
AH
SP
ESP
MM4
XMM4
4
100
CH
BP
EBP
MM5
XMM5
5
101
DH
SI
ESI
MM6
XMM6
6
110
BH
DI
EDI
MM7
XMM7
7
111
実効アドレスMod R/M ModR/M バイトの値 (16 進表現)
[BX+SI]
[BX+DI]
[BP+SI]
[BP+DI]
[SI]
[DI]
disp162
[BX]
00 000
001
010
011
100
101
110
111
00
01
02
03
04
05
06
07
08
09
0A
0B
0C
0D
0E
0F
10
11
12
13
14
15
16
17
18
19
1A
1B
1C
1D
1E
1F
20
21
22
23
24
25
26
27
28
29
2A
2B
2C
2D
2E
2F
30
31
32
33
34
35
36
37
38
39
3A
3B
3C
3D
3E
3F
[BX+SI]+disp83
[BX+DI]+disp8
[BP+SI]+disp8
[BP+DI]+disp8
[SI]+disp8
[DI]+disp8
[BP]+disp8
[BX]+disp8
01 000
001
010
011
100
101
110
111
40
41
42
43
44
45
46
47
48
49
4A
4B
4C
4D
4E
4F
50
51
52
53
54
55
56
57
58
59
5A
5B
5C
5D
5E
5F
60
61
62
63
64
65
66
67
68
69
6A
6B
6C
6D
6E
6F
70
71
72
73
74
75
76
77
78
79
7A
7B
7C
7D
7E
7F
[BX+SI]+disp16
[BX+DI]+disp16
[BP+SI]+disp16
[BP+DI]+disp16
[SI]+disp16
[DI]+disp16
[BP]+disp16
[BX]+disp16
10 000
001
010
011
100
101
110
111
80
81
82
83
84
85
86
87
88
89
8A
8B
8C
8D
8E
8F
90
91
92
93
94
95
96
97
98
99
9A
9B
9C
9D
9E
9F
A0
A1
A2
A3
A4
A5
A6
A7
A8
A9
AA
AB
AC
AD
AE
AF
B0
B1
B2
B3
B4
B5
B6
B7
B8
B9
BA
BB
BC
BD
BE
BF
EAX/AX/AL/MM0/XMM0
ECX/CX/CL/MM1/XMM1
EDX/DX/DL/MM2/XMM2
EBX/BX/BL/MM3/XMM3
ESP/SP/AHMM4/XMM4
EBP/BP/CH/MM5/XMM5
ESI/SI/DH/MM6/XMM6
EDI/DI/BH/MM7/XMM7
11 000
001
010
011
100
101
110
111
C0
C1
C2
C3
C4
C5
C6
C7
C8
C9
CA
CB
CC
CD
CE
CF
D0
D1
D2
D3
D4
D5
D6
D7
D8
D9
DA
DB
DC
DD
DE
DF
E0
EQ
E2
E3
E4
E5
E6
E7
E8
E9
EA
EB
EC
ED
EE
EF
F0
F1
F2
F3
F4
F5
F6
F7
F8
F9
FA
FB
FC
FD
FE
FF
2-6
命令フォーマット
注:
1. [--][--] は、ModR/M バイトの次にSIB があることを意味する。
2. "disp32" は、SIB バイトの次の、インデックスに加算される32 ビットのディスプレースメントを示す。
3. "disp8" は、SIB バイトの次の、符号拡張され、インデックスに加算される8 ビットのディスプレースメント
を示す。
表2-2. ModR/M バイトによる32 ビット・アドレス指定形式
r8(/r)
r16(/r)
r32(/r)
mm(/r)
xmm(/r)
/digit (Opcode)
REG =
AL
AX
EAX
MM0
XMM0
0
000
CL
CX
ECX
MM1
XMM1
1
001
DL
DX
EDX
MM2
XMM2
2
010
BL
BX
EBX
MM3
XMM3
3
011
AH
SP
ESP
MM4
XMM4
4
100
CH
BP
EBP
MM5
XMM5
5
101
DH
SI
ESI
MM6
XMM6
6
110
BH
DI
EDI
MM7
XMM7
7
111
実効アドレスMod R/M ModR/M バイトの値 (16 進表現)
[EAX]
[ECX]
[EDX]
[EBX]
[--][--]1
disp322
[ESI]
[EDI]
00 000
001
010
011
100
101
110
111
00
01
02
03
04
05
06
07
08
09
0A
0B
0C
0D
0E
0F
10
11
12
13
14
15
16
17
18
19
1A
1B
1C
1D
1E
1F
20
21
22
23
24
25
26
27
28
29
2A
2B
2C
2D
2E
2F
30
31
32
33
34
35
36
37
38
39
3A
3B
3C
3D
3E
3F
disp8[EAX]3
disp8[ECX]
disp8[EDX]
disp8[EBX];
disp8[--][--]
disp8[EBP]
disp8[ESI]
disp8[EDI]
01 000
001
010
011
100
101
110
111
40
41
42
43
44
45
46
47
48
49
4A
4B
4C
4D
4E
4F
50
51
52
53
54
55
56
57
58
59
5A
5B
5C
5D
5E
5F
60
61
62
63
64
65
66
67
68
69
6A
6B
6C
6D
6E
6F
70
71
72
73
74
75
76
77
78
79
7A
7B
7C
7D
7E
7F
disp32[EAX]
disp32[ECX]
disp32[EDX]
disp32[EBX]
disp32[--][--]
disp32[EBP]
disp32[ESI]
disp32[EDI]
10 000
001
010
011
100
101
110
111
80
81
82
83
84
85
86
87
88
89
8A
8B
8C
8D
8E
8F
90
91
92
93
94
95
96
97
98
99
9A
9B
9C
9D
9E
9F
A0
A1
A2
A3
A4
A5
A6
A7
A8
A9
AA
AB
AC
AD
AE
AF
B0
B1
B2
B3
B4
B5
B6
B7
B8
B9
BA
BB
BC
BD
BE
BF
EAX/AX/AL/MM0
ECX/CX/CL/MM1
EDX/DX/DL/MM2
EBX/BX/BL/MM3
ESP/SP/AH/MM4
EBP/BP/CH/MM5
ESI/SI/DH/MM6
EDI/DI/BH/MM7
11 000
001
010
011
100
101
110
111
C0
C1
C2
C3
C4
C5
C6
C7
C8
C9
CA
CB
CC
CD
CE
CF
D0
D1
D2
D3
D4
D5
D6
D7
D8
D9
DA
DB
DC
DD
DE
DF
E0
E1
E2
E3
E4
E5
E6
E7
E8
E9
EA
EB
EC
ED
EE
EF
F0
F1
F2
F3
F4
F5
F6
F7
F8
F9
FA
FB
FC
FD
FE
FF
2-7
命令フォーマット
表2-3. の構成は、本体がSIB バイトの存在可能な256 個の値を16 進で示す点以外は表2-1. および表
2-2. と同じである。8 つの汎用レジスタのどれがベースとして使用されるかは、表の一番上に、ベー
ス・フィールド ( ビット0、1、2) の10 進および2 進の対応値と合わせて示してある。各行は、ス
ケーリング・ファクタ ( ビット6、7 によって決まる) と合わせて、どのレジスタがインデックスと
して使用されるか ( ビット3、4、5 によって決まる) を示している。
注:
1. [*] は、MOD が00 である場合はベースなしのdisp32 を意味し、MOD が00 でない場合は[EBP] を意味する。
したがって、以下のアドレス指定モードが提供される。
disp32[index] (MOD=00)
disp8[EBP][index] (MOD=01)
disp32[EBP][index] (MOD=10)
表2-3. SIB バイトによる32 ビット・アドレス指定形式
r32
Base =
Base =
EAX
0
000
ECX
1
001
EDX
2
010
EBX
3
011
ESP
4
100
[*]
5
101
ESI
6
110
EDI
7
111
スケーリング結果
インデックスSS インデックスSIB バイトの値 (16 進表現)
[EAX]
[ECX]
[EDX]
[EBX]
none
[EBP]
[ESI]
[EDI]
00 000
001
010
011
100
101
110
111
00
08
10
18
20
28
30
38
01
09
11
19
21
29
31
39
02
0A
12
1A
22
2A
32
3A
03
0B
13
1B
23
2B
33
3B
04
0C
14
1C
24
2C
34
3C
05
0D
15
1D
25
2D
35
3D
06
0E
16
1E
26
2E
36
3E
07
0F
17
1F
27
2F
37
3F
[EAX*2]
[ECX*2]
[EDX*2]
[EBX*2]
none
[EBP*2]
[ESI*2]
[EDI*2]
01 000
001
010
011
100
101
110
111
40
48
50
58
60
68
70
78
41
49
51
59
61
69
71
79
42
4A
52
5A
62
6A
72
7A
43
4B
53
5B
63
6B
73
7B
44
4C
54
5C
64
6C
74
7C
45
4D
55
5D
65
6D
75
7D
46
4E
56
5E
66
6E
76
7E
47
4F
57
5F
67
6F
77
7F
[EAX*4]
[ECX*4]
[EDX*4]
[EBX*4]
none
[EBP*4]
[ESI*4]
[EDI*4]
10 000
001
010
011
100
101
110
111
80
88
90
98
A0
A8
B0
B8
81
89
91
89
A1
A9
B1
B9
82
8A
92
9A
A2
AA
B2
BA
83
8B
93
9B
A3
AB
B3
BB
84
8C
94
9C
A4
AC
B4
BC
85
8D
95
9D
A5
AD
B5
BD
86
8E
96
9E
A6
AE
B6
BE
87
8F
97
9F
A7
AF
B7
BF
[EAX*8]
[ECX*8]
[EDX*8]
[EBX*8]
none
[EBP*8]
[ESI*8]
[EDI*8]
11 000
001
010
011
100
101
110
111
C0
C8
D0
D8
E0
E8
F0
F8
C1
C9
D1
D9
E1
E9
F1
F9
C2
CA
D2
DA
E2
EA
F2
FA
C3
CB
D3
DB
E3
EB
F3
FB
C4
CC
D4
DC
E4
EC
F4
FC
C5
CD
D5
DD
E5
ED
F5
FD
C6
CE
D6
DE
E6
EE
F6
FE
C7
CF
D7
DF
E7
EF
F7
FF
2-8
命令フォーマット
３
命令セット・
リファレンス

3-1
第 3 章
命令セット・リファレンス
本章では、汎用、x87 FPU、MMXテクノロジ、SSE、SSE 2、およびシステム用の命令をカバーする
IA-32 の完全な命令セットを構成する各命令について説明する。命令の説明はアルファベット順に整
理してある。各命令について、オペコード、必要なオペランド、および説明の各項からなる特定の
記述形式により各オペランドの組み合わせを示している。その他に、各命令について、命令および
そのオペランド、操作に関する説明、EFLAGS レジスタのフラグに対する命令の影響の説明、およ
び発生する可能性がある例外の要約も併記する。
3.1. 命令リファレンス・ページの読み方
本節では、本章の大部分を構成する命令リファレンス・ページのさまざまな説明項の記載内容につ
いて説明する。さらに、それらの項で使用される表記法と省略形式についても説明する。
3.1.1. 命令フォーマット
以下に、本章の各IA-32 命令の説明に使用するフォーマットの例を示す。
CMC?Complement Carry Flag
3.1.1.1. オペコード欄
「オペコード」欄には、各命令フォーマットに対して生成される完全なオブジェクト・コードを示す。
可能な場合、コードは、メモリ内に現れるのと同じ順序で16 進バイトとして示される。16 進バイト
以外のエントリの定義は、以下のとおりである。
? /digit − 0 から7 までの数字で、命令のModR/Mバイトがr/m ( レジスタまたはメモリ) オペラン
ドだけを使用することを示す。reg フィールドには、命令のオペコードを拡張する数字が入って
いる。
? /r − 命令のModR/Mバイトに、レジスタ・オペランドとR/Mオペランドの両方があることを示す。
? cb、cw、cd、cp − オペコードの後に続く1 バイト (cb)、2 バイト (cw)、4 バイト (cd)、または
6 バイト (cp) の値であり、コード・オフセット、およびコード・セグメント・レジスタの新しい
値を指定することができる。
オペコード命令説明
F5 CMC キャリー・フラグの補数をとる。
3-2
命令セット・リファレンス
? ib、iw、id − オペコード、ModM/R バイト、またはスケール・インデクッス・バイトの後に続
く命令への1 バイト(ib)、2 バイト(iw)、または4 バイト(id) の即値オペランドである。オペラン
ドが符号付きかどうかは、オペコードによって決まる。すべてのワードおよびダブルワードが
下位バイトから先に示される。
? +rb、+rw、+rd − 0 から 7 までのレジスタ・コードであり、+ 符号の左側に現れる16 進バイト
に加算されて、単一のオペコード・バイトを構成する。すべてのレジスタ・コードを表3-1. に示す。
? +i − オペランドの1 つがFPU レジスタ・スタックからのST(i) であるときに浮動小数点命令で
使用される数値。数値i (0 から7 までの数値) は+符号の左側に現れる16 進バイトに加算されて、
単一のオペコード・バイトを構成する。
3.1.1.2. 命令欄
「命令」欄は、ASM386 プログラムに現れる場合の命令文のシンタックスを示す。以下に、命令文内
のオペランドを表現するために使用される記号の一覧を示す。
? rel8 − 命令の終りの前の128 バイトから命令の終りの後の127 バイトまでの範囲の相対アドレ
ス。
? rel16 およびrel32 − アセンブル結果の命令と同じコード・セグメント内の相対アドレス。記号
rel16 は、オペランド・サイズ属性が16 ビットである命令に適用され、rel32 はオペランド・サイ
ズ属性が32 ビットである命令に適用される。
? ptr16:16 およびptr16:32 − 一般的に命令のコード・セグメントとは異なるコード・セグメント
内のfar ポインタ。16:16 という表記法は、ポインタの値が2 つの部分からなっていることを示
す。コロンの左側の値は、16 ビットのセレクタ、すなわちコード・セグメント・レジスタに送
られる値である。右側の値はデスティネーション・セグメント内のオフセットに対応する。記
号ptr16:16 は命令のオペランド・サイズ属性が16ビットである場合に使用され、記号ptr16:32 は
オペランド・サイズ属性が32 ビットである場合に使用される。
? r8 − 汎用バイト・レジスタAL、CL、DL、BL、AH、CH、DH、およびBHの中の1 つ。
? r16 − 汎用ワード・レジスタAX、CX、DX、BX、SP、BP、SI、およびDI の中の1 つ。
表3-1. +rb、+rw、および+rd に対応するレジスタのコード化
rb rw rd
AL = 0 AX = 0 EAX = 0
CL = 1 CX = 1 ECX = 1
DL = 2 DX = 2 EDX = 2
BL = 3 BX = 3 EBX = 3
rb rw rd
AH = 4 SP = 4 ESP = 4
CH = 5 BP = 5 EBP = 5
DH = 6 SI = 6 ESI = 6
BH = 7 DI = 7 EDI = 7
3-3
命令セット・リファレンス
? r32 − 汎用ダブルワード・レジスタEAX、ECX、EDX、EBX、ESP、EBP、ESI、およびEDI の中の1つ。
? imm8 − 即値バイト値。記号imm8 は-128 から+127 までの符号付き数値である。imm8 がワー
ドまたはダブルワードのオペランドと結合される命令については、即値は符号拡張されてワー
ドまたはダブルワードを構成する。その場合は、ワードの上位バイトは即値の最上位ビットで
埋められる。
? imm16 − オペランド・サイズ属性が16 ビットである命令に使用される即値ワード値。これは-
32,768 から+32,767 までの数値である。
? imm32 − オペランド・サイズ属性が32 ビットである命令に使用される即値ダブルワード値。こ
れには-2,147,483,648 から+2,147,483,647 までの数値を使用できる。
? r/m8 − 汎用バイト・レジスタ (AL、BL、CL、DL、AH、BH、CH、およびDH) か、メモリから
のバイトかの内容であるバイト・オペランド。
? r/m16 − オペランド・サイズ属性が16 ビットである命令に使用される汎用ワード・レジスタ・
オペランドまたはメモリ・オペランド。汎用ワード・レジスタは、AX、BX、CX、DX、SP、
BP、SI、およびDI である。メモリの内容は、実効アドレスの計算によって与えられるアドレス
にある。
? r/m32 − オペランド・サイズ属性が32 ビットである命令に使用される汎用ダブルワード・レジ
スタ・オペランドまたはメモリ・オペランド。汎用ダブルワード・レジスタは、EAX、EBX、
ECX、EDX、ESP、EBP、ESI、およびEDI である。メモリの内容は、実効アドレスの計算によっ
て与えられるアドレスにある。
? m − 16 または32ビットのメモリ・オペランド。
? m8 − 通常、変数名または配列名として表されるが、DS:(E)SI またはES:(E)DI レジスタによっ
てアドレス指定されるバイト・メモリ・オペランド。これはストリング命令およびXLAT 命令に
対してのみ使用される。
? m16 − 通常、変数名または配列名として表されるが、DS:(E)SI またはES:(E)DI レジスタによっ
てアドレス指定されるワード・メモリ・オペランド。これはストリング命令に対してのみ使用
される。
? m32 − 通常、変数名または配列名として表されるが、DS:(E)SI またはES:(E)DI レジスタによっ
てアドレス指定されるダブルワード・メモリ・オペランド。これはストリング命令に対しての
み使用される。
? m64 − クワッドワード・メモリ・オペランド。これはCMPXCHG8B 命令に対してのみ使用さ
れる。
? m128 − ダブル・クワッドワード・メモリ ・オペランド。これはストリージングSIMD 拡張命令に対し
てのみ使用される。
? m16:16、m16:32 − 2 つの数値からなるfar ポインタを内容とするメモリ・オペランド。コロン
の左側の数値はポインタのセグメント・セレクタに対応し、右側の数値はポインタのオフセッ
トに対応する。
3-4
命令セット・リファレンス
? m16&32、m16&16、m32&32 − サイズがアンパーサンド記号の左側と右側に示されるデータ項
目の対からなるメモリ・オペランド。すべてのメモリ・アドレス指定モードが可能である。
m16&16 およびm32&32 オペランドはBOUND命令で使用され、配列インデックスの上限および
下限を内容とするオペランドを提供する。m16&32 オペランドはLIDTおよびLGDTで使用され、
対応するGDTR およびIDTR レジスタのlimit フィールドにロードするワード、およびベース・
フィールドにロードするダブルワードを提供する。
? moffs8、moffs16、moffs32 − MOV 命令の一部のバリエーションによって使用されるバイト、
ワード、またはダブルワード型のシンプル・メモリ変数 ( メモリ・オフセット)。実際のアドレ
スは、セグメント・ベースからのシンプル・オフセットによって与えられる。命令にはModR/M
バイトは使用されない。moffs の次の数値はセグメントのサイズであり、これは命令のアドレス・
サイズ属性によって決まる。
? Sreg − セグメント・レジスタ。セグメント・レジスタのビット割り当ては、ES=0、CS=1、SS=2、
DS=3、FS=4、およびGS=5。
? m32fp、m64fp、m80fp − それぞれ 単精度、倍精度、および拡張倍精度浮動小数点数のメモリ・
オペランドである。これらのシンボルにより、x87 FPU浮動小数点命令のオペランドとして使用
される浮動小数点の値が指定される。
? m16int、m32int、m64int − それぞれ ワード、ダブルワード、およびクワッドワード整数のメモ
リ・オペランドである。これらのシンボルにより、x87 FPU整数命令のオペランドとして使用さ
れる整数が指定される。
? ST またはST(0) − FPUレジスタ・スタックの一番上の要素。
? ST(i) − FPUレジスタ・スタックの一番上からi 番目の要素 (i ← 0 〜7)。
? mm − MMXテクノロジ・レジスタ。64 ビットMMXテクノロジ・レジスタMM0 からMM7 まで。
? mm/m32 − MMX テクノロジ・レジスタの下位32 ビットまたは32 ビットのメモリ・オペラン
ド。64 ビットのMMXテクノロジ・レジスタはMM0からMM7 まで。メモリの内容は、実効ア
ドレス計算によって与えられるアドレスにある。
? mm/m64 − MMXテクノロジ・レジスタまたは64 ビットのメモリ・オペランド。64 ビットMMX
テクノロジ・レジスタはMM0 からMM7 まで。メモリの内容は実効アドレス計算によって与え
られるアドレスにある。
? xmm − XMMレジスタ。128 ビットのXMMレジスタは、XMM0からXMM7まで。
? xmm/m32 − XMMレジスタまたは32 ビットのメモリ・オペランド。128 ビットのXMMレジス
タは、XMM0からXMM7 まで。メモリの内容は、実効アドレス計算によって与えられるアドレ
スにある。
? xmm/m64 − XMMレジスタまたは64 ビットのメモリ・オペランド。128 ビットのSIMD浮動小
数点レジスタは、XMM0 からXMM7まで。メモリの内容は、実効アドレス計算によって与えら
れるアドレスにある。
? xmm/m128 − XMM レジスタまたは128 ビットのメモリ・オペランド。128 ビットのXMMレ
ジスタは、XMM0からXMM7まで。メモリの内容は、実効アドレス計算によって与えられるア
ドレスにある。
3-5
命令セット・リファレンス
3.1.1.3. 説明欄
「命令」欄の次の「説明」欄では、各種の命令フォーマットについて簡単に説明する。命令のフォー
マットの下の「説明」および「操作」の項には、命令の動作の詳細が記載してある。
3.1.1.4. 説明
「説明」の項では、命令の目的と必要なオペランドについて説明する。さらに、命令のフラグに対す
る影響についても説明する。
3.1.2. 操作
「操作」の項には、命令のアルゴリズムに関する説明を記載する ( 疑似コードで記述)。この疑似コー
ドは、Algol またはPascal 言語に似た表記法を使用している。アルゴリズムは、以下の要素からなっ
ている。
? コメントは記号の対 "(*" および "*)" で囲まれる。
? 複合文は、それぞれ、if 文についてはIF、THEN、ELSE、およびFI、do 文についてはDO およ
びOD、またはcase 文についてはCASE ... OFおよびESACなどのキーワードで囲まれる。
? レジスタ名は暗黙にレジスタの内容を意味する。ブラケットで囲まれたレジスタ名は、暗黙に、
アドレスがそのレジスタにストアされているロケーションの内容を意味する。例えば、ES:[DI]
は、ES セグメント相対アドレスがレジスタDI にストアされているロケーションの内容を示す。
[SI] は、レジスタSI にストアされている、SI レジスタのデフォルト・セグメント (DS) または
オーバライドされたセグメントの相対アドレスの内容を示す。
? 例えば (E)SI のように、汎用レジスタ名の中で "E" がかっこで囲まれているのは、現在のアドレ
ス・サイズ属性が16 である場合はオフセットがSI レジスタから読み込まれ、アドレス・サイズ
属性が32 である場合はESI レジスタから読み込まれることを示す。
? ブラケットはメモリ・オペランドに対しても使用され、その場合は、メモリ・ロケーションの
内容がセグメント相対オフセットであることを意味する。例えば、[SRC] はソース・オペランド
の内容がセグメント相対オフセットであることを示す。
? A ← B; は、Bの値がAに代入されることを示す。
? 記号=、≠、≧、および≦は2 つの値の比較に使用される関係演算子であり、それぞれ、「等し
い」、「等しくない」、「より大きいか等しい」、「より小さいか等しい」を意味する。例えば、関
係式A←Bは、Aの値がBに等しい場合はTRUE (真) であり、そうでない場合はFALSE (偽) である。
? 式 "<< COUNT" と ">> COUNT" は、デスティネーション・オペランドがカウント・オペランド
が示すビット数だけそれぞれ左または右にシフトされることを示す。
以下の識別子が、アルゴリズムの記述に使用される。
? OperandSize とAddressSize − OperandSize 識別子は、16 ビットか32 ビットの命令のオペラン
ド・サイズ属性を表す。AddressSize 識別子は、16ビットか32 ビットのアドレス・サイズ属性を
表す。例えば、以下の疑似コードは、オペランド・サイズ属性が使用されるCMPS命令のフォー
マットに依存することを示している。
3-6
命令セット・リファレンス
IF instruction ← CMPSW
THEN OperandSize ← 16;
ELSE
IF instruction ← CMPSD
THEN OperandSize ← 32;
FI;
FI;
これらの属性の決定方法の一般的ガイドラインについては、『IA-32 インテルR アーキテクチャ・
ソフトウェア・デベロッパーズ・マニュアル、上巻』第3 章の「オペランド・サイズ属性とア
ドレス・サイズ属性」を参照のこと。
? StackAddrSize − 命令に関連するスタックのアドレス・サイズ属性を表す。この属性の値は16
または32 ビットである (『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・
マニュアル、上巻』第6 章の「スタック・アクセスにおけるアドレス・サイズ属性」を参照のこと)。
? SRC − ソース・オペランドを表す。
? DEST − デスティネーション・オペランドを表す。
以下の関数が、アルゴリズムの記述に使用される。
? ZeroExtend( 値) − 命令のオペランド・サイズ属性に合わせたゼロ拡張値を返す。例えば、オペ
ランド・サイズ属性が32である場合は、-10 のバイト値をゼロ拡張すると、そのバイトはF6Hか
らダブルワード値000000F6H に変換される。ZeroEztend 関数に渡された値とオペランド・サイ
ズ属性とが同じサイズである場合は、ZeroExtend はその値を変えずにそのまま返す。
? SignExtend( 値) − 命令のオペランド・サイズ属性に合わせた符号拡張値を返す。例えば、オペ
ランド・サイズ属性が32 である場合は、内容が値-10 であるバイトを符号拡張すると、そのバ
イトはF6Hからダブルワード値FFFFFFF6Hに変換される。SignEztend 関数に渡された値とオペ
ランド・サイズ属性とが同じサイズである場合は、SignExtend はその値を変えずにそのまま返す。
? SaturateSignedWordToSignedByte − 符号付き16 ビット値を符号付き8 ビット値に変換する。
符号付き16 ビット値が-128 より小さい場合は、その値は飽和値-128 (80H) で表される。127 よ
り大きい場合は、飽和値 127 (7FH) で表される。
? SaturateSignedDWordToSignedWord − 符号付き32 ビット値を符号付き16 ビット値に変換す
る。符号付き32 ビット値が-32768 より小さい場合は、その値は飽和値-32768 (8000H) で表され
る。32767 より大きい場合は、飽和値32767 (7FFFH) で表される。
? SaturateSignedWordToUnsignedByte − 符号付き16ビット値を符号なし8ビット値に変換する。
符号付き16 ビット値が0 より小さい場合は、その値は飽和値0 (00H) で表される。255 より大き
い場合は、飽和値255 (FFH) で表される。
? SaturateToSignedByte − 演算の結果を符号付き8 ビット値として表す。結果が-128 より小さい
場合は、その値は飽和値-128 (80H) で表される。127 より大きい場合は、飽和値127 (7FH) で表
される。
? SaturateToSignedWord − 演算の結果を符号付き16 ビット値として表す。結果が-32768 より小
さい場合は、その値は飽和値-32768 (8000H) で表される。32767 より大きい場合は、飽和値32767
(7FFFH) で表される。
? SaturateToUnsignedByte − 演算の結果を符号なし8 ビット値として表す。結果が0 より小さい
場合は、その値は飽和値0 (00H) で表される。255より大きい場合は、飽和値255 (FFH) で表される。
3-7
命令セット・リファレンス
? SaturateToUnsignedWord − 演算の結果を符号なし16 ビット値として表す。結果が0 より小さ
い場合は、その値は飽和値0 (00H) で表される。65535 より大きい場合は、飽和値65535 (FFFFH)
で表される。
? LowOrderWord(DEST * SRC) − ワード・オペランドにワード・オペランドを掛け、ダブルワー
ドの結果の下位ワードをデスティネーション・オペランドにストアする。
? HighOrderWord(DEST * SRC) − ワード・オペランドにワード・オペランドを掛け、ダブルワー
ドの結果の上位ワードをデスティネーション・オペランドにストアする。
? Push( 値) − 値をスタックにプッシュする。プッシュされるバイト数は命令のオペランド・サ
イズ属性によって決まる。プッシュ操作の詳細については、本章の「PUSH?Push Word or
Doubleword onto the Stack」の「操作」の項を参照のこと。
? Pop() − 一番上のスタックから値を削除し、その値を返す。文EAX ← Pop(); は、一番上のス
タックから32 ビット値をEAXに代入する。Popは、オペランド・サイズ属性に応じて、ワード
かダブルワードを返す。ポップ操作の詳細については、本章の「POP?Pop a Value from the Stack」
の「操作」の項を参照のこと。
? PopRegisterStack − FPU のST(0) レジスタを空としてマークし、FPU レジスタ・スタック・ポ
インタ (TOP) を1 だけインクリメントする。
? Switch-Tasks − タスク・スイッチを行う。
? Bit(BitBase, BitOffset) − メモリまたはレジスタ内の一連のビットであるビット・ストリング内
の特定ビットの値を返す。ビットには、レジスタ内またはメモリ・バイト内で下位から上位に
番号が割り振られている。ベース・オペランドがレジスタである場合は、存在可能なオフセッ
トの範囲は0 〜 31 である。このオフセットは、指定されたレジスタ内のビットのアドレスを指
定する。例として、図3-1. に関数Bit[EAX,21] の図解を示す。
BitBase がメモリ・アドレスである場合は、BitOffset の存在可能な範囲は-2G ビットから2G ビッ
トまでである。アドレス指定されるビットには、アドレス (BitBase + (BitOffset DIV 8)) のバイト
内の番号 (Offset MOD 8) が与えられる。ただし、DIV は負の無限大に向かう丸めを伴う符号付
き除算であり、MOD は正の数値を返す。図3-2. に、この操作の図解を示す。
図3-1. BIT[EAX,21] のビット・オフセット
31 21 0
BitOffset ← 21
3-8
命令セット・リファレンス
3.1.3. インテルC/C++ コンパイラ組み込み関数
インテルC/C++ コンパイラ組み込み関数は、特殊なC/C++コーディングの拡張によって、ハードウェ
ア・レジスタの代わりに、C関数呼び出しおよびC変数の構文を使用できるようにする。組み込み関
数の使用によって、プログラマは、レジスタの管理やアセンブリ言語のプログラミング作業から解
放される。さらに、コンパイラが命令のスケジューリングを最適化するため、実行可能プログラム
の速度がアップする。
ここでは、組み込み関数のAPI、MMXテクノロジ組み込み関数、およびSIMD浮動小数点組み込み
関数について説明する。各組み込み関数およびそれに対応する命令の説明が示される。対応する命
令を持たない組み込み関数が存在する可能性があるため、コンパイラのマニュアルを参照して、サ
ポートしているすべての組み込み関数のリストを確認することを強くお勧めする。『Intel C/C++
Compiler User’s Guide With Support for the Streaming SIMD Extensions 2』( 資料番号718195-2001) を参照
のこと。組み込み関数の使用についての詳細は、本書の付録C「機能的に同等のインテルR C/C++コ
ンパイラ組み込み関数」を参照のこと。
3.1.3.1. 組み込み関数のAPI
MMXテクノロジ組み込み関数およびSSEとSSE 2 の組み込み関数を使用したコーディングのメリッ
トは、ハードウェア・レジスタの代わりに、C関数呼び出しおよびC変数の構文を使用できることで
ある。これにより、プログラマは、レジスタの管理やアセンブリ言語のプログラミング作業から解
放される。さらに、コンパイラが命令のスケジューリングを最適化するため、実行可能プログラム
の速度がアップする。新しい命令セットのそれぞれの計算命令およびデータ操作命令に対して、そ
の命令を直接実装したC の組み込み関数が存在する。組み込み関数を使用して、アルゴリズムの基
礎となる手法( 命令の選択) をプログラマが指定し、命令のスケジューリングとレジスタの割り当て
はコンパイラに任せることができる。
3.1.3.2. MMXR テクノロジ組み込み関数
MMXテクノロジ組み込み関数は、MMXテクノロジ・レジスタの内容を表す、新しい__m64 データ
型に基づいている。値は、バイト、16 ビット整数、32 ビット値、または64ビット・オブジェクトで
指定できる。ただし、__m64 データ型は基本的なANSI C データ型ではないため、次の制限を守って
使用しなければならない。
? __m64 データは、必ず代入の左辺側、戻り値、またはパラメータとして使用すること。その他
の算術式("+"、">>" など) に__m64 データを使用することはできない。
? __m64 オブジェクトは、バイト要素にアクセスする共用体や構造体など、複数のオブジェクト
の集合体として使用すること。1 つの__m64 オブジェクトのアドレスを使用できる。
? __m64 データは、本書および『Intel C/C++ Compiler User’s Guide With Support for the Streaming
SIMD Extensions 2』( 資料番号718195-2001) で説明するMMXテクノロジ組み込み関数でのみ使
用すること。組み込み関数の使用についての詳細は、本書の付録C「機能的に同等のインテルR
C/C++ コンパイラ 組み込み関数」を参照のこと。
3-9
命令セット・リファレンス
3.1.3.3. SSE およびSSE 2 の組み込み関数
SSEとSSE 2 のすべての組み込み関数は、Pentium III プロセッサとPentium 4 プロセッサのXMMレジ
スタを使用する。これらの組み込み関数は、__m128、__m128d、および__m128i の3 つのデータ型を
サポートしている。
? __m128 データ型は、SSE 組み込み関数が使用するXMM レジスタの内容を表現する。これは、
4 つのパックド単精度浮動小数点値または1 つのスカラ単精度浮動小数点値である。
? __m128d データ型は、2 つのパックド倍精度浮動小数点値、または1 つのスカラ倍精度浮動小数
点値を格納する。
? __m128i データ型は、16 個のバイト整数値、8 個のワード整数値、4 個のダブルワード整数値、
または2 個のクワッドワード整数値を格納する。
コンパイラは、__m128、__m128d、および__m128i のローカル・データとグローバル・データのア
ライメントを、スタック上の16 バイト境界に合わせる。integer 型、float 型、またはdouble 型配列の
アライメントを合わせるには、『Intel C/C++ Compiler User's Guide With Support for the Streaming SIMD
Extensions 2』（資料番号718195-2001）の説明に従って、declspec 文を使用する。
__m128、__m128d、および__m128i データ型は基本的なANSI C データ型ではないため、次の制限を
守って使用しなければならない。
? __m128、__m128d および__m128i データは、必ず代入の左辺側、戻り値、またはパラメータと
して使用すること。その他の算術式("+"、">>" など) に__m64 データを使用することはできない。
? リテラルを持つ__m128、__m128d および__m128i データを初期化してはならない。128 ビット
の定数を表現する方法はない。
? __m128、__m128d および__m128i オブジェクトは、( 例えば、浮動小数点要素にアクセスする)
共用体や構造体など、複数のオブジェクトの集合体として使用すること。1 つの__m128 オブジェ
クトのアドレスを使用できる。
? __m128、__m128d および__m128i データは、本書で説明する組み込み関数でのみ使用すること。
組み込み関数の使用についての詳細は、本書の付録C「機能的に同等のインテルR C/C++コンパ
イラ 組み込み関数」を参照。
コンパイラは、ローカルな__m128、__m128d および__m128i データのアライメントをスタックの16
バイト境界に合わせる。グローバルな__m128 データのアライメントも、16 バイト境界に合わせられ
る( 浮動小数点データの配列のアライメントを合わせるには、後で説明するdeclspec 指定子を使用で
きる)。新しい命令セットは、スカラ・データを処理する場合も、パックド・データの場合と同じ方
法でSIMD 浮動小数点レジスタを処理する。したがって、スカラ・データを表す__m32 データ型は
存在しない。スカラ演算には、__m128 オブジェクトと「スカラ」形式の組み込み関数を使用する必
要がある。コンパイラとプロセッサは、32 ビットのメモリ参照を使用してスカラ演算を実行する。
サフィックスps およびss は、「パックド単精度」および「スカラ単精度」演算を示す。パックド浮動
小数点値は、[z, y, x, w] のように、右から左の順番で表される。最下位ワード( 一番右) がスカラ演算
に使用される。この方式がメモリへのストアにどのように反映されるかを理解するには、次の例を
考えればよい。
3-10
命令セット・リファレンス
次の演算は、
float a[4] ← { 1.0, 2.0, 3.0, 4.0 };
__m128 t ← _mm_load_ps(a);
次の演算と同じ結果を生じる。
__m128 t ← _mm_set_ps(4.0, 3.0, 2.0, 1.0);
つまり、次のようになる。
t ← [ 4.0, 3.0, 2.0, 1.0 ]
この場合、「スカラ」要素は1.0 である。
いくつかの組み込み関数は、2 つ以上の命令を使って実行されるため、「複合組み込み関数」と呼ば
れる。組み込み関数を使用してプログラムを作成する際は、SSE とSSE 2 とMMXテクノロジが提供
するハードウェア機能をよく理解する必要がある。
次の重要事項を忘れないこと。
? _mm_loadr_ps および_mm_cmpgt_ss のように、命令セットで直接サポートしていない組み込み
関数もある。これらの組み込み関数はプログラミングに便利であるが、展開されるコード・サ
イズや命令のコストを考慮に入れる必要がある。
? __m128 オブジェクトとしてロードまたはストアされるデータは、通常は16 バイト・アライメ
ントでなければならない。
? いくつかの組み込み関数は、SIMD浮動小数点命令の性質上、引数が即値、すなわち定数の整数
( リテラル) であることを要求する。
? 2 つのNaN(Not a Number) 引数を処理する算術演算の結果は未定義である。したがって、複数の
NaN 引数を使用する浮動小数点演算は、それに対応するアセンブリ言語の命令の予想される動
作と一致しないことがある。
各組み込み関数とその使用方法についての詳細は、『Intel C/C++ Compiler User’s Guide With Support for
the Streaming SIMD Extensions 2』( 資料番号718195-2001) を参照されたい。組み込み関数の使用につ
いての詳細は、本書の付録C「機能的に同等のインテルR C/C++ コンパイラ 組み込み関数」を参照の
こと。
3.1.4. 影響を受けるフラグ
「影響を受けるフラグ」の項には、命令の影響を受けるEFLAGSレジスタのフラグを示す。フラグは
クリアされたときは0 に等しく、セットされたときは1 に等しい。算術演算および論理演算命令は、
通常、一定の方法で値をステータス・フラグに代入する ( 詳細は『IA-32 インテルR アーキテクチャ・
ソフトウェア・デベロッパーズ・マニュアル、上巻』付録 A「EFLAGS クロス・リファレンス」を
参照のこと)。「操作」の項では、非従来型の代入について説明している。未定義として示してある
フラグの値は、不確定な方法で変更されることがある。記載されていないフラグは命令によって変
更されない。
3-11
命令セット・リファレンス
3.1.5. 影響を受けるFPU フラグ
浮動小数点命令については、「影響を受けるFPUフラグ」という項があり、そこで、各命令がFPUス
テータス・ワードの4 つの条件コード・フラグにどのように影響を与えるかを説明している。
3.1.6. 保護モード例外
「保護モード例外」の項には、命令を保護モードで実行したときに発生する可能性がある例外および
それらの例外の理由を示す。各例外は、番号記号 (#) とその後に続く2 文字からなるニーモニック、
および括弧で囲まれたオプションのエラー・コードで表される。例えば、#GP(0) はエラー・コード
0 を伴う一般保護例外を示す。表3-2. に、各2 文字のニーモニックと割り込みベクタ番号および例外
名との対応を示す。これらの例外の詳細については、『IA-32 インテルR アーキテクチャ・ソフトウェ
ア・デベロッパーズ・マニュアル、下巻』第5 章「割り込みと例外の処理」を参照のこと。
アプリケーション・プログラマは、例外が発生した場合は、該当するオペレーティング・システム
に付属のマニュアルを調べて対処すること。
図3-2. メモリ・ビットのインデックス操作
BitBase + 1
7 5 0 7 0 7 0
BitBase ? 2
7 07 075 0
BitBase BitBase ? 1
BitOffset ← +13
BitOffset ← ?11
BitBase BitBase ? 1
3-12
命令セット・リファレンス
注:
* 実アドレス・モードにおいて、ベクタ13 はセグメント・オーバーラン例外である。
3.1.7. 実アドレス・モード例外
「実アドレス・モード例外」の項には、命令を実アドレス・モードで実行したときに発生する可能性
がある例外を示す( 表3-2. を参照)。
表3-2. IA-32 の一般例外
ベクタ
番号名称発生源
保護
モード
実アドレス・
モード
仮想
8086
モード
0 #DE - 除算エラーDIV およびIDIV 命令○ ○ ○
1 #DB - デバッグ任意のコードまたはデータ参照○ ○ ○
3 #BP - ブレークポイントINT 3 命令○ ○ ○
4 #OF - オーバフローINTO 命令○ ○ ○
5 #BR - BOUND範囲外BOUND 命令○ ○ ○
6 #UD - 無効オペコード
( 未定義オペコード)
UD2 命令または予約オペコード○ ○ ○
7 #NM - デバイスなし ( 算術演算
コプロセッサなし)
浮動小数点またはWAIT/FWAIT 命令○ ○ ○
8 #DF - ダブル・フォルト例外、NMI、またはINTR を発生する
可能性がある任意の命令
○ ○ ○
10 #TS - 無効TSS タスク・スイッチまたはTSS アクセ
ス
○ 予約○
11 #NP? セグメントなしセグメント・レジスタのロードまた
はシステム・セグメントのアクセス
○ 予約○
12 #SS - スタック・セグメン
ト・フォルト
スタック操作およびSS レジスタ・
ロード
○ ○ ○
13 #GP - 一般保護* 任意のメモリ参照およびその他の保護
チェック
○ ○ ○
14 #PF - ページ・フォルト任意のメモリ参照○ 予約○
16 #MF - 浮動小数点エラー
( 算術演算フォルト)
浮動小数点またはWAIT/FWAIT 命令○ ○ ○
17 #AC - アライメント・チェック任意のメモリ・データ参照○ 予約○
18 #MC - マシン・チェックマシン・チェック・エラーはモデルに
依存
○ ○ ○
19 #XF - SIMD 浮動小数点数値エ
ラー
SSE およびSSE 2 浮動小数点命令○ ○ ○
3-13
命令セット・リファレンス
3.1.8. 仮想8086 モード例外
「仮想8086 モード例外」の項には、命令を仮想8086 モードで実行したときに発生する可能性がある
例外を示す( 表3-2. を参照)。
3.1.9. 浮動小数点例外
「浮動小数点例外」の項には、x87 FPU の浮動小数点命令を実行したときに発生する可能性がある例
外を示す。これらの例外条件はすべて浮動小数点エラー例外 (#MF、ベクタ番号16) を発生させる。
表3-3. に、1 または2 文字のニーモニックと例外名との対応を示す。これらの例外の詳細については、
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』第8 章の
「浮動小数点例外条件」の説明を参照のこと。
3.1.10. SIMD 浮動小数点例外
「SIMD浮動小数点例外」の項では、SSEおよびSSE 2 浮動小数点命令を実行したときに発生する可能
性がある例外を示す。これらの例外条件は、すべてSIMD 浮動小数点エラー例外(#XF、ベクタ番号
19) を発生させる。表3-4. に、ニーモニックと例外名の対応を示す。これらの例外についての詳細は、
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の第11章
「SSEとSSE 2 の例外」を参照のこと。
表3-3. x87 FPU の浮動小数点例外
ニーモニック名称発生源
#IS
#IA
無効浮動小数点演算:
- スタック・オーバフローまたはスタック・
アンダフロー
- 無効算術演算
- x87 FPU スタック・オーバフローまた
はx87 FPU スタック・アンダフロー
- 無効FPU 算術演算
#Z 0 での浮動小数点除算ゼロによる除算
#D 浮動小数点演算デノーマル・オペランドデノーマル・オペランド
#O 浮動小数点数値オーバフロー結果がオーバフロー
#U 浮動小数点数値アンダフロー結果がアンダフロー
#P 浮動小数点不正確結果 ( 精度) 不正確結果 ( 精度)
3-14
命令セット・リファレンス
3.2. 命令リファレンス
本章の以降では、IA-32 の各命令の詳細について説明する。
表3-4. SIMD 浮動小数点例外
ニーモニック名称発生源
#I 浮動小数点無効演算無効算術演算またはソース・オペランド
#Z 浮動小数点ゼロによる除算ゼロによる除算
#D 浮動小数点デノーマル・オペランドデノーマル・オペランド
#O 浮動小数点数値オーバーフロー結果がオーバーフロー
#U 浮動小数点数値アンダーフロー結果がアンダーフロー
#P 浮動小数点不正確結果不正確結果( 精度)
3-15
命令セット・リファレンス
AAA?ASCII Adjust After Addition
説明
2 つのアンパックBCD値の和を調整して、アンパックBCD結果を作成する。ALレジスタは、この命
令の暗黙のソース兼デスティネーション・オペランドである。AAA命令は、ADD命令の次に実行し
たときに限り有効である。ADD命令は、2 つのアンパックBCD値を加算 (2 進加算) し、バイトの結
果をALレジスタにストアする。次に、AAA命令がALレジスタの内容を調整して、正しい1 桁のア
ンパックBCD結果にまとめる。
加算によって10 進キャリーが生じた場合は、AHレジスタが1 インクリメントされ、CFおよびAFフ
ラグがセットされる。10 進キャリーが生じなかった場合は、CF およびAFフラグはクリアされ、AH
レジスタは変わらない。どちらの場合も、ALレジスタのビット4 から7 までは0 にクリアされる。
操作
IF ((AL AND 0FH) > 9) OR (AF ← 1)
THEN
AL ← (AL + 6);
AH ← AH + 1;
AF ← 1;
CF ← 1;
ELSE
AF ← 0;
CF ← 0;
FI;
AL ← AL AND 0FH;
影響を受けるフラグ
調整によって10 進キャリーが生じた場合は、AFおよびCF フラグが1 にセットされる。10進キャリー
が生じなかった場合は、両フラグが0 にクリアされる。OF、SF、ZF、およびPFフラグは未定義。
例外 ( すべての操作モード)
なし。
オペコード命令説明
37 AAA 加算後にAL をASCII 調整する。
3-16
命令セット・リファレンス
AAD?ASCII Adjust AX Before Division
説明
調整結果に対して除算を行った場合に正しいアンパックBCD 値が生じるように、2 桁のアンパック
BCD数 (ALレジスタの下位桁とAHレジスタの上位桁) を調整する。AAD命令は、AXレジスタの調
整結果の値をアンパックBCD値で除算 (2 進除算) するDIV命令の直前に実行したときに限り有効で
ある。
AAD命令は、ALレジスタの値を (AL + (10*AH)) に設定し、次にAHレジスタを00Hにクリアする。
したがって、AXレジスタの値は、ALおよびAHレジスタの元のパックされていない2 桁の ( 基数10
の) 数に等価な2 進値に等しい。
この命令の一般的なバージョンでは、imm8 バイトを選択した基数 ( 例えば、8 進数では08H、10 進
数では0CH、基数12 の数では0CH) に設定することにより、パックされていない任意の基数の2 桁の
数を調整できる ( 以下の「操作」の項を参照)。AADニーモニックは、すべてのアセンブラがASCII
( 基数10 の) 値を調整するものとして解釈する。他の基数の値を調整するには、この命令はマシン・
コード (D5 imm8) でハンド・コーディングしなければならない。
操作
tempAL ← AL;
tempAH ← AH;
AL ← (tempAL + (tempAH ? imm8)) AND FFH; (* imm8 is set to 0AH for the AAD mnemonic *)
AH ← 0
即値 (imm8) は命令の第2 バイトから与えられる。
影響を受けるフラグ
SF、ZF、およびPF フラグがALレジスタの2 進値の結果に従ってセットされる。OF、AF、およびCF
フラグは未定義。
例外 ( すべての操作モード)
なし。
オペコード命令説明
D5 0A AAD 除算前にAX をASCII 調整する。
D5 ib ( ニーモニックなし) 除算前にAX を基数imm8 に調整する。
3-17
命令セット・リファレンス
AAM?ASCII Adjust AX After Multiply
説明
2 つのアンパックBCD 値間の乗算結果を調整して、1 対のアンパック ( 基数10 の) BCD 値を作成す
る。AX レジスタは、この命令の暗黙のソース兼デスティネーション・オペランドである。AAM 命
令は、2 つのアンパックBCD値を乗算 (2 進乗算) し、ワードの結果をAXレジスタにストアするMUL
命令の次に実行したときに限り有効である。次に、AAM命令がAXレジスタの内容を調整して、2 桁
のアンパック ( 基数10 の) BCD結果にまとめる。
この命令の一般的なバージョンでは、AXの内容を調整して任意の基数の2 桁のアンパック数を作成
することができる ( 下記の「操作」の項を参照)。ここで、imm8 バイトは選択した基数 ( 例えば、8
進数では08H、10進数では0AH、または基数12 の数では0CH) に設定される。AAMニーモニックは、
すべてのアセンブラがASCII ( 基数10 の) 値に調整するものとして解釈する。他の基数の値の調整す
るには、この命令をマシン・コード (D4 imm8) でハンド・コーディングしなければならない。
操作
tempAL ← AL;
AH ← tempAL / imm8; (* imm8 is set to 0AH for the AAD mnemonic *)
AL ← tempAL MOD imm8;
即値 (imm8) は命令の第2 バイトから与えられる。
影響を受けるフラグ
SF、ZF、およびPF フラグがALレジスタの2 進値の結果に従ってセットされる。OF、AF、およびCF
フラグは未定義。
例外 ( すべての操作モード)
0AHのデフォルトの即値に対しては例外はない。ただし、即値として0 を使用した場合は、#DE ( 除
算エラー) 例外が発生する。
オペコード命令説明
D4 0A AAM 乗算後にAX をASCII 調整する。
D4 ib ( ニーモニックなし) 乗算後にAX を基数imm8 に調整する。
3-18
命令セット・リファレンス
AAS?ASCII Adjust AL After Subtraction
説明
2 つのアンパックBCD値間の減算結果を調整して、アンパックBCDの結果を作成する。ALレジスタ
は、この命令の暗黙のソース兼デスティネーション・オペランドである。AAS 命令は、1 つのアン
パックBCD値からもう1 つのアンパックBCD値を減算 (2 進減算) し、バイトの結果をALレジスタ
にストアするSUB 命令の次に実行したときに限り有効である。次に、AAS 命令がAL レジスタの内
容を調整して、正しい1 桁のアンパックBCDの結果にまとめる。
減算によって10進キャリーが生じた場合は、AHレジスタが1 デクリメントされ、CF およびAFフラ
グがセットされる。10 進キャリーが生じなかった場合は、CFおよびAFフラグはクリアされ、AHレ
ジスタは変わらない。どちらの場合も、ALレジスタの上位ニブルは0 に設定されたままである。
操作
IF ((AL AND 0FH) > 9) OR (AF ← 1)
THEN
AL ← AL ? 6;
AH ← AH ? 1;
AF ← 1;
CF ← 1;
ELSE
CF ← 0;
AF ← 0;
FI;
AL ← AL AND 0FH;
影響を受けるフラグ
10 進ボローが生じた場合は、AF およびCF フラグが1 にセットされ、10 進ボローが生じなかった場
合は両フラグが0 にクリアされる。OF、SF、ZF、およびPF フラグは未定義。
例外 ( すべての操作モード)
なし。
オペコード命令説明
3F AAS 減算後にAL をASCII 調整する。
3-19
命令セット・リファレンス
ADC?Add with Carry
説明
デスティネーション・オペランド ( 第1 オペランド)、ソース・オペランド ( 第2 オペランド)、およ
びキャリー (CF) を加算し、結果をデスティネーション・オペランドにストアする。デスティネー
ション・オペランドには、レジスタまたはメモリ・ロケーションを使用できる。ソース・オペラン
ドには、即値、レジスタ、またはメモリ・ロケーションを使用できる。( ただし、1 つの命令に2 つ
のメモリ・オペランドを使用することはできない。) CF フラグの状態は、前の加算からのキャリー
を表す。オペランドとして即値を使用した場合は、その即値はデスティネーション・オペランド・
フォーマットの長さに符号拡張される。
ADC 命令は符号付きと符号なしのオペランドを区別しない。その代わりに、プロセッサが両データ
型について結果を評価し、OF およびCF フラグをセットして、それぞれ符号付きまたは符号なしの
結果のキャリーを示す。SFフラグが符号付き結果の符号を示す。
ADC命令は、通常、複数バイトまたは複数ワード間の加算の一部として実行され、そのときに ADD
命令の後にADC命令が実行される。
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
DEST ← DEST + SRC + CF;
影響を受けるフラグ
OF、SF、ZF、AF、CF、およびPF フラグが結果に従ってセットされる。
オペコード命令説明
14 ib ADC AL,imm8 キャリーを加えてimm8 をAL に加算する。
15 iw ADC AX,imm16 キャリーを加えてimm16 をAX に加算する。
15 id ADC EAX,imm32 キャリーを加えてimm32 をEAX に加算する。
80 /2 ib ADC r/m8,imm8 キャリーを加えてimm8 をr/m8 に加算する。
81 /2 iw ADC r/m16,imm16 キャリーを加えてimm16 をr/m16 に加算する。
81 /2 id ADC r/m32,imm32 CF を加えてimm32 をr/m32 に加算する。
83 /2 ib ADC r/m16,imm8 CF を加えて符号拡張imm8 をr/m16 に加算する。
83 /2 ib ADC r/m32,imm8 CF を加えて符号拡張imm8 をr/m32 に加算する。
10 /r ADC r/m8,r8 キャリーを加えてバイト・レジスタをr/m8 に加算する。
11 /r ADC r/m16,r16 キャリーを加えてr16 をr/m16 に加算する。
11 /r ADC r/m32,r32 CF を加えてr32 をr/m32 に加算する。
12 /r ADC r8,r/m8 キャリーを加えてr/m8 をバイト・レジスタに加算する。
13 /r ADC r16,r/m16 キャリーを加えてr/m16 をr16 に加算する。
13 /r ADC r32,r/m32 CF を加えてr/m32 をr32 に加算する。
3-20
命令セット・リファレンス
ADC?Add with Carry ( 続き)
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリをアクセスしたが、
その内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-21
命令セット・リファレンス
ADD?Add
説明
デスティネーション・オペランド ( 第1 オペランド) とソース・オペランド ( 第2 オペランド) を加算
し、結果をデスティネーション・オペランドにストアする。デスティネーション・オペランドには、
レジスタまたはメモリ・ロケーションを使用できる。ソース・オペランドには、即値、レジスタ、ま
たはメモリ・ロケーションを使用できる。( ただし、1 つの命令に2 つのメモリ・オペランドを使用
することはできない。) CF フラグの状態は、前の加算からのキャリーを表す。オペランドとして即
値を使用した場合は、その即値はデスティネーション・オペランド・フォーマットの長さに符号拡
張される。
ADD命令は、整数加算を実行する。ADDは、符号付き整数オペランドおよび符号なし整数オペラン
ドの両方の結果を評価する。また、符号付き結果または符号なし結果のキャリーを示すCF フラグお
よびオーバーフローを示すOFフラグを設定する。SF フラグは、符号付き結果の符号を表す。
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
DEST ← DEST + SRC;
影響を受けるフラグ
OF、SF、ZF、AF、CF、およびPF フラグが結果に従ってセットされる。
オペコード命令説明
04 ib ADD AL,imm8 imm8 をAL に加算する。
05 iw ADD AX,imm16 imm16 をAX に加算する。
05 id ADD EAX,imm32 imm32 をEAX に加算する。
80 /0 ib ADD r/m8,imm8 imm8 をr/m8 に加算する。
81 /0 iw ADD r/m16,imm16 imm16 をr/m16 に加算する。
81 /0 id ADD r/m32,imm32 imm32 をr/m32 に加算する。
83 /0 ib ADD r/m16,imm8 符号拡張imm8 をrm16 に加算する。
83 /0 ib ADD r/m32,imm8 符号拡張imm8 をrm32 に加算する。
00 /r ADD r/m8,r8 r8 をr/m8 に加算する。
01 /r ADD r/m16,r16 r16 をr/m16 に加算する。
01 /r ADD r/m32,r32 r32 をr/m32 に加算する。
02 /r ADD r8,r/m8 r/m8 をr8 に加算する。
03 /r ADD r16,r/m16 r/m16 をr16 に加算する。
03 /r ADD r32,r/m32 r/m32 をr32 に加算する。
3-22
命令セット・リファレンス
ADD?Add ( 続き)
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリをアクセスしたが、
その内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-23
命令セット・リファレンス
ADDPD?Add Packed Double-Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の2
つのパックド倍精度浮動小数点値のSIMD加算を実行し、結果のパックド倍精度浮動小数点値をデス
ティネーション・オペランドに格納する。ソース・オペランドは、XMMレジスタまたは128 ビット
のメモリ・ロケーションである。デスティネーション・オペランドはXMMレジスタである。倍精度
浮動小数点値のSIMD演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』の図11-3. を参照のこと。
操作
DEST[63-0] ← DEST[63-0] + SRC[63-0];
DEST[127-64] ← DEST[127-64] + SRC[127-64];
同等のインテルC/C++ コンパイラ組み込み関数
ADDPD __m128d _mm_add_pd (m128d a, m128d b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
66 0F 58 /r ADDPD xmm1, xmm2/m128 xmm2/m128 とxmm1 のパックド倍精度浮動小数点値を
加算して、結果をxmm1 に格納する。
3-24
命令セット・リファレンス
ADDPD?Add Packed Double-Precision Floating-Point Values ( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-25
命令セット・リファレンス
ADDPS?Add Packed Single-Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の4
つのパックド単精度浮動小数点値のSIMD加算を実行し、結果のパックド単精度浮動小数点値をデス
ティネーション・オペランドに格納する。ソース・オペランドは、XMMレジスタまたは128 ビット
のメモリ・ロケーションである。デスティネーション・オペランドはXMMレジスタである。単精度
浮動小数点値のSIMD演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』の図10-5. を参照のこと。
操作
DEST[31-0] ← DEST[31-0] + SRC[31-0];
DEST[63-32] ← DEST[63-32] + SRC[63-32];
DEST[95-64] ← DEST[95-64] + SRC[95-64];
DEST[127-96] ← DEST[127-96] + SRC[127-96];
同等のインテルC/C++ コンパイラ組み込み関数
ADDPS __m128 _mm_add_ps(__m128 a, __m128 b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
0F 58 /r ADDPS xmm1, xmm2/m128 xmm1 およびxmm2/m128 のパックド単精度浮動小数点
値を加算して、結果をxmm1 レジスタにストアする。
3-26
命令セット・リファレンス
ADDPS?Add Packed Single-Precision Floating-Point Values ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-27
命令セット・リファレンス
ADDSD?Add Scalar Double-Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の
下位の倍精度浮動小数点値同士を加算し、結果の倍精度浮動小数点値をデスティネーション・オペ
ランドに格納する。ソース・オペランドは、XMMレジスタまたは64 ビットのメモリ・ロケーショ
ンである。デスティネーション・オペランドはXMMレジスタである。デスティネーション・オペ
ランドの上位クワッドワードは変更されない。倍精度浮動小数点値のスカラ演算の図は、『IA-32 イ
ンテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図11-4.を参照のこと。
操作
DEST[63-0] ← DEST[63-0] + SRC[63-0];
* DEST[127-64] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
ADDSD __m128d _mm_add_sd (m128d a, m128d b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
F2 0F 58 /r ADDSD xmm1, xmm2/m64 xmm2/m64 とxmm1 の下位の倍精度浮動小数点値を加
算して、結果をxmm1 に格納する。
3-28
命令セット・リファレンス
ADDSD?Add Scalar Double-Precision Floating-Point Values ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-29
命令セット・リファレンス
ADDSS?Add Scalar Single-Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の下
位の単精度浮動小数点値同士を加算し、結果の単精度浮動小数点値をデスティネーション・オペラ
ンドに格納する。ソース・オペランドは、XMM レジスタまたは32 ビットのメモリ・ロケーション
である。デスティネーション・オペランドはXMMレジスタである。デスティネーション・オペラン
ドの上位3 つのダブルワードは変更されない。単精度浮動小数点値のスカラ演算の図は、『IA-32 イン
テルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図10-6. を参照のこと。
操作
DEST[31-0] ← DEST[31-0] + SRC[31-0];
* DEST[127-32] remain unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
ADDSS __m128 _mm_add_ss(__m128 a, __m128 b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令
ADDSS xmm1, xmm2/m32
説明
F3 0F 58 /r xmm1 およびxmm2/m32 の下位の単精度浮動小数点値
を加算して、結果をxmm1 レジスタにストアする。
3-30
命令セット・リファレンス
ADDSS?Add Scalar Single-Precision Floating-Point Values ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-31
命令セット・リファレンス
AND?Logical AND
説明
デスティネーション ( 第1) オペランドとソース ( 第2) オペランドとの間のビット単位のAND ( 論理
積) 演算を実行し、結果をデスティネーション・オペランドにストアする。ソース・オペランドに
は、即値、レジスタ、またはメモリ・ロケーションを使用できる。デスティネーション・オペラン
ドには、レジスタまたはメモリ・ロケーションを使用できる。( ただし、1 つの命令に2 つのメモリ・
オペランドを使用することはできない。) その結果の各ビットは、第1 オペランドと第2 オペランド
の対応ビットがともに1 の場合は1 にセットされ、そうでない場合は0 にセットされる。
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
DEST ← DEST AND SRC;
影響を受けるフラグ
OF およびCF フラグがクリアされ、SF、ZF、およびPF フラグが結果に従ってセットされる。AF フ
ラグの状態は未定義。
保護モード例外
#GP(0) デスティネーション・オペランドの指示先が書き込み不可能なセグメン
トの場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
オペコード命令説明
24 ib AND AL,imm8 AL とimm8 とのAND をとる。
25 iw AND AX,imm16 AX とimm16 とのAND をとる。
25 id AND EAX,imm32 EAX とimm32 とのAND をとる。
80 /4 ib AND r/m8,imm8 r/m8 とimm8 とのAND をとる。
81 /4 iw AND r/m16,imm16 r/m16 とimm16 とのAND をとる。
81 /4 id AND r/m32,imm32 r/m32 とimm32 とのAND をとる。
83 /4 ib AND r/m16,imm8 r/m16 とimm8 ( 符号拡張) とのAND をとる。
83 /4 ib AND r/m32,imm8 r/m32 とimm8 ( 符号拡張) とのAND をとる。
20 /r AND r/m8,r8 r/m8 とr8 とのAND をとる。
21 /r AND r/m16,r16 r/m16 とr16 とのAND をとる。
21 /r AND r/m32,r32 r/m32 とr32 とのAND をとる。
22 /r AND r8,r/m8 r8 とr/m8 とのAND をとる。
23 /r AND r16,r/m16 r16 とr/m16 とのAND をとる。
23 /r AND r32,r/m32 r32 とr/m32 とのAND をとる。
3-32
命令セット・リファレンス
AND?Logical AND ( 続き)
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-33
命令セット・リファレンス
ANDPD?Bitwise Logical AND of Packed Double-Precision Floating-
Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の2
つのパックド倍精度浮動小数点値の間でビット単位のAND（論理積）演算を実行し、結果をデスティ
ネーション・オペランドに格納する。ソース・オペランドは、XMMレジスタまたは128 ビットのメ
モリ・ロケーションである。デスティネーション・オペランドはXMMレジスタである。
操作
DEST[127-0] ← DEST[127-0] BitwiseAND SRC[127-0];
同等のインテルC/C++ コンパイラ組み込み関数
ANDPD __m128d _mm_and_pd(__m128d a, __m128d b)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
66 0F 54 /r ANDPD xmm1, xmm2/m128 xmm2/m128 とxmm1 のビット単位のAND（論理積）
演算を実行する。
3-34
命令セット・リファレンス
ANDPD?Bitwise Logical AND of Packed Double-Precision Floating-
Point Values ( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-35
命令セット・リファレンス
ANDPS?Bitwise Logical AND of Packed Single-Precision
Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）内の
4 つのパックド単精度浮動小数点値の間でビット単位のAND（論理積）演算を実行し、結果をデス
ティネーション・オペランドに格納する。ソース・オペランドは、XMMレジスタまたは128 ビット
のメモリ・ロケーションである。デスティネーション・オペランドはXMMレジスタである。
操作
DEST[127-0] ← DEST[127-0] BitwiseAND SRC[127-0];
同等のインテルC/C++ コンパイラ組み込み関数
ANDPS __m128 _mm_and_ps(__m128 a, __m128 b)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
オペコード命令説明
0F 54 /r ANDPS xmm1, xmm2/m128 xmm2/m128 とxmm1 のビット単位のAND（論理積）
演算を実行する。
3-36
命令セット・リファレンス
ANDPS?Bitwise Logical AND of Packed Single-Precision
Floating-Point Values ( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-37
命令セット・リファレンス
ANDNPD?Bitwise Logical AND NOT of Packed Double-Precision
Floating-Point Values
説明
デスティネーション・オペランド（第1 オペランド）内の2 つのパックド倍精度浮動小数点値の各
ビットを反転して、反転された中間結果とソース・オペランド（第2 オペランド）内の2 つのパック
ド倍精度浮動小数点値の間でビット単位のAND（論理積）演算を実行し、結果をデスティネーショ
ン・オペランドに格納する。ソース・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロ
ケーションである。デスティネーション・オペランドはXMMレジスタである。
操作
DEST[127-0] ← (NOT(DEST[127-0])) BitwiseAND (SRC[127-0]);
同等のインテルC/C++ コンパイラ組み込み関数
ANDNPD __m128d _mm_andnot_pd(__m128d a, __m128d b)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
66 0F 55 /r ADDPD xmm1, xmm2/m128 xmm2/m128 とxmm1 のビット単位のAND NOT（否定
論理積）演算を実行する。
3-38
命令セット・リファレンス
ANDNPD?Bitwise Logical AND NOT of Packed Double-Precision
Floating-Point Values ( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-39
命令セット・リファレンス
ANDNPS?Bitwise Logical AND NOT of Packed Single-Precision
Floating-Point Values
説明
デスティネーション・オペランド（第1 オペランド）内の4 つのパックド単精度浮動小数点値の各
ビットを反転して、反転された中間結果とソース・オペランド（第2 オペランド）内の4 つのパック
ド単精度浮動小数点値の間でビット単位のAND（論理積）演算を実行し、結果をデスティネーショ
ン・オペランドに格納する。ソース・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロ
ケーションである。デスティネーション・オペランドはXMMレジスタである。
操作
DEST[127-0] ← (NOT(DEST[127-0])) BitwiseAND (SRC[127-0]);
同等のインテルC/C++ コンパイラ組み込み関数
ANDNPS __m128 _mm_andnot_ps(__m128 a, __m128 b)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
オペコード命令説明
0F 55 /r ANDNPS xmm1,xmm2/m128 xmm2/m128 とxmm1 のビット単位のAND（論理積）
演算を実行する。
3-40
命令セット・リファレンス
ANDNPS?Bitwise Logical AND NOT of Packed Single-Precision
Floating-Point Values ( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-41
命令セット・リファレンス
ARPL?Adjust RPL Field of Segment Selector
説明
2 つのセグメント・セレクタのRPL フィールドを比較する。第1 オペランド ( デスティネーション・
オペランド) に一方のセグメント・セレクタがあり、第2 オペランド ( ソース・オペランド) に他方
のセグメント・セレクタがある。(RPL フィールドは各オペランドのビット0 と1 を占める。) デス
ティネーション・オペランドのRPL フィールドがソース・オペランドのRPL フィールドより小さい
場合は、ZF フラグがセットされ、デスティネーション・オペランドのRPLフィールドが増加されて
ソース・オペランドのRPLフィールドに合わせられる。そうでない場合は、ZF フラグがクリアされ、
デスティネーション・オペランドの変更は行われない。( デスティネーション・オペランドには、ワー
ド・レジスタまたはメモリ・ロケーションを使用できる。ソース・オペランドは、ワード・レジス
タでなければならない。)
APRL命令は、オペレーティング・システム・プロシージャに使用させるために設けられている ( た
だし、アプリケーションも使用できる)。この命令は、一般に、アプリケーションからオペレーティ
ング・システムに渡されていたセグメント・セレクタのRPL を調整して、アプリケーション・プロ
グラムの特権レベルに合わせるために使用する。ここで、オペレーティング・システムに渡されて
いたセグメント・セレクタがデスティネーション・オペランドに入れられ、アプリケーション・プ
ログラムのコード・セグメントのセグメント・セレクタがソース・オペランドに入れられる。( ソー
ス・オペランドのRPL フィールドはアプリケーション・プログラムの特権レベルを表す。) 次に、
ARPL 命令を実行すれば、オペレーティング・システムが受け取っていたセグメント・セレクタの
RPLをアプリケーション・プログラムの特権レベルより低く ( 特権レベルを高く) させないように保
証できる。( アプリケーション・プログラムのコード・セグメントのセグメント・セレクタはプロ
シージャ・コールの後でスタックから読み出すことができる。)
この命令の使用方法の詳細については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッ
パーズ・マニュアル、下巻』第4 章の「呼び出し側のアクセス特権のチェック」を参照のこと。
操作
IF DEST[RPL) < SRC[RPL)
THEN
ZF ← 1;
DEST[RPL) ← SRC[RPL);
ELSE
ZF ← 0;
FI;
影響を受けるフラグ
デスティネーション・オペランドのRPL フィールドがソース・オペランドのRPL フィールドより小
さい場合は、ZF フラグが1 にセットされる。そうでない場合は、ZF フラグが0 にクリアされる。
オペコード命令説明
63 /r ARPL r/m16,r16 r/m16 のRPL をr16 のRPL 未満に調整する。
3-42
命令セット・リファレンス
ARPL?Adjust RPL Field of Segment Selector ( 続き)
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリをアクセスしたが、
その内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#UD 実アドレス・モードでは、ARPL 命令は認識されない。
仮想8086 モード例外
#UD 仮想8086 モードでは、ARPL 命令は認識されない。
3-43
命令セット・リファレンス
BOUND?Check Array Index Against Bounds
説明
第1 オペランド ( 配列インデックス) が第2 オペランド ( 範囲オペランド) によって指定される配列の
下限から上限までの範囲内であるかどうか判定する。配列インデックスは、レジスタ内の符号付き
整数である。範囲オペランドは、オペランド・サイズ属性が32 の場合は1 対の符号付きダブルワー
ド整数を、オペランド・サイズ属性が16 の場合は1 対の符号付きワード整数を内容とするメモリ・
ロケーションである。第1 のダブルワード ( またはワード) が配列の下限であり、第2 のダブルワー
ド ( またはワード) が配列の上限である。配列インデックスは下限より大きいか等しくなければなら
ず、かつ上限にバイト単位のオペランド・サイズを加算した値より小さいか等しくなければならな
い。インデックスが上下限の範囲内でない場合は、BOUND 範囲外例外 (#BR) が報告される。( この
例外が発生したときは、セーブされたリターン命令ポインタがBOUND命令を指している。)
上下限範囲データ構造 ( 配列の上下限を内容とする2 つのワードまたはダブルワード) は、通常、配
列自体の直前に置いて、配列の先頭からの一定のオフセットで上下限をアドレス指定できるように
する。配列のアドレスはすでにレジスタにストアされているので、上記のような慣行によって、配
列の上下限の実効アドレスを得るために余分なバス・サイクルを避けることができる。
操作
IF (ArrayIndex < LowerBound OR ArrayIndex > UppderBound)
(* Below lower bound or above upper bound *)
THEN
#BR;
FI;
影響を受けるフラグ
なし。
保護モード例外
#BR 範囲テストが失敗した場合。
#UD 第2 オペランドがメモリ・ロケーションでない場合。
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
オペコード命令説明
62 /r BOUND r16,m16&16 r16 ( 配列インデックス) がm16&16 の指定範囲内かどうか
を確認する。
62 /r BOUND r32,m32&32 r32 ( 配列インデックス) がm16&16 の指定範囲内かどうか
を確認する。
3-44
命令セット・リファレンス
BOUND?Check Array Index Against Bounds ( 続き)
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#BR 範囲テストが失敗した場合。
#UD 第2 オペランドがメモリ・ロケーションでない場合。
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#BR 範囲テストが失敗した場合。
#UD 第2 オペランドがメモリ・ロケーションでない場合。
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-45
命令セット・リファレンス
BSF?Bit Scan Forward
説明
ソース・オペランド ( 第2 オペランド) を検索して、最下位のセット・ビット ( 値1 のビット) を探す。
最下位のセット・ビットが見つかると、そのビット・インデックスがデスティネーション・オペラ
ンド ( 第1 オペランド) にストアされる。ソース・オペランドには、レジスタまたはメモリ・ロケー
ションを使用できる。デスティネーション・オペランドはレジスタである。ビット・インデックス
は、ソース・オペランドのビット0 からの符号なしオフセットである。ソース・オペランドの内容が
0 の場合は、デスティネーション・オペランドの内容は未定義になる。
操作
IF SRC ← 0
THEN
ZF ← 1;
DEST is undefined;
ELSE
ZF ← 0;
temp ← 0;
WHILE Bit(SRC, temp) ← 0
DO
temp ← temp + 1;
DEST ← temp;
OD;
FI;
影響を受けるフラグ
ソース・オペランドのすべてのビットが0 の場合は、ZF フラグが1 にセットされる。そうでない場
合は、ZF フラグがクリアされる。CF、OF、SF、AF、およびPF フラグは未定義。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
0F BC BSF r16,r/m16 r/m16 を順方向にビット・スキャンする。
0F BC BSF r32,r/m32 r/m32 を順方向にビット・スキャンする。
3-46
命令セット・リファレンス
BSF?Bit Scan Forward ( 続き)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-47
命令セット・リファレンス
BSR?Bit Scan Reverse
説明
ソース・オペランド ( 第2 オペランド) を検索して、最上位のセット・ビット ( 値1 のビット) を探す。
最上位のセット・ビットが見つかると、そのビット・インデックスがデスティネーション・オペラ
ンド ( 第1 オペランド) にストアされる。ソース・オペランドには、レジスタまたはメモリ・ロケー
ションを使用できる。デスティネーション・オペランドはレジスタである。ビット・インデックス
は、ソース・オペランドのビット0 からの符号なしオフセットである。ソース・オペランドの内容が
0 の場合は、デスティネーション・オペランドの内容は未定義になる。
操作
IF SRC ← 0
THEN
ZF ← 1;
DEST is undefined;
ELSE
ZF ← 0;
temp ← OperandSize ? 1;
WHILE Bit(SRC, temp) ← 0
DO
temp ← temp ? 1;
DEST ← temp;
OD;
FI;
影響を受けるフラグ
ソース・オペランドのすべてのビットが0 の場合は、ZF フラグが1 にセットされる。そうでない場
合は、ZF フラグはクリアされる。CF、OF、SF、AF、およびPF フラグは未定義。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
0F BD BSR r16,r/m16 r/m16 を逆方向にビット・スキャンする。
0F BD BSR r32,r/m32 r/m32 を逆方向にビット・スキャンする。
3-48
命令セット・リファレンス
BSR?Bit Scan Reverse ( 続き)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-49
命令セット・リファレンス
BSWAP?Byte Swap
説明
32 ビットの ( デスティネーション) レジスタのバイトの順序を逆にする。すなわち、ビット0 から7
がビット24 から31 と入れ換えられ、ビット8 から15 がビット16 から23 と入れ換えられる。この命
令は、リトル・エンディアン値をビッグ・エンディアン・フォーマットに、およびその逆に変換す
るために設けられている。
ワード値 (16 ビット・レジスタ) 内のバイトを入れ換えるには、XCHG 命令を使用する。BSWAP 命
令が16 ビット・レジスタを参照すると、結果は未定義になる。
IA-32 の互換性
BSWAP命令は、Intel486 プロセッサ・ファミリより以前のIA-32 プロセッサに対してはサポートされ
ていない。この命令との互換性を保証するためには、Intel486 プロセッサ・ファミリより以前のイン
テル・プロセッサで実行できる、機能的に等価なコードを組み込むこと。
操作
TEMP ← DEST
DEST[7..0] ← TEMP(31..24]
DEST[15..8] ← TEMP(23..16]
DEST[23..16] ← TEMP(15..8]
DEST[31..24] ← TEMP(7..0]
影響を受けるフラグ
なし。
例外 ( すべての操作モード)
なし。
オペコード命令説明
0F C8+rd BSWAP r32 32 ビット・レジスタのバイト順序を逆にする。
3-50
命令セット・リファレンス
BT?Bit Test
説明
ビット・ベース・オペランド ( 第1 オペランド) によって指定されるビット・ストリング内で、ビッ
ト・オフセット・オペランド ( 第2 オペランド) によって指定されるビット位置のビットを選択し、
そのビットの値をCF フラグにストアする。ビット・ベース・オペランドには、レジスタまたはメモ
リ・ロケーションを使用できる。ビット・オフセット・オペランドには、レジスタまたは即値を使
用できる。ビット・ベース・オペランドがレジスタを指定している場合は、この命令はビット・オ
フセット・オペランドの ( レジスタ・サイズに従って) 16 または32 の剰余をとり、それぞれ16 また
は32 ビットのレジスタで任意のビット位置を選択できるようにしている ( 図3-1. を参照)。ビット・
ベース・オペランドがメモリ・ロケーションを指定している場合は、このオペランドは対象のビッ
ト・ストリングのビット・ベース ( 指定されたバイトのビット0) を含むメモリ内のバイトのアドレ
スを表している ( 図3-2. を参照)。したがって、オフセット・オペランドは、レジスタ・オフセット
の場合は-231 から231 - 1 までの範囲のビット位置を、また即値オフセットの場合は0 から31 までの
範囲のビット位置を選択する。
一部のアセンブラは、即値ビット・オフセット・フィールドをメモリ・オペランドのディスプレー
スメント・フィールドと組み合わせて使用することにより、31 より大きい即値ビット・オフセット
をサポートしている。その場合は、アセンブラによって、即値ビット・オフセットの下位3 または5
ビット (16 ビット・オペランドの場合は3、32 ビット・オペランドの場合は5) が即値ビット・オフ
セット・フィールドにストアされ、上位ビットはシフトされ、アドレス指定モードのバイト・ディ
スプレースメントと組み合わされる。プロセッサは、0 でなくても、上位ビットを無視する。
メモリ内のビットをアクセスするときは、プロセッサは、以下の関係を使用して、32 ビットのオペ
ランド・サイズのメモリ・アドレスから始まる4 バイトをアクセスできる。
実効アドレス + (4 * (BitOffset DIV 32))
または、以下の関係を使用して、16 ビット・オペランドのメモリ・アドレスから始まる2 バイトを
アクセスできる。
実効アドレス + (2 * (BitOffset DIV 16))
該当するビットに到達するのに1 バイトだけのアクセスで足りるときでも、上記の操作に差し支えは
ない。このビット・アドレス指定方式を使用するときは、ソフトウェアはアドレス・スペース・ホー
ルに近いメモリ領域の参照を避けるようにすること。特に、メモリ・マップドI/Oレジスタへの参照
は避けなければならない。その代わりに、ソフトウェアにMOV系の命令を使用してそれらのアドレ
スからロードまたはそれらのアドレスにストアさせ、レジスタ形式のこれらの命令を使用してデー
タを操作するようにする。
操作
CF ← Bit(BitBase, BitOffset)
オペコード命令説明
0F A3 BT r/m16,r16 選択したビットをCF フラグにストアする。
0F A3 BT r/m32,r32 選択したビットをCF フラグにストアする。
0F BA /4 ib BT r/m16,imm8 選択したビットをCF フラグにストアする。
0F BA /4 ib BT r/m32,imm8 選択したビットをCF フラグにストアする。
3-51
命令セット・リファレンス
BT?Bit Test ( 続き)
影響を受けるフラグ
CFフラグに選択されたビットの値がストアされる。OF、SF、ZF、AF、およびPF フラグは未定義。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-52
命令セット・リファレンス
BTC?Bit Test and Complement
説明
ビット・ベース・オペランド ( 第1 オペランド) によって指定されるビット・ストリング内で、ビッ
ト・オフセット・オペランド ( 第2 オペランド) によって指定されるビット位置のビットを選択し、
そのビットの値をCF フラグにストアし、ビット・ストリング内の選択したビットを補数に変換する。
ビット・ベース・オペランドには、レジスタまたはメモリ・ロケーションを使用できる。ビット・
オフセット・オペランドには、レジスタまたは即値を使用できる。ビット・ベース・オペランドが
レジスタを指定している場合は、この命令はビット・オフセット・オペランドの ( レジスタ・サイズ
に従って) 16 または32 の剰余をとり、それぞれ16 または32 ビットのレジスタで任意のビット位置を
選択できるようにしている ( 図3-1. を参照)。ビット・ベース・オペランドがメモリ・ロケーション
を指定している場合は、このオペランドは対象のビット・ストリングのビット・ベース ( 指定された
バイトのビット0) を含むメモリ内のバイトのアドレスを表している ( 図3-2. を参照)。したがって、
オフセット・オペランドは、レジスタ・オフセットの場合は-231 から231 - 1 までの範囲のビット位
置を、また即値オフセットの場合は0 から31までの範囲のビット位置を選択する。
一部のアセンブラは、即値ビット・オフセット・フィールドをメモリ・オペランドのディスプレー
スメント・フィールドと組み合わせて使用することにより、31 より大きい即値ビット・オフセット
をサポートしている。このアドレス指定方式の詳細については、本章の「 BT?Bit Test」を参照のこと。
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
CF ← Bit(BitBase, BitOffset)
Bit(BitBase, BitOffset) ← NOT Bit(BitBase, BitOffset);
影響を受けるフラグ
CF フラグに選択されたビットの補数に変換される前の値がストアされる。OF、SF、ZF、AF、およ
びPFフラグは未定義。
保護モード例外
#GP(0) デスティネーション・オペランドの指示先が書き込み不可能なセグメン
トの場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
オペコード命令説明
0F BB BTC r/m16,r16 選択したビットをCF フラグにストアし、補数をとる。
0F BB BTC r/m32,r32 選択したビットをCF フラグにストアし、補数をとる。
0F BA /7 ib BTC r/m16,imm8 選択したビットをCF フラグにストアし、補数をとる。
0F BA /7 ib BTC r/m32,imm8 選択したビットをCF フラグにストアし、補数をとる。
3-53
命令セット・リファレンス
BTC?Bit Test and Complement ( 続き)
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-54
命令セット・リファレンス
BTR?Bit Test and Reset
説明
ビット・ベース・オペランド ( 第1 オペランド) によって指定されるビット・ストリング内で、ビッ
ト・オフセット・オペランド ( 第2 オペランド) によって指定されるビット位置のビットを選択し、
そのビットの値をCF フラグにストアし、ビット・ストリング内の選択したビットを0 にクリアする。
ビット・ベース・オペランドには、レジスタまたはメモリ・ロケーションを使用できる。ビット・
オフセット・オペランドには、レジスタまたは即値を使用できる。ビット・ベース・オペランドが
レジスタを指定している場合は、この命令はビット・オフセット・オペランドの ( レジスタ・サイズ
に従って) 16 または32 の剰余をとり、それぞれ16 または32 ビットのレジスタで任意のビット位置を
選択できるようにしている ( 図3-1. を参照)。ビット・ベース・オペランドがメモリ・ロケーション
を指定している場合は、このオペランドは対象のビット・ストリングのビット・ベース ( 指定された
バイトのビット0) を含むメモリ内のバイトのアドレスを表している ( 図3-2. を参照)。したがって、
オフセット・オペランドは、レジスタ・オフセットの場合は-231 から231 - 1 までの範囲のビット位
置を、また即値オフセットの場合は0 から31までの範囲のビット位置を選択する。
一部のアセンブラは、即値ビット・オフセット・フィールドをメモリ・オペランドのディスプレー
スメント・フィールドと組み合わせて使用することにより、31 より大きい即値ビット・オフセット
をサポートしている。このアドレス指定方式の詳細については、本章の「 BT?Bit Test」を参照のこと。
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
CF ← Bit(BitBase, BitOffset)
Bit(BitBase, BitOffset) ← 0;
影響を受けるフラグ
CF フラグに選択されたビットのクリアされる前の値がストアされる。OF、SF、ZF、AF、およびPF
フラグは未定義。
保護モード例外
#GP(0) デスティネーション・オペランドの指示先が書き込み不可能なセグメン
トの場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
オペコード命令説明
0F B3 BTR r/m16,r16 選択したビットをCF フラグにストアし、クリアする。
0F B3 BTR r/m32,r32 選択したビットをCF フラグにストアし、クリアする。
0F BA /6 ib BTR r/m16,imm8 選択したビットをCF フラグにストアし、クリアする。
0F BA /6 ib BTR r/m32,imm8 選択したビットをCF フラグにストアし、クリアする。
3-55
命令セット・リファレンス
BTR?Bit Test and Reset ( 続き)
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-56
命令セット・リファレンス
BTS?Bit Test and Set
説明
ビット・ベース・オペランド ( 第1 オペランド) によって指定されるビット・ストリング内で、ビッ
ト・オフセット・オペランド ( 第2 オペランド) によって指定されるビット位置のビットを選択し、
そのビットの値をCF フラグにストアし、ビット・ストリング内の選択したビットを1 にセットする。
ビット・ベース・オペランドには、レジスタまたはメモリ・ロケーションを使用できる。ビット・
オフセット・オペランドには、レジスタまたは即値を使用できる。ビット・ベース・オペランドが
レジスタを指定している場合は、この命令はビット・オフセット・オペランドの ( レジスタ・サイズ
に従って) 16 または32 の剰余をとり、それぞれ16 または32 ビットのレジスタで任意のビット位置を
選択できるようにしている( 図3-1. を参照)。ビット・ベース・オペランドがメモリ・ロケーション
を指定している場合は、このオペランドは対象のビット・ストリングのビット・ベース ( 指定された
バイトのビット0) を含むメモリ内のバイトのアドレスを表している ( 図3-2. を参照)。したがって、
オフセット・オペランドは、レジスタ・オフセットの場合は-231 から231 - 1 までの範囲のビット位
置を、また即値オフセットの場合は0 から31までの範囲のビット位置を選択する。
一部のアセンブラは、即値ビット・オフセット・フィールドをメモリ・オペランドのディスプレー
スメント・フィールドと組み合わせて使用することにより、31 より大きい即値ビット・オフセット
をサポートしている。このアドレス指定機構の詳細については、本章の「BT?Bit Test」を参照のこと。
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
CF ← Bit(BitBase, BitOffset)
Bit(BitBase, BitOffset) ← 1;
影響を受けるフラグ
CF フラグに選択されたビットのセットされる前の値がストアされる。OF、SF、ZF、AF、およびPF
フラグは未定義。
保護モード例外
#GP(0) デスティネーション・オペランドの指示先が書き込み不可能なセグメン
トの場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
オペコード命令説明
0F AB BTS r/m16,r16 選択したビットをCF フラグにストアし、セットする。
0F AB BTS r/m32,r32 選択したビットをCF フラグにストアし、セットする。
0F BA /5 ib BTS r/m16,imm8 選択したビットをCF フラグにストアし、セットする。
0F BA /5 ib BTS r/m32,imm8 選択したビットをCF フラグにストアし、セットする。
3-57
命令セット・リファレンス
BTS?Bit Test and Set ( 続き)
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-58
命令セット・リファレンス
CALL?Call Procedure
説明
プロシージャ・リンク情報をスタックにセーブし、デスティネーション ( ターゲット) オペランドで
指定されるプロシージャ ( コール先プロシージャ) に分岐する。ターゲット・オペランドは、コール
先プロシージャの最初の命令のアドレスを指定する。このオペランドには、即値、汎用レジスタ、ま
たはメモリ・ロケーションを使用できる。
この命令を使用して、以下の異なる4 つのタイプのコールを実行できる。
? near コール - 現在のコード・セグメント ( 現在のCS レジスタの指示先のセグメント) 内にある
プロシージャへのコール。セグメント内コールともいう。
? far コール - 現在のコード・セグメントとは異なるセグメント内にあるプロシージャへのコール。
セグメント間コールともいう。
? 特権レベル間far コール - 現在実行中のプログラムまたはプロシージャの特権レベルとは異なる
特権レベルのセグメント内にあるプロシージャへのコール。
? タスク・スイッチ - 異なるタスク内にあるプロシージャへのコール。
上記の最後の2 つのコール・タイプ ( 特権レベル間コールとタスク・スイッチ) は、保護モードでの
み実行できる。near、far、および特権レベル間の各コール・タイプの詳細については、『IA-32 イン
テルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』第6 章の「CALL と
RETによるプロシージャのコール」の説明を参照のこと。CALL命令によるタスク・スイッチの実行
の詳細については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュア
ル、下巻』第6 章「タスク管理」を参照のこと。
near コール: near コールを実行するときは、プロセッサは、EIP レジスタの値 (CALL 命令の次の命
令のオフセットを内容とする) を (後でリターン命令のポインタとして使用するために) スタックに
プッシュする。プロセッサは、次にターゲット・オペランドで指定される現在のコード・セグメン
ト内のアドレスに分岐する。ターゲット・オペランドは、コード・セグメント内の絶対オフセット
( すなわち、コード・セグメントのベースからのオフセット) か、相対オフセット (CALL 命令の次
の命令を指示先とする、EIP レジスタ内の命令ポインタの現在値に相対的な符号付きディスプレー
スメント) かを指定する。CSレジスタはnear コールでは変わらない。
オペコード命令説明
E8 cw CALL rel16 相対near コール、次の命令とディスプレースメント相対。
E8 cd CALL rel32 相対near コール、次の命令とディスプレースメント相対。
FF /2 CALL r/m16 絶対間接near コール、r/m16 でアドレスを指定。
FF /2 CALL r/m32 絶対間接near コール、r/m32 でアドレスを指定。
9A cd CALL ptr16:16 絶対far コール、オペランドでアドレスを指定。
9A cp CALL ptr16:32 絶対far コール、オペランドでアドレスを指定。
FF /3 CALL m16:16 絶対間接far コール、m16:16 でアドレスを指定。
FF /3 CALL m16:32 絶対間接far コール、m16:32 でアドレスを指定。
3-59
命令セット・リファレンス
CALL?Call Procedure ( 続き)
near コールについては、絶対オフセットは汎用レジスタまたはメモリ・ロケーション (r/m16 または
r/m32) で間接的に指定する。オペランド・サイズ属性によってターゲット・オペランドのサイズ (16
または32 ビット) が決まる。ターゲット・オフセットはEIP レジスタに直接ロードされる。オペラン
ド・サイズ属性が16 の場合は、EIP レジスタの上位2 バイトが0 にクリアされ、命令ポインタの最大
サイズが16 ビットになる。( スタック・ポインタ[ESP] をベース・レジスタとして使用して絶対オフ
セットを間接的にアクセスするときは、使用されるベース値は命令が実行される前のESP の値であ
る。)
相対オフセット (rel16 またはrel32) は、一般的にアセンブリ・コードではラベルとして指定されるが、
マシン・コード・レベルでは符号付きの16 または32 ビット即値にコード化される。この値がEIP レ
ジスタの値に加算される。絶対オフセットの場合と同様に、オペランド・サイズ属性によってター
ゲット・オペランドのサイズ (16 または32ビット) が決まる。
実アドレス・モードまたは仮想8086 モードでのfar コール: 実アドレス・モードまたは仮想8086 モー
ドでfar コールを実行するときは、プロセッサは、リターン命令ポインタとして使用するために、CS
およびEIP 両レジスタの現在の値をスタックにプッシュする。プロセッサは、次にコール先プロシー
ジャのターゲット・オペランドで指定されるコード・セグメントとオペランドへの「far 分岐」を実
行する。この場合、ターゲット・オペランドは、絶対far アドレスをポインタ (ptr16:16 またはptr16:32)
で直接的に、またはメモリ・ロケーション (m16:16 またはm16:32) で間接的に指定する。ポインタ
方式では、コール先プロシージャのセグメントとオフセットは、命令内で4 バイト (16 ビット・オ
ペランド・サイズ) または6 バイト (32 ビット・オペランド・サイズ) のfar 即値アドレスを使用し
てコード化される。間接方式では、ターゲット・オペランドは、4 バイト (16 ビット・オペランド・
サイズ) または6 バイト (32 ビット・オペランド・サイズ) のfar アドレスがストアされているメモ
リ・ロケーションを指定する。オペランド・サイズ属性によってfar アドレス内のオフセットのサ
イズ (16 または32 ビット) が決まる。far アドレスはCSおよびEIP レジスタに直接ロードされる。オ
ペランド・サイズ属性が16 の場合は、EIP レジスタの上位2 バイトが0 にクリアされる。
保護モードでのfar コール: プロセッサが保護モードで動作しているときは、CALL 命令を使用して以
下の3 つのタイプのfar コールを実行できる。
? 同じ特権レベルへのfar コール
? 異なる特権レベルへのfar コール ( 特権レベル間コール)
? タスク・スイッチ ( 別のタスクへのfar コール)
保護モードでは、プロセッサは常にfar アドレスのセグメント・セレクタ部分を使用してGDTまたは
LDT内の対応する記述子をアクセスする。記述子タイプ ( コード・セグメント、コール・ゲート、タ
スク・ゲート、またはTSS) とアクセス権によって実行されるコール操作のタイプが決まる。
選択された記述子がコード・セグメントのものである場合は、同じ特権レベルのコード・セグメン
トへのfar コールが実行される。( 選択されたコード・セグメントが異なる特権レベルにあり、非コ
ンフォーミング・コード・セグメントの場合は、一般保護例外が発生する。) 保護モードでの同じ特
権レベルへのfar コールは、実アドレス・モードまたは仮想8086 モードで実行するfar コールに非常
によく似ている。ターゲット・オペランドは、絶対far アドレスをポインタ (ptr16:16 またはptr16:32)
で直接的に、またはメモリ・ロケーション (m16:16 またはm16:32) で間接的に指定する。オペラン
ド・サイズ属性によってfar アドレス内のオフセットのサイズ (16 または32 ビット) が決まる。新し
いコード・セグメント・セレクタとその記述子がCSレジスタにロードされ、命令からのオフセット
がEIPレジスタにロードされる。
3-60
命令セット・リファレンス
CALL?Call Procedure ( 続き)
コール・ゲート ( 次の段落で説明) を使用して、同じ特権レベルのコード・セグメントへのfar コー
ルも実行できるので注意されたい。この仕組みを使用すると、特別レベルのインダイレクションが
可能になり、これは16ビットと32 ビットとのコード・セグメント間の好ましいコール実行方法であ
る。
特権レベル間のfar コールを実行するときは、コール先プロシージャのコード・セグメントにはコー
ル・ゲートを介してアクセスしなければならない。コール・ゲートはターゲット・オペランドによっ
て指定されるセグメント・セレクタによって指定される。ターゲット・オペランドは、ここでもや
はりコール・ゲート・セグメント・セレクタをポインタ (ptr16:16 またはptr16:32) で直接的に、また
はメモリ・ロケーション (m16:16 またはm16:32) で間接的に指定できる。プロセッサは、コール・
ゲート記述子から新しいコード・セグメントのセグメント・セレクタと新しい命令ポインタ ( オフ
セット) を得る。( コール・ゲートを使用するときは、ターゲット・オペランドからのオフセットは
無視される。) 特権レベル間コールでは、プロセッサはコール先プロシージャの特権レベルのスタッ
クに切り替える。新しいスタック・セグメントのセグメント・セレクタは、現在実行中のタスクの
TSS で指定される。新しいコード・セグメントへの分岐はスタック・スイッチの後で行われる。( コー
ル・ゲートを使用して同じ特権レベルのセグメントへのfar コールを実行するときは、スタック・ス
イッチは行われないのて注意されたい。) プロセッサは、新しいスタックに、コール元プロシージャ
のスタックのセグメント・セレクタとスタック・ポインタ、およびコール元プロシージャのコード・
セグメントのセグメント・セレクタと命令ポインタをプッシュする。( コール・ゲート記述子内の値
によって、新しいスタックにコピーするパラメータの数が決まる。) プロセッサは、最後に新しい
コード・セグメント内のコール先プロシージャのアドレスに分岐する。
CALL 命令でタスク・スイッチを実行するのは、コール・ゲートを介したコールを実行するのに多少
似ている。タスク・スイッチの場合、ターゲット・オペランドは切り替え先タスクへのタスク・ゲー
トのセグメント・セレクタを指定する ( ターゲット・オペランド内のオフセットは無視される)。次
に、タスク・ゲートがタスクのTSS を指す。TSS の内容はタスクのコードおよびスタックの両セグ
メントのセグメント・セレクタである。TSS には、さらに、タスクが中断される前に、次に実行さ
れる予定であった命令のEIP 値も入っている。この命令ポインタ値はEIPレジスタにロードされ、し
たがってタスクは再び、この中断された点の次の命令から実行を開始する。
CALL 命令は、TSSのセグメント・セレクタを直接指定することもでき、その結果タスク・ゲートの
インダイレクションの必要がなくなる。タスク・スイッチの仕組みの詳細については、『IA-32 イン
テルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、下巻』第6 章「タスク管理」
を参照のこと。
CALL 命令でタスク・スイッチを実行すると、EFLAGS レジスタにネストされたタスク・フラグ (NT)
がセットされ、新しいTSS の以前のタスク・リンク・フィールドに前のタスクのTSS セレクタがロー
ドされることに注意されたい。IRET 命令を実行することにより、コードはこのネストされたタスク
を中断するものと予測される。すなわち、NTフラグがセットされているために、IRET 命令は自動的
に以前のタスク・リンクを使用してコール元タスクに戻る( 制御を戻す)。( ネストされたタスクの詳
細については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、下
巻』第6 章の「タスクのリンク」の説明を参照のこと。) CALL 命令でのタクスの切り替えは、この
点においてJMP 命令とは異なる。JMP 命令は、NT フラグをセットしないため、IRET 命令がタスク
を中断することを予測しない。
3-61
命令セット・リファレンス
CALL?Call Procedure ( 続き)
16ビットおよび32ビット両コールの混用: 16 ビットと32ビットのコード・セグメント間のコールを
実行するときは、コール・ゲートを介して実行する。32ビットのコード・セグメントから16 ビット
のコード・セグメントへのfar コールの場合、コールは32 ビット・コード・セグメントの最初の64 K
バイトから実行する必要がある。それは、命令のオペランド・サイズ属性が16 に設定されているた
め、16 ビットのリターン・アドレス・オフセットしかセーブされないからである。さらに、スタッ
クに16 ビット値がプッシュされるように、16 ビットのコール・ゲートを使用する。16 ビットと32
ビットのコード・セグメント間でのコールの実行の詳細については、『IA-32 インテルR アーキテク
チャ・ソフトウェア・デベロッパーズ・マニュアル、下巻』第16 章「16 ビット・コードと32 ビッ
ト・コードの混在」を参照のこと。
操作
IF near call
THEN IF near relative call
IF the instruction pointer is not within code segment limit THEN #GP(0); FI;
THEN IF OperandSize ← 32
THEN
IF stack not large enough for a 4-byte return address THEN #SS(0); FI;
Push(EIP);
EIP ← EIP + DEST; (* DEST is rel32 *)
ELSE (* OperandSize ← 16 *)
IF stack not large enough for a 2-byte return address THEN #SS(0); FI;
Push(IP);
EIP ← (EIP + DEST) AND 0000FFFFH; (* DEST is rel16 *)
FI;
FI;
ELSE (* near absolute call *)
IF the instruction pointer is not within code segment limit THEN #GP(0); FI;
IF OperandSize ← 32
THEN
IF stack not large enough for a 4-byte return address THEN #SS(0); FI;
Push(EIP);
EIP ← DEST; (* DEST is r/m32 *)
ELSE (* OperandSize ← 16 *)
IF stack not large enough for a 2-byte return address THEN #SS(0); FI;
Push(IP);
EIP ← DEST AND 0000FFFFH; (* DEST is r/m16 *)
FI;
FI:
FI;
IF far call AND (PE ← 0 OR (PE ← 1 AND VM ← 1)) (* real-address or virtual-8086 mode *)
THEN
IF OperandSize ← 32
3-62
命令セット・リファレンス
CALL?Call Procedure ( 続き)
THEN
IF stack not large enough for a 6-byte return address THEN #SS(0); FI;
IF the instruction pointer is not within code segment limit THEN #GP(0); FI;
Push(CS); (* padded with 16 high-order bits *)
Push(EIP);
CS ← DEST[47:32]; (* DEST is ptr16:32 or [m16:32] *)
EIP ← DEST[31:0]; (* DEST is ptr16:32 or [m16:32] *)
ELSE (* OperandSize ← 16 *)
IF stack not large enough for a 4-byte return address THEN #SS(0); FI;
IF the instruction pointer is not within code segment limit THEN #GP(0); FI;
Push(CS);
Push(IP);
CS ← DEST[31:16]; (* DEST is ptr16:16 or [m16:16] *)
EIP ← DEST[15:0]; (* DEST is ptr16:16 or [m16:16] *)
EIP ← EIP AND 0000FFFFH; (* clear upper 16 bits *)
FI;
FI;
IF far call AND (PE ← 1 AND VM ← 0) (* Protected mode, not virtual-8086 mode *)
THEN
IF segment selector in target operand null THEN #GP(0); FI;
IF segment selector index not within descriptor table limits
THEN #GP(new code segment selector);
FI;
Read type and access rights of selected segment descriptor;
IF segment type is not a conforming or nonconforming code segment, call gate,
task gate, or TSS THEN #GP(segment selector); FI;
Depending on type and access rights
GO TO CONFORMING-CODE-SEGMENT;
GO TO NONCONFORMING-CODE-SEGMENT;
GO TO CALL-GATE;
GO TO TASK-GATE;
GO TO TASK-STATE-SEGMENT;
FI;
CONFORMING-CODE-SEGMENT:
IF DPL > CPL THEN #GP(new code segment selector); FI;
IF segment not present THEN #NP(new code segment selector); FI;
IF OperandSize ← 32
THEN
IF stack not large enough for a 6-byte return address THEN #SS(0); FI;
IF the instruction pointer is not within code segment limit THEN #GP(0); FI;
Push(CS); (* padded with 16 high-order bits *)
Push(EIP);
CS ← DEST[NewCodeSegmentSelector);
(* segment descriptor information also loaded *)
3-63
命令セット・リファレンス
CALL?Call Procedure ( 続き)
CS(RPL) ← CPL
EIP ← DEST[offset);
ELSE (* OperandSize ← 16 *)
IF stack not large enough for a 4-byte return address THEN #SS(0); FI;
IF the instruction pointer is not within code segment limit THEN #GP(0); FI;
Push(CS);
Push(IP);
CS ← DEST[NewCodeSegmentSelector);
(* segment descriptor information also loaded *)
CS(RPL) ← CPL
EIP ← DEST[offset) AND 0000FFFFH; (* clear upper 16 bits *)
FI;
END;
NONCONFORMING-CODE-SEGMENT:
IF (RPL > CPL) OR (DPL ≠ CPL) THEN #GP(new code segment selector); FI;
IF segment not present THEN #NP(new code segment selector); FI;
IF stack not large enough for return address THEN #SS(0); FI;
tempEIP ← DEST[offset)
IF OperandSize=16
THEN
tempEIP ← tempEIP AND 0000FFFFH; (* clear upper 16 bits *)
FI;
IF tempEIP outside code segment limit THEN #GP(0); FI;
IF OperandSize ← 32
THEN
Push(CS); (* padded with 16 high-order bits *)
Push(EIP);
CS ← DEST[NewCodeSegmentSelector);
(* segment descriptor information also loaded *)
CS(RPL) ← CPL;
EIP ← tempEIP;
ELSE (* OperandSize ← 16 *)
Push(CS);
Push(IP);
CS ← DEST[NewCodeSegmentSelector);
(* segment descriptor information also loaded *)
CS(RPL) ← CPL;
EIP ← tempEIP;
FI;
END;
CALL-GATE:
IF call gate DPL < CPL or RPL THEN #GP(call gate selector); FI;
IF call gate not present THEN #NP(call gate selector); FI;
IF call gate code-segment selector is null THEN #GP(0); FI;
3-64
命令セット・リファレンス
CALL?Call Procedure ( 続き)
IF call gate code-segment selector index is outside descriptor table limits
THEN #GP(code segment selector); FI;
Read code segment descriptor;
IF code-segment segment descriptor does not indicate a code segment
OR code-segment segment descriptor DPL > CPL
THEN #GP(code segment selector); FI;
IF code segment not present THEN #NP(new code segment selector); FI;
IF code segment is non-conforming AND DPL < CPL
THEN go to MORE-PRIVILEGE;
ELSE go to SAME-PRIVILEGE;
FI;
END;
MORE-PRIVILEGE:
IF current TSS is 32-bit TSS
THEN
TSSstackAddress ← new code segment (DPL ? 8) + 4
IF (TSSstackAddress + 7) > TSS limit
THEN #TS(current TSS selector); FI;
newSS ← TSSstackAddress + 4;
newESP ← stack address;
ELSE (* TSS is 16-bit *)
TSSstackAddress ← new code segment (DPL ? 4) + 2
IF (TSSstackAddress + 4) > TSS limit
THEN #TS(current TSS selector); FI;
newESP ← TSSstackAddress;
newSS ← TSSstackAddress + 2;
FI;
IF stack segment selector is null THEN #TS(stack segment selector); FI;
IF stack segment selector index is not within its descriptor table limits
THEN #TS(SS selector); FI
Read code segment descriptor;
IF stack segment selector's RPL ≠ DPL of code segment
OR stack segment DPL ≠ DPL of code segment
OR stack segment is not a writable data segment
THEN #TS(SS selector); FI
IF stack segment not present THEN #SS(SS selector); FI;
IF CallGateSize ← 32
THEN
IF stack does not have room for parameters plus 16 bytes
THEN #SS(SS selector); FI;
IF CallGate(InstructionPointer) not within code segment limit THEN #GP(0); FI;
SS ← newSS;
(* segment descriptor information also loaded *)
3-65
命令セット・リファレンス
CALL?Call Procedure ( 続き)
ESP ← newESP;
CS:EIP ← CallGate(CS:InstructionPointer);
(* segment descriptor information also loaded *)
Push(oldSS:oldESP); (* from calling procedure *)
temp ← parameter count from call gate, masked to 5 bits;
Push(parameters from calling procedure’s stack, temp)
Push(oldCS:oldEIP); (* return address to calling procedure *)
ELSE (* CallGateSize ← 16 *)
IF stack does not have room for parameters plus 8 bytes
THEN #SS(SS selector); FI;
IF (CallGate(InstructionPointer) AND FFFFH) not within code segment limit
THEN #GP(0); FI;
SS ← newSS;
(* segment descriptor information also loaded *)
ESP ← newESP;
CS:IP ← CallGate(CS:InstructionPointer);
(* segment descriptor information also loaded *)
Push(oldSS:oldESP); (* from calling procedure *)
temp ← parameter count from call gate, masked to 5 bits;
Push(parameters from calling procedure’s stack, temp)
Push(oldCS:oldEIP); (* return address to calling procedure *)
FI;
CPL ← CodeSegment(DPL)
CS(RPL) ← CPL
END;
SAME-PRIVILEGE:
IF CallGateSize ← 32
THEN
IF stack does not have room for 8 bytes
THEN #SS(0); FI;
IF EIP not within code segment limit then #GP(0); FI;
CS:EIP ← CallGate(CS:EIP) (* segment descriptor information also loaded *)
Push(oldCS:oldEIP); (* return address to calling procedure *)
ELSE (* CallGateSize ← 16 *)
IF stack does not have room for parameters plus 4 bytes
THEN #SS(0); FI;
IF IP not within code segment limit THEN #GP(0); FI;
CS:IP ← CallGate(CS:instruction pointer)
(* segment descriptor information also loaded *)
Push(oldCS:oldIP); (* return address to calling procedure *)
FI;
CS(RPL) ← CPL
3-66
命令セット・リファレンス
CALL?Call Procedure ( 続き)
END;
TASK-GATE:
IF task gate DPL < CPL or RPL
THEN #GP(task gate selector);
FI;
IF task gate not present
THEN #NP(task gate selector);
FI;
Read the TSS segment selector in the task-gate descriptor;
IF TSS segment selector local/global bit is set to local
OR index not within GDT limits
THEN #GP(TSS selector);
FI;
Access TSS descriptor in GDT;
IF TSS descriptor specifies that the TSS is busy (low-order 5 bits set to 00001)
THEN #GP(TSS selector);
FI;
IF TSS not present
THEN #NP(TSS selector);
FI;
SWITCH-TASKS (with nesting) to TSS;
IF EIP not within code segment limit
THEN #GP(0);
FI;
END;
TASK-STATE-SEGMENT:
IF TSS DPL < CPL or RPL
OR TSS descriptor indicates TSS not available
THEN #GP(TSS selector);
FI;
IF TSS is not present
THEN #NP(TSS selector);
FI;
SWITCH-TASKS (with nesting) to TSS
IF EIP not within code segment limit
THEN #GP(0);
FI;
END;
影響を受けるフラグ
タスク・スイッチが行われた場合はすべてのフラグが影響を受け、タスク・スイッチが行われなかっ
た場合はどのフラグも影響を受けない。
3-67
命令セット・リファレンス
CALL?Call Procedure ( 続き)
保護モード例外
#GP(0) デスティネーション・オペランド内のターゲット・オフセットが新しい
コード・セグメントの範囲外の場合。
デスティネーション・オペランド内のセグメント・セレクタがヌルの場
合。
ゲート内のコード・セグメント・セレクタがヌルの場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#GP( セレクタ) コード・セグメント、ゲート、またはTSS のセレクタ・インデックスが
記述子テーブルの範囲外の場合。
デスティネーション・オペランドにあるセグメント・セレクタの指示先
のセグメント記述子がコンフォーミング・コード・セグメント、非コン
フォーミング・コード・セグメント、コール・ゲート、タスク・ゲート、
またはタスク・ステート・セグメントのいずれのものでもなかった場合。
非コンフォーミング・コード・セグメントのDPL がCPL に等しくない
か、またはセグメントのセグメント・セレクタのRPL がCPL より大き
い場合。
コンフォーミング・コード・セグメントのDPL がCPL より大きい場合。
コール・ゲート、タスク・ゲート、またはTSS のセグメント記述子から
のDPL が、CPL、またはコール・ゲート、タスク・ゲート、またはTSS
のセグメント・セレクタのRPL より小さい場合。
コール・ゲートからのセグメント・セレクタのセグメント記述子が、そ
のコール・ゲートがコード・セグメントであることを示していない場合。
コール・ゲートからのセグメント・セレクタが記述子テーブルの範囲外
の場合。
コール・ゲートから得られたコード・セグメントのDPL がCPL より大
きい場合。
TSS のセグメント・セレクタのローカル/ グローバル・ビットがローカ
ルとしてセットされている場合。
TSS のセグメント記述子が、TSS がビジーであるか、または使用不可能
であることを示している場合。
#SS(0) スタック・スイッチが行われなかったときに、リターン・アドレス、パラ
メータ、またはスタック・セグメント・ポインタをスタックにプッシュした
結果、スタック・セグメントの範囲を超えた場合。
メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
3-68
命令セット・リファレンス
CALL?Call Procedure ( 続き)
#SS( セレクタ) スタック・スイッチが行われたときに、リターン・アドレス、パラメー
タ、またはスタック・セグメント・ポインタをスタックにプッシュした
結果、スタック・セグメントの範囲を超えた場合。
スタック・スイッチの一環としてSS レジスタへのロードが行われよう
とするとき、指示先のセグメントが存在しないとマークされていた場
合。
スタック・スイッチが行われたとき、リターン・アドレス、パラメータ、
またはスタック・セグメント・ポインタをストアするための余裕がス
タック・セグメントにない場合。
#NP( セレクタ) コード・セグメント、データ・セグメント、スタック・セグメント、コー
ル・ゲート、タスク・ゲート、またはTSS が存在しない場合。
#TS( セレクタ) 新しいスタック・セグメント・セレクタとESP がTSS の終りを超えて
いる場合。
新しいスタック・セグメント・セレクタがヌルの場合。
TSS 内の新しいスタック・セグメント・セレクタのRPL がアクセス先の
コード・セグメントのDPL と等しくない場合。
新しいスタック・セグメント用のスタック・セグメント記述子のDPL が
コード・セグメント記述子のDPL と等しくない場合。
新しいスタック・セグメントが書き込み可能なデータ・セグメントでな
い場合。
スタック・セグメントのセグメント・セレクタ・インデックスが記述子
テーブルの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
ターゲット・オフセットがコード・セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
ターゲット・オフセットがコード・セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-69
命令セット・リファレンス
CBW/CWDE?Convert Byte to Word/Convert Word to Doubleword
説明
符号拡張により、ソース・オペランドのサイズを2 倍に拡張する (『IA-32 インテルR アーキテクチャ・
ソフトウェア・デベロッパーズ・マニュアル、上巻』の図6-5. を参照)。CBW ( バイトからワードへ
の変換) 命令は、ソース・オペランドの符号 ( ビット7) をAHレジスタのすべてのビットにコピーす
る。CWDE ( ワードからダブルワードへの変換) 命令は、AXレジスタ内のワードの符号 ( ビット15)
をEAXレジスタの上位16 ビットにコピーする。
CBWおよびCWDE ニーモニックは同じオペコードを参照する。CBW 命令はオペランド・サイズ属
性が16 のとき、またCWDE命令はオペランド・サイズ属性が32 のときに使用することを目的として
いる。一部のアセンブラには、CBW が使用されたときはオペランド・サイズを16 ビットに、また
CWDE が使用されたときは32 ビットに強制できるものがある。その他のアセンブラは、これらの
ニーモニックを同義語 (CBW/CWDE) として取り扱い、どちらのニーモニックが使用されても、その
ときのオペランド・サイズ属性の設定を使用して変換対象の値のサイズを判定できる。
CWDE 命令は、CWD ( ワードからダブルへの変換) 命令とは異なる。すなわち、CWD 命令はデス
ティネーション・オペランドしてDX:AX レジスタ・ペアを使用するのに対し、CWDE 命令はデス
ティネーションとしてEAXレジスタを使用する。
操作
IF OperandSize ← 16 (* instruction ← CBW *)
THEN AX ← SignExtend(AL);
ELSE (* OperandSize ← 32, instruction ← CWDE *)
EAX ← SignExtend(AX);
FI;
影響を受けるフラグ
なし。
例外 ( すべての操作モード)
なし。
オペコード命令説明
98 CBW AX ← AL の符号拡張
98 CWDE EAX ← AX の符号拡張
3-70
命令セット・リファレンス
CDQ?Convert Double to Quad
「CWD/CDQ?Convert Word to Doubleword/Convert Doubleword to Quadword」を参照のこと。
3-71
命令セット・リファレンス
CLC?Clear Carry Flag
説明
EFLAGSレジスタ内のCF フラグをクリアする。
操作
CF ← 0;
影響を受けるフラグ
CFフラグが0 にクリアされる。OF、ZF、SF、AF、およびPFフラグは影響を受けない。
例外 ( すべての操作モード)
なし。
オペコード命令説明
F8 CLC CF フラグをクリアする。
3-72
命令セット・リファレンス
CLD?Clear Direction Flag
説明
EFLAGSレジスタ内のDFフラグをクリアする。DFフラグが0 にセットされているときは、ストリン
グ操作を行うと、インデックス・レジスタ (ESI またはEDI、あるいは両方) がインクリメントされる。
操作
DF ← 0;
影響を受けるフラグ
DFフラグが0 にクリアされる。CF、OF、ZF、SF、AF、およびPF フラグは影響を受けない。
例外 ( すべての操作モード)
なし。
オペコード命令説明
FC CLD DF フラグをクリアする。
3-73
命令セット・リファレンス
CLFLUSH?Cache Line Flush
説明
プロセッサのキャッシュ階層（データおよび命令）のすべてのレベルで、ソース・オペランドで指
定されたリニア・アドレスが入っているキャッシュ・ラインを無効化する。この無効化は、キャッ
シュのコヒーレンシ・ドメイン全体にブロードキャストされる。キャッシュ階層のいずれかのレベ
ルで、指定されたキャッシュ・ラインとメモリの内容が一致しない（キャッシュ・ラインがダーティ
になっている）場合は、無効化される前に、キャッシュ・ラインの内容がメモリに書き込まれる。
ソース・オペランドは、1 バイトのメモリ・ロケーションである。
CLFLUSHが使用できるかどうかは、CPUID機能フラグCLFSHの状態によって示される（EDXレジ
スタのビット19 は「CPUID?CPU Identification」の項を参照）。CLFLUSH 命令の影響を受ける、ア
ライメントの合ったキャッシュ・ラインのサイズもCPUID 命令で示される(EAX レジスタの初期値
が1 の場合は、EBXレジスタのビット8 〜ビット15まで)。
この命令の影響を受けるキャッシュ・ラインを含むページのメモリ属性は、この命令の動作に影響
を与えない。ただし、プロセッサは、見込み的な読み込みが許されるメモリ・タイプ（すなわち、
WB、WC、およびWT メモリ・タイプ）が割り当てられたシステム・メモリ領域から、自由にデー
タを見込み的にフェッチしてキャッシュに入れることができる。この見込み的な動作に対するヒン
トをプロセッサに提示するには、PREFETCHh 命令を使用する。この見込み的なフェッチ動作は、命
令の実行には拘束されず、任意の時点で発生する。したがって、CLFLUSH 命令は、PREFETCHh 命
令などの見込み的なフェッチ機構に対して順序付けされない（つまり、キャッシュ・ラインを参照
するCLFLUSH命令の実行の直前、実行中、または実行後に、データがキャッシュに見込み的にロー
ドされる可能性がある）。
CLFLUSH は、MFENCE 命令によってのみ順序付けされる。他のフェンス操作命令、シリアル化命
令、または他のCLFLUSH命令による順序付けは保証されない。例えば、ソフトウェアは、MFENCE
命令を使用して、ライトバックに以前のストアが含まれるように保証することができる。
CLFLUSH 命令は、すべての特権レベルで使用できる。CLFLUSH 命令には、バイト・ロードに関連
するすべてのパーミッション・チェックとフォルトが適用される( 更に、CLFLUSH 命令は、実行専
用セグメント内のリニア・アドレスをフラッシュすることが許される)。ロードと同じように、
CLFLUSH命令は、ページ・テーブル内のAビットをセットし、Dビットはセットしない。
CLFLUSH命令は、SSE2 拡張命令に対して導入されたものである。ただし、独自のCPUID機能フラ
グを持つため、SSE2 拡張命令が組み込まれていないIA-32 プロセッサに実装することができる。ま
た、CPUID命令を使ってSSE2拡張命令が存在することが検出されても、プロセッサにCLFLUSH命
令が実装されているかどうかは保証されない。
操作
Flush_Cache_Line(SRC)
同等のインテルC/C++ コンパイラ組み込み関数
CLFLUSH void_mm_clflush(void const *p)
オペコード命令説明
0F AE /7 CLFLUSH m8 m8 が入っているキャッシュ・ラインをフラッシュする。
3-74
命令セット・リファレンス
CLFLUSH?Cache Line Flush ( 続き)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#UD CPUID 機能フラグCLFSH が0 の場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CPUID 機能フラグCLFSH が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-75
命令セット・リファレンス
CLI?Clear Interrupt Flag
説明
EFLAGS レジスタ内のIF フラグをクリアする。その他のフラグは影響を受けない。IF フラグをクリ
アすると、プロセッサはマスク可能な外部割り込みを無視する。IF フラグとCLI およびSTI 命令は、
例外およびNMI 割り込みの発生には関係しない。
以下のデシジョン・テーブルに、プロセッサの動作モードによるCLI 命令の処置 ( テーブルの横の太
い線の下側) と、そのとき実行中のプログラムまたはプロシージャのCPL およびIOPL ( テーブルの
横の太い線の上側) を示す。
注:
X 無指定。
N 左端の欄の処置が行われない。
Y 左端の欄の処置が行われる。
オペコード命令説明
FA CLI 割り込みフラグをクリアする。割り込みフラグがクリアさ
れているときは割り込みはディスエーブルにされる。
PE = 0 1 1 1 1
VM = X 0 X 0 1
CPL X ? IOPL X > IOPL X
IOPL X X = 3 X < 3
IF ← 0 Y Y Y N N
#GP(0) N N N Y Y
3-76
命令セット・リファレンス
CLI?Clear Interrupt Flag ( 続き)
操作
IF PE ← 0 (* Executing in real-address mode *)
THEN
IF ← 0;
ELSE
IF VM ← 0 (* Executing in protected mode *)
THEN
IF CPL ? IOPL
THEN
IF ← 0;
ELSE
#GP(0);
FI;
FI;
ELSE (* Executing in Virtual-8086 mode *)
IF IOPL ← 3
THEN
IF ← 0
ELSE
#GP(0);
FI;
FI;
FI;
影響を受けるフラグ
CPLがIOPLに等しいか小さい場合は、IF フラグが0 にクリアされる。そうでない場合、IF フラグは
変わらない。EFLAGSレジスタ内のその他のフラグは影響を受けない。
保護モード例外
#GP(0) CPL が現在のプログラムまたはプロシージャのIOPL より大きい ( 特権
が小さい) 場合。
実アドレス・モード例外
なし。
仮想8086 モード例外
#GP(0) CPL が現在のプログラムまたはプロシージャのIOPL より大きい ( 特権
が小さい) 場合。
3-77
命令セット・リファレンス
CLTS?Clear Task-Switched Flag in CR0
説明
CR0 レジスタ内のタスク・スイッチ (TS) フラグをクリアする。この命令は、オペレーティング・シ
ステム内で使用することを目的としている。これはCPL = 0 でのみ実行できる特権命令である。この
命令は、保護モード向けの初期化を可能にするため、実アドレス・モードで実行できるようになっ
ている。
プロセッサはタスク・スイッチが行われるたびにTS フラグをセットする。このフラグは、マルチタ
スキング・アプリケーションでのFPU コンテキストのセーブを同期させるために使用される。この
フラグの詳細については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マ
ニュアル、下巻』第2 章の「制御レジスタ」のTS フラグに関する説明を参照のこと。
操作
CR0(TS) ← 0;
影響を受けるフラグ
CR0 レジスタ内のTS フラグがクリアされる。
保護モード例外
#GP(0) CPL が0 より大きい場合。
実アドレス・モード例外
なし。
仮想8086 モード例外
#GP(0) CPL が0 より大きい場合。
オペコード命令説明
0F 06 CLTS CR0 のTS フラグをクリアする。
3-78
命令セット・リファレンス
CMC?Complement Carry Flag
説明
EFLAGSレジスタ内のCFフラグの状態を反転する。
操作
CF ← NOT CF;
影響を受けるフラグ
CF フラグの内容がその元の値の補数になる。OF、ZF、SF、AF、およびPF フラグは影響を受けない。
例外 ( すべての操作モード)
なし。
オペコード命令説明
F5 CMC CF フラグの状態を反転する。
3-79
命令セット・リファレンス
CMOVcc?Conditional Move
オペコード命令説明
0F 47 /r CMOVA r16, r/m16 より上 (CF=0 およびZF=0) の場合転送する。
0F 47 /r CMOVA r32, r/m32 より上 (CF=0 およびZF=0) の場合転送する。
0F 43 /r CMOVAE r16, r/m16 より上か等しい (CF=0) 場合転送する。
0F 43 /r CMOVAE r32, r/m32 より上か等しい (CF=0) 場合転送する。
0F 42 /r CMOVB r16, r/m16 より下 (CF=1) の場合転送する。
0F 42 /r CMOVB r32, r/m32 より下 (CF=1) の場合転送する。
0F 46 /r CMOVBE r16, r/m16 より下か等しい (CF=1 またはZF=1) 場合転送する。
0F 46 /r CMOVBE r32, r/m32 より下か等しい (CF=1 またはZF=1) 場合転送する。
0F 42 /r CMOVC r16, r/m16 キャリーがある (CF=1) 場合転送する。
0F 42 /r CMOVC r32, r/m32 キャリーがある (CF=1) 場合転送する。
0F 44 /r CMOVE r16, r/m16 等しい (ZF=1) 場合転送する。
0F 44 /r CMOVE r32, r/m32 等しい (ZF=1) 場合転送する。
0F 4F /r CMOVG r16, r/m16 より大きい (ZF=0 およびSF=OF) 場合転送する。
0F 4F /r CMOVG r32, r/m32 より大きい (ZF=0 およびSF=OF) 場合転送する。
0F 4D /r CMOVGE r16, r/m16 より大きいか等しい (SF=OF) 場合転送する。
0F 4D /r CMOVGE r32, r/m32 より大きいか等しい (SF=OF) 場合転送する。
0F 4C /r CMOVL r16, r/m16 より小さい (SF<>OF) 場合転送する。
0F 4C /r CMOVL r32, r/m32 より小さい (SF<>OF) 場合転送する。
0F 4E /r CMOVLE r16, r/m16 より小さいか等しい (ZF=1 またはSF<>OF) 場合転送する。
0F 4E /r CMOVLE r32, r/m32 より小さいか等しい (ZF=1 またはSF<>OF) 場合転送する。
0F 46 /r CMOVNA r16, r/m16 より上でない (CF=1 またはZF=1) 場合転送する。
0F 46 /r CMOVNA r32, r/m32 より上でない (CF=1 またはZF=1) 場合転送する。
0F 42 /r CMOVNAE r16, r/m16 より上でなく等しくない (CF=1) 場合転送する。
0F 42 /r CMOVNAE r32, r/m32 より上でなく等しくない (CF=1) 場合転送する。
0F 43 /r CMOVNB r16, r/m16 より下でない (CF=0) 場合転送する。
0F 43 /r CMOVNB r32, r/m32 より下でない (CF=0) 場合転送する。
0F 47 /r CMOVNBE r16, r/m16 より下でなく等しくない (CF=0 およびZF=0) 場合転送する。
0F 47 /r CMOVNBE r32, r/m32 より下でなく等しくない (CF=0 およびZF=0) 場合転送する。
0F 43 /r CMOVNC r16, r/m16 キャリーがない (CF=0) 場合転送する。
0F 43 /r CMOVNC r32, r/m32 キャリーがない (CF=0) 場合転送する。
0F 45 /r CMOVNE r16, r/m16 等しくない (ZF=0) 場合転送する。
0F 45 /r CMOVNE r32, r/m32 等しくない (ZF=0) 場合転送する。
0F 4E /r CMOVNG r16, r/m16 より大きくない (ZF=1 またはSF<>OF) 場合転送する。
0F 4E /r CMOVNG r32, r/m32 より大きくない (ZF=1 またはSF<>OF) 場合転送する。
0F 4C /r CMOVNGE r16, r/m16 より大きくなく等しくない (SF<>OF) 場合転送する。
0F 4C /r CMOVNGE r32, r/m32 より大きくなく等しくない (SF<>OF) 場合転送する。
0F 4D /r CMOVNL r16, r/m16 より小さくない (SF=OF) 場合転送する。
0F 4D /r CMOVNL r32, r/m32 より小さくない (SF=OF) 場合転送する。
0F 4F /r CMOVNLE r16, r/m16 より小さくなく等しくない (ZF=0 およびSF=OF) 場合転送する。
0F 4F /r CMOVNLE r32, r/m32 より小さくなく等しくない (ZF=0 およびSF=OF) 場合転送する。
3-80
命令セット・リファレンス
CMOVcc?Conditional Move ( 続き)
説明
CMOVcc 命令は、EFLAGS レジスタ内のステータス・フラグ (CF、OF、PF、SF、およびZF) の1 つ
以上の状態を調べ、それらのフラグが指定された状態 ( または条件) の場合、転送操作を実行する。
各命令ごとに特定の条件コード(cc) が対応しており、テスト対象の条件を示している。条件が満た
されなかった場合は、転送は行われず、CMOVcc 命令の次の命令から実行が継続される。
これらの命令では、メモリからいずれかの汎用レジスタに、または1 つの汎用レジスタから他の汎用
レジスタに16 または32 ビットの値を転送する。8 ビット・レジスタ・オペランドの条件付き転送は
サポートされていない。
各CMOVccニーモニックの条件は、上記の表の説明欄に示してある。「より小さい」および「より大
きい」という表現は、符号付き整数の比較に使用され、「より上」および「より下」という表現は符
号なし整数の比較に使用されている。
ステータス・フラグの特定の状態はときとして2 種類に解釈されることがあるので、一部のオペコー
ドに対しては2 つのニーモニックが定義されている。例えば、CMOVA ( より上条件付き転送) 命令と
CMOVNBE ( より下でなく等しくない条件付き転送) 命令とは、同一のオペコード 0F 47H に対する2
つのニーモニックである。
オペコード命令説明
0F 41 /r CMOVNO r16, r/m16 オーバフローがない (OF=0) 場合転送する。
0F 41 /r CMOVNO r32, r/m32 オーバフローがない (OF=0) 場合転送する。
0F 4B /r CMOVNP r16, r/m16 パリティがない (PF=0) 場合転送する。
0F 4B /r CMOVNP r32, r/m32 パリティがない (PF=0) 場合転送する。
0F 49 /r CMOVNS r16, r/m16 符号がない (SF=0) 場合転送する。
0F 49 /r CMOVNS r32, r/m32 符号がない (SF=0) 場合転送する。
0F 45 /r CMOVNZ r16, r/m16 ゼロでない (ZF=0) 場合転送する。
0F 45 /r CMOVNZ r32, r/m32 ゼロでない (ZF=0) 場合転送する。
0F 40 /r CMOVO r16, r/m16 オーバフローがある (OF=0) 場合転送する。
0F 40 /r CMOVO r32, r/m32 オーバフローがある (OF=0 場合転送する。
0F 4A /r CMOVP r16, r/m16 パリティがある (PF=1) 場合転送する。
0F 4A /r CMOVP r32, r/m32 パリティがある (PF=1) 場合転送する。
0F 4A /r CMOVPE r16, r/m16 パリティが偶数 (PF=1) の場合転送する。
0F 4A /r CMOVPE r32, r/m32 パリティが偶数 (PF=1) の場合転送する。
0F 4B /r CMOVPO r16, r/m16 パリティが奇数 (PF=0) の場合転送する。
0F 4B /r CMOVPO r32, r/m32 パリティが奇数 (PF=0) の場合転送する。
0F 48 /r CMOVS r16, r/m16 符号がある (SF=1) 場合転送する。
0F 48 /r CMOVS r32, r/m32 符号がある (SF=1) 場合転送する。
0F 44 /r CMOVZ r16, r/m16 ゼロ (ZF=1) の場合転送する。
0F 44 /r CMOVZ r32, r/m32 ゼロ (ZF=1) の場合転送する。
3-81
命令セット・リファレンス
CMOVcc?Conditional Move ( 続き)
CMOVcc 命令はPentium Pro プロセッサ・ファミリに新たに導入されたが、これらの命令はこのファ
ミリのすべてのプロセッサでサポートされているわけではない。CMOVcc 命令がサポートされてい
るかどうかは、CPUID 命令でプロセッサの機能情報を調べることにより判定できる ( 本章の
「COMISS?Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS」を参照)。
操作
temp ← DEST
IF condition TRUE
THEN
DEST ← SRC
ELSE
DEST ← temp
FI;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
3-82
命令セット・リファレンス
CMOVcc?Conditional Move ( 続き)
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-83
命令セット・リファレンス
CMP?Compare Two Operands
説明
第1 ソース・オペランドを第2 ソース・オペランドと比較し、結果に従ってEFLAGSレジスタ内のス
テータス・フラグをセットする。比較は、第1 オペランドから第2 オペランドを引き、次にSUB命令
の場合と同様にステータス・フラグをセットして行われる。オペランドとして即値を使用した場合
は、そのオペランドは第1 オペランドの長さに符号拡張される。
CMP 命令は、一般的に条件付きジャンプ (Jcc)、条件付き転送 (CMOVcc)、またはSETcc 命令と併用さ
れる。Jcc、CMOVcc、およびSETcc 命令が使用する条件コードはCMP 命令の結果に基づく。『IA-32
インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』付録B「EFLAGS
条件コード」に、ステータス・フラグと条件コードとの関係が示してある。
操作
temp ← SRC1 ? SignExtend(SRC2);
ModifyStatusFlags; (* Modify status flags in the same manner as the SUB instruction*)
影響を受けるフラグ
CF、OF、SF、ZF、AF、およびPF フラグが結果に従ってセットされる。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
オペコード命令説明
3C ib CMP AL, imm8 imm8 をAL と比較する。
3D iw CMP AX, imm16 imm16 をAX と比較する。
3D id CMP EAX, imm32 imm32 をEAX と比較する。
80 /7 ib CMP r/m8, imm8 imm8 をr/m8 と比較する。
81 /7 iw CMP r/m16, imm16 imm16 をr/m16 と比較する。
81 /7 id CMP r/m32,imm32 imm32 をr/m32 と比較する。
83 /7 ib CMP r/m16,imm8 imm8 をr/m16 と比較する。
83 /7 ib CMP r/m32,imm8 imm8 をr/m32 と比較する。
38 /r CMP r/m8,r8 r8 をr/m8 と比較する。
39 /r CMP r/m16,r16 r16 をr/m16 と比較する。
39 /r CMP r/m32,r32 r32 をr/m32 と比較する。
3A /r CMP r8,r/m8 r/m8 をr8 と比較する。
3B /r CMP r16,r/m16 r/m16 をr16 と比較する。
3B /r CMP r32,r/m32 r/m32 をr32 と比較する。
3-84
命令セット・リファレンス
CMP?Compare Two Operands ( 続き)
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-85
命令セット・リファレンス
CMPPD?Compare Packed Double-Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の2
つのパックド倍精度浮動小数点値のSIMD比較を実行し、比較の結果をデスティネーション・オペラ
ンドに返す。比較プレディケート・オペランド（第3 オペランド）は、パックド値の各ペアに対して
実行される比較のタイプを指定する。各比較の結果は、すべて1（比較は真）またはすべて0（比較
は偽）のクワッドワード・マスクになる。ソース・オペランドは、XMMレジスタまたは128 ビット
のメモリ・ロケーションである。デスティネーション・オペランドはXMMレジスタである。比較プ
レディケート・オペランドは8 ビット即値であり、実行される比較のタイプを最初の3 ビットで定義
する（表3-5. を参照）。即値のビット4 〜7 は予約済みである。
オペコード命令説明
66 0F C2 /r ib CMPPD xmm1,
xmm2/m128, imm8
imm8 を比較プレディケートとして使用して、xmm2/m128
のパックド倍精度浮動小数点値とxmm1 のパックド倍精度
浮動小数点値を比較する。
表3-5. CMPPD 命令とCMPPS 命令の比較プレディケート
プレディ
ケート
imm8 の
エンコー
ディング
説明関係:
A は第1 オペランド
B は第2 オペランド
エミュレー
ション
NaN
オペランドの
場合の結果
QNaN
オペランドの
場合に無効が
報告されるか
EQ 000B 等しいA = B 偽いいえ
LT 001B より小さいA < B 偽はい
LE 010B より小さいか等
しい
A ? B 偽はい
より大きいA > B オペランドを入
れ替えて、LT を
使用する。
偽はい
より大きいか等
しい
A ? B オペランドを入
れ替えて、LE
を使用する。
偽はい
UNORD 011B アンオーダーA、B= アンオーダー真いいえ
NEQ 100B 等しくないA ≠ B 真いいえ
NLT 101B より小さくないNOT(A < B) 真はい
NLE 110B より小さくなく
等しくない
NOT(A ? B) 真はい
より大きくないNOT(A > B) オペランドを入
れ替えて、NLT
を使用する。
真はい
より大きくなく
等しくない
NOT(A ? B) オペランドを入
れ替えて、NLE
を使用する。
真はい
ORD 111B オーダーA、B= オーダー偽いいえ
3-86
命令セット・リファレンス
CMPPD?Compare Packed Double-Precision Floating-Point Values
( 続き)
2 つの比較対象ソース・オペランドのうち、少なくとも1 つがNaNであるかフォーマットが定義され
ていない場合、アンオーダー関係は真となる。ソース・オペランドがNaN ではなく、フォーマット
も定義されている場合は、オーダー関係は真となる。
この命令の後に、結果として得られたデスティネーション・オペランド内のマスクを入力オペラン
ドとして使用して計算命令を実行しても、例外は発生しない。これは、すべて0 のマスクは浮動小数
点値+0.0 に対応し、すべて1 のマスクはQNaNに対応するためである。
プロセッサには、「より大きい」、「より大きいか等しい」、「より大きくない」、「より大きくなく等し
くない」の関係は実装されていない。これらの比較を行なうには、逆の関係を利用するか( すなわ
ち、「より大きい」比較を行なうには「より小さくなく等しくない」を使用する)、またはソフトウェ
ア・エミュレーションを利用する。ソフトウェア・エミュレーションを使用する場合、プログラム
上では、ソース・オペランドとデスティネーション・オペランドを入れ替え、必要に応じてレジス
タをコピーして、新たにデスティネーションに入るデータを保護し、さらに、異なるプレディケー
トを使って比較を実行しなければならない。これらのエミュレーションに使用されるプレディケー
トは、表3-5. の「エミュレーション」の項目に記載されている。
コンパイラとアセンブラは、3 オペランドのCMPPD 命令以外に、以下の2 オペランドの擬似演算を
サポートできる。
「より大きい」の関係は、プロセッサが用意していないため、2 つ以上の命令を使用してソフトウェ
ア的にエミュレートする必要がある。したがって、これらの関係は擬似演算としてはサポートされ
ない。「より大きい」の条件で比較する場合は、プログラマは、それに対応する「より小さい」の関
係のソース・オペランドとデスティネーション・オペランドを入れ替え、移動命令を使用してマス
クを適切なデスティネーション・レジスタに移動し、ソース・オペランドが影響を受けないように
する必要がある。
擬似演算対応するCMPPD 命令
CMPEQPD xmm1, xmm2 CMPPD xmm1, xmm2, 0
CMPLTPD xmm1, xmm2 CMPPD xmm1, xmm2, 1
CMPLEPD xmm1, xmm2 CMPPD xmm1, xmm2, 2
CMPUNORDPD xmm1, xmm2 CMPPD xmm1, xmm2, 3
CMPNEQPD xmm1, xmm2 CMPPD xmm1, xmm2, 4
CMPNLTPD xmm1, xmm2 CMPPD xmm1, xmm2, 5
CMPNLEPD xmm1, xmm2 CMPPD xmm1, xmm2, 6
CMPORDPD xmm1, xmm2 CMPPD xmm1, xmm2, 7
3-87
命令セット・リファレンス
CMPPD?Compare Packed Double-Precision Floating-Point Values
( 続き)
操作
CASE (COMPARISON PREDICATE) OF
0: OP ← EQ;
1: OP ← LT;
2: OP ← LE;
3: OP ← UNORD;
4: OP ← NEQ;
5: OP ← NLT;
6: OP ← NLE;
7: OP ← ORD;
DEFAULT: Reserved;
CMP0 ← DEST[63-0] OP SRC[63-0];
CMP1 ← DEST[127-64] OP SRC[127-64];
IF CMP0 == TRUE
THEN DEST[63-0] ← FFFFFFFFFFFFFFFFH
ELSE DEST[63-0] ← 0000000000000000H; FI;
IF CMP1 == TRUE
THEN DEST[127-64] ← FFFFFFFFFFFFFFFFH
ELSE DEST[127-64] ← 0000000000000000H; FI;
同等のインテルC/C++ コンパイラ組み込み関数
CMPPD「等しい」の条件で比較。 __m128d _mm_cmpeq_pd(__m128d a, __m128d b)
CMPPD「より小さい」の条件で比較。 __m128d _mm_cmplt_pd(__m128d a, __m128d b)
CMPPD「より小さいか等しい」の条件で比較。
__m128d _mm_cmple_pd(__m128d a, __m128d b)
CMPPD「より大きい」の条件で比較。 __m128d _mm_cmpgt_pd(__m128d a, __m128d b)
CMPPD「より大きいか等しい」の条件で比較。
__m128d _mm_cmpge_pd(__m128d a, __m128d b)
CMPPD「等しくない」の条件で比較。 __m128d _mm_cmpneq_pd(__m128d a, __m128d b)
CMPPD「より小さくない」の条件で比較。
__m128d _mm_cmpnlt_pd(__m128d a, __m128d b)
CMPPD「より大きくない」の条件で比較。
__m128d _mm_cmpngt_pd(__m128d a, __m128d b)
CMPPD「より大きくなく等しくない」の条件で比較。
__m128d _mm_cmpnge_pd(__m128d a, __m128d b)
CMPPD「オーダー」の条件で比較。 __m128d _mm_cmpord_pd(__m128d a, __m128d b)
CMPPD「アンオーダー」の条件で比較。 __m128d _mm_cmpunord_pd(__m128d a, __m128d b)
CMPPD「より小さくなく等しくない」の条件で比較。
__m128d _mm_cmpnle_pd(__m128d a, __m128d b)
3-88
命令セット・リファレンス
CMPPD?Compare Packed Double-Precision Floating-Point Values
( 続き)
SIMD 浮動小数点例外
無効（SNaN オペランドの場合）、無効（QNaNと上記の表のプレディケートの場合）、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-89
命令セット・リファレンス
CMPPS?Compare Packed Single-Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の4
つのパックド単精度浮動小数点値のSIMD比較を実行し、比較の結果をデスティネーション・オペラ
ンドに返す。比較プレディケート・オペランド（第3 オペランド）は、パックド値の各ペアに対して
実行される比較のタイプを指定する。比較の結果は、すべて1（比較は真）またはすべて0（比較は
偽）の4 つのダブルワード・マスクになる。ソース・オペランドは、XMMレジスタまたは128 ビッ
トのメモリ・ロケーションである。デスティネーション・オペランドはXMMレジスタである。比較
プレディケート・オペランドは8 ビット即値であり、実行される比較のタイプを最初の3 ビットで定
義する（表3-5. を参照）。即値のビット4 〜7 は予約済みである。
2 つの比較対象ソース・オペランドのうち、少なくとも1 つがNaNであるかフォーマットが定義され
ていない場合、アンオーダー関係は真となる。ソース・オペランドがNaN ではなく、フォーマット
も定義されている場合は、オーダー関係は真となる。
この命令の後に、デスティネーション・オペランド内の結果のマスクを入力オペランドとして使用
する計算命令を実行しても、フォルトは発生しない。これは、すべて0 のマスクは+0.0 の浮動小数
点値に対応し、すべて1 のマスクはQNaNに対応するためである。
表3-5. に示した一部の比較（「より大きい」、「より大きいか等しい」、「より大きくない」、および「よ
り大きくなく等しくない」の関係）は、ソフトウェア・エミュレーションでしか実行できない。こ
れらの比較を行う場合、プログラムは、ソース・オペランドとデスティネーション・オペランドを
入れ替え（必要に応じてレジスタをコピーして、新たにデスティネーションに入るデータを保護し）、
異なるプレディケートを使って比較を実行しなければならない。これらのエミュレーションに使用
されるプレディケートは、表3-5. の「エミュレーション」の項目に記載されている。
コンパイラとアセンブラは、3 オペランドのCMPPS 命令以外に、次の2 オペランドの擬似演算をサ
ポートする必要がある。
オペコード命令説明
0F C2 /r ib CMPPS xmm1,
xmm2/m128, imm8
imm8 を比較プレディケートとして使用して、xmm2/mem
のパックド単精度浮動小数点値とxmm1 のパックド単精度
浮動小数点値を比較する。
擬似演算対応するCMPPS 命令
CMPEQPS xmm1, xmm2 CMPPS xmm1,xmm2, 0
CMPLTPS xmm1, xmm2 CMPPS xmm1,xmm2, 1
CMPLEPS xmm1, xmm2 CMPPS xmm1,xmm2, 2
CMPUNORDPS xmm1, xmm2 CMPPS xmm1,xmm2, 3
CMPNEQPS xmm1, xmm2 CMPPS xmm1,xmm2, 4
CMPNLTPS xmm1, xmm2 CMPPS xmm1,xmm2, 5
CMPNLEPS xmm1, xmm2 CMPPS xmm1,xmm2, 6
CMPORDPS xmm1, xmm2 CMPPS xmm1,xmm2, 7
3-90
命令セット・リファレンス
CMPPS?Compare Packed Single-Precision Floating-Point Values
( 続き)
「より大きい」の関係は、ハードウェア上で用意されていないため、2 つ以上の命令を使用してソフ
トウェア的にエミュレートする必要がある。したがって、これらの関係は擬似演算としてはサポー
トされない。「より大きい」の条件で比較する場合は、プログラマが、対応する「より小さい」の関
係のソース・オペランドとデスティネーション・オペランドを入れ替え、ソース・オペランドが影
響を受けないように、移動命令を使用してマスクを適切なデスティネーション・レジスタに移動し
なければならない。
操作
CASE (COMPARISON PREDICATE) OF
0: OP ← EQ;
1: OP ← LT;
2: OP ← LE;
3: OP ← UNORD;
4: OP ← NE;
5: OP ← NLT;
6: OP ← NLE;
7: OP ← ORD;
EASC
CMP0 ← DEST[31-0] OP SRC[31-0];
CMP1 ← DEST[63-32] OP SRC[63-32];
CMP2 ← DEST [95-64] OP SRC[95-64];
CMP3 ← DEST[127-96] OP SRC[127-96];
IF CMP0 == TRUE
THEN DEST[31-0] ← FFFFFFFFH
ELSE DEST[31-0] ← 00000000H; FI;
IF CMP1 == TRUE
THEN DEST[63-32] ← FFFFFFFFH
ELSE DEST[63-32] ← 00000000H; FI;
IF CMP2 == TRUE
THEN DEST95-64] ← FFFFFFFFH
ELSE DEST[95-64] ← 00000000H; FI;
IF CMP3 == TRUE
THEN DEST[127-96] ← FFFFFFFFH
ELSE DEST[127-96] ← 00000000H; FI;
同等のインテルC/C++ コンパイラ組み込み関数
CMPPS「等しい」の条件で比較。 __m128 _mm_cmpeq_ps(__m128 a, __m128 b)
CMPPS「より小さい」の条件で比較。 __m128 _mm_cmplt_ps(__m128 a, __m128 b)
CMPPS「より小さいか等しい」の条件で比較。
__m128 _mm_cmple_ps(__m128 a, __m128 b)
CMPPS「より大きい」の条件で比較。 __m128 _mm_cmpgt_ps(__m128 a, __m128 b)
3-91
命令セット・リファレンス
CMPPS?Compare Packed Single-Precision Floating-Point Values
( 続き)
CMPPS「より大きいか等しい」の条件で比較。
__m128 _mm_cmpge_ps(__m128 a, __m128 b)
CMPPS「等しくない」の条件で比較。 __m128 _mm_cmpneq_ps(__m128 a, __m128 b)
CMPPS「より小さくない」の条件で比較。 __m128 _mm_cmpnlt_ps(__m128 a, __m128 b)
CMPPS「より大きくない」の条件で比較。 __m128 _mm_cmpngt_ps(__m128 a, __m128 b)
CMPPS「より大きくなく等しくない」の条件で比較。
__m128 _mm_cmpnge_ps(__m128 a, __m128 b)
CMPPS「オーダー」の条件で比較。 __m128 _mm_cmpord_ps(__m128 a, __m128 b)
CMPPS「アンオーダー」の条件で比較。 __m128 _mm_cmpunord_ps(__m128 a, __m128 b)
CMPPS「より小さくなく等しくない」の条件で比較。
__m128 _mm_cmpnle_ps(__m128 a, __m128 b)
SIMD 浮動小数点例外
無効(SNaNオペランドの場合)、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
3-92
命令セット・リファレンス
CMPPS?Compare Packed Single-Precision Floating-Point Values
( 続き)
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-93
命令セット・リファレンス
CMPS/CMPSB/CMPSW/CMPSD?Compare String Operands
説明
第1 ソース・オペランドで指定されるバイト、ワード、またはダブルワードを第2 ソース・オペラン
ドで指定されるバイト、ワード、またはダブルワードと比較し、結果に従ってEFLAGS レジスタ内
のステータス・フラグをセットする。両ソース・オペランドはメモリにある。第1 ソース・オペラン
ドのアドレスは、( 命令のそれぞれ32 または16 ビットのアドレス・サイズ属性によって) DS:ESI、
DS:SI のいずれかのレジスタから読み取られる。第2 ソース・オペランドのアドレスは、( やはり命
令のアドレス・サイズ属性によって) ES:EDI、ES:DI のいずれかのレジスタから読み取られる。DSセ
グメントはセグメント・オーバライド・プリフィックスでオーバライドすることもできるが、ES セ
グメントはオーバライドできない。
アセンブリ・コード・レベルでは、この命令の「明示オペランド」形式と「オペランドなし」形式
という2 つの形式が使用できる。明示オペランド形式 (CMPS ニーモニックで指定する) では、2 つの
ソース・オペランドを明示的に指定できる。その場合、両ソース・オペランドは両ソース値のサイ
ズとロケーションを示す記号とする。この明示オペランド形式はドキュメンテーションを可能にす
るために設けられたものであるが、この形式によって提供されるドキュメンテーションは誤解を招
く場合があるので注意されたい。すなわち、両ソース・オペランド記号は正しいタイプ ( サイズ) の
オペランド ( バイト、ワード、またはダブルワード) を指定しなければならないが、正しいロケー
ションは指定しなくてもよい。両ソース・オペランドのロケーションは常にDS:(E)SI とES:(E)DI に
よって指定されるので、ストリング比較命令を実行する前に、それらのレジスタに正しくロードし
なければならない。
オペランドなし形式は、「ショート形式」のバイト、ワード、およびダブルワード各バージョンの
CMPS 命令を提供する。この場合も、プロセッサはDS:(E)SI およびES:(E)DI レジスタをソース・オ
ペランドのロケーションを指定するものとみなす。ソース・オペランドのサイズは、CMPSB ( バイ
ト比較)、CMPSW (ワード比較)、またはCMPSD (ダブルワード比較) の各ニーモニックで選択される。
オペコード命令説明
A6 CMPS m8, m8 アドレスDS:(E)SI のバイトをアドレスES:(E)DI のバイト
と比較し、結果に従ってステータス・フラグをセットする。
A7 CMPS m16, m16 アドレスDS:(E)SI のワードをアドレスES:(E)DI のワード
と比較し、結果に従ってステータス・フラグをセットする。
A7 CMPS m32, m32 アドレスDS:(E)SI のダブルワードをアドレスES:(E)DI の
ダブルワードと比較し、結果に従ってステータス・フラグ
をセットする。
A6 CMPSB アドレスDS:(E)SI のバイトをアドレスES:(E)DI のバイト
と比較し、結果に従ってステータス・フラグをセットする。
A7 CMPSW アドレスDS:(E)SI のワードをアドレスES:(E)DI のワード
と比較し、結果に従ってステータス・フラグをセットする。
A7 CMPSD アドレスDS:(E)SI のダブルワードをアドレスES:(E)DI の
ダブルワードと比較し、結果に従ってステータス・フラグ
をセットする。
3-94
命令セット・リファレンス
CMPS/CMPSB/CMPSW/CMPSD?Compare String Operands ( 続き)
比較の後、EFLAGS レジスタ内のDFフラグの設定に従って、(E)SI および(E)DI レジスタが自動的に
インクリメントまたはデクリメントされる。(DF フラグが0 の場合は(E)SI および(E)DI レジスタはイ
ンクリメントされ、DFフラグが1 の場合はデクリメントされる。) これらのレジスタは、バイト操作
の場合は1、ワード操作の場合は2、ダブルワード操作の場合は4 それぞれインクリメントまたはデ
クリメントされる。
CMPS、CMPSB、CMPSW、およびCMPSD 命令は、前にREP プリフィックスを付けることにより、
ECX バイト、ワード、またはダブルワードのブロック比較を行うことができる。ただし、これらの
命令は、次の比較が行われる前にステータスの設定に基づいてなんらかの処置を行うLOOP 構成体
で使用されることの方が多い。REP プリフィックスについては、本章の「REP/REPE/REPZ/REPNE
/REPNZ?Repeat String Operation Prefix」を参照のこと。
操作
temp ←SRC1 ? SRC2;
SetStatusFlags(temp);
IF (byte comparison)
THEN IF DF ← 0
THEN
(E)SI ← (E)SI + 1;
(E)DI ← (E)DI + 1;
ELSE
(E)SI ← (E)SI ? 1;
(E)DI ← (E)DI ? 1;
FI;
ELSE IF (word comparison)
THEN IF DF ← 0
(E)SI ← (E)SI + 2;
(E)DI ← (E)DI + 2;
ELSE
(E)SI ← (E)SI ? 2;
(E)DI ← (E)DI ? 2;
FI;
ELSE (* doubleword comparison*)
THEN IF DF ← 0
(E)SI ← (E)SI + 4;
(E)DI ← (E)DI + 4;
ELSE
(E)SI ← (E)SI ? 4;
(E)DI ← (E)DI ? 4;
FI;
FI;
3-95
命令セット・リファレンス
CMPS/CMPSB/CMPSW/CMPSD?Compare String Operands ( 続き)
影響を受けるフラグ
CF、OF、SF、ZF、AF、およびPF フラグが比較の一時的結果に従ってセットされる。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-96
命令セット・リファレンス
CMPSD?Compare Scalar Double-Precision Floating-Point Value
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の下
位の倍精度浮動小数点値を比較し、比較の結果をデスティネーション・オペランドに返す。比較プ
レディケート・オペランド（第3 オペランド）は、実行される比較のタイプを指定する。比較の結果
は、すべて1（比較は真）またはすべて0（比較は偽）のクワッドワード・マスクになる。ソース・
オペランドは、XMM レジスタまたは64 ビットのメモリ・ロケーションである。デスティネーショ
ン・オペランドはXMM レジスタである。結果はデスティネーション・オペランドの下位クワッド
ワードに格納され、上位クワッドワードは変更されない。比較プレディケート・オペランドは8 ビッ
ト即値であり、実行される比較のタイプを最初の3 ビットで定義する（表3-5. を参照）。即値のビッ
ト4 〜7 は予約済みである。
2 つの比較対象ソース・オペランドのうち、少なくとも1 つがNaNであるかフォーマットが定義され
ていない場合、アンオーダー関係は真となる。ソース・オペランドがNaN ではなく、フォーマット
も定義されている場合は、オーダー関係は真となる。
この命令の後に、結果として得られたデスティネーション・オペランド内のマスクを入力オペラン
ドとして使用して計算命令を実行しても、フォルトは発生しない。これは、すべて0 のマスクは浮動
小数点値+0.0 に対応し、すべて1 のマスクはQNaNに対応するためである。
表3-5. に示した一部の比較は、ソフトウェア・エミュレーションでしか実行できない。これらの比
較を行う場合、プログラムは、ソース・オペランドとデスティネーション・オペランドを入れ替え
（必要に応じてレジスタをコピーして、新たにデスティネーション・オペランドに入るデータを保護
し）、異なるプレディケートを使って比較を実行しなければならない。これらのエミュレーションに
使用されるプレディケートは、表3-5. の「エミュレーション」の項目に記載されている。
コンパイラとアセンブラは、3 オペランドのCMPSD 命令以外に、以下の2 オペランドの擬似演算を
サポートできる。
.
オペコード命令説明
F2 0F C2 /r ib CMPSD xmm1,
xmm2/m64, imm8
imm8 を比較プレディケートとして使用して、xmm2/m64
の下位の倍精度浮動小数点値とxmm1 の下位の倍精度浮動
小数点値を比較する。
擬似演算対応するCMPSD 命令
CMPEQSD xmm1, xmm2 CMPSD xmm1,xmm2, 0
CMPLTSD xmm1, xmm2 CMPSD xmm1,xmm2, 1
CMPLESD xmm1, xmm2 CMPSD xmm1,xmm2, 2
CMPUNORDSD xmm1, xmm2 CMPSD xmm1,xmm2, 3
CMPNEQSD xmm1, xmm2 CMPSD xmm1,xmm2, 4
CMPNLTSD xmm1, xmm2 CMPSD xmm1,xmm2, 5
CMPNLESD xmm1, xmm2 CMPSD xmm1,xmm2, 6
CMPORDSD xmm1, xmm2 CMPSD xmm1,xmm2, 7
3-97
命令セット・リファレンス
CMPSD?Compare Scalar Double-Precision Floating-Point Value
( 続き)
「より大きい」の関係は、ハードウェア上で用意されていないため、2 つ以上の命令を使用してソフ
トウェア的にエミュレートする必要がある。したがって、これらの関係は擬似演算としてはサポー
トされない。「より大きい」の条件で比較する場合は、プログラマは、それに対応する「より小さい」
の関係のソース・オペランドとデスティネーション・オペランドを入れ替え、移動命令を使用して
マスクを適切なデスティネーション・レジスタに移動し、ソース・オペランドが影響を受けないよ
うにする必要がある。
操作
CASE (COMPARISON PREDICATE) OF
0: OP ← EQ;
1: OP ← LT;
2: OP ← LE;
3: OP ← UNORD;
4: OP ← NEQ;
5: OP ← NLT;
6: OP ← NLE;
7: OP ← ORD;
DEFAULT: Reserved;
CMP0 ← DEST[63-0] OP SRC[63-0];
IF CMP0 == TRUE
THEN DEST[63-0] ← FFFFFFFFFFFFFFFFH
ELSE DEST[63-0] ← 0000000000000000H; FI;
* DEST[127-64] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
CMPSD「等しい」の条件で比較。 __m128d _mm_cmpeq_sd(__m128d a, __m128d b)
CMPSD「より小さい」の条件で比較。 __m128d _mm_cmplt_sd(__m128d a, __m128d b)
CMPSD「より小さいか等しい」の条件で比較。
__m128d _mm_cmple_sd(__m128d a, __m128d b)
CMPSD「より大きい」の条件で比較。 __m128d _mm_cmpgt_sd(__m128d a, __m128d b)
CMPSD「より大きいか等しい」の条件で比較。
__m128d _mm_cmpge_sd(__m128d a, __m128d b)
CMPSD「等しくない」の条件で比較。 __m128d _mm_cmpneq_sd(__m128d a, __m128d b)
CMPSD「より小さくない」の条件で比較。 __m128d _mm_cmpnlt_sd(__m128d a, __m128d b)
CMPSD「より大きくない」の条件で比較。 __m128d _mm_cmpngt_sd(__m128d a, __m128d b)
CMPSD「より大きくなく等しくない」の条件で比較。
__m128d _mm_cmpnge_sd(__m128d a, __m128d b)
CMPSD「オーダー」の条件で比較。 __m128d _mm_cmpord_sd(__m128d a, __m128d b)
CMPSD「アンオーダー」の条件で比較。 __m128d _mm_cmpunord_sd(__m128d a, __m128d b)
3-98
命令セット・リファレンス
CMPSD?Compare Scalar Double-Precision Floating-Point Value
( 続き)
CMPSD「より小さくなく等しくない」の条件で比較。
__m128d _mm_cmpnle_sd(__m128d a, __m128d b)
SIMD 浮動小数点例外
無効（SNaN オペランドの場合）、無効（QNaNと上記の表のプレディケートの場合）、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
3-99
命令セット・リファレンス
CMPSD?Compare Scalar Double-Precision Floating-Point Value
( 続き)
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-100
命令セット・リファレンス
CMPSS?Compare Scalar Single-Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の最
下位の単精度浮動小数点値を比較し、比較の結果をデスティネーション・オペランドに返す。比較
プレディケート・オペランド（第3 オペランド）は、実行される比較のタイプを指定する。比較の結
果は、すべて1（比較は真）またはすべて0（比較は偽）のダブルワード・マスクになる。ソース・
オペランドは、XMM レジスタまたは32 ビットのメモリ・ロケーションである。デスティネーショ
ン・オペランドはXMMレジスタである。結果はデスティネーション・オペランドの最下位のダブル
ワードに格納され、上位3 つのダブルワードは変更されない。比較プレディケート・オペランドは8
ビット即値であり、実行される比較のタイプを最初の3 ビットで定義する（表3-5. を参照）。即値の
ビット4 〜7 は予約済みである。
2 つの比較対象ソース・オペランドのうち、少なくとも1 つがNaNであるかフォーマットが定義され
ていない場合、アンオーダー関係は真となる。ソース・オペランドがNaN ではなく、フォーマット
も定義されている場合は、オーダー関係は真となる。
この命令の後に、結果として得られたデスティネーション・オペランド内のマスクを入力オペラン
ドとして使用して計算命令を実行しても、フォルトは発生しない。これは、すべて0 のマスクは浮動
小数点値+0.0 に対応し、すべて1 のマスクはQNaNに対応するためである。
表3-5. に示した比較の中には、ソフトウェア・エミュレーション以外では実行できないものがある。
これらの比較を行う際は、プログラムが（必要に応じてレジスタをコピーしてデスティネーション・
オペランドになるデータを保護し）、ソース・オペランドとデスティネーション・オペランドを入れ
替えた後、異なる述語を使って比較を実行しなければならない。これらのエミュレーションに使用
される述語は、表3-5. の「エミュレーション」の欄に記載されている。
コンパイラとアセンブラは、3 オペランドのCMPSS 命令以外に、次の2 オペランドの擬似演算をサ
ポートする必要がある。
オペコード命令説明
F3 0F C2 /r ib CMPSS xmm1,
xmm2/m32, imm8
imm8 を比較プレディケートとして使用して、xmm2/m32
の最下位の単精度浮動小数点値とxmm1 の最下位の単精度
浮動小数点値を比較する。
擬似演算対応するCMPSS 命令
CMPEQSS xmm1, xmm2 CMPSS xmm1,xmm2, 0
CMPLTSS xmm1, xmm2 CMPSS xmm1,xmm2, 1
CMPLESS xmm1, xmm2 CMPSS xmm1,xmm2, 2
CMPUNORDSS xmm1, xmm2 CMPSS xmm1,xmm2, 3
CMPNEQSS xmm1, xmm2 CMPSS xmm1,xmm2, 4
CMPNLTSS xmm1, xmm2 CMPSS xmm1,xmm2, 5
CMPNLESS xmm1, xmm2 CMPSS xmm1,xmm2, 6
CMPORDSS xmm1, xmm2 CMPSS xmm1,xmm2, 7
3-101
命令セット・リファレンス
CMPSS?Compare Scalar Single-Precision Floating-Point Values
( 続き)
「より大きい」の関係は、ハードウェア上で用意されていないため、2 つ以上の命令を使用してソフ
トウェア的にエミュレートする必要がある。したがって、これらの関係は擬似演算としてはサポー
トされない。「より大きい」の条件で比較する場合は、プログラマが、対応する「より小さい」の関
係のソース・オペランドとデスティネーション・オペランドを入れ替え、ソース・オペランドが影
響を受けないように、移動命令を使用してマスクを適切なデスティネーション・レジスタに確実に
移動しなければならない。
操作
CASE (COMPARISON PREDICATE) OF
0: OP ← EQ;
1: OP ← LT;
2: OP ← LE;
3: OP ← UNORD;
4: OP ← NEQ;
5: OP ← NLT;
6: OP ← NLE;
7: OP ← ORD;
DEFAULT: Reserved;
CMP0 ← DEST[31-0] OP SRC[31-0];
IF CMP0 == TRUE
THEN DEST[31-0] ← FFFFFFFFH
ELSE DEST[31-0] ← 00000000H; FI;
* DEST[127-32] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
CMPSS「等しい」の条件で比較。 __m128 _mm_cmpeq_ss(__m128 a, __m128 b)
CMPSS「より小さい」の条件で比較。 __m128 _mm_cmplt_ss(__m128 a, __m128 b)
CMPSS「より小さいか等しい」の条件で比較。
__m128 _mm_cmple_ss(__m128 a, __m128 b)
CMPSS「より大きい」の条件で比較。 __m128 _mm_cmpgt_ss(__m128 a, __m128 b)
CMPSS「より大きいか等しい」の条件で比較。
__m128 _mm_cmpge_ss(__m128 a, __m128 b)
CMPSS「等しくない」の条件で比較。 __m128 _mm_cmpneq_ss(__m128 a, __m128 b)
CMPSS「より小さくない」の条件で比較。 __m128 _mm_cmpnlt_ss(__m128 a, __m128 b)
CMPSS「より大きくない」の条件で比較。 __m128 _mm_cmpngt_ss(__m128 a, __m128 b)
CMPSS「より大きくなく等しくない」の条件で比較。
__m128 _mm_cmpnge_ss(__m128 a, __m128 b)
CMPSS「オーダー」の条件で比較。 __m128 _mm_cmpord_ss(__m128 a, __m128 b)
CMPSS「アンオーダー」の条件で比較。 __m128 _mm_cmpunord_ss(__m128 a, __m128 b)
3-102
命令セット・リファレンス
CMPSS?Compare Scalar Single-Precision Floating-Point Values
( 続き)
CMPSS「より小さくなく等しくない」の条件で比較。
__m128 _mm_cmpnle_ss(__m128 a, __m128 b)
SIMD 浮動小数点例外
無効(SNaNオペランドの場合)、無効( 上記の表に記載されたQNaN および述語の場合)、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
3-103
命令セット・リファレンス
CMPSS?Compare Scalar Single-Precision Floating-Point Values
( 続き)
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-104
命令セット・リファレンス
CMPXCHG?Compare and Exchange
説明
( オペランドのサイズに従って) AL、AX、またはEAXレジスタの値を第1 オペランド ( デスティネー
ション・オペランド) と比較する。2 つの値が等しい場合は、第2 オペランド ( ソース・オペランド)
がデスティネーション・オペランドにロードされる。等しくない場合は、デスティネーション・オ
ペランドがAL、AX、またはEAXレジスタにロードされる。
この命令は、前にLOCKプリフィックスを付けることにより、自動的に実行させることができる。プ
ロセッサのバスとのインターフェイスを単純にするため、デスティネーション・オペランドは比較
の結果にかかわりなく書き込みサイクルを受ける。比較が失敗した場合はデスティネーション・オ
ペランドがデスティネーションに書き戻され、比較が成功した場合はソース・オペランドがデスティ
ネーションに書き込まれる。( プロセッサは、同時にロック書き込みも伴わずにロック読み取りを生
じることは決してない。)
IA-32 アーキテクチャにおける互換性
この命令は、Intel486 プロセッサより以前のインテル・プロセッサではサポートされていない。
操作
(* accumulator ← AL, AX, or EAX, depending on whether *)
(* a byte, word, or doubleword comparison is being performed*)
IF accumulator ← DEST
THEN
ZF ← 1
DEST ← SRC
ELSE
ZF ← 0
accumulator ← DEST
FI;
影響を受けるフラグ
デスティネーション・オペランドとAL、AX、またはEAXレジスタの値が等しい場合はZFフラグが
セットされ、等しくない場合はクリアされる。CF、PF、AF、SF、およびOF フラグは比較演算の結
果に従ってセットされる。
オペコード命令説明
0F B0/r CMPXCHG r/m8,r8 AL をr/m8 と比較し、等しい場合はZF をセットし、r8 を
r/m8 にロードする。等しくない場合はZF をクリアし、
r/m8 をAL にロードする。
0F B1/r CMPXCHG r/m16,r16 AX をr/m16 と比較し、等しい場合はZF をセットし、r16
をr/m16 にロードする。等しくない場合はZF をクリアし、
r/m16 をAL にロードする。
0F B1/r CMPXCHG r/m32,r32 EAX をr/m32 と比較し、等しい場合はZF をセットし、r32
をr/m32 にロードする。等しくない場合はZF をクリアし、
r/m32 をAL にロードする。
3-105
命令セット・リファレンス
CMPXCHG?Compare and Exchange ( 続き)
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-106
命令セット・リファレンス
CMPXCHG8B?Compare and Exchange 8 Bytes
説明
EDX:EAXの64 ビット値をオペランド ( デスティネーション・オペランド) と比較する。値が等しい
場合は、ECX:EBXの64 ビット値がデスティネーション・オペランドにストアされる。等しくない場
合は、デスティネーション・オペランドの値がEDX:EAXにロードされる。デスティネーション・オ
ペランドは8 バイトのメモリ・ロケーションである。EDX:EAX およびECX:EBX のレジスタ・ペア
では、EDX とECX の内容が64 ビット値の上位32 ビットであり、EAXとEBXの内容が下位32 ビッ
トである。
この命令は、前にLOCKプリフィックスを付けることにより、自動的に実行させることができる。プ
ロセッサのバスとのインターフェイスを単純にするため、デスティネーション・オペランドは比較
の結果にかかわりなく書き込みサイクルを受ける。比較が失敗した場合はデスティネーション・オ
ペランドがデスティネーションに書き戻され、比較が成功した場合はソース・オペランドがデスティ
ネーションに書き込まれる。( プロセッサは、同時にロック書き込みも伴わずにロック読み取りを生
じることは決してない。)
IA-32 アーキテクチャにおける互換性
この命令は、Pentiumプロセッサより以前のインテル・プロセッサではサポートされていない。
操作
IF (EDX:EAX ← DEST)
ZF ← 1
DEST ← ECX:EBX
ELSE
ZF ← 0
EDX:EAX ← DEST
影響を受けるフラグ
デスティネーション・オペランドとEDX:EAX が等しい場合はZF フラグがセットされ、等しくない
場合はクリアされる。CF、PF、AF、SF、およびOFフラグは影響を受けない。
オペコード命令説明
0F C7 /1 m64 CMPXCHG8B m64 EDX:EAX をm64 と比較し、等しい場合はZF をセットし、
ECX:EBX をm64 にロードする。等しくない場合はZF を
クリアし、m64 をEDX:EAX にロードする。
3-107
命令セット・リファレンス
CMPXCHG8B?Compare and Exchange 8 Bytes ( 続き)
保護モード例外
#UD デスティネーション・オペランドがメモリ・ロケーションでない場合。
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#UD デスティネーション・オペランドがメモリ・ロケーションでない場合。
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#UD デスティネーション・オペランドがメモリ・ロケーションでない場合。
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-108
命令セット・リファレンス
COMISD?Compare Scalar Ordered Double-Precision Floating-Point
Values and Set EFLAGS
説明
ソース・オペランド1（第1 オペランド）とソース・オペランド2（第2 オペランド）の下位のクワッ
ドワードの倍精度浮動小数点値を比較し、その結果（アンオーダー、より大きい、より小さい、ま
たは等しい）に従って、EFLAGSレジスタのZF、PF、およびCFフラグをセットする。EFLAGSレジ
スタのOF、SF、およびAFフラグは0 にクリアされる。いずれかのソース・オペランドがNaN（QNaN
またはSNaN）の場合は、アンオーダーのプレディケートが返される。
ソース・オペランド1 はXMMレジスタである。ソース・オペランド2 は、XMMレジスタまたは64
ビットのメモリ・ロケーションである。
COMISD 命令とUCOMISD 命令の相違点は、COMISD 命令は、ソース・オペランドがQNaN または
SNaNの場合にSIMD浮動小数点無効操作例外（#I）を報告することである。UCOMISD命令は、ソー
ス・オペランドがSNaN の場合にのみ、無効数値例外を報告する。
マスクされていないSIMD浮動小数点例外が発生した場合は、EFLAGSレジスタは更新されない。
操作
RESULT ← OrderedCompare(DEST[63-0] <> SRC[63-0]) {
* Set EFLAGS *CASE (RESULT) OF
UNORDERED: ZF,PF,CF ← 111;
GREATER_THAN: ZF,PF,CF ← 000;
LESS_THAN: ZF,PF,CF ← 001;
EQUAL: ZF,PF,CF ← 100;
ESAC;
OF,AF,SF ← 0;
同等のインテルC/C++ コンパイラ組み込み関数
int_mm_comieq_sd(__m128d a, __m128d b)
int_mm_comilt_sd(__m128d a, __m128d b)
int_mm_comile_sd(__m128d a, __m128d b)
int_mm_comigt_sd(__m128d a, __m128d b)
int_mm_comige_sd(__m128d a, __m128d b)
int_mm_comineq_sd(__m128d a, __m128d b)
オペコード命令説明
66 0F 2F /r COMISD xmm1, xmm2/m64 xmm1 とxmm2/mem64 の下位の倍精度浮動小数点値を
比較し、その結果に従ってEFLAGS フラグをセットす
る。
3-109
命令セット・リファレンス
COMISD?Compare Scalar Ordered Double-Precision Floating-Point
Values and Set EFLAGS ( 続き)
SIMD 浮動小数点例外
無効（SNaNまたはQNaNオペランドの場合）、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
3-110
命令セット・リファレンス
COMISD?Compare Scalar Ordered Double-Precision Floating-Point
Values and Set EFLAGS ( 続き)
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-111
命令セット・リファレンス
COMISS?Compare Scalar Ordered Single-Precision Floating-Point
Values and Set EFLAGS
説明
ソース・オペランド1（第1 オペランド）とソース・オペランド2（第2 オペランド）の最下位のダ
ブルワードの単精度浮動小数点値を比較し、その結果（アンオーダー、より大きい、より小さい、ま
たは等しい）に従って、EFLAGSレジスタのZF、PF、およびCFフラグをセットする。EFLAGSレジ
スタのOF、SF、およびAFフラグは0 にクリアされる。いずれかのソース・オペランドがNaN(QNaN
またはSNaN) の場合は、順序付けされない結果を返す。
ソース・オペランド1 はXMMレジスタで、ソース・オペランド2 はXMMレジスタまたは32 ビット
のメモリ・ロケーションを使用できる。
COMISS 命令とUCOMISS 命令の相違点は、COMISS は、ソース・オペランドがQNaN またはSNaN
オペランドである場合にSIMD浮動小数点無効操作例外（#I）を報告することである。UCOMISS は、
ソース・オペランドがSNaNである場合にのみ無効数値例外を報告する。
マスクされていないSIMD浮動小数点例外が発生した場合は、EFLAGSレジスタは更新されない。
操作
RESULT ← OrderedCompare(SRC1[31-0] <> SRC2[31-0]) {
* Set EFLAGS *CASE (RESULT) OF
UNORDERED: ZF,PF,CF ← 111;
GREATER_THAN: ZF,PF,CF ← 000;
LESS_THAN: ZF,PF,CF ← 001;
EQUAL: ZF,PF,CF ← 100;
ESAC;
OF,AF,SF ← 0;
同等のインテルC/C++ コンパイラ組み込み関数
int_mm_comieq_ss(__m128 a, __m128 b)
int_mm_comilt_ss(__m128 a, __m128 b)
int_mm_comile_ss(__m128 a, __m128 b)
int_mm_comigt_ss(__m128 a, __m128 b)
int_mm_comige_ss(__m128 a, __m128 b)
int_mm_comineq_ss(__m128 a, __m128 b)
オペコード命令説明
0F 2F /r COMISS xmm1, xmm2/m32 xmm1 とxmm2/mem32 の最下位の単精度浮動小数点値
を比較し、その結果に従ってEFLAGS フラグをセット
する。
3-112
命令セット・リファレンス
COMISS?Compare Scalar Ordered Single-Precision Floating-Point
Values and Set EFLAGS ( 続き)
SIMD 浮動小数点例外
無効(SNaNまたはQNaNオペランドの場合)、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
3-113
命令セット・リファレンス
COMISS?Compare Scalar Ordered Single-Precision Floating-Point
Values and Set EFLAGS ( 続き)
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-114
命令セット・リファレンス
CPUID?CPU Identification
説明
プロセッサの識別情報および機能情報をEAX、EBX、ECX、EDXの各レジスタに返す。返される情
報を選択するには、命令が実行される前にEAXレジスタに値を入力する。表3-6. は、EAXレジスタ
にロードされる初期値と、それに対して返される情報を示している。
EFLAGSレジスタ内のIDフラグ( ビット21) は、CPUID命令のサポートの有無を示している。ソフト
ウェア・プロシージャでこのフラグを設定およびクリアすることができる場合、そのプロシージャ
を実行するプロセッサはCPUID命令をサポートしていることになる。
CPUID 命令に対して返される情報は、基本情報と拡張機能情報の2 つのグループに分けられる。基
本情報を得るには、IA-32 プロセッサのタイプに応じて、0 〜3 の値をEAXレジスタに入力する。拡
張機能情報を得るには、80000000H〜80000004Hの値を入力する。CPUIDの拡張機能情報はPentium
4 プロセッサで導入されたものなので、それより前のIA-32 プロセッサでは利用することができない。
表3-7. は、基本情報および拡張機能情報を取得するためのCPUID 命令に対してプロセッサが認識可
能な最大入力値について、CPUID命令が実装されているIA-32 プロセッサ・ファミリごとに示したも
のである。
表3-6. に示す値より大きな値が特定のプロセッサに入力されると、基本情報についての最大値に対
する情報が返される。例えば、Pentium 4 プロセッサの場合、EAX に5 が入力されると、入力値が2
のときの情報が返される。ただし、拡張機能情報を返す場合の入力値( 現時点では、80000000H 〜
80000004Hの値) については、この規則は適用されない。Pentium 4 プロセッサの場合には、80000005H
以上の値を入力すると、入力値が2 のときの情報が返される。
CPUID 命令はどの特権レベルでも実行でき、命令の実行をシリアル化することができる。命令の実
行をシリアル化することにより、前の命令においてフラグ、レジスタ、メモリに対して修正が行わ
れた場合、それらの修正がすべて完了してから、次の命令がフェッチされて実行されることが保証
される(『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、下巻』の
第7 章の「シリアル化命令」を参照)。
EAX レジスタの入力値が0 の場合、プロセッサは、CPUID 基本情報を返すためのEAX レジスタに、
CPUID命令が認識可能な最大値を返す( 表3-7. を参照)。EBX、EDX、ECXの各レジスタには、ベン
ダー識別ストリングが返される。インテル・プロセッサの場合、ベンダー識別ストリングは次のよ
うに"GenuineIntel" になる。
EBX ← 756e6547h (* "Genu", with G in the low nibble of BL *)
EDX ← 49656e69h (* "ineI", with i in the low nibble of DL *)
ECX ← 6c65746eh (* "ntel", with n in the low nibble of CL *)
オペコード命令説明
0F A2 CPUID EAX レジスタに最初に入力された値に応じて、プロセッサ
の識別情報と機能情報をEAX、EBX、ECX、EDX の各レ
ジスタに返す。
3-115
命令セット・リファレンス
CPUID?CPU Identification ( 続き)
表3-6. CPUID 命令から返される情報
EAX の初期値提供されるプロセッサに関する情報
CPUID 基本情報
0H EAX
EBX
ECX
EDX
CPUID 基本情報の最大入力値( 表3-7. を参照)
“Genu”
“ntel”
“ineI”
1H EAX
EBX
ECX
EDX
バージョン情報( タイプ、ファミリ、モデル、ステッピングID)
ビット7 〜 0: ブランド・インデックス
ビット15 〜 8:CLFLUSH のライン・サイズ( 返される値*8= キャッシュ・
ライン・サイズ)
ビット23 〜 16: 予約済み
ビット31 〜 24: プロセッサのローカルAPIC の物理ID
予約済み
機能情報( 図3-4. および表3-9. を参照)
2H EAX
EBX
ECX
EDX
キャッシュおよびTLB 情報
キャッシュおよびTLB 情報
キャッシュおよびTLB 情報
キャッシュおよびTLB 情報
3H EAX
EBX
ECX
EDX
予約済み。
予約済み。
96 ビットのプロセッサ・シリアル・ナンバのビット00 〜 31(Pentium III
プロセッサのみ。それ以外、このレジスタの値は予約されている)。
96 ビットのプロセッサ・シリアル・ナンバのビット32 〜 63(Pentium III
プロセッサのみ。それ以外、このレジスタの値は予約されている)。
拡張機能CPUID 情報
80000000H EAX
EBX
ECX
EDX
拡張機能CPUID 情報の最大入力値( 表3-7. を参照)。
予約済み。
予約済み。
予約済み。
80000001H EAX
EBX
ECX
EDX
拡張されたプロセッサ・シグネチャと拡張された機能ビット( 現在は予約さ
れている)。
予約済み。
予約済み。
予約済み。
80000002H EAX
EBX
ECX
EDX
プロセッサ・ブランド・ストリング
プロセッサ・ブランド・ストリング（続き）
プロセッサ・ブランド・ストリング（続き）
プロセッサ・ブランド・ストリング（続き）
80000003H EAX
EBX
ECX
EDX
プロセッサ・ブランド・ストリング（続き）
プロセッサ・ブランド・ストリング（続き）
プロセッサ・ブランド・ストリング（続き）
プロセッサ・ブランド・ストリング（続き）
80000004H EAX
EBX
ECX
EDX
プロセッサ・ブランド・ストリング（続き）
プロセッサ・ブランド・ストリング（続き）
プロセッサ・ブランド・ストリング（続き）
プロセッサ・ブランド・ストリング（続き）
3-116
命令セット・リファレンス
CPUID?CPU Identification ( 続き)
EAX レジスタの入力値が1 の場合、プロセッサはEAX レジスタにバージョン情報を返す( 図3-3. を
参照)。バージョン情報は、IA32 プロセッサ・ファミリ識別子、モデル識別子、ステッピングID、プ
ロセッサ・タイプで構成される。インテルPentium 4 ファミリの最初のプロセッサのモデル、ファミ
リ、プロセッサ・タイプは、次のようになる。
? モデル−0000B
? ファミリ−1111B
? プロセッサ・タイプ−00B
表3-8. に、使用可能なプロセッサ・タイプを示す。インテルは、ステッピングID については必要に
応じて情報をリリースしている。
表3-7. IA-32 プロセッサに対するCPUID 命令のソース・オペランドの最大値
IA-32 プロセッサ
EAX レジスタの最大値
基本情報拡張機能情報
初期Intel486 プロセッサCPUID は実装されていないCPUID は実装されていない
後期Intel486 プロセッサおよびPentium
プロセッサ
1H 実装されていない
Pentium Pro プロセッサおよびPentium II
プロセッサ、インテルR Celeron? プロセッ
サ
2H 実装されていない
Pentium III プロセッサ3H 実装されていない
Pentium 4 プロセッサ2H 80000004H
図3-3. EAX レジスタのバージョン情報
31 12 11 8 7 4 3 0
EAX
ファミリ(Pentium 4 プロセッサ・ファミリの場合は1111B)
モデル(0000B から始まる)
14 13
プロセッサ・タイプ
ファミリモデル
ステッピ
15
拡張
拡張ファミリ
28 27 20 19 16
モデルングID
3-117
命令セット・リファレンス
CPUID?CPU Identification ( 続き)
注：
* Intel486 プロセッサには該当しない。
ファミリ・フィールドおよびモデル・フィールドの両方または一方の値がFH以上の場合、CPUID命
令は、EAX レジスタ内に、拡張ファミリ・フィールドおよび拡張モデル・フィールドという2 つの
追加フィールドを生成する。ここで、モデル・フィールドまたはファミリ・フィールドのいずれか
の値がFHの場合は、拡張モデル・フィールドまたは拡張ファミリ・フィールドがそれぞれ有効であ
ることを意味する。FHを超えるファミリ番号およびモデル番号の範囲は0FH〜FFHであり、16 進下
位2 桁は常にFHとなる。
従来のIA-32 プロセッサの識別に関する詳細は、AP-485『インテルR プロセッサの識別とCPUID 命
令』( 資料番号241618J)、および『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』の第13章を参照のこと。
EAXレジスタの入力値が1 の場合、EBXレジスタには、次に示す3 つの関連のない情報が返される。
? ブランド・インデックス(EBX の下位バイト) − IA-32 プロセッサのブランド・ストリングで構
成されるブランド・ストリング・テーブルのエントリには、この数字が入っている。ブランド・
インデックスの意図的な使用に関しては、この命令の説明の後半の「ブランドの識別」を参照
のこと。このフィールドは、Pentium III Xeon?プロセッサで導入されたものである。
? CLFLUSH 命令キャッシュ・ライン・サイズ(EBX の第2 バイト) −この数字は、CLFLUSH 命
令によって8 バイト・インクリメントでフラッシュされるキャッシュ・ラインのサイズを示す。
このフィールドは、Pentium 4 プロセッサで導入されたものである。
? 初期APIC ID(EBX の上位バイト) −この数字は、電源入力時にプロセッサのローカルAPIC に
割り当てられる8 ビットの物理ID を示す。このフィールドは、Pentium 4 プロセッサで導入され
たものである。
EAXレジスタの入力値が1 の場合、EDXレジスタには機能情報が返される( 図3-4. を参照)。機能ビッ
トを使って、オペレーティング・システムまたはアプリケーション・コードにおいて、プロセッサ
で使用可能なIA-32 アーキテクチャ機能を判定することができる。表3-9. は、EDXレジスタ内の機能
フラグのエンコード方式を示している。現時点でEDXレジスタに返されるすべての機能フラグにお
いては、1 が設定されている場合は対応する機能がサポートされていることを示す。ソフトウェアで
は、機能フラグを適切に解釈するベンダとしてインテルを識別する必要がある。( ソフトウェア上で
は、将来的に機能フラグの機能が存在することを示す1 に依存してはならない)
表3-8. プロセッサ・タイプ・フィールド
タイプコード化
オリジナルOEM プロセッサ00B
インテルR OverDriveR プロセッサ01B
デュアル・プロセッサ* 10B
インテル用に予約済み11B
3-118
命令セット・リファレンス
CPUID?CPU Identification ( 続き)
図3-4. EDX レジスタの機能情報
31
APIC- オンチップAPIC
CX8-CMPXCHG8B 命令
MCE- マシン・チェック例外
PAE- 物理アドレス拡張
MSR-RDMSR およびWRMSR のサポート
TSC- タイム・スタンプ・カウンタ
MTRR- メモリ・タイプ範囲レジスタ
CMOV- 条件付き転送/ 比較命令
MCA- マシン・チェック・アーキテクチャ
15 14 13 12 9 8 7 6 5 4 3 2 1 0
PGE-PTE グローバル・ビット
PSE- ページ・サイズ拡張
DE- デバッグ拡張
VME- 仮想8086 モード強化
FPU-x87 オンチップFPU
予約済み
EDX
28 27 26 25 24 23 2221 20 19 18 17 16 11 10
SS- セルフ・スヌープ
SSE2-SSE2 拡張命令
SSE-SSE 拡張命令
FXSR-FXSAVE/FXRSTOR
MMX-MMX テクノロジ
ACPI- 温度モニタおよびクロック制御
DS- デバッグ・ストア
CLFSH-CFLUSH 命令
PSN- プロセッサ・シリアル番号
PSE- ページ・サイズ拡張
PAT- ページ属性テーブル
SEP-SYSENTER およびSYSEXIT
30 29
TM- 温度モニタ
7
3-119
命令セット・リファレンス
CPUID?CPU Identification ( 続き)
表3-9. EDX レジスタに返されるCPUID 機能フラグ
ビット# ニーモニック 説明
0 FPU オンチップ浮動小数点ユニット。プロセッサは、x87 FPU を搭載してい
る。
1 VME 仮想8086 モード強化。仮想8086 モード強化機能には次のものが含まれ
る。機能制御用のCR4.VME、保護モード仮想割り込み用のCR4.PVI、ソフト
ウェア割り込みインダイレクション、ソフトウェア・インダイレクション・
ビットマップによるTSS の拡張、EFLAGS.VIF フラグ、およびEFLAGS.VIP
フラグ。
2 DE デバッグ拡張。機能制御用のCR4.DE、およびオプションのDR4 および
DR5 へのアクセス・トラップを含めて、I/O ブレークポイントをサポート。
3 PSE ページ・サイズ拡張。機能制御用のCR4.PSE、PDE( ページ・ディレクト
リ・エントリ) 内の定義済みのダーティ・ビット、CR3、PDE、およびPTE
内のオプションの予約ビット・トラッピングを含めて、4M バイトのラージ・
ページ・サイズをサポート。
4 TSC タイム・スタンプ・カウンタ。特権制御用のCR4.TSD を含めて、
RDTSC 命令をサポート。
5 MSR モデル固有レジスタのRDMSR 命令およびWRMSR 命令。RDMSR 命
令およびWRMSR 命令をサポート。MSR によっては、プロセッサに依存し
ないものもある。
6 PAE 物理アドレス拡張。32 ビットを超える物理アドレスをサポート。拡張ペー
ジ・テーブル・エントリ・フォーマット、ページ変換テーブル内の特別レベ
ルが定義され、PAE ビットが1 の場合は、4M バイト・ページの代わりに2M
バイト・ページをサポート。32 ビットを超える場合の実際のアドレス・ビッ
ト数は定義されておらず、プロセッサ固有である。
7 MCE マシン・チェック例外。機能制御用のCR4.MCE を含めて、マシン・
チェック用に例外18 が定義される。この機能は、モデル固有インプリメン
テーションにおけるマシン・チェック・エラーのロギング、レポート、およ
びプロセッサ・シャットダウンについては定義しない。マシン・チェック例
外ハンドラは、プロセッサのバージョンに従ってモデル固有の例外処理を実
行するか、またはマシン・チェック機能の有無を確認する必要が生じる場合
がある。
8 CX8 CMPXCHG8B 命令。8 バイト(64 ビット) 比較交換命令をサポート( 暗黙
的にロックされ、アトミックに行われる)。
9 APIC オンチップAPIC。プロセッサは、アドバンスト・プログラム可能割り込み
コントローラ(APIC) を内蔵し、物理アドレス範囲FFFE0000H 〜
FFFE0FFFH でメモリ・マップ・コマンドに応答する( デフォルトでは、プロ
セッサによってはAPIC の再配置を許可するものもある)。
10 Reserved 予約済み
11 SEP SYSENTER 命令およびSYSEXIT 命令。SYSENTER、SYSEXIT、およ
び関連するMSR をサポート。
12 MTRR メモリ・タイプ範囲レジスタ。MTRR をサポート。MTRRcap MSR には
機能ビットが含まれていて、サポートされているメモリ・タイプ、サポート
されている可変MTRR の個数、固定MTRR のサポートの有無について示され
る。
3-120
命令セット・リファレンス
CPUID?CPU Identification ( 続き)
表3-9. EDX レジスタに返されるCPUID 機能フラグ
ビット# ニーモニック 説明
13 PGE PTE グローバル・ビット。ページ・ディレクトリ・エントリ(PDE) およ
びページ・テーブル・エントリ(PTE) 内のグローバル・ビットをサポート。
これらは、各種の処理に共通で、フラッシュする必要のないTLB エントリで
あることを示す。この機能は、CR4.PGE ビットによって制御される。
14 MCA マシン・チェック・アーキテクチャ。Pentium 4 プロセッサ、P6 ファミ
リ・プロセッサ、および将来のプロセッサのエラー・レポート用の互換メカ
ニズムを提供するマシン・チェック・アーキテクチャをサポート。
MCG_CAP MSR には、サポートされているエラー・レポート用MSR バンク
の個数を示す機能ビットが含まれる。
15 CMOV 条件付き転送命令。条件付き転送命令(CMOV) をサポート。また、x87
FPU が搭載されている場合は(CPUID.FPU 機能ビットによって示される)、
FCOMI 命令およびFCMOV 命令をサポート。
16 PAT ページ属性テーブル。ページ属性テーブルをサポート。この機能は、メモ
リ・タイプ範囲レジスタ(MTRR) の数を増やす。これによって、オペレー
ティング・システムは、リニア・アドレスを使用して4K バイト単位でメモリ
の属性を指定できる。
17 PSE-36 32 ビット・ページ・サイズ拡張。拡張4M バイト・ページをサポート。
これにより、4G バイトを超える物理メモリのアドレス指定が可能になる。こ
の機能は、4M バイト・ページの物理アドレスの上位4 ビットが、ページ・
ディレクトリ・エントリのビット13 〜 16 によってエンコーディングされる
ことを示す。
18 PSN プロセッサ・シリアル番号。96 ビットのプロセッサ識別番号機能をサ
ポートしており、この機能がイネーブルになっている。
19 CLFSH CLFLUSH 命令。CLFLUSH 命令をサポート。
20 Reserved 予約済み
21 DS デバッグ・ストア。メモリ常駐バッファにデバッグ情報を書き込む機能を
サポート。この機能は、分岐トレース・ストア(BTS) およびプリサイス・イ
ベント・ベース・サンプリング(PEBS) 機能によって使用される( 詳しくは、
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュ
アル、下巻』の第14 章「デバッグと性能モニタリング」を参照のこと)。
22 ACPI 温度モニタおよびソフトウェア制御クロック機能。プロセッサはMSR
を内部に実装している。MSR を使用すると、ソフトウェアによる制御の下で
プロセッサ温度を監視できるとともに、事前に定義したデューティ・サイク
ルでプロセッサのパフォーマンスを調整することができる。
23 MMX インテルMMX テクノロジ。インテルMMX テクノロジをサポート。
24 FXSR FXSAVE 命令およびFXRSTOR 命令。浮動小数点コンテキストの高速な
保存/ 復元用のFXSAVE 命令およびFXRSTOR 命令をサポート。また、この
ビットがセットされている場合、オペレーティング・システムは、
CR4.OSFXSR を利用して、FXSAVE 命令およびFXRSTOR 命令をサポート
することを示すことができる。
25 SSE SSE。SSE 拡張命令をサポート。
26 SSE2 SSE2。SSE2 拡張命令をサポート。
3-121
命令セット・リファレンス
CPUID?CPU Identification ( 続き)
EAXレジスタの入力値が2 のときは、プロセッサはプロセッサの内部キャッシュおよびTLB に関す
る情報をEAX、EBX、ECX、およびEDXレジスタに返す。これらのレジスタのコード化は、以下の
とおりである。
? EAX レジスタ (AL レジスタ) の最下位バイトは、入力値を2 として、プロセッサのキャッシュ
とTLBの完全な記述を得るためにCPUID命令が実行されなければならない回数を示す。Pentium
4 プロセッサ・ファミリの最初のメンバは1 を返す。
? 各レジスタの最上位ビット ( ビット31) は、レジスタに有効な情報がある (0 にクリア) か、予約
されている (1 にセット) かを示す。
? レジスタに有効な情報がある場合は、その情報は1 バイトの記述子に収められる。表3-10. に、
それらの記述子のコード化を示す。EAX、EBX、ECX、EDX の各レジスタ内の記述子の順序は
定義されていない。すなわち、特定のバイトが特定のキャッシュ・タイプまたはTLB タイプの
記述子が入るようには指定されていない。記述子は、あらゆる順序で示されることがある。
表3-9. EDX レジスタに返されるCPUID 機能フラグ
ビット# ニーモニック 説明
27 SS セルフ・スヌープ。競合するメモリ・タイプの管理機能をサポートしてお
り、プロセッサのキャッシュ構造のスヌープを実行して、バスに対して発行
されたトランザクションを検出できる。
28 Reserved 予約済み
29 TM 温度モニタ。プロセッサは、温度モニタ自動温度制御回路(TCC) を実装し
ている。
30 - 31 Reserved 予約済み
表3-10. キャッシュおよびTLB 記述子のコード化
記述子の値 キャッシュまたはTLB の記述
00H NULL 記述子
01H 命令TLB: 4 K バイト・ページ、4 ウェイ・セット・アソシアティブ、32 エントリ
02H 命令TLB: 4 M バイト・ページ、フル・アソシアティブ、2 エントリ
03H データTLB: 4 K バイト・ページ、4 ウェイ・セット・アソシアティブ、64 エントリ
04H データTLB: 4 M バイト・ページ、4 ウェイ・セット・アソシアティブ、8 エントリ
06H 第1 レベルの命令キャッシュ: 8 K バイト、4 ウェイ・セット・アソシアティブ、32 バイト・
ライン・サイズ
08H 第1 レベルの命令キャッシュ: 16 K バイト、4 ウェイ・セット・アソシアティブ、32 バイ
ト・ライン・サイズ
0AH 第1 レベルのデータ・キャッシュ: 8 K バイト、2 ウェイ・セット・アソシアティブ、32 バイ
ト・ライン・サイズ
0CH 第1 レベルのデータ・キャッシュ: 16 K バイト、4 ウェイ・セット・アソシアティブ、32 バ
イト・ライン・サイズ
40H 第2 レベルのキャッシュなし。プロセッサに有効な第2 レベルのキャッシュが実装されてい
る場合は、第3 レベルのキャッシュなし
3-122
命令セット・リファレンス
CPUID?CPU Identification ( 続き)
表 3-10. キャッシュおよびTLB 記述子のコード化 ( 続き)
記述子の値 キャッシュまたはTLB の記述
41H 第2 レベルのキャッシュ: 128 K バイト、4 ウェイ・セット・アソシアティブ、32 バイト・ラ
イン・サイズ
42H 第2 レベルのキャッシュ: 256 K バイト、4 ウェイ・セット・アソシアティブ、32 バイト・ラ
イン・サイズ
43H 第2 レベルのキャッシュ: 512 K バイト、4 ウェイ・セット・アソシアティブ、32 バイト・ラ
イン・サイズ
44H 第2 レベルのキャッシュ: 1 M バイト、4 ウェイ・セット・アソシアティブ、32 バイト・ライ
ン・サイズ
45H 第2 レベルのキャッシュ：2M バイト、4 ウェイ・セット・アソシアティブ、32 バイト・ライ
ン・サイズ
50H 命令TLB:4K バイト、2M バイト、4M バイト・ページ、64 エントリ
51H 命令TLB:4K バイト、2M バイト、4M バイト・ページ、128 エントリ
52H 命令TLB:4K バイト、2M バイト、4M バイト・ページ、256 エントリ
5BH データTLB:4K バイト、4M バイト・ページ、64 エントリ
5CH データTLB:4K バイト、4M バイト・ページ、128 エントリ
5DH データTLB:4K バイト、4M バイト・ページ、256 エントリ
66H 第1 レベルのデータ・キャッシュ:8K バイト、4 ウェイ・セット・アソシアティブ、64 バイ
ト・ライン・サイズ
67H 第1 レベルのデータ・キャッシュ:16K バイト、4 ウェイ・セット・アソシアティブ、64 バイ
ト・ライン・サイズ
68H 第1 レベルのデータ・キャッシュ:32K バイト、4 ウェイ・セット・アソシアティブ、64 バイ
ト・ライン・サイズ
70H トレース・キャッシュ:12K-μop、8 ウェイ・セット・アソシアティブ
71H トレース・キャッシュ:16K-μop、8 ウェイ・セット・アソシアティブ
72H トレース・キャッシュ:32K-μop、8 ウェイ・セット・アソシアティブ
79H 第2 レベルのキャッシュ:128K バイト、8 ウェイ・セット・アソシアティブ、セクタ化、64
バイト・ライン・サイズ
7AH 第2 レベルのキャッシュ:256K バイト、8 ウェイ・セット・アソシアティブ、セクタ化、64
バイト・ライン・サイズ
7BH 第2 レベルのキャッシュ:512K バイト、8 ウェイ・セット・アソシアティブ、セクタ化、64
バイト・ライン・サイズ
7CH 第2 レベルのキャッシュ:1M バイト、8 ウェイ・セット・アソシアティブ、セクタ化、64 バ
イト・ライン・サイズ
82H 第2 レベルのキャッシュ：256K バイト、8 ウェイ・セット・アソシアティブ、32 バイト・ラ
イン・サイズ
84H 第2 レベルのキャッシュ：1M バイト、8 ウェイ・セット・アソシアティブ、32 バイト・ライ
ン・サイズ
85H 第2 レベルのキャッシュ：2M バイト、8 ウェイ・セット・アソシアティブ、32 バイト・ライ
ン・サイズ
3-123
命令セット・リファレンス
CPUID?CPU Identification ( 続き)
Pentium 4 プロセッサ・ファミリの最初のメンバは、CPUID命令が入力値2 で実行されると、キャッ
シュとTLBに関する以下の情報を返す。
EAX 66 5B 50 01H
EBX 0H
ECX 0H
EDX 00 7A 70 00H
これらの値は、以下のように解釈される。
? EAXレジスタの最下位バイト ( バイト0) が01Hに設定されており、プロセッサのキャッシュと
TLBに関する完全な情報を取り出すのに、CPUID命令は入力値を2 として1 回だけ実行すればよ
いことを示している。
? 4 つのレジスタすべて (EAX、EBX、ECX、およびEDX) の最上位ビットが 0 にセットされてお
り、各レジスタが有効な1 バイトの記述子をもつことを示している。
? EAXレジスタのバイト1、2、および3 は、プロセッサが以下のものを備えていることを示す。
? 50H - 4 K バイト、2 M バイト、4 M バイト・ページ・マップ用の64 エントリ命令TLB
? 5BH - 4 K バイトおよび4 M バイト・ページ・マップ用の64 エントリ・データTLB
? 66H - 8 K バイト第1 レベルのデータ・キャッシュ、4 ウェイ・セット・アソシアティブ、64
バイト・キャッシュ・ライン・サイズ
? EBXおよびECXレジスタ内の記述子は有効であるが、内容はヌル記述子である。
? EDXレジスタのバイト0、1、2、および3 は、プロセッサが以下のものを備えていることを示す。
? 00H - Null 記述子
? 70H - 12 K バイト第1 レベルのコード・キャッシュ、4 ウェイ・セット・アソシアティブ、
64 バイト・キャッシュ・ライン・サイズ
? 7AH - 256 K バイト第2 レベルのキャッシュ、8 ウェイ・セット・アソシアティブ、128 バ
イト・キャッシュ・ライン・サイズ
? 00H - Null 記述子
ブランドの識別
CPUID 命令を使用してIA-32 プロセッサのブランドの識別を容易に行なうために、ブランド・イン
デックスとブランド・ストリングという2 つの機能が用意されている。
ブランド・インデックスは、Pentium III Xeon プロセッサに関してCPUID命令に追加された。この機
能は、Pentium 4 プロセッサを含め、今後発表されるIA-32 プロセッサのすべてに搭載される。ブラ
ンド・インデックスは、ブランド識別テーブルへのエントリ・ポイントとなる。ブランド識別テー
ブルはシステム・ソフトウェアによってメモリ内に保持され、システム・レベルおよびユーザー・
レベルのコードからアクセスが可能である。このブランド識別テーブルでは、各ブランド・インデッ
クスが、公認のインテル・プロセッサ・ファミリであることを示すASCII ブランド識別ストリング
とプロセッサのモデル番号とに関連付けられている(例えば、"インテルPentium IIIプロセッサ"など)。
3-124
命令セット・リファレンス
CPUID?CPU Identification ( 続き)
EAXレジスタに値1 を設定してCPUID命令を実行すると、EBXレジスタの下位バイトにブランド・
インデックスが返される。ソフトウェアでこのインデックスを使用することで、ブランド識別テー
ブル内にあるプロセッサのブランド識別ストリングを特定することができる。ブランド識別テーブ
ルの最初のエントリ( ブランド・インデックス0) は予約されており、ブランド識別機能をサポートし
ていないプロセッサとの下方互換性が保たれている。表3-11. は、現時点でプロセッサ・ブランド識
別ストリングが関連付けられているブランド・インデックスを示している。
次のことが推奨される。(1) ブランド識別テーブル内にある予約済みのエントリはすべて、今後のイ
ンテル・プロセッサ用にインデックスが予約されていることを示すブランド・ストリングと関連付
けておくこと。(2) 予約済みのブランド・インデックスを正常に処理できるようにソフトウェアを準
備しておくこと。
注：
† Pentium III Xeon プロセッサ以降に発表されたプロセッサのバージョンを指す。
ブランド・ストリング機能はCPUID命令の拡張機能であり、Pentium 4 プロセッサで導入された。こ
の機能では、CPUID 命令を実行することにより、EAX、EBX、ECX、EDXの各レジスタにASCII ブ
ランド識別ストリングとプロセッサの最大動作周波数が返される。( ただし、返される周波数はその
プロセッサについて定義されている最大動作周波数であり、そのプロセッサのその時点での動作周
波数ではない。)
ブランド・ストリング機能を使用するには、CPUID 命令を3 回実行しなければならない。つまり、
EAX レジスタの入力値として、1 回目は80000002H、2 回目は80000003H、3 回目は80000004H を設
定する必要がある。
ブランド・ストリングは、アーキテクチャ上、48バイトの長さに定義されている。先頭の47 バイト
にはASCII 文字が入り、48 番目のバイトはNULL(0) になるように定義されている。プロセッサによっ
ては、簡単にするために、ストリングが( 先頭にスペースが入って) 右揃えにされることがある。
CPUID命令は、それぞれの入力値(EAX=80000002H、80000003H、80000004H) ごとに、EAX、EBX、
ECX、EDXの各レジスタに16 バイトのブランド・ストリングを返す。47 文字未満のASCII 文字をプ
ロセッサが返すことがあるが、この場合、ストリングはNULL で終了し、プロセッサは、CPUID の
入力値である80000002H、80000003H、および80000004Hごとに有効な値を返す。
表3-12. は、Pentium 4 プロセッサ・ファミリの最初のプロセッサによって返されるブランド・ストリ
ングを示している。
表3-11. ブランド・インデックスとIA-32 プロセッサ・ブランド・ストリングの対応関係
ブランド・
インデックス
ブランド・ストリング
0 このプロセッサはブランドID 機能をサポートしていない。
1 インテルCeleron プロセッサ†
2 Pentium III プロセッサ†
3 インテルPentium III Xeon プロセッサ
4 ? 7 今後のプロセッサのために予約済み
8 インテルPentium 4 プロセッサ
5 ? 255 今後のプロセッサのために予約済み。
3-125
命令セット・リファレンス
CPUID?CPU Identification ( 続き)
注記
ブランド・ストリング内に周波数が示されている場合、この周波数は、そのプロ
セッサに対して定義されている最大周波数を表すもので、実際の動作周波数を表
しているのではない。
以下の手順を実行すると、ブランド・ストリング機能を検出することができる。
1. EAX に入力値として80000000H を設定して、CPUID 命令を実行する。
2. ((EAX_Return_Value) AND (80000000H) ≠ 0) の場合、プロセッサはCPUID 命令の拡張機能をサ
ポートしており、その拡張機能に対してサポートされている最大入力値がEAX に返される。
3. EAX_Return_Value ≧ 80000004H の場合、CPUID 命令は、ブランド・ストリング機能をサポート
している。
CPUID命令を使用してIA-32 プロセッサを識別する場合、ブランド識別のためのソフトウェアでは、
以下のブランド識別手法を使用する必要がある( 先にあげる項目ほど優先順位が高くなる)。
? プロセッサ・ブランド・ストリング
? プロセッサ・ブランド・インデックスおよびソフトウェア提供ブランド・ストリング・テーブル
? CPUID 命令によって返されるタイプ、ファミリ、モデル、ステッピング、キャッシュ情報を利
用した、テーブル方式の機構
IA-32 アーキテクチャにおける互換性
CPUID命令は、初期モデルのIntel486 プロセッサまたはIntel486プロセッサよりも以前のすべてのIA-
32 プロセッサでサポートされていない。
表3-12. 最初のPentiumR 4 プロセッサに関して返されるプロセッサ・ブランド・ストリング
EAX 入力値戻り値対応するASCII ストリング
80000002H EAX = 20202020H
EBX = 20202020H
ECX = 20202020H
EDX = 6E492020H;
“ ”
“ ”
“ ”
“nI ”
80000003H EAX = 286C6574H
EBX = 50202952H
ECX = 69746E65H
EDX = 52286D75H
“(let”
“P )R”
“itne”
“R(mu”
80000004H EAX = 20342029H;
EBX = 20555043H;
ECX = 30303531H
EDX = 007A484DH
“ 4 )”
“ UPC”
“0051”
“\0zHM”
3-126
命令セット・リファレンス
CPUID?CPU Identification ( 続き)
操作
CASE (EAX) OF
EAX ← 0:
EAX ← highest basic function input value understood by CPUID;
EBX ← Vendor identification string;
EDX ← Vendor identification string;
ECX ← Vendor identification string;
BREAK;
EAX ← 1H:
EAX[3:0] ← Stepping ID;
EAX[7:4] ← Model;
EAX[11:8] ← Family;
EAX[13:12] ← Processor type;
EAX[15:14] ← Reserved;
EAX[19:16] ← Extended Model;
EAX[23:20] ← Extended Family;
EAX[31:24] ← Reserved;
EBX[7:0] ← Brand Index;
EBX[15:8] ← CLFLUSH Line Size;
EBX[16:23] ← Reserved;
EBX[24:31] ← Initial APIC ID;
ECX ← Reserved;
EDX ← Feature flags; (* 図3-4. を参照 *)
BREAK;
EAX ← 2H:
EAX ← Cache and TLB information;
EBX ← Cache and TLB information;
ECX ← Cache and TLB information;
EDX ← Cache and TLB information;
BREAK;
EAX ← 3H:
EAX ← Reserved;
EBX ← Reserved;
ECX ← ProcessorSerialNumber[31:0];
(* Pentium III processors only, otherwise reserved *)
EDX ← ProcessorSerialNumber[63:32];
(* Pentium III processors only, otherwise reserved *
BREAK;
EAX ← 80000000H:
EAX ← highest extended function input value understood by CPUID;
EBX ← Reserved;
ECX ← Reserved;
EDX ← Reserved;
BREAK;
3-127
命令セット・リファレンス
CPUID?CPU Identification ( 続き)
EAX ← 80000001H:
EAX ← Extended Processor Signature and Feature Bits (*Currently Reserved*);
EBX ← Reserved;
ECX ← Reserved;
EDX ← Reserved;
BREAK;
EAX ← 80000002H:
EAX ← Processor Name;
EBX ← Processor Name;
ECX ← Processor Name;
EDX ← Processor Name;
BREAK;
EAX ← 80000003H:
EAX ← Processor Name;
EBX ← Processor Name;
ECX ← Processor Name;
EDX ← Processor Name;
BREAK;
EAX ← 80000004H:
EAX ← Processor Name;
EBX ← Processor Name;
ECX ← Processor Name;
EDX ← Processor Name;
BREAK;
DEFAULT: (* EAX > highest value recognized by CPUID *)
EAX ← Reserved; (* undefined*)
EBX ← Reserved; (* undefined*)
ECX ← Reserved; (* undefined*)
EDX ← Reserved; (* undefined*)
BREAK;
ESAC;
影響を受けるフラグ
なし。
例外 ( すべての操作モード)
なし。
注記
CPUID 命令をサポートしていない初期のIA-32 プロセッサでは、CPUID 命令を実
行すると、無効オペコード(#UD) 例外が発生する。
3-128
命令セット・リファレンス
CVTDQ2PD?Convert Packed Doubleword Integers to Packed Double-
Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）の2 つのパックド符号付きダブルワード整数を、デスティ
ネーション・オペランド（第1 オペランド）の2 つのパックド倍精度浮動小数点値に変換する。ソー
ス・オペランドは、XMM レジスタまたは64 ビットのメモリ・ロケーションである。デスティネー
ション・オペランドはXMMレジスタである。ソース・オペランドがXMMレジスタの場合は、パッ
クド整数はレジスタの下位クワッドワードに置かれる。
操作
DEST[63-0] ← Convert_Integer_To_Double_Precision_Floating_Point(SRC[31-0]);
DEST[127-64] ← Convert_Integer_To_Double_Precision_Floating_Point(SRC[63-32]);
同等のインテルC/C++ コンパイラ組み込み関数
CVTDQ2PD __m128d _mm_cvtepi32_pd(__m128di a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
F3 0F E6 CVTDQ2PD xmm1, xmm2/m64 xmm2/m128 の2 つのパックド符号付きダブルワー
ド整数をxmm1 の2 つのパックド倍精度浮動小数点
値に変換する。
3-129
命令セット・リファレンス
CVTDQ2PD?Convert Packed Doubleword Integers to Packed Double-
Precision Floating-Point Values ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-130
命令セット・リファレンス
CVTDQ2PS?Convert Packed Doubleword Integers to Packed Single-
Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）の4 つのパックド符号付きダブルワード整数を、デスティ
ネーション・オペランド（第1 オペランド）の4 つのパックド単精度浮動小数点値に変換する。ソー
ス・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネー
ション・オペランドはXMMレジスタである。変換が不正確な場合は、MXCSRレジスタの丸め制御
ビットに従って丸めが実行される。
操作
DEST[31-0] ← Convert_Integer_To_Single_Precision_Floating_Point(SRC[31-0]);
DEST[63-32] ← Convert_Integer_To_Single_Precision_Floating_Point(SRC[63-32]);
DEST[95-64] ← Convert_Integer_To_Single_Precision_Floating_Point(SRC[95-64]);
DEST[127-96] ← Convert_Integer_To_Single_Precision_Floating_Point(SRC[127-96]);
同等のインテルC/C++ コンパイラ組み込み関数
CVTDQ2PS __m128d _mm_cvtepi32_ps(__m128di a)
SIMD 浮動小数点例外
精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
0F 5B /r CVTDQ2PS xmm1,
xmm2/m128
xmm2/m128 の4 つのパックド符号付きダブルワード整数
をxmm1 の4 つのパックド単精度浮動小数点値に変換す
る。
3-131
命令セット・リファレンス
CVTDQ2PS?Convert Packed Doubleword Integers to Packed Single-
Precision Floating-Point Values ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-132
命令セット・リファレンス
CVTPD2DQ?Convert Packed Double-Precision Floating-Point Values
to Packed Doubleword Integers
ソース・オペランド（第2 オペランド）の2 つのパックド倍精度浮動小数点値を、デスティネーショ
ン・オペランド（第1 オペランド）の2 つのパックド符号付きダブルワード整数に変換する。ソー
ス・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネー
ション・オペランドはXMMレジスタである。変換の結果はデスティネーション・オペランドの下位
クワッドワードに格納され、上位クワッドワードはすべて0 にクリアされる。
変換が不正確な場合は、MXCSRレジスタの丸め制御ビットに従って丸められた値が返される。変換
の結果が符号付きダブルワード整数の最大値より大きくなる場合は、整数不定値（80000000H）が返
される。
操作
DEST[31-0] ← Convert_Double_Precision_Floating_Point_To_Integer(SRC[63-0]);
DEST[63-32] ← Convert_Double_Precision_Floating_Point_To_Integer(SRC[127-64]);
DEST[127-64] ← 0000000000000000H;
同等のインテルC/C++ コンパイラ組み込み関数
CVTPD2DQ __m128d _mm_cvtpd_epi32(__m128d a)
SIMD 浮動小数点例外
無効、精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
F2 0F E6 CVTPD2DQ xmm1,
xmm2/m128
xmm2/m128 の2 つのパックド倍精度浮動小数点値を
xmm1 の2 つのパックド符号付きダブルワード整数に変換
する。
3-133
命令セット・リファレンス
CVTPD2DQ?Convert Packed Double-Precision Floating-Point Values
to Packed Doubleword Integers ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-134
命令セット・リファレンス
CVTPD2PI?Convert Packed Double-Precision Floating-Point to
Packed Doubleword Integers
説明
ソース・オペランド（第2 オペランド）の2 つのパックド倍精度浮動小数点値を、デスティネーショ
ン・オペランド（第1 オペランド）の2 つのパックド符号付きダブルワード整数に変換する。ソー
ス・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネー
ション・オペランドはMMXテクノロジ・レジスタである。
変換が不正確な場合は、MXCSRレジスタの丸め制御ビットに従って丸められた値が返される。変換
の結果が符号付きダブルワード整数の最大値より大きくなる場合は、整数不定値（80000000H）が返
される。
この命令を使用すると、x87 FPU 操作からMMX テクノロジ操作への移行が発生する（つまり、x87
FPUのトップオブスタック・ポインタは0 に設定され、x87 FPUタグ・ワードはすべて0[ 有効] に設
定される）。未処理のx87 FPU 浮動小数点例外があるときにこの命令を実行しようとすると、
CVTPD2PI 命令を実行する前にその例外が処理される。
操作
DEST[31-0] ← Convert_Double_Precision_Floating_Point_To_Integer(SRC[63-0]);
DEST[63-32] ← Convert_Double_Precision_Floating_Point_To_Integer(SRC[127-64]);
同等のインテルC/C++ コンパイラ組み込み関数
CVTPD2PI __m64 _mm_cvtpd_pi32(__m128d a)
SIMD 浮動小数点例外
無効、精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#MF 未処理のx87 FPU 例外がある場合。
#NM CR0 のTS がセットされた場合。
オペコード命令説明
66 0F 2D /r CVTPD2PI mm, xmm/m128 xmm/m128 の2 つのパックド倍精度浮動小数点値を
mm の2 つのパックド符号付きダブルワード整数に変換
する。
3-135
命令セット・リファレンス
CVTPD2PI?Convert Packed Double-Precision Floating-Point Values to
Packed Doubleword Integers ( 続き)
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-136
命令セット・リファレンス
CVTPD2PS?Covert Packed Double-Precision Floating-Point Values to
Packed Single-Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）の2 つのパックド倍精度浮動小数点値を、デスティネーショ
ン・オペランド（第1 オペランド）の2 つのパックド単精度浮動小数点値に変換する。ソース・オペ
ランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・
オペランドはXMMレジスタである。変換の結果はデスティネーション・オペランドの下位クワッド
ワードに格納され、上位クワッドワードはすべて0 にクリアされる。変換が不正確な場合は、MXCSR
レジスタの丸め制御ビットに従って丸められた値が返される。
操作
DEST[31-0] ← Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[63-0]);
DEST[63-32] ← Convert_Double_Precision_To_Single_Precision_
Floating_Point(SRC[127-64]);
DEST[127-64] ← 0000000000000000H;
同等のインテルC/C++ コンパイラ組み込み関数
CVTPD2PS __m128d _mm_cvtpd_ps(__m128d a)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
66 0F 5A /r CVTPD2PS xmm1,
xmm2/m128
xmm2/m128 の2 つのパックド倍精度浮動小数点値を
xmm1 の2 つのパックド単精度浮動小数点値に変換する。
3-137
命令セット・リファレンス
CVTPD2PS?Covert Packed Double-Precision Floating-Point Values to
Packed Single-Precision Floating-Point Values ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-138
命令セット・リファレンス
CVTPI2PD?Convert Packed Doubleword Integers to Packed Double-
Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）の2 つのパックド符号付きダブルワード整数を、デスティ
ネーション・オペランド（第1 オペランド）の2 つのパックド倍精度浮動小数点値に変換する。ソー
ス・オペランドは、MMXテクノロジ・レジスタまたは64ビットのメモリ・ロケーションである。デ
スティネーション・オペランドはXMMレジスタである。
この命令を使用すると、x87 FPU 操作からMMX テクノロジ操作への移行が発生する（つまり、x87
FPUのトップオブスタック・ポインタは0 に設定され、x87 FPUタグ・ワードはすべて0[ 有効] に設
定される）。未処理のx87 FPU 浮動小数点例外があるときにこの命令を実行しようとすると、
CVTPI2PD命令を実行する前にその例外が処理される。
操作
DEST[63-0] ← Convert_Integer_To_Double_Precision_Floating_Point(SRC[31-0]);
DEST[127-64] ← Convert_Integer_To_Double_Precision_Floating_Point(SRC[63-32]);
同等のインテルC/C++ コンパイラ組み込み関数
CVTPI2PD __m128d _mm_cvtpi32_pd(__m64 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
66 0F 2A /r CVTPI2PD xmm, mm/m64 mm/mem64 の2 つのパックド符号付きダブルワード整
数をxmm の2 つのパックド倍精度浮動小数点値に変換
する。
3-139
命令セット・リファレンス
CVTPI2PD?Convert Packed Doubleword Integers to Packed Double-
Precision Floating-Point Values ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-140
命令セット・リファレンス
CVTPI2PS?Convert Packed Doubleword Integers to Packed Single-
Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）の2 つのパックド符号付きダブルワード整数を、デスティ
ネーション・オペランド（第1 オペランド）の2 つのパックド単精度浮動小数点値に変換する。ソー
ス・オペランドは、MMXテクノロジ・レジスタまたは64ビットのメモリ・ロケーションである。デ
スティネーション・オペランドはXMMレジスタである。変換の結果はデスティネーション・オペラ
ンドの下位クワッドワードに格納され、上位クワッドワードは変更されない。
この命令を使用すると、x87 FPU 操作からMMX テクノロジ操作への移行が発生する（つまり、x87
FPUのトップオブスタック・ポインタは0 に設定され、x87 FPUタグ・ワードはすべて0[ 有効] に設
定される）。未処理のx87 FPU 浮動小数点例外があるときにこの命令を実行しようとすると、
CVTPI2PS 命令を実行する前にその例外が処理される。
操作
DEST[31-0] ← Convert_Integer_To_Single_Precision_Floating_Point(SRC[31-0]);
DEST[63-32] ← Convert_Integer_To_Single_Precision_Floating_Point(SRC[63-32]);
* high quadword of destination remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
CVTPI2PS __m128 _mm_cvtpi32_ps(__m128 a, __m64 b)
SIMD 浮動小数点例外
精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
0F 2A /r CVTPI2PS xmm, mm/m64 mm/m64 の2 つのパックド符号付きダブルワード整数
をxmm の2 つのパックド単精度浮動小数点値に変換す
る。
3-141
命令セット・リファレンス
CVTPI2PS?Convert Packed Doubleword Integers to Packed Single-
Precision Floating-Point Values ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-142
命令セット・リファレンス
CVTPS2DQ?Convert Packed Single-Precision Floating-Point Values
to Packed Doubleword Integers
説明
ソース・オペランド（第2 オペランド）の4 つのパックド単精度浮動小数点値を、デスティネーショ
ン・オペランド（第1 オペランド）の4 つのパックド符号付きダブルワード整数に変換する。ソー
ス・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネー
ション・オペランドはXMMレジスタである。
変換が不正確な場合は、MXCSRレジスタの丸め制御ビットに従って丸められた値が返される。変換
の結果が符号付きダブルワード整数の最大値より大きくなる場合は、整数不定値（80000000H）が返
される。
操作
DEST[31-0] ← Convert_Single_Precision_Floating_Point_To_Integer(SRC[31-0]);
DEST[63-32] ← Convert_Single_Precision_Floating_Point_To_Integer(SRC[63-32]);
DEST[95-64] ← Convert_Single_Precision_Floating_Point_To_Integer(SRC[95-64]);
DEST[127-96] ← Convert_Single_Precision_Floating_Point_To_Integer(SRC[127-96]);
同等のインテルC/C++ コンパイラ組み込み関数
__m128d _mm_cvtps_epi32(__m128d a)
SIMD 浮動小数点例外
無効、精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#MF 未処理のx87 FPU 例外がある場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
66 0F 5B /r CVTPS2DQ xmm1,
xmm2/m128
xmm2/m128 の4 つのパックド単精度浮動小数点値を
xmm1 の4 つのパックド符号付きダブルワード整数に変換
する。
3-143
命令セット・リファレンス
CVTPS2DQ?Convert Packed Single-Precision Floating-Point Values to
Packed Doubleword Integers ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-144
命令セット・リファレンス
CVTPS2PD?Covert Packed Single-Precision Floating-Point Values to
Packed Double-Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）の2 つのパックド単精度浮動小数点値を、デスティネーショ
ン・オペランド（第1 オペランド）の2 つのパックド倍精度浮動小数点値に変換する。ソース・オペ
ランドは、XMMレジスタまたは64 ビットのメモリ・ロケーションである。デスティネーション・オ
ペランドはXMMレジスタである。ソース・オペランドがXMMレジスタの場合は、パックド単精度
浮動小数点値はレジスタの下位クワッドワードに置かれる。
操作
DEST[63-0] ← Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[31-0]);
DEST[127-64] ← Convert_Single_Precision_To_Double_Precision_
Floating_Point(SRC[63-32]);
同等のインテルC/C++ コンパイラ組み込み関数
CVTPS2PD __m128d _mm_cvtps_pd(__m128 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
0F 5A /r CVTPS2PD xmm1,
xmm2/m64
xmm2/m64 の2 つのパックド単精度浮動小数点値をxmm1
の2 つのパックド倍精度浮動小数点値に変換する。
3-145
命令セット・リファレンス
CVTPS2PD?Covert Packed Single-Precision Floating-Point Values to
Packed Double-Precision Floating-Point Values ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-146
命令セット・リファレンス
CVTPS2PI?Convert Packed Single-Precision Floating-Point Values to
Packed Doubleword Integers
説明
ソース・オペランド（第2 オペランド）の2 つのパックド単精度浮動小数点値を、デスティネーショ
ン・オペランド（第1 オペランド）の2 つのパックド符号付きダブルワード整数に変換する。ソー
ス・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネー
ション・オペランドはMMXテクノロジ・レジスタである。ソース・オペランドがXMMレジスタの
場合は、2 つの単精度浮動小数点値はレジスタの下位クワッドワードに置かれる。
変換が不正確な場合は、MXCSRレジスタの丸め制御ビットに従って丸められた値が返される。変換
された結果が符号付きダブルワード整数の最大値より大きい場合は、整数不定値(80000000H) が返さ
れる。
この命令を使用すると、x87 FPU 操作からMMX テクノロジ操作への移行が発生する（つまり、x87
FPUのトップオブスタック・ポインタは0 に設定され、x87 FPUタグ・ワードはすべて0[ 有効] に設
定される）。未処理のx87 FPU 浮動小数点例外があるときにこの命令を実行しようとすると、
CVTPS2PI 命令を実行する前にその例外が処理される。
操作
DEST[31-0] ← Convert_Single_Precision_Floating_Point_To_Integer(SRC[31-0]);
DEST[63-32] ← Convert_Single_Precision_Floating_Point_To_Integer(SRC[63-32]);
同等のインテルC/C++ コンパイラ組み込み関数
__m64 _mm_cvtps_pi32(__m128 a)
SIMD 浮動小数点例外
無効、精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#MF 未処理のx87 FPU 例外がある場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
0F 2D /r CVTPS2PI mm, xmm/m64 xmm/m64 の2 つのパックド単精度浮動小数点値を、
mm の2 つのパックド符号付きダブルワード整数に変換
する。
3-147
命令セット・リファレンス
CVTPS2PI?Convert Packed Single-Precision Floating-Point Values to
Packed Doubleword Integers ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-148
命令セット・リファレンス
CVTSD2SI?Convert Scalar Double-Precision Floating-Point Value to
Doubleword Integer
説明
ソース・オペランド（第2 オペランド）の1 つの倍精度浮動小数点値を、デスティネーション・オペ
ランド（第1 オペランド）の1 つの符号付きダブルワード整数に変換する。ソース・オペランドは、
XMM レジスタまたは64 ビットのメモリ・ロケーションである。デスティネーション・オペランド
は汎用レジスタである。ソース・オペランドがXMMレジスタの場合は、倍精度浮動小数点値はレジ
スタの下位クワッドワードに置かれる。
変換が不正確な場合は、MXCSRレジスタの丸め制御ビットに従って丸められた値が返される。変換
の結果が符号付きダブルワード整数の最大値より大きくなる場合は、整数不定値（80000000H）が返
される。
操作
DEST[31-0] ← Convert_Double_Precision_Floating_Point_To_Integer(SRC[63-0]);
同等のインテルC/C++ コンパイラ組み込み関数
int_mm_cvtsd_si32(__m128d a)
SIMD 浮動小数点例外
無効、精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
F2 0F 2D /r CVTSD2SI r32, xmm/m64 xmm/m64 の1 つの倍精度浮動小数点値をr32 の1 つの
符号付きダブルワード整数に変換する。
3-149
命令セット・リファレンス
CVTSD2SI?Convert Scalar Double-Precision Floating-Point Value to
Doubleword Integer ( 続き)
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-150
命令セット・リファレンス
CVTSD2SS?Convert Scalar Double-Precision Floating-Point Value to
Scalar Single-Precision Floating-Point Value
説明
ソース・オペランド（第2 オペランド）の1 つの倍精度浮動小数点値を、デスティネーション・オペ
ランド（第1 オペランド）の1 つの単精度浮動小数点値に変換する。ソース・オペランドは、XMM
レジスタまたは64 ビットのメモリ・ロケーションである。デスティネーション・オペランドはXMM
レジスタである。ソース・オペランドがXMMレジスタの場合は、倍精度浮動小数点値はレジスタの
下位クワッドワードに置かれる。変換の結果はデスティネーション・オペランドの最下位のダブル
ワードに格納され、上位3 つのダブルワードは変更されない。変換が不正確な場合は、MXCSRレジ
スタの丸め制御ビットに従って丸められた値が返される。
操作
DEST[31-0] ← Convert_Double_Precision_To_Single_Precision_Floating_Point(SRC[63-0]);
* DEST[127-32] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
CVTSD2SS __m128_mm_cvtsd_ss(__m128d a, __m128d b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
F2 0F 5A /r CVTSD2SS xmm1, xmm2/m64 xmm2/m64 の1 つの倍精度浮動小数点値をxmm1 の
1 つの単精度浮動小数点値に変換する。
3-151
命令セット・リファレンス
CVTSD2SS?Convert Scalar Double-Precision Floating-Point Value to
Scalar Single-Precision Floating-Point Value ( 続き)
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-152
命令セット・リファレンス
CVTSI2SD?Convert Doubleword Integer to Scalar Double-Precision
Floating-Point Value
説明
ソース・オペランド（第2 オペランド）の1 つの符号付きダブルワード整数を、デスティネーショ
ン・オペランド（第1 オペランド）の1 つの倍精度浮動小数点値に変換する。ソース・オペランドは、
汎用レジスタまたは32 ビットのメモリ・ロケーションである。デスティネーション・オペランドは
XMMレジスタである。変換の結果はデスティネーション・オペランドの下位クワッドワードに格納
され、上位クワッドワードは変更されない。
操作
DEST[63-0] ← Convert_Integer_To_Double_Precision_Floating_Point(SRC[31-0]);
* DEST[127-64] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
int_mm_cvtsd_si32(__m128d a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
F2 0F 2A /r CVTSI2SD xmm, r/m32 r/m32 の1 つの符号付きダブルワード整数をxmm の1 つの
倍精度浮動小数点値に変換する。
3-153
命令セット・リファレンス
CVTSI2SD?Convert Doubleword Integer to Scalar Double-Precision
Floating-Point Value ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-154
命令セット・リファレンス
CVTSI2SS?Convert Doubleword Integer to Scalar Single-Precision
Floating-Point Value
説明
ソース・オペランド（第2 オペランド）の1 つの符号付きダブルワード整数を、デスティネーショ
ン・オペランド（第1 オペランド）の1 つの単精度浮動小数点値に変換する。ソース・オペランドは、
汎用レジスタまたは32 ビットのメモリ・ロケーションである。デスティネーション・オペランドは
XMMレジスタである。変換の結果はデスティネーション・オペランドの最下位のダブルワードに格
納され、上位3 つのダブルワードは変更されない。変換が不正確な場合は、MXCSRレジスタの丸め
制御ビットに従って丸められた値が返される。
操作
DEST[31-0] ← Convert_Inteter_To_Single_Precision_Floating_Point(SRC[31-0]);
* DEST[127-32] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
__m128_mm_cvtsi32_ss(__m128d a, int b)
SIMD 浮動小数点例外
精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
F3 0F 2A /r CVTSI2SS xmm, r/m32 r/m32 の1 つの符号付きダブルワード整数をxmm の1 つの
単精度浮動小数点値に変換する。
3-155
命令セット・リファレンス
CVTSI2SS?Convert Doubleword Integer to Scalar Single-Precision
Floating-Point Value ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-156
命令セット・リファレンス
CVTSS2SD?Convert Scalar Single-Precision Floating-Point Value to
Scalar Double-Precision Floating-Point Value
説明
ソース・オペランド（第2 オペランド）の1 つの単精度浮動小数点値を、デスティネーション・オペ
ランド（第1 オペランド）の1 つの倍精度浮動小数点値に変換する。ソース・オペランドは、XMM
レジスタまたは32 ビットのメモリ・ロケーションである。デスティネーション・オペランドはXMM
レジスタである。ソース・オペランドがXMMレジスタの場合は、単精度浮動小数点値はレジスタの
最下位のダブルワードに置かれる。変換の結果はデスティネーション・オペランドの下位クワッド
ワードに格納され、上位クワッドワードは変更されない。
操作
DEST[63-0] ← Convert_Single_Precision_To_Double_Precision_Floating_Point(SRC[31-0]);
* DEST[127-64] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
CVTSS2SD __m128d_mm_cvtss_sd(__m128d a, __m128 b)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
F3 0F 5A /r CVTSS2SD xmm1, xmm2/m32 xmm2/m32 の1 つの単精度浮動小数点値をxmm1 の
1 つの倍精度浮動小数点値に変換する。
3-157
命令セット・リファレンス
CVTSS2SD?Convert Scalar Single-Precision Floating-Point Value to
Scalar Double-Precision Floating-Point Value ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-158
命令セット・リファレンス
CVTSS2SI?Convert Scalar Single-Precision Floating-Point Value to
Doubleword Integer
説明
ソース・オペランド（第2 オペランド）の1 つの単精度浮動小数点値を、デスティネーション・オペ
ランド（第1 オペランド）の1 つの符号付きダブルワード整数に変換する。ソース・オペランドは、
XMM レジスタまたは32 ビットのメモリ・ロケーションである。デスティネーション・オペランド
は汎用レジスタである。ソース・オペランドがXMMレジスタの場合は、単精度浮動小数点値はレジ
スタの最下位のダブルワードに置かれる。
変換が不正確な場合は、MXCSRレジスタの丸め制御ビットに従って丸められた値が返される。変換
された結果が符号付きダブルワード整数の最大値より大きい場合は、整数不定値(80000000H) が返さ
れる。
操作
DEST[31-0] ← Convert_Single_Precision_Floating_Point_To_Integer(SRC[31-0]);
同等のインテルC/C++ コンパイラ組み込み関数
int_mm_cvtss_si32(__m128d a)
SIMD 浮動小数点例外
無効、精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
オペコード命令説明
F3 0F 2D /r CVTSS2SI r32, xmm/m32 xmm/m32 の1 つの単精度浮動小数点値をr32 の1 つの
符号付きダブルワード整数に変換し、結果を整数レジス
タに移動する。
3-159
命令セット・リファレンス
CVTSS2SI?Convert Scalar Single-Precision Floating-Point Value to
Doubleword Integer ( 続き)
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-160
命令セット・リファレンス
CVTTPD2PI?Convert with Truncation Packed Double-Precision
Floating-Point Values to Packed Doubleword Integers
説明
ソース・オペランド（第2 オペランド）の2 つのパックド倍精度浮動小数点値を、デスティネーショ
ン・オペランド（第1 オペランド）の2 つのパックド符号付きダブルワード整数に変換する。ソー
ス・オペランドは、XMM テクノロジ・レジスタまたは128 ビットのメモリ・ロケーションである。
デスティネーション・オペランドはMMXテクノロジ・レジスタである。
変換が不正確な場合は、切り捨てられた（ゼロに丸められる）結果が返される。変換の結果が符号
付きダブルワード整数の最大値より大きくなる場合は、整数不定値（80000000H）が返される。
この命令を使用すると、x87 FPU 操作からMMX テクノロジ操作への移行が発生する（つまり、x87
FPUのトップオブスタック・ポインタは0 に設定され、x87 FPUタグ・ワードはすべて0[ 有効] に設
定される）。未処理のx87 FPU 浮動小数点例外があるときにこの命令を実行しようとすると、
CVTPD2PI 命令を実行する前にその例外が処理される。
操作
DEST[31-0] ← Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[63-0]);
DEST[63-32] ← Convert_Double_Precision_Floating_Point_To_Integer_
Truncate(SRC[127-64]);
同等のインテルC/C++ コンパイラ組み込み関数
CVTTPD2PI __m64 _mm_cvttpd_pi32(__m128d a)
SIMD 浮動小数点例外
無効、精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#MF 未処理のx87 FPU 例外がある場合。
#NM CR0 のTS がセットされた場合。
オペコード命令説明
66 0F 2C /r CVTTPD2PI mm, xmm/m128 切り捨てを使用して、xmm/m128 の2 つのパックド倍
精度浮動小数点値をmm の2 つのパックド符号付きダ
ブルワード整数に変換する。
3-161
命令セット・リファレンス
CVTTPD2PI?Convert with Truncation Packed Double-Precision
Floating-Point Values to Packed Doubleword Integers ( 続き)
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-162
命令セット・リファレンス
CVTTPD2DQ?Convert with Truncation Packed Double-Precision
Floating-Point Values to Packed Doubleword Integers
説明
ソース・オペランド（第2 オペランド）の2 つのパックド倍精度浮動小数点値を、デスティネーショ
ン・オペランド（第1 オペランド）の2 つのパックド符号付きダブルワード整数に変換する。ソー
ス・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネー
ション・オペランドはXMMレジスタである。変換の結果はデスティネーション・オペランドの下位
クワッドワードに格納され、上位クワッドワードはすべて0 にクリアされる。
変換が不正確な場合は、切り捨てられた（ゼロに丸められる）結果が返される。変換の結果が符号
付きダブルワード整数の最大値より大きくなる場合は、整数不定値（80000000H）が返される。
操作
DEST[31-0] ← Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[63-0]);
DEST[63-32] ← Convert_Double_Precision_Floating_Point_To_Integer_
Truncate(SRC[127-64]);
DEST[127-64] ← 0000000000000000H;
同等のインテルC/C++ コンパイラ組み込み関数
CVTTPD2DQ __m128i _mm_cvttpd_epi32(__m128d a)
SIMD 浮動小数点例外
無効、精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
66 0F E6 CVTTPD2DQ xmm1,
xmm2/m128
切り捨てを使用して、xmm2/m128 の2 つのパックド倍精
度浮動小数点値をxmm1 の2 つのパックド符号付きダブル
ワード整数に変換する。
3-163
命令セット・リファレンス
CVTPD2DQ?Convert with Truncation Packed Double-Precision
Floating-Point Values to Packed Doubleword Integers ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-164
命令セット・リファレンス
CVTTPS2DQ?Convert with Truncation Packed Single-Precision
Floating-Point Values to Packed Doubleword Integers
説明
ソース・オペランド（第2 オペランド）の4 つのパックド単精度浮動小数点値を、デスティネーショ
ン・オペランド（第1 オペランド）の4 つのパックド符号付きダブルワード整数に変換する。ソー
ス・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネー
ション・オペランドはXMMレジスタである。
変換が不正確な場合は、切り捨てられた（ゼロに丸められる）結果が返される。変換の結果が符号
付きダブルワード整数の最大値より大きくなる場合は、整数不定値（80000000H）が返される。
操作
DEST[31-0] ← Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31-0]);
DEST[63-32] ← Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[63-32]);
DEST[95-64] ← Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[95-64]);
DEST[127-96] ← Convert_Single_Precision_Floating_Point_To_Integer_
Truncate(SRC[127-96]);
同等のインテルC/C++ コンパイラ組み込み関数
__m128d _mm_cvttps_epi32(__m128d a)
SIMD 浮動小数点例外
無効、精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
F3 0F 5B /r CVTTPS2DQ xmm1,
xmm2/m128
切り捨てを使用して、xmm2/m128 の4 つの単精度浮動小
数点値をxmm1 の4 つの符号付きダブルワード整数に変換
する。
3-165
命令セット・リファレンス
CVTTPS2DQ?Convert with Truncation Packed Single-Precision
Floating-Point Values to Packed Doubleword Integers ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-166
命令セット・リファレンス
CVTTPS2PI?Convert with Truncation Packed Single-Precision
Floating-Point Values to Packed Doubleword Integers
説明
ソース・オペランド（第2 オペランド）の2 つのパックド単精度浮動小数点値を、デスティネーショ
ン・オペランド（第1 オペランド）の2 つのパックド符号付きダブルワード整数に変換する。ソー
ス・オペランドは、XMM レジスタまたは64 ビットのメモリ・ロケーションである。デスティネー
ション・オペランドはMMXテクノロジ・レジスタである。ソース・オペランドがXMMレジスタの
場合は、2 つの単精度浮動小数点値はレジスタの下位クワッドワードに置かれる。
変換が不正確な場合は、切り捨てられた（ゼロに丸められる）結果が返される。変換された結果が
符号付きダブルワード整数の最大値より大きい場合は、整数不定値(80000000H) が返される。
この命令を使用すると、x87 FPU 操作からMMX テクノロジ操作への移行が発生する（つまり、x87
FPUのトップオブスタック・ポインタは0 に設定され、x87 FPUタグ・ワードはすべて0[ 有効] に設
定される）。未処理のx87 FPU 浮動小数点例外があるときにこの命令を実行しようとすると、
CVTTPS2PI 命令を実行する前にその例外が処理される。
操作
DEST[31-0] ← Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31-0]);
DEST[63-32] ← Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[63-32]);
同等のインテルC/C++ コンパイラ組み込み関数
__m64 _mm_cvttps_pi32(__m128 a)
SIMD 浮動小数点例外
無効、精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#MF 未処理のx87 FPU 例外がある場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
0F 2C /r CVTTPS2PI mm, xmm/m64 切り捨てを使用して、xmm/m64 の下位の2 つの単精度
浮動小数点値をmm の2 つの符号付きダブルワード整
数に変換する。
3-167
命令セット・リファレンス
CVTTPS2PI?Convert with Truncation Packed Single-Precision
Floating-Point Values to Packed Doubleword Integers ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-168
命令セット・リファレンス
CVTTSD2SI?Convert with Truncation Scalar Double-Precision
Floating-Point Value to Signed Doubleword Integer
説明
ソース・オペランド（第2 オペランド）の1 つの倍精度浮動小数点値を、デスティネーション・オペ
ランド（第1 オペランド）の1 つの符号付きダブルワード整数に変換する。ソース・オペランドは、
XMM レジスタまたは64 ビットのメモリ・ロケーションである。デスティネーション・オペランド
は汎用レジスタである。ソース・オペランドがXMMレジスタの場合は、倍精度浮動小数点値はレジ
スタの下位クワッドワードに置かれる。
変換が不正確な場合は、切り捨てられた（ゼロに丸められる）結果が返される。変換の結果が符号
付きダブルワード整数の最大値より大きくなる場合は、整数不定値（80000000H）が返される。
操作
DEST[31-0] ← Convert_Double_Precision_Floating_Point_To_Integer_Truncate(SRC[63-0]);
同等のインテルC/C++ コンパイラ組み込み関数
int_mm_cvttsd_si32(__m128d a)
SIMD 浮動小数点例外
無効、精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
F2 0F 2C /r CVTTSD2SI r32, xmm/m64 切り捨てを使用して、xmm/m64 の1 つの倍精度浮動小
数点値をr32 の1 つの符号付きダブルワード整数に変換
する。
3-169
命令セット・リファレンス
CVTTSD2SI?Convert with Truncation Scalar Double-Precision
Floating-Point Value to Doubleword Integer ( 続き)
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-170
命令セット・リファレンス
CVTTSS2SI?Convert with Truncation Scalar Single-Precision Floating-
Point Value to Doubleword Integer
説明
ソース・オペランド（第2 オペランド）の1 つの単精度浮動小数点値を、デスティネーション・オペ
ランド（第1 オペランド）の1 つの符号付きダブルワード整数に変換する。ソース・オペランドは、
XMM レジスタまたは32 ビットのメモリ・ロケーションである。デスティネーション・オペランド
は汎用レジスタである。ソース・オペランドがXMMレジスタの場合は、単精度浮動小数点値はレジ
スタの最下位のダブルワードに置かれる。
変換が不正確な場合は、切り捨てられた（ゼロに丸められる）結果が返される。変換された結果が
符号付きダブルワード整数の最大値より大きい場合は、整数不定値(80000000H) が返される。
操作
DEST[31-0] ← Convert_Single_Precision_Floating_Point_To_Integer_Truncate(SRC[31-0]);
同等のインテルC/C++ コンパイラ組み込み関数
int_mm_cvttss_si32(__m128d a)
SIMD 浮動小数点例外
無効、精度。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
オペコード命令説明
F3 0F 2C /r CVTTSS2SI r32, xmm/m32 切り捨てを使用して、xmm/32 の1 つの単精度浮動小数
点値をr32 の1 つの符号付きダブルワード整数に変換す
る。
3-171
命令セット・リファレンス
CVTTSS2SI?Convert with Truncation Scalar Single-Precision Floating-
Point Value to Doubleword Integer ( 続き)
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-172
命令セット・リファレンス
CWD/CDQ?Convert Word to Doubleword/Convert Doubleword
to Quadword
説明
( オペランド・サイズにより) AXまたはEAXレジスタ内のオペランドのサイズを符号拡張によって
2 倍に拡張し、結果をそれぞれDX:AXまたはEDX:EAXレジスタにストアする。CWD命令は、AXレ
ジスタの値の符号( ビット15) をDXレジスタのすべてのビット位置にコピーする ( 詳細は『IA-32 イ
ンテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図7-6. を参照)。
CDQ命令は、EAXレジスタの値の符号 ( ビット31) をEDXレジスタのすべてのビット位置にコピー
する。
CWD 命令を使用すると、ワード除算の前にワードからダブルワードの被除数を作ることができ、
CDQ 命令を使用すると、ダブルワード除算の前にダブルワードからクワッドワードの被除数を作る
ことができる。
CWDおよびCDQニーモニックは同じオペコードを参照する。CWD命令はオペランド・サイズ属性
が16 のとき、またCDQ 命令はオペランド・サイズ属性が32 のときに使用することを目的としてい
る。一部のアセンブラには、CWDが使用されたときはオペランド・サイズを16 ビットに、またCDQ
が使用されたときは32 ビットに強制できるものがある。その他のアセンブラは、これらのニーモニッ
クを同義語 (CWD/CDQ) として取り扱い、どちらのニーモニックが使用されても、そのときのオペ
ランド・サイズ属性の設定を使用して変換対象の値のサイズを判定できる。
操作
IF OperandSize ← 16 (* CWD instruction *)
THEN DX ← SignExtend(AX);
ELSE (* OperandSize ← 32, CDQ instruction *)
EDX ← SignExtend(EAX);
FI;
影響を受けるフラグ
なし。
例外 ( すべての操作モード)
なし。
オペコード命令説明
99 CWD DX:AX ← AX の符号拡張
99 CDQ EDX:EAX ← EAX の符号拡張
3-173
命令セット・リファレンス
CWDE?Convert Word to Doubleword
「CBW/CWDE?Convert Byte to Word/Convert Word to Doubleword」を参照のこと。
3-174
命令セット・リファレンス
DAA?Decimal Adjust AL after Addition
説明
2 つのパックBCD値の和を調整して、パックBCD結果を作成する。ALレジスタは、この命令の暗黙
のソース兼デスティネーション・オペランドである。DAA命令は、2 桁のパックBCD値を加算 (2 進
加算) し、バイト結果をALレジスタにストアするADD命令の次に実行したときに限り有効である。
そこで、DAA 命令がAL レジスタの内容を調整して、正しい2 桁のパックBCD 結果にまとめる。10
進キャリーが検出された場合は、キャリーに従ってCF およびAFフラグがセットされる。
操作
IF (((AL AND 0FH) > 9) or AF ← 1)
THEN
AL ← AL + 6;
CF ← CF OR CarryFromLastAddition; (* CF OR carry from AL ← AL + 6 *)
AF ← 1;
ELSE
AF ← 0;
FI;
IF ((AL AND F0H) > 90H) or CF ← 1)
THEN
AL ← AL + 60H;
CF ← 1;
ELSE
CF ← 0;
FI;
例
ADD AL, BL Before: AL=79H BL=35H EFLAGS(OSZAPC)=XXXXXX
After: AL=AEH BL=35H EFLAGS(0SZAPC)=110000
DAA Before: AL=AEH BL=35H EFLAGS(OSZAPC)=110000
After: AL=14H BL=35H EFLAGS(0SZAPC)=X00111
DAA Before: AL=2EH BL=35H EFLAGS(OSZAPC)=110000
After: AL=04H BL=35H EFLAGS(0SZAPC)=X00101
影響を受けるフラグ
値の調整によって結果のどちらかの桁に10 進キャリーが生じた場合は、CFおよびAFフラグがセッ
トされる ( 上記の「操作」の項を参照)。SF、ZF、およびPF フラグが結果に従ってセットされる。OF
フラグは未定義。
オペコード命令説明
27 DAA 加算後にAL を10 進調整する。
3-175
命令セット・リファレンス
DAA?Decimal Adjust AL after Addition ( 続き)
例外 ( すべての操作モード)
なし。
3-176
命令セット・リファレンス
DAS?Decimal Adjust AL after Subtraction
説明
2 つのパックBCD値間の減算結果を調整して、パックBCD結果を作成する。ALレジスタは、この命
令の暗黙のソース兼デスティネーション・オペランドである。DAS命令は、一方の2 桁のパックBCD
値からもう一方の2 桁のパックBDC値を引き (2 進減算)、バイトの結果をALレジスタにストアする
SUB 命令の次に実行したときに限り有効である。そこで、DAS 命令がAL レジスタの内容を調整し
て、正しい2 桁のパックBCD結果にまとめる。10 進ボローが検出された場合は、ボローに従ってCF
およびAFフラグがセットされる。
操作
IF (AL AND 0FH) > 9 OR AF ← 1
THEN
AL ← AL ? 6;
CF ← CF OR BorrowFromLastSubtraction; (* CF OR borrow from AL ← AL ? 6 *)
AF ← 1;
ELSE AF ← 0;
FI;
IF ((AL > 9FH) or CF ← 1)
THEN
AL ← AL ? 60H;
CF ← 1;
ELSE CF ← 0;
FI;
例
SUB AL, BL Before: AL=35H BL=47H EFLAGS(OSZAPC)=XXXXXX
After: AL=EEH BL=47H EFLAGS(0SZAPC)=010111
DAA Before: AL=EEH BL=47H EFLAGS(OSZAPC)=010111
After: AL=88H BL=47H EFLAGS(0SZAPC)=X10111
影響を受けるフラグ
値の調整によって結果のどちらかの桁に10 進ボローが生じた場合は、CF およびAF フラグがセット
される ( 上記の「操作」の項を参照)。SF、ZF、およびPF フラグが結果に従ってセットされる。OF
フラグは未定義。
例外 ( すべての操作モード)
なし。
オペコード命令説明
2F DAS 減算後にAL を10 進調整する。
3-177
命令セット・リファレンス
DEC?Decrement by 1
説明
CF フラグの状態を変えないで、デスティネーション・オペランドから1 を引く ( デクリメントする
)。デスティネーション・オペランドには、レジスタまたはメモリ・ロケーションを使用できる。こ
の命令では、CF フラグの状態を変えることなくループ・カウンタを更新できる。(CF フラグを更新
するデクリメント操作を行うには、値1 の即値オペランドを使用してSUB命令を実行する。)
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
DEST ← DEST ? 1;
影響を受けるフラグ
CFフラグは影響を受けない。OF、SF、ZF、AF、およびPFフラグが結果に従ってセットされる。
保護モード例外
#GP(0) デスティネーション・オペランドが書き込み不可能なセグメントにある
場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
オペコード命令説明
FE /1 DEC r/m8 r/m8 を1 デクリメントする。
FF /1 DEC r/m16 r/m16 を1 デクリメントする。
FF /1 DEC r/m32 r/m32 を1 デクリメントする。
48+rw DEC r16 r16 を1 デクリメントする。
48+rd DEC r32 r32 を1 デクリメントする。
3-178
命令セット・リファレンス
DEC?Decrement by 1 ( 続き)
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-179
命令セット・リファレンス
DIV?Unsigned Divide
説明
AXレジスタ、DX:AXレジスタ、またはEDX:EAXレジスタ内の値 ( 被除数) をソース・オペランド
( 除数) で ( 符号なしで) 割り、結果をそれぞれAX (AH:AL)、DX:AX、またはEDX:EAXレジスタに
ストアする。ソース・オペランドには、汎用レジスタまたはメモリ・ロケーションを使用できる。
この命令の処理は、以下の表に示すように、オペランド・サイズ（被除数/ 除数) に依存する。
非整数の結果は0 に向かって切り捨てられる。剰余の絶対値は常に除数のそれより小さい。オーバフ
ローは、CFフラグではなく、#DE ( 除算エラー) 例外で示される。
オペコード命令説明
F6 /6 DIV r/m8 AX をr/m8 で符号なし除算する。結果は次のようにストア
される。
AL ←商、AH ←剰余
F7 /6 DIV r/m16 DX:AX をr/m16 で符号なし除算する。結果は次のようにス
トアされる。
AX ←商、DX ←剰余
F7 /6 DIV r/m32 EDX:EAX をr/m32 で符号なし除算する。結果は次のよう
にストアされる。
EAX ←商、EDX ←剰余
オペランド・サイズ被除数除数商剰余商の最大値
ワード/ バイトAX r/m8 AL AH 255
ダブルワード/ ワードDX:AX r/m16 AX DX 65,535
クワッドワード/ ダブルワードEDX:EAX r/m32 EAX EDX 232 ? 1
3-180
命令セット・リファレンス
DIV?Unsigned Divide ( 続き)
操作
IF SRC ← 0
THEN #DE; (* divide error *)
FI;
IF OpernadSize ← 8 (* word/byte operation *)
THEN
temp ← AX / SRC;
IF temp > FFH
THEN #DE; (* divide error *) ;
ELSE
AL ← temp;
AH ← AX MOD SRC;
FI;
ELSE
IF OperandSize ← 16 (* doubleword/word operation *)
THEN
temp ← DX:AX / SRC;
IF temp > FFFFH
THEN #DE; (* divide error *) ;
ELSE
AX ← temp;
DX ← DX:AX MOD SRC;
FI;
ELSE (* quadword/doubleword operation *)
temp ← EDX:EAX / SRC;
IF temp > FFFFFFFFH
THEN #DE; (* divide error *) ;
ELSE
EAX ← temp;
EDX ← EDX:EAX MOD SRC;
FI;
FI;
FI;
3-181
命令セット・リファレンス
DIV?Unsigned Divide ( 続き)
影響を受けるフラグ
CF、OF、SF、ZF、AF、およびPF フラグは未定義。
保護モード例外
#DE ソース・オペランド ( 除数) が0 の場合。
商が大きすぎて、指定されたレジスタにストアできない場合。
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#DE ソース・オペランド ( 除数) が0 の場合。
商が大きすぎて、指定されたレジスタにストアできない場合。
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#DE ソース・オペランド ( 除数) が0 の場合。
商が大きすぎて、指定されたレジスタにストアできない場合。
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-182
命令セット・リファレンス
DIVPD?Divide Packed Double-Precision Floating-Point Values
説明
デスティネーション・オペランド（第1 オペランド）の2 つのパックド倍精度浮動小数点値を、ソー
ス・オペランド（第2 オペランド）の2 つのパックド倍精度浮動小数点値でSIMD除算し、パックド
倍精度浮動小数点の結果をデスティネーション・オペランドに格納する。ソース・オペランドは、
XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・オペランド
はXMM レジスタである。倍精度浮動小数点値のSIMD 演算の図は、『IA-32 インテルR アーキテク
チャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図11-3. を参照のこと。
操作
DEST[63-0] ← DEST[63-0] / (SRC[63-0]);
DEST[127-64] ← DEST[127-64] / (SRC[127-64]);
同等のインテルC/C++ コンパイラ組み込み関数
DIVPD __m128 _mm_div_pd(__m128 a, __m128 b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、ゼロ除算、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
66 0F 5E /r DIVPD xmm1, xmm2/m128 xmm1 のパックド倍精度浮動小数点値をxmm2/m128 の
パックド倍精度浮動小数点値で割る。
3-183
命令セット・リファレンス
DIVPD?Divide Packed Double-Precision Floating-Point Values ( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-184
命令セット・リファレンス
DIVPS?Divide Packed Single-Precision Floating-Point Values
説明
デスティネーション・オペランド（第1 オペランド）の2 つのパックド単精度浮動小数点値を、ソー
ス・オペランド（第2 オペランド）の2 つのパックド単精度浮動小数点値でSIMD除算し、パックド
倍精度浮動小数点の結果をデスティネーション・オペランドに格納する。ソース・オペランドは、
XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・オペランド
はXMM レジスタである。単精度浮動小数点値のSIMD 演算の図は、『IA-32 インテルR アーキテク
チャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図10-5. を参照のこと。
操作
DEST[31-0] ← DEST[31-0] / (SRC[31-0]);
DEST[63-32] ← DEST[63-32] / (SRC[63-32]);
DEST[95-64] ← DEST[95-64] / (SRC[95-64]);
DEST[127-96] ← DEST[127-96] / (SRC[127-96]);
同等のインテルC/C++ コンパイラ組み込み関数
DIVPS __m128 _mm_div_ps(__m128 a, __m128 b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、ゼロによる除算、精度、デノーマル。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスが、CS、DS、ES、FS、またはGS
セグメントの範囲外の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
0F 5E /r DIVPS xmm1, xmm2/m128 xmm1 のパックド単精度浮動小数点値をxmm2/m128 の
パックド単精度浮動小数点値で割る。
3-185
命令セット・リファレンス
DIVPS?Divide Packed Single-Precision Floating-Point Values ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-186
命令セット・リファレンス
DIVSD?Divide Scalar Double-Precision Floating-Point Values
説明
デスティネーション・オペランド（第1 オペランド）の下位の倍精度浮動小数点値を、ソース・オペ
ランド（第2 オペランド）の下位の倍精度浮動小数点値で割り、結果の倍精度浮動小数点値をデス
ティネーション・オペランドに格納する。ソース・オペランドは、XMM レジスタまたは64 ビット
のメモリ・ロケーションである。デスティネーション・オペランドはXMM レジスタである。デス
ティネーション・オペランドの上位クワッドワードは変更されない。倍精度浮動小数点値のスカラ
演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上
巻』の図11-4. を参照のこと。
操作
DEST[63-0] ← DEST[63-0] / SRC[63-0];
* DEST[127-64] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
DIVSD __m128d _mm_div_sd (m128d a, m128d b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、ゼロ除算、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
F2 0F 5E /r DIVSD xmm1, xmm2/m64 xmm1 の下位の倍精度浮動小数点値をxmm2/mem64 の
下位の倍精度浮動小数点値で割る。
3-187
命令セット・リファレンス
DIVSD?Divide Scalar Double-Precision Floating-Point Values ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-188
命令セット・リファレンス
DIVSS?Divide Scalar Single-Precision Floating-Point Values
説明
デスティネーション・オペランド（第1 オペランド）の最下位の単精度浮動小数点値を、ソース・オ
ペランド（第2 オペランド）の最下位の単精度浮動小数点値で割り、結果の単精度浮動小数点値をデ
スティネーション・オペランドに格納する。ソース・オペランドは、XMMレジスタまたは32 ビッ
トのメモリ・ロケーションである。デスティネーション・オペランドはXMMレジスタである。デス
ティネーション・オペランドの上位3 つのダブルワードは変更されない。単精度浮動小数点値のスカ
ラ演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上
巻』の図10-6. を参照のこと。
操作
DEST[31-0] ← DEST[31-0] / SRC[31-0];
* DEST[127-32] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
DIVSS __m128 _mm_div_ss(__m128 a, __m128 b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、ゼロによる除算、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
F3 0F 5E /r DIVSS xmm1, xmm2/m32 xmm1 の下位の単精度浮動小数点値をxmm2/m32 の下
位の単精度浮動小数点値で割る。
3-189
命令セット・リファレンス
DIVSS?Divide Scalar Single-Precision Floating-Point Values ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-190
命令セット・リファレンス
EMMS?Empty MMX State
説明
x87 FPUタグ・ワードのすべてのタグの値を空（すべて1）に設定する。この操作によって、（MMX
テクノロジ・レジスタとして別名定義されている）x87 FPUレジスタは、x87 FPU浮動小数点命令で
使用可能としてマークされる(x87 FPU タグ・ワードのフォーマットについては、『IA-32 インテルR
アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図7-11. を参照のこと)。 そ
の他の (EMMS 命令以外の) すべてのMMXテクノロジ命令は、x87 FPU タグ・ワード内のすべての
タグを有効 ( すべて0) に設定する。
x87 浮動小数点命令を実行する可能性がある他のプロシージャまたはサブルーチンをコールする前
には、すべてのMMX テクノロジ・プロシージャまたはサブルーチンの終わりでEMMS 命令を使用
してMMXテクノロジの状態をクリアしなければならない。x87 FPUデータ・タグ・ワードがEMMS
命令によってリセットされる前にx87 浮動小数点命令がx87 FPUレジスタ・スタックのレジスタの1
つに値をロードした場合は、x87 浮動小数点レジスタ・スタック・オーバフローが発生する可能性が
あり、その結果、x87 浮動小数点例外が発生したり、誤った結果が生じることになる。
操作
x87FPUTagWord ← FFFFH;
同等のインテルC/C++ コンパイラ組み込み関数
void_mm_empty()
影響を受けるフラグ
なし。
保護モード例外
#UD CR0 のEM がセットされた場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のFPU 例外がある場合。
実アドレス・モード例外
保護モード例外と同じ。
仮想8086 モード例外
保護モード例外と同じ。
オペコード命令説明
0F 77 EMMS x87 FP タグ・ワードを空に設定する。
3-191
命令セット・リファレンス
ENTER?Make Stack Frame for Procedure Parameters
説明
プロシージャのためのスタック・フレームを作成する。第1 オペランド ( サイズ・オペランド) は、
スタック・フレームのサイズ ( すなわち、プロシージャのスタックに割り当てられる動的記憶域のバ
イト数) を指定する。第2 オペランド ( ネスティング・レベル・オペランド) は、プロシージャのレ
キシカル・ネスティング・レベル (0 から31 まで) を指定する。ネスティング・レベルによって、以
前のスタック・フレームから新しいスタック・フレームの「表示領域」にコピーされるスタック・
フレーム・ポインタの数が決まる。これらのオペランドはともに即値である。
スタック・サイズ属性によって、BP (16 ビット)、EBP (32 ビット) のどちらのレジスタで現在のフ
レーム・ポインタを指定するか、およびSP (16 ビット)、ESP (32 ビット) のどちらのレジスタでス
タック・ポインタを指定するかが決まる。
対をなすENTER 命令とLEAVE 命令は、ブロック構造言語をサポートするために設けられたもので
ある。( 使用されるときは) ENTER 命令は一般的にプロシージャ内の最初の命令であり、プロシー
ジャの新しいスタック・フレームをセットアップするために使用される。次に、LEAVE 命令をプロ
シージャの終わり (RET命令の直前) で使用して、スタック・フレームを開放する。
ネスティング・レベルが0 の場合は、プロセッサはフレーム・ポインタをEBP レジスタからスタッ
クにプッシュし、現在のスタック・ポインタをESP レジスタからEBP レジスタにコピーし、ESP レ
ジスタに現在のスタック・ポインタ値からサイズ・オペランドの値を引いた値をロードする。ネス
ティング・レベルが1 以上の場合は、プロセッサはスタック・ポインタを調整する前に追加フレー
ム・ポインタをスタックにプッシュする。それらの追加フレーム・ポインタによって、コール先プ
ロシージャにスタック上の他のネストされたフレームへのアクセス・ポイントが与えられる。ENTER
命令の処理の詳細については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・
マニュアル、上巻』第6 章の「ブロック構造言語でのプロシージャ・コール」を参照のこと。
オペコード命令説明
C8 iw 00 ENTER imm16,0 プロシージャのスタック・フレームを作成する。
C8 iw 01 ENTER imm16,1 プロシージャのネストされたスタック・フレームを作成す
る。
C8 iw ib ENTER imm16,imm8 プロシージャのネストされたスタック・フレームを作成す
る。
3-192
命令セット・リファレンス
ENTER?Make Stack Frame for Procedure Parameters ( 続き)
操作
NestingLevel ← NestingLevel MOD 32
IF StackSize ← 32
THEN
Push(EBP) ;
FrameTemp ← ESP;
ELSE (* StackSize ← 16*)
Push(BP);
FrameTemp ← SP;
FI;
IF NestingLevel ← 0
THEN GOTO CONTINUE;
FI;
IF (NestingLevel > 0)
FOR i ← 1 TO (NestingLevel ? 1)
DO
IF OperandSize ← 32
THEN
IF StackSize ← 32
EBP ← EBP ? 4;
Push([EBP]); (* doubleword push *)
ELSE (* StackSize ← 16*)
BP ← BP ? 4;
Push([BP]); (* doubleword push *)
FI;
ELSE (* OperandSize ← 16 *)
IF StackSize ← 32
THEN
EBP ← EBP ? 2;
Push([EBP]); (* word push *)
ELSE (* StackSize ← 16*)
BP ← BP ? 2;
Push([BP]); (* word push *)
FI;
FI;
OD;
IF OperandSize ← 32
THEN
Push(FrameTemp); (* doubleword push *)
ELSE (* OperandSize ← 16 *)
Push(FrameTemp); (* word push *)
FI;
GOTO CONTINUE;
3-193
命令セット・リファレンス
ENTER?Make Stack Frame for Procedure Parameters ( 続き)
FI;
CONTINUE:
IF StackSize ← 32
THEN
EBP ← FrameTemp
ESP ← EBP ? Size;
ELSE (* StackSize ← 16*)
BP ← FrameTemp
SP ← BP ? Size;
FI;
END;
;
影響を受けるフラグ
なし。
保護モード例外
#SS(0) SP またはESP レジスタの新しい値がスタック・セグメントの範囲外の
場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
実アドレス・モード例外
#SS(0) SP またはESP レジスタの新しい値がスタック・セグメントの範囲外の
場合。
仮想8086 モード例外
#SS(0) SP またはESP レジスタの新しい値がスタック・セグメントの範囲外の
場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-194
命令セット・リファレンス
F2XM1?Compute 2x?1
説明
2 のソース・オペランド乗という指数値から1 を引いた値を計算する。ソース・オペランドはST(0)
レジスタにあり、結果もST(0) にストアされる。ソース・オペランドの値は-1.0 から+1.0 までの範囲
でなければならない。ソース値がこの範囲外の場合は、結果は未定義になる。
以下の表に、オーバフローもアンダフローも発生しないものとして、さまざまなクラスの数の指数
値を計算したときに得られる結果を示す。
2 以外の値の累乗は、以下の式を使用して計算する。
xy ← 2(y ? log2x)
操作
ST(0) ← (2ST(0) ? 1);
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、またはそのフォーマットがサ
ポートされていない場合。
#D 結果がデノーマル値である場合。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
オペコード命令説明
D9 F0 F2XM1 ST(0) を (2ST(0) - 1) で置き換える。
ST(0) SRC ST(0) DEST
?1.0 〜 ?0 ?0.5 〜 ?0
?0 ?0
+0 +0
+0 〜 +1.0 +0 〜 1.0
3-195
命令セット・リファレンス
F2XM1?Compute 2x?1 ( 続き)
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-196
命令セット・リファレンス
FABS?Absolute Value
説明
ST(0) の符号ビットをクリアして、オペランドの絶対値を作成する。以下の表に、さまざまなクラス
の数の絶対値を作成したときに得られる結果を示す。
注:
F 有限浮動小数点値を示す。
操作
ST(0) ← |ST(0)|
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされ、発生しな
かった場合は0 にクリアされる。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
オペコード命令説明
D9 E1 FABS ST をその絶対値で置き換える。
ST(0) SRC ST(0) DEST
?∞ +∞
?F +F
?0 +0
+0 +0
+F +F
+∞ +∞
NaN NaN
3-197
命令セット・リファレンス
FABS?Absolute Value
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-198
命令セット・リファレンス
FADD/FADDP/FIADD?Add
説明
ソース・オペランドをデスティネーション・オペランドに加え、結果をデスティネーション・ロケー
ションにストアする。デスティネーション・オペランドは常にFPU レジスタである。ソース・オペ
ランドには、レジスタまたはメモリ・ロケーションを使用できる。メモリ内のソース・オペランド
には、単精度浮動小数点、倍精度浮動小数点、ワード整数、またはダブルワード整数のフォーマッ
トを使用できる。
この命令のオペランドなしバージョンでは、ST(0) レジスタの内容をST(1) レジスタに加える。1 オペ
ランド・バージョンでは、メモリ・ロケーションの内容 ( 浮動小数点値または整数値) をST(0) レジ
スタに加える。2 オペランド・バージョンでは、ST(0) レジスタの内容をST(i) レジスタに、またはそ
の逆に加算する。ST(0) の値は、以下のコーディングによって2 倍にすることができる。
FADD ST(0), ST(0);
FADDP 命令は、結果をストアした後に、追加操作としてFPUレジスタ・スタックをポップする。レ
ジスタ・スタックをポップするため、プロセッサはST(0) レジスタを空としてマークし、スタック・
ポインタ (TOP) を1 インクリメントする。( 浮動小数点加算命令のオペランドなしバージョンでは、
常にレジスタ・スタックのポップを伴う。一部のアセンブラでは、この命令のニーモニックはFADDP
ではなくFADDになっている。)
FIADD 命令は、整数のソース・オペランドを拡張倍精度浮動小数点フォーマットに変換してから加
算を行う。
次ページの表に、オーバフローもアンダフローも発生しないものとして、さまざまなクラスの数値
を加算したときに得られる結果を示す。
符号が反対の2 つのオペランドの和が0 のときは、- ∞への丸めモードの場合を除いて、結果は+0 で
ある。- ∞方向への丸めモードの場合は、結果は-0 である。ソース・オペランドは、整数0 のときは
+0 として取り扱われる。
両方のオペランドが同じ符号で無限大のときは、結果は予期される符号の∞である。両方のオペラ
ンドが反対符号で無限大の場合は、無効操作例外が発生する。
オペコード命令説明
D8 /0 FADD m32fp m32fp をST(0) に加え、結果をST(0) にストアする。
DC /0 FADD m64fp m64fp をST(0) に加え、結果をST(0) にストアする。
D8 C0+i FADD ST(0), ST(i) ST(0) をST(i) に加え、結果をST(0) にストアする。
DC C0+i FADD ST(i), ST(0) ST(i) をST(0) に加え、結果をST(i) にストアする。
DE C0+i FADDP ST(i), ST(0) ST(0) をST(i) に加え、結果をST(i) にストアし、レジス
タ・スタックをポップする。
DE C1 FADDP ST(0) をST(1) に加え、結果をST(1) にストアし、レジス
タ・スタックをポップする。
DA /0 FIADD m32int m32int をST(0) に加え、結果をST(0) にストアする。
DE /0 FIADD m16int m16int をST(0) に加え、結果をST(0) にストアする。
3-199
命令セット・リファレンス
FADD/FADDP/FIADD?Add ( 続き)
.
注:
F 有限実数を示す。
I 整数を示す。
* 浮動小数点無効算術オペランド例外 (#IA) を示す。
操作
IF instruction is FIADD
THEN
DEST ← DEST + ConvertToDoubleExtendedPrecisionFP(SRC);
ELSE (* source operand is floating-point value *)
DEST ← DEST + SRC;
FI;
IF instruction ← FADDP
THEN
PopRegisterStack;
FI;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA オペランドがSNaN 値であるか、またはそのフォーマットがサポートさ
れていない場合。
両方のオペランドの符号が反対で、絶対値が無限大の場合。
DEST
-∞ ?F ?0 +0 +F +∞ NaN
-∞ -∞ -∞ -∞ -∞ -∞ * NaN
?F or ?I -∞ ?F SRC SRC ±F or ±0 +∞ NaN
SRC ?0 -∞ DEST ?0 ±0 DEST +∞ NaN
+0 -∞ DEST ±0 +0 DEST +∞ NaN
+F or +I -∞ ±F or ±0 SRC SRC +F +∞ NaN
+∞ * +∞ +∞ +∞ +∞ +∞ NaN
NaN NaN NaN NaN NaN NaN NaN NaN
3-200
命令セット・リファレンス
FADD/FADDP/FIADD?Add ( 続き)
#D ソース・オペランドがデノーマル値である場合。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#O 結果が大きすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-201
命令セット・リファレンス
FBLD?Load Binary Coded Decimal
説明
BCDのソース・オペランドを拡張倍精度浮動小数点フォーマットに変換し、変換結果の値をFPUス
タックにプッシュする。ソース・オペランドは丸めエラーなしにロードされる。ソース・オペラン
ドの符号は、-0 の場合の符号を含めて保持される。
パックBCD数字は0 から9 までの範囲とみなされる。すなわち、この命令は無効な数字(AHからFH)
の有無をチェックしない。無効なコードをロードしようとすると、結果は未定義になる。
操作
TOP ← TOP ? 1;
ST(0) ← ConvertToDoubleExtendedPrecisionFP(SRC);
FPU 影響を受けるフラグ
C1 スタック・オーバフローが発生した場合は1 にセットされ、発生しな
かった場合は0 にクリアされる。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・オーバフローが発生した場合。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
オペコード命令説明
DF /4 FBLD m80 dec BCD 値を浮動小数点に変換し、FPU スタックにプッシュ
する。
3-202
命令セット・リファレンス
FBLD?Load Binary Coded Decimal ( 続き)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-203
命令セット・リファレンス
FBSTP?Store BCD Integer and Pop
説明
ST(0) レジスタの値を18 桁のパックBCD 整数に変換し、結果をデスティネーション・オペランドに
ストアし、レジスタ・スタックをポップする。ソース値は、非整数値の場合、FPU制御ワードのRC
フィールドによって指定される丸めモードに従って丸められる。レジスタ・スタックをポップする
ため、プロセッサはST(0) レジスタを空としてマークし、スタック・ポインタ (TOP) を1 インクリメ
ントする。
デスティネーション・オペランドは、デスティネーション値の最初のバイトがストアされるアドレ
スを指定する。結果のBCD値は、 ( その符号値を含めて) 10 バイトのメモリ空間を必要とする。
以下の表に、さまざまなクラスのパックBCDフォーマットの数をストアしたときに得られる結果を
示す。
注:
F 有限浮動小数点値を示す。
D パックBCD 数を示す。
* 浮動小数点無効操作 (#IA) 例外を示す。
** 丸めモードによって、± 0 または± 1。
ソース値が大きすぎてデスティネーション・フォーマットで表現できない場合、無効操作例外がマ
スクされていなければ、無効操作例外が発生し、デスティネーション・オペランドに値はストアさ
れない。無効操作例外がマスクされている場合は、パックBCDの未定義値がメモリにストアされる。
ソース値がクワイエットNaNの場合は、無効操作例外が発生する。通常、クワイエットNaNs では、
この例外は発生しない。
オペコード命令説明
DF /6 FBSTP m80bcd ST(0) をm80bcd にストアし、ST(0) をポップする。
ST(0) DEST
-∞ *
?F < ?1 ?D
?1 < ?F < ?0 **
?0 ?0
+0 +0
+0 < +F < +1 **
+F > +1 +D
+∞ *
NaN *
3-204
命令セット・リファレンス
FBSTP?Store BCD Integer and Pop ( 続き)
操作
DEST ← BCD(ST(0));
PopRegisterStack;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 = 切り上
げなし、1 ← 切り上げ。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドが空であるか、内容がNaN または±∞、あるいは
サポートされていないフォーマットであるか、または内容値が18 BCD
桁の長さを超えている場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#GP(0) セグメント・レジスタに書き込み不可能なセグメントを指示先とするセ
グメント・セレクタがロードされようとした場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
3-205
命令セット・リファレンス
FBSTP?Store BCD Integer and Pop ( 続き)
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-206
命令セット・リファレンス
FCHS?Change Sign
説明
ST(0) の符号を反転する。この操作は、正の値を同じ絶対値の負の値に、またはその逆に変換する。
以下の表に、さまざまなクラスの数の符号を反転したときに得られる結果を示す。
注:
F 有限浮動小数点値を示す。
操作
SignBit(ST(0)) ← NOT (SignBit(ST(0)))
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされ、発生しな
かった場合は0 にクリアされる。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
オペコード命令説明
D9 E0 FCHS ST(0) の符号を反転する。
ST(0) SRC ST(0) DEST
?∞ +∞
?F +F
?0 +0
+0 ?0
+F ?F
+∞ ?∞
NaN NaN
3-207
命令セット・リファレンス
FCHS?Change Sign ( 続き)
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-208
命令セット・リファレンス
FCLEX/FNCLEX?Clear Exceptions
注:
* 下記の「IA-32 アーキテクチャにおける互換性」の項を参照。
説明
これらの命令は、FPU ステータス・ワード内の浮動小数点例外フラグ (PE、UE、OE、ZE、DE、お
よびIE)、例外サマリ・ステータス・フラグ (ES)、スタック・フォルト・フラグ (SF)、およびビジー・
フラグ (B) をクリアする。FCLEX 命令は、未処理のマスクされていない浮動小数点例外がないかど
うかをチェックしてから各例外フラグをクリアする。FNCLEX命令はこのチェックを行わない。
FCLEX命令の場合、アセンブラは2 つの命令を発行する( つまり、FWAIT 命令に続けてFNCLEX 命
令)。プロセッサは、これらの命令をそれぞれ個別に実行する。これらの命令のいずれかで例外が発
生すると、セーブEIP は、例外を発生させた命令をポイントする。
IA-32 アーキテクチャにおける互換性
Pentium プロセッサまたはIntel486 プロセッサをMS-DOS互換モードで動作させたときは、( 通常の状
況下で) 実行される前にFNCLEX 命令に割り込みをかけて、未処理のFPU 例外を処理させることが
できる。それらの状況については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』付録D の「非同期型命令のウインドウ内のx87 FPU 割り込み」の説明を参
照のこと。Pentium 4 プロセッサまたはP6 ファミリ・プロセッサでは、FNCLEX命令にこの方法では
割り込みをかけられない。
この命令は、x87 FPU 浮動小数点例外フラグにのみ影響を与える。この命令は、MXCSRレジスタの
SIMD浮動小数点例外フラグには影響を与えない。
操作
FPUStatusWord[0..7] ← 0;
FPUStatusWord[15] ← 0;
FPU 影響を受けるフラグ
FPU ステータス・ワード内のPE、UE、OE、ZE、DE、IE、ES、SF、およびB フラグがクリアされ
る。C0、C1、C2、およびC3 フラグは未定義。
浮動小数点例外
なし。
オペコード命令説明
9B DB E2 FCLEX 未処理のマスクされていない浮動小数点例外の有無を
チェックした後、浮動小数点例外フラグをクリアする。
DB E2 FNCLEX* 未処理のマスクされていない浮動小数点例外の有無を
チェックしないで、浮動小数点例外フラグをクリアする。
3-209
命令セット・リファレンス
FCLEX/FNCLEX?Clear Exceptions ( 続き)
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-210
命令セット・リファレンス
FCMOVcc?Floating-Point Conditional Move
説明
EFLAGSレジスタ内のステータス・フラグをテストし、与えられたテスト条件が真の場合、ソース・
オペランド ( 第2 オペランド) をデスティネーション・オペランド ( 第1 オペランド) に転送する。各
ニーモニックの条件は、上記の「説明」の欄、および『IA-32 インテルR アーキテクチャ・ソフト
ウェア・デベロッパーズ・マニュアル、上巻』の表7-4. に示してある。ソース・オペランドは常に
ST(i) レジスタにあり、デスティネーション・オペランドは常にST(0) である。
FCMOVcc 命令は小さいIF 構造を最適化する場合に有用である。これらの命令は、さらにIF 操作の
分岐にかかわるオーバヘッドおよびプロセッサによる分岐の予測ミスを排除する上でも有効であ
る。
プロセッサによっては、FCMOVcc 命令をサポートしていないものがある。ソフトウェアで、CPUID
命令 ( 本章の「COMISS?Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS」
を参照) を使用してプロセッサの機能情報を調べることにより、FCMOVcc 命令がサポートされてい
るかどうかを確認できる。CMOV およびFPU の両機能ビットがセットされていれば、FCMOVcc 命
令がサポートされている。
IA-32 アーキテクチャにおける互換性
FCMOVcc 命令は、Pentium Pro プロセッサ・ファミリでIA-32 アーキテクチャに導入され、それより
以前のIA-32 プロセッサには備えられていない。
操作
IF condition TRUE
ST(0) ← ST(i)
FI;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
C0、C2、C3 未定義。
オペコード命令説明
DA C0+i FCMOVB ST(0), ST(i) より下 (CF=1) の場合転送する。
DA C8+i FCMOVE ST(0), ST(i) 等しい (ZF=1) 場合転送する。
DA D0+i FCMOVBE ST(0), ST(i) より下か等しい (CF=1 またはZF=1) 場合転送する。
DA D8+i FCMOVU ST(0), ST(i) 順序付けなし (PF=1) の場合転送する。
DB C0+i FCMOVNB ST(0), ST(i) より下でない (CF=0) 場合転送する。
DB C8+i FCMOVNE ST(0), ST(i) 等しくない (ZF=0) 場合転送する。
DB D0+i FCMOVNBE ST(0), ST(i) より下でなく等しくない (CF=0 およびZF=0) 場合転送する。
DB D8+i FCMOVNU ST(0), ST(i) 順序付け (PF=0) の場合転送する。
3-211
命令セット・リファレンス
FCMOVcc?Floating-Point Conditional Move ( 続き)
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
Integer 影響を受けるフラグ
なし。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-212
命令セット・リファレンス
FCOM/FCOMP/FCOMPP?Compare Floating Point Values
説明
ST(0) レジスタの内容とソース値を比較し、結果に従ってFPUステータス・ワード内の条件コード・
フラグC0、C2、およびC3 をセットする ( 下記の表を参照)。ソース・オペランドには、データ・レ
ジスタまたはメモリ・ロケーションを使用できる。ソース・オペランドを指定しない場合は、ST(0)
の値はST(1) の値と比較される。ゼロの符号は無視される。すなわち、-0.0 ← +0.0 である。
注:
* マスクされていない無効算術オペランド (#IA) 例外が発生しても、フラグはセットされない。
この命令は比較対象の両数値のクラスを調べる ( 本章の「FXAM?Examine」を参照)。いずれかのオ
ペランドがNaN であるか、またはそのフォーマットがサポートされていない場合は、無効算術オペ
ランド例外 (#IA) が発生し、さらに、その例外がマスクされている場合は、条件フラグが「順序付け
なし」に設定される。無効算術オペランド例外がマスクされていない場合は、条件コード・フラグ
はセットされない。
FCOMP 命令は比較操作の後にレジスタ・スタックをポップし、FCOMPP 命令は比較操作の後にレジ
スタ・スタックを2 回ポップする。レジスタ・スタックをポップするため、プロセッサはST(0) レジ
スタを空としてマークし、スタック・ポインタ (TOP) を1 インクリメントする。
FCOM命令が行う操作は、QNaNオペランドの取り扱い方を除いてFUCOM命令のそれと同じである。
FCOM命令は、一方または両方のオペランドがNaN 値であるか、またはそれらのフォーマットがサ
ポートされていないときは、無効算術オペランド例外(#IA) を発生する。FUCOM命令が行う操作は、
オペランドがQNaN 値であっても無効算術オペランド例外を発生しない点を除いてFCOMの操作と
同じである。
オペコード命令説明
D8 /2 FCOM m32fp ST(0) をm32fp と比較する。
DC /2 FCOM m64fp ST(0) をm64fp と比較する。
D8 D0+i FCOM ST(i) ST(0) をST(i) と比較する。
D8 D1 FCOM ST(0) をST(1) と比較する。
D8 /3 FCOMP m32fp ST(0) をm32fp と比較し、レジスタ・スタックをポップする。
DC /3 FCOMP m64fp ST(0) をm64fp と比較し、レジスタ・スタックをポップする。
D8 D8+i FCOMP ST(i) ST(0) をST(i) と比較し、レジスタ・スタックをポップする。
D8 D9 FCOMP ST(0) をST(1) と比較し、レジスタ・スタックをポップする。
DE D9 FCOMPP ST(0) をST(1) と比較し、レジスタ・スタックを2 回ポップする。
条件C3 C2 C0
ST(0) > SRC 0 0 0
ST(0) < SRC 0 0 1
ST(0) ← SRC 1 0 0
順序付けなし* 1 1 1
3-213
命令セット・リファレンス
FCOM/FCOMP/FCOMPP?Compare Floating Point Values ( 続き)
操作
CASE (relation of operands) OF
ST > SRC: C3, C2, C0 ← 000;
ST < SRC: C3, C2, C0 ← 001;
ST ← SRC: C3, C2, C0 ← 100;
ESAC;
IF ST(0) or SRC ← NaN or unsupported format
THEN
#IA
IF FPUControlWord.IM ← 1
THEN
C3, C2, C0 ← 111;
FI;
FI;
IF instruction ← FCOMP
THEN
PopRegisterStack;
FI;
IF instruction ← FCOMPP
THEN
PopRegisterStack;
PopRegisterStack;
FI;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされ、発生しな
かった場合は0 にクリアされる。
C0、C2、C3 前ページの表を参照。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA 一方または両方のオペランドがNaN 値であるか、またはそれらのフォー
マットがサポートされていない場合。
レジスタが空にマークされる場合。
#D 一方または両方のオペランドがデノーマル値である場合。
3-214
命令セット・リファレンス
FCOM/FCOMP/FCOMPP?Compare Floating Point Values ( 続き)
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。.
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-215
命令セット・リファレンス
FCOMI/FCOMIP/ FUCOMI/FUCOMIP?Compare Floating Point Values
and Set EFLAGS
説明
レジスタST(0) とST(i) の内容を比較し、結果に従ってEFLAGS レジスタ内のステータス・フラグZF、
PF、およびCF をセットする ( 以下の表を参照)。これらの命令の比較では、ゼロの符号は無視され
る。すなわち、-0.0 ← +0.0 である。
注:
*　マスクされていない無効算術オペランド(#IA) 例外が生成された場合、フラグはセットされない。
FCOMI/FCOMIP 命令が行う操作は、QNaN オペランドの取り扱い方を除いてFUCOMI/FUCOMIP 命
令のそれと同じである。FCOMI/FCOMIP 命令は、一方または両方のオペランドがNaN値 (SNaNまた
はQNaN) であるか、またはそれらのフォーマットがサポートされていないときは、ステータス・フ
ラグを「順序付けなし」に設定し、無効算術オペランド例外 (#IA) を発生する。
FUCOMI/FUCOMIP命令が行う操作は、オペランドがQNaN値であっても無効算術オペランド例外を
発生しない点を除いてFCOMI/FCOMIP命令の操作と同じである。順序付けなし比較の詳細について
は、本章の「FXAM?Examine」を参照のこと。
無効操作例外がマスクされていない場合は、無効算術オペランド例外が発生しても、ステータス・
フラグはセットされない。
FCOMIPおよびFUCOMIP 命令は、比較操作の後にさらにレジスタ・スタックをポップする。レジス
タ・スタックをポップするため、プロセッサはST(0) レジスタを空としてマークし、スタック・ポイ
ンタ (TOP) を1 インクリメントする。
オペコード命令説明
DB F0+i FCOMI ST, ST(i) ST(0) をST(i) と比較し、結果に従ってステータス・フラグ
をセットする。
DF F0+i FCOMIP ST, ST(i) ST(0) をST(i) と比較し、結果に従ってステータス・フラグ
をセットし、レジスタ・スタックをポップする。
DB E8+i FUCOMI ST, ST(i) ST(0) をST(i) と比較し、順序付け値の有無をチェックし、
結果に従ってステータス・フラグをセットする。
DF E8+i FUCOMIP ST, ST(i) ST(0) をST(i) と比較し、順序付け値の有無をチェックし、
結果に従ってステータス・フラグをセットし、レジスタ・
スタックをポップする。
比較結果ZF PF CF
ST0 > ST(i) 0 0 0
ST0 < ST(i) 0 0 1
ST0 ← ST(i) 1 0 0
順序付けなし* 1 1 1
3-216
命令セット・リファレンス
FCOMI/FCOMIP/ FUCOMI/FUCOMIP?Compare Floating Point Values
and Set EFLAGS ( 続き)
IA-32 アーキテクチャにおける互換性
FCOMI/FCOMIP/FUCOMI/FUCOMIP 命令は、Pentium Pro プロセッサ・ファミリでIA-32 アーキテク
チャに導入され、それより以前のIA-32 プロセッサには備えられていない。
操作
CASE (relation of operands) OF
ST(0) > ST(i): ZF, PF, CF ← 000;
ST(0) < ST(i): ZF, PF, CF ← 001;
ST(0) ← ST(i): ZF, PF, CF ← 100;
ESAC;
IF instruction is FCOMI or FCOMIP
THEN
IF ST(0) or ST(i) ← NaN or unsupported format
THEN
#IA
IF FPUControlWord.IM ← 1
THEN
ZF, PF, CF ← 111;
FI;
FI;
FI;
IF instruction is FUCOMI or FUCOMIP
THEN
IF ST(0) or ST(i) ← QNaN, but not SNaN or unsupported format
THEN
ZF, PF, CF ← 111;
ELSE (* ST(0) or ST(i) is SNaN or unsupported format *)
#IA;
IF FPUControlWord.IM ← 1
THEN
ZF, PF, CF ← 111;
FI;
FI;
FI;
IF instruction is FCOMIP or FUCOMIP
THEN
PopRegisterStack;
FI;
3-217
命令セット・リファレンス
FCOMI/FCOMIP/ FUCOMI/FUCOMIP?Compare Floating Point Values
and Set EFLAGS ( 続き)
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされ、発生しな
かった場合は0 にクリアされる。
C0、C2、C3 影響を受けない。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA (FCOMI またはFCOMIP 命令) 一方または両方のオペランドがNaN 値で
あるか、またはそれらのフォーマットがサポートされていない場合。
(FUCOMI またはFUCOMIP 命令) 一方または両方のオペランドがSNaN
値である ( ただし、QNaN ではない) か、またはそれらのフォーマット
が定義されていない場合。QNaN 値が検出されても、無効オペランド例
外は発生しない。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-218
命令セット・リファレンス
FCOS?Cosine
説明
ST(0) レジスタ内のソース・オペランドの余弦を計算し、結果をST(0) にストアする。ソース・オペ
ランドはラジアン単位の±263の範囲内の値でなければならない。以下の表に、オーバフローもアン
ダフローも発生しないものとして、さまざまなクラスの数の余弦を計算したときに得られる結果を
示す。
注:
F 有限浮動小数点値を示す。
* 浮動小数点無効算術オペランド (#IA) 例外を示す。
ソース・オペランドが許容可能な範囲を超えた場合は、FPUステータス・ワードのC2 フラグがセッ
トされ、ST(0) レジスタの値は以前のまま変わらない。この命令は、ソース・オペランドが範囲外で
も例外を発生しない。プログラムの責任で、C2 フラグを調べて範囲外条件の有無を確認しなければ
ならない。± 263 の範囲を超えるソース値は、2π の適切な整数倍を引くか、または除数を2π とし
てFPREM命令を使用して、命令の許容範囲内に縮小することができる。そのような縮小のための減
算に使用する適切なπの値については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッ
パーズ・マニュアル、上巻』第8 章の「π」の説明を参照のこと。
操作
IF |ST(0)| < 263
THEN
C2 ← 0;
ST(0) ← cosine(ST(0));
ELSE (*source operand is out-of-range *)
C2 ← 1;
FI;
オペコード命令説明
D9 FF FCOS ST(0) をその余弦で置き換える。
ST(0) SRC ST(0) DEST
?∞ *
?F ?1 〜 +1
?0 +1
+0 +1
+F ?1 〜 +1
+∞ *
NaN NaN
3-219
命令セット・リファレンス
FCOS?Cosine ( 続き)
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C2 が1 の場合は未定義。
C2 ソース・オペランドが± 263 の範囲外の場合は1 にセットされる。範囲
内の場合は0 にクリアされる。
C0, C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値または∞であるか、そのフォーマットが
サポートされていない場合。
#D 結果がデノーマル値である場合。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-220
命令セット・リファレンス
FDECSTP?Decrement Stack-Top Pointer
説明
FPUステータス・ワードのTOP フィールドから1 を引く ( すなわち、スタック・トップ・ポインタを
デクリメントする)。TOP フィールドは、内容が0 の場合は7 に設定される。この命令の働きは、ス
タックを1 レジスタ位置回転させることである。FPUデータ・レジスタおよびタグ・レジスタの内容
は影響を受けない。
操作
IF TOP ← 0
THEN TOP ← 7;
ELSE TOP ← TOP ? 1;
FI;
FPU 影響を受けるフラグ
C1 0 にセットされる。そうでない場合は0 にクリアされる。
C0、C2、C3 未定義。
浮動小数点例外
なし。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
オペコード命令説明
D9 F6 FDECSTP FPU ステータス・ワードのTOP フィールドをデクリメン
トする。
3-221
命令セット・リファレンス
FDIV/FDIVP/FIDIV?Divide
説明
デスティネーション・オペランドをソース・オペランドで割り、結果をデスティネーション・ロケー
ションにストアする。デスティネーション・オペランド ( 被除数) は常にFPUレジスタである。ソー
ス・オペランド ( 除数) には、レジスタまたはメモリ・ロケーションを使用できる。メモリ内のソー
ス・オペランドには、単精度浮動小数点、倍精度浮動小数点、ワード整数、またはダブルワード整
数のフォーマットを使用できる。
この命令のオペランドなしバージョンでは、ST(1) レジスタの内容をST(0) レジスタの内容で割る。1
オペランド・バージョンでは、ST(0) レジスタの内容をメモリ・ロケーションの内容 ( 浮動小数点値
または整数値) で割る。2 オペランド・バージョンでは、ST(0) レジスタの内容をST(i) レジスタの内
容で割るか、またはその逆の除算を行う。
FDIVP命令は、除算結果をストアした後に、追加操作としてFPUレジスタ・スタックをポップする。
レジスタ・スタックをポップするため、プロセッサはST(0) レジスタを空としてマークし、スタッ
ク・ポインタ (TOP) を1 インクリメントする。これらの浮動小数点除算命令のオペランドなしバー
ジョンでは、常にレジスタ・スタックのポップを伴う。一部のアセンブラでは、この命令のニーモ
ニックはFDIVP ではなくFDIV になっている。
FIDIV命令は、整数のソース・オペランドを拡張倍精度浮動小数点フォーマットに変換してから除算
を行う。ソース・オペランドは、整数0 のときは+0 として取り扱われる。
ゼロによる除算例外 (#Z) が発生しても、それがマスクされていない場合は結果はストアされない。
この例外がマスクされていた場合は、正しい符号の∞がデスティネーション・オペランドにストア
される。
以下の表に、オーバフローもアンダフローも発生しないものとして、さまざまなクラスの数の除算
を行ったときに得られる結果を示す。
オペコード命令説明
D8 /6 FDIV m32fp ST(0) をm32fp で割り、結果をST(0) にストアする。
DC /6 FDIV m64fp ST(0) をm64fp で割り、結果をST(0) にストアする。
D8 F0+i FDIV ST(0), ST(i) ST(0) をST(i) で割り、結果をST(0) にストアする。
DC F8+i FDIV ST(i), ST(0) ST(i) をST(0) で割り、結果をST(i) にストアする。
DE F8+i FDIVP ST(i), ST(0) ST(i) をST(0) で割り、結果をST(i) にストアし、レジス
タ・スタックをポップする。
DE F9 FDIVP ST(1) をST(0) で割り、結果をST(1) にストアし、レジス
タ・スタックをポップする。
DA /6 FIDIV m32int ST(0) をm32int で割り、結果をST(0) にストアする。
DE /6 FIDIV m16int ST(0) をm64int で割り、結果をST(0) にストアする。
3-222
命令セット・リファレンス
FDIV/FDIVP/FIDIV?Divide ( 続き)
注:
F 有限浮動小数点値を示す。
I 整数を示す。
* 浮動小数点無効算術オペランド (#IA) 例外を示す。
** 浮動小数点0 による除算 (#Z) 例外を示す。
操作
IF SRC = 0
THEN
#Z
ELSE
IF instruction is FIDIV
THEN
DEST ← DEST / ConvertToDoubleExtendedPrecisionFP(SRC);
ELSE (* source operand is floating-point value *)
DEST ← DEST / SRC;
FI;
FI;
IF instruction ← FDIVP
THEN
PopRegisterStack
FI;
DEST
-∞ ?F ?0 +0 +F +∞ NaN
-∞ * +0 +0 ?0 ?0 * NaN
?F +∞ +F +0 ?0 ?F -∞ NaN
?I +∞ +F +0 ?0 ?F -∞ NaN
SRC ?0 +∞ ** * * ** -∞ NaN
+0 -∞ ** * * ** +∞ NaN
+I -∞ ?F ?0 +0 +F +∞ NaN
+F -∞ ?F ?0 +0 +F +∞ NaN
+∞ * ?0 ?0 +0 +0 * NaN
NaN NaN NaN NaN NaN NaN NaN NaN
3-223
命令セット・リファレンス
FDIV/FDIVP/FIDIV?Divide ( 続き)
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA オペランドがSNaN 値であるか、またはそのフォーマットがサポートさ
れていない場合。
±∞ / ±∞、± 0/ ± 0 の場合。
#D 結果がデノーマル値である場合。
#Z DEST/ ± 0 の場合。ただし、DEST は± 0 に等しくない。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#O 結果が大きすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
3-224
命令セット・リファレンス
FDIV/FDIVP/FIDIV?Divide ( 続き)
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-225
命令セット・リファレンス
FDIVR/FDIVRP/FIDIVR?Reverse Divide
説明
ソース・オペランドをデスティネーション・オペランドで割り、結果をデスティネーション・ロケー
ションにストアする。デスティネーション・オペランド ( 除数) は常にFPU レジスタである。ソー
ス・オペランド ( 被除数) には、レジスタまたはメモリ・ロケーションを使用できる。メモリ内の
ソース・オペランドには、単精度浮動小数点、倍精度浮動小数点、ワード整数、またはダブルワー
ド整数のフォーマットを使用できる。
これらの命令は、それぞれFDIV、FDIVP、およびFIDIV命令の逆の演算を行う。これらは、コーディ
ング効率の向上をサポートする目的で設けられたものである。
これらの命令のオペランドなしバージョンでは、ST(0) レジスタの内容をST(1) レジスタの内容で割
る。1 オペランド・バージョンでは、メモリ・ロケーションの内容 ( 浮動小数点値または整数値) を
ST(0) レジスタの内容で割る。2 オペランド・バージョンでは、ST(i) レジスタの内容をST(0) レジス
タの内容で割るか、またはその逆の除算を行う。
FDIVRP 命令は、除算結果をストアした後に、追加操作としてFPU レジスタ・スタックをポップす
る。レジスタ・スタックをポップするため、プロセッサはST(0) レジスタを空としてマークし、ス
タック・ポインタ (TOP) を1 インクリメントする。これらの浮動小数点除算命令のオペランドなし
バージョンでは、常にレジスタ・スタックのポップを伴う。一部のアセンブラでは、この命令のニー
モニックはFDIVRPではなくFDIVRになっている。
FIDIVR命令は、整数のソース・オペランドを拡張倍精度浮動小数点フォーマットに変換してから除
算を行う。
ゼロによる除算例外 (#Z) が発生しても、それがマスクされていない場合は結果はストアされない。
この例外がマスクされていた場合は、正しい符号の∞がデスティネーション・オペランドにストア
される。
以下の表に、オーバフローもアンダフローも発生しないものとして、さまざまなクラスの数の除算
を行ったときに得られる結果を示す。
オペコード命令説明
D8 /7 FDIVR m32fp m32fp をST(0) で割り、結果をST(0) にストアする。
DC /7 FDIVR m64fp m64fp をST(0) で割り、結果をST(0) にストアする。
D8 F8+i FDIVR ST(0), ST(i) ST(i) をST(0) で割り、結果をST(0) にストアする。
DC F0+i FDIVR ST(i), ST(0) ST(0) をST(i) で割り、結果をST(i) にストアする。
DE F0+i FDIVRP ST(i), ST(0) ST(0) をST(i) で割り、結果をST(i) にストアし、レジス
タ・スタックをポップする。
DE F1 FDIVRP ST(0) をST(1) で割り、結果をST(1) にストアし、レジス
タ・スタックをポップする。
DA /7 FIDIVR m32int m32int をST(0) で割り、結果をST(0) にストアする。
DE /7 FIDIVR m16int m16int をST(0) で割り、結果をST(0) にストアする。
3-226
命令セット・リファレンス
FDIVR/FDIVRP/FIDIVR?Reverse Divide ( 続き)
注:
F 有限浮動小数点値を示す。
I 整数を示す。
* 浮動小数点無効算術オペランド (#IA) 例外を示す。
** 浮動小数点0 による除算 (#Z) 例外を示す。
ソース・オペランドは、整数0 の場合は+0 として取り扱われる。
操作
IF DEST = 0
THEN
#Z
ELSE
IF instruction is FIDIVR
THEN
DEST ← ConvertToDoubleExtendedPrecisionFP(SRC) / DEST;
ELSE (* source operand is floating-point value *)
DEST ← SRC / DEST;
FI;
FI;
IF instruction ← FDIVRP
THEN
PopRegisterStack
FI;
DEST
?∞ ?F ?0 +0 +F +∞ NaN
?∞ * +∞ +∞ ?∞ ?∞ * NaN
SRC ?F +0 +F ** ** ?F ?0 NaN
?I +0 +F ** ** ?F ?0 NaN
?0 +0 +0 * * ?0 ?0 NaN
+0 ?0 ?0 * * +0 +0 NaN
+I ?0 ?F ** ** +F +0 NaN
+F ?0 ?F ** ** +F +0 NaN
+∞ * ?∞ ?∞ +∞ +∞ * NaN
NaN NaN NaN NaN NaN NaN NaN NaN
3-227
命令セット・リファレンス
FDIVR/FDIVRP/FIDIVR?Reverse Divide ( 続き)
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA オペランドがSNaN 値であるか、またはそのフォーマットがサポートさ
れていない場合。
±∞ / ±∞、± 0/ ± 0 の場合。
#D 結果がデノーマル値である場合。
#Z SCR/ ± 0 の場合。ただし、SCR は± 0 に等しくない。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#O 結果が大きすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
3-228
命令セット・リファレンス
FDIVR/FDIVRP/FIDIVR?Reverse Divide ( 続き)
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-229
命令セット・リファレンス
FFREE?Free Floating-Point Register
説明
ST(i) レジスタに関連するFPU タグ・レジスタ内のタグを空 (11B) に設定する。ST(i) およびFPU ス
タック・トップ・ポインタ (TOP) の内容は影響を受けない。
操作
TAG(i) ← 11B;
FPU 影響を受けるフラグ
C0, C1, C2, C3 未定義。
浮動小数点例外
なし。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
オペコード命令説明
DD C0+i FFREE ST(i) ST(i) のタグを空に設定する。
3-230
命令セット・リファレンス
FICOM/FICOMP?Compare Integer
説明
ST(0) レジスタの値を整数ソース・オペランドと比較し、結果に従ってFPUステータス・ワードの条
件コード・フラグC0、C2、およびC3 をセットする ( 以下の表を参照)。整数値は、比較が行われる
前に拡張倍精度浮動小数点フォーマットに変換される。
これらの命令では、「順序付けなし比較」を実行する。順序付けなし比較は、さらに比較対象の2 つ
の数値のクラスのチェックも行う ( 本章の「FXAM?Examine」を参照)。どちらかのオペランドが
NaNであるか、またはそのフォーマットが定義されていない場合は、条件フラグが「順序付けなし」
に設定される。
ゼロの符号は無視される。すなわち、-0.0 ← +0.0 である。
FICOMP 命令は、比較後にレジスタ・スタックをポップする。レジスタ・スタックをポップするた
め、プロセッサはST(0) レジスタを空としてマークし、スタック・ポインタ (TOP) を1 インクリメン
トする。
操作
CASE (relation of operands) OF
ST(0) > SRC: C3, C2, C0 ← 000;
ST(0) < SRC: C3, C2, C0 ← 001;
ST(0) ← SRC: C3, C2, C0 ← 100;
Unordered: C3, C2, C0 ← 111;
ESAC;
IF instruction ← FICOMP
THEN
PopRegisterStack;
FI;
オペコード命令説明
DE /2 FICOM m16int ST(0) をm16int と比較する。
DA /2 FICOM m32int ST(0) をm32int と比較する。
DE /3 FICOMP m16int ST(0) をm16int と比較し、スタック・レジスタをポップする。
DA /3 FICOMP m32int ST(0) をm32int と比較し、スタック・レジスタをポップする。
条件C3 C2 C0
ST(0) > SRC 0 0 0
ST(0) < SRC 0 0 1
ST(0) ← SRC 1 0 0
順序付けなし1 1 1
3-231
命令セット・リファレンス
FICOM/FICOMP?Compare Integer ( 続き)
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされ、発生しな
かった場合は0 にクリアされる。
C0、C2、C3 前ページの表を参照。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA 一方または両方のオペランドがNaN 値であるか、またはそれらのフォー
マットがサポートされていない場合。
#D 一方または両方のオペランドがデノーマル値である場合。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-232
命令セット・リファレンス
FILD?Load Integer
説明
符号付き整数のソース・オペランドを拡張倍精度浮動小数点フォーマットに変換し、変換結果の値
をFPU レジスタ・スタックにプッシュする。ソース・オペランドには、ワード、ダブルワード、ま
たはクワッドワード整数値を使用できる。ソース・オペランドは丸めエラーなしにロードされる。
ソース・オペランドの符号が保持される。
操作
TOP ← TOP ? 1;
ST(0) ← ConvertToDoubleExtendedPrecisionFP(SRC);
FPU 影響を受けるフラグ
C1 スタック・オーバフローが発生した場合は1 にセットされ、発生しな
かった場合は0 にクリアされる。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・オーバフローが発生した場合。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
オペコード命令説明
DF /0 FILD m16int m16int をFPU レジスタ・スタックにプッシュする。
DB /0 FILD m32int m32int をFPU レジスタ・スタックにプッシュする。
DF /5 FILD m64int m64int をFPU レジスタ・スタックにプッシュする。
3-233
命令セット・リファレンス
FILD?Load Integer ( 続き)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-234
命令セット・リファレンス
FINCSTP?Increment Stack-Top Pointer
説明
FPUステータス・ワードのTOP フィールドに1 を加える ( すなわち、スタック・トップ・ポインタを
インクリメントする)。TOP フィールドは、内容が7 の場合は0 に設定される。この命令の働きは、ス
タックを1 レジスタ位置回転させることである。FPUデータ・レジスタおよびタグ・レジスタの内容
は影響を受けない。この操作はスタックをポップすることと等価ではない。それは、前のスタック・
トップ・レジスタのタグが空にマークされないためである。
操作
IF TOP ← 7
THEN TOP ← 0;
ELSE TOP ← TOP + 1;
FI;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされ、発生しな
かった場合は0 にクリアされる
C0、C2、C3 未定義。
浮動小数点例外
なし。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
オペコード命令説明
D9 F7 FINCSTP FPU ステータス・レジスタのTOP フィールドをインクリ
メントする。
3-235
命令セット・リファレンス
FINIT/FNINIT?Initialize Floating-Point Unit
注:
* 下記の「IA-32 アーキテクチャにおける互換性」の項を参照。
説明
FPU 制御、ステータス、タグ、命令ポインタ、およびデータ・ポインタの各レジスタをそれぞれの
デフォルト状態に設定する。FPU制御ワードは037FHに設定される ( 最も近い整数に丸められる、全
例外がマスクされる、64 ビット精度)。ステータス・ワードはクリアされる ( 全例外フラグはセット
されず、TOP は0 に設定される)。レジスタ・スタック内のデータ・レジスタは以前のまま変わらな
いが、すべて空 (11B) としてタグ付けされる。命令およびデータのポインタはクリアされる。
FINIT命令は未処理のマスクされていない浮動小数点例外の有無を調べ、処理してから、初期化を行
う。FNINIT 命令はこのチェックを行わない。
FINIT 命令の場合、アセンブラは、2 つの命令を発行する( つまり、FWAIT 命令に続けてFNINIT 命
令)。プロセッサは、これらの命令をそれぞれ個別に実行する。これらの命令のいずれかで例外が
発生すると、セーブEIP は、例外を発生させた命令をポイントする。
IA-32 アーキテクチャにおける互換性
PentiumプロセッサまたはIntel486 プロセッサをMS-DOS* 互換性モードで動作させたときは、( 通常
の状況下で) 実行される前にFNINIT 命令に割り込みをかけて、未処理のFPU例外を処理させること
ができる。それらの状況については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッ
パーズ・マニュアル、上巻』付録D の「非同期型命令のウインドウ内のx87 FPU 割り込み」の説明
を参照のこと。Pentium Pro プロセッサでは、FNINIT 命令にこの方法では割り込みをかけられない。
Intel387数値演算プロセッサでは、FINIT/FNINIT 命令は命令およびデータの両ポインタをクリアしな
い。
この命令は、x87 FPUのみに影響する。XMMおよびMXCSRレジスタには影響を与えない。
操作
FPUControlWord ← 037FH;
FPUStatusWord ← 0;
FPUTagWord ← FFFFH;
FPUDataPointer ← 0;
FPUInstructionPointer ← 0;
FPULastInstructionOpcode ← 0;
オペコード命令説明
9B DB E3 FINIT 未処理のマスクされていない浮動小数点例外の有無を
チェックした後、FPU を初期化する。
DB E3 FNINIT* 未処理のマスクされていない浮動小数点例外の有無を
チェックしないで、FPU を初期化する。
3-236
命令セット・リファレンス
FINIT/FNINIT?Initialize Floating-Point Unit ( 続き)
FPU 影響を受けるフラグ
C0, C1, C2, C3 0 にクリアされる。
浮動小数点例外
なし。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-237
命令セット・リファレンス
FIST/FISTP?Store Integer
説明
ST(0) レジスタの値を符号付き整数に変換し、変換結果の値をデスティネーション・オペランドにス
トアする。値はワード整数またはダブルワード整数のフォーマットでストアできる。デスティネー
ション・オペランドは、デスティネーション値の最初のバイトがストアされるアドレスを指定する。
FISTP命令は、FIST命令と同じ操作を行ってから、レジスタ・スタックをポップする。レジスタ・ス
タックをポップするため、プロセッサはST(0) レジスタを空としてマークし、スタック・ポインタ
(TOP) を1 インクリメントする。FISTP 命令は、値をロング整数フォーマットでもストアできる。
以下の表に、さまざまなクラスの数を整数フォーマットでストアしたときに得られる結果を示す。
注:
F 有限浮動小数点値を示す。
I 整数を示す。
* 浮動小数点無効操作 (#IA) 例外を示す。
** 丸めモードにより、0 または± 1。
オペコード命令説明
DF /2 FIST m16int ST(0) をm16int にストアする。
DB /2 FIST m32int ST(0) をm32int にストアする。
DF /3 FISTP m16int ST(0) をm16int にストアし、レジスタ・スタックをポップする。
DB /3 FISTP m32int ST(0) をm32int にストアし、レジスタ・スタックをポップする。
DF /7 FISTP m64int ST(0) をm64int にストアし、レジスタ・スタックをポップする。
ST(0) DEST
?∞ *
?F < ?1 ?I
?1 < ?F < ?0 **
?0 0
+0 0
+0 < +F < +1 **
+F > +1 +I
+∞ *
NaN *
3-238
命令セット・リファレンス
FIST/FISTP?Store Integer ( 続き)
ソース値は、非整数値の場合は、FPU制御ワードのRCフィールドによって指定される丸めモードに
従って整数値に丸められる。
ストアされる値がデスティネーション・フォーマットに対して大きすぎる、すなわち∞またはNaN
であるか、あるいはそのフォーマットがサポートされていない場合で、かつ無効算術オペランド例
外 (#IA) がマスクされていない場合は、無効操作例外が発生し、値はデスティネーション・オペラン
ドにストアされない。無効操作例外がマスクされている場合は、整数の未定義値がデスティネーショ
ン・オペランドにストアされる。
操作
DEST ← Integer(ST(0));
IF instruction ← FISTP
THEN
PopRegisterStack;
FI;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされ、発生しな
かった場合は0 にクリアされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
発生しなかった場合は0 にクリアされる。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドが大きすぎて、デスティネーション・フォーマット
で表現できない場合。
ソース・オペランドがNaN 値であるか、またはそのフォーマットがサ
ポートされていない場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
3-239
命令セット・リファレンス
FIST/FISTP?Store Integer ( 続き)
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-240
命令セット・リファレンス
FLD?Load Floating Point Value
説明
ソース・オペランドをFPU レジスタ・スタックにプッシュする。ソース・オペランドは、単精度、
倍精度、または拡張倍精度浮動小数点フォーマットが可能である。ソース・オペランドが、単精度
浮動小数点または倍精度浮動小数点数のフォーマットの場合は、スタックにプッシュされる前に自
動的に拡張倍精度浮動小数点フォーマットに変換される。
FLD命令は選択されたFPUレジスタ[ST(i)] の値もスタックにプッシュできる。この場合、ST(0) レジ
スタをプッシュすると、スタック・トップとその下のスタック・レジスタがともに以前のスタック・
トップ値になる。
操作
IF SRC is ST(i)
THEN
temp ← ST(i)
FI;
TOP ← TOP ? 1;
IF SRC is memory-operand
THEN
ST(0) ← ConvertToDoubleExtendedPrecisionFP(SRC);
ELSE (* SRC is ST(i) *)
ST(0) ← temp;
FI;
FPU 影響を受けるフラグ
C1 スタック・オーバフローが発生した場合は1 にセットされ、発生しな
かった場合は0 にクリアされる。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・オーバフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、またはそのフォーマットがサ
ポートされていない場合。
#D ソース・オペランドがデノーマル値である場合。ソース・オペランドが
拡張倍精度浮動小数点フォーマットの場合は発生しない。
オペコード命令説明
D9 /0 FLD m32fp m32fp をFPU レジスタ・スタックにプッシュする。
DD /0 FLD m64fp m64fp をFPU レジスタ・スタックにプッシュする。
DB /5 FLD m80fp m80fp をFPU レジスタ・スタックにプッシュする。
D9 C0+i FLD ST(i) ST(i) をFPU レジスタ・スタックにプッシュする。
3-241
命令セット・リファレンス
FLD?Load Floating Point Value ( 続き)
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-242
命令セット・リファレンス
FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ?Load
Constant
説明
拡張倍精度浮動小数点フォーマットで 広く使用されている7 つの定数の中の1 つをFPUレジスタ・
スタックにプッシュする。これらの命令でロードできる定数は、+1.0、+0.0、log210、log2e、π、
log102、およびloge2 である。各定数について、66 ビットの内部定数が (FPU制御ワードのRCフィー
ルドの指定に従って) 拡張倍精度浮動小数点フォーマットに丸められる。丸めの結果としては、不
正確結果例外 (#P) は発生しない。
π 定数については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュア
ル、上巻』第8 章の「π」の説明を参照のこと。
操作
TOP ← TOP ? 1;
ST(0) ← CONSTANT;
FPU 影響を受けるフラグ
C1 スタック・オーバフローが発生した場合は1 にセットされ、発生しな
かった場合は0 にクリアされる。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・オーバフローが発生した場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
オペコード命令説明
D9 E8 FLD1 +1.0 をFPU レジスタ・スタックにプッシュする。
D9 E9 FLDL2T log210 をFPU レジスタ・スタックにプッシュする。
D9 EA FLDL2E log2e をFPU レジスタ・スタックにプッシュする。
D9 EB FLDPI π をFPU レジスタ・スタックにプッシュする。
D9 EC FLDLG2 log102 をFPU レジスタ・スタックにプッシュする。
D9 ED FLDLN2 loge2 をFPU レジスタ・スタックにプッシュする。
D9 EE FLDZ +0.0 をFPU レジスタ・スタックにプッシュする。
3-243
命令セット・リファレンス
FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ?Load
Constant ( 続き)
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
IA-32 アーキテクチャにおける互換性
RCフィールドが「最も近い整数に丸める」(round-to-nearest) に設定されているときは、FPUは、Intel
8087およびIntel287 数値演算プロセッサが生じるものと同じ定数を生じる。
3-244
命令セット・リファレンス
FLDCW?Load x87 FPU Control Word
説明
16 ビットのソース・オペランドをFPU制御ワードにロードする。ソース・オペランドはメモリ・ロ
ケーションである。この命令は、一般的にFPUの動作モードを設定または変更する場合に使用される。
新しいFPU制御ワードをロードする前に、FPUステータス・ワード内の1 つ以上の例外フラグがセッ
トされていて、新しい制御ワードがそれらの例外の1 つ以上のマスクを解除した場合は、次の浮動小
数点命令が実行されたときに浮動小数点例外が発生する ( ただし、「非同期型」(no-wait) 浮動小数点
命令の場合を除く。詳細は『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マ
ニュアル、上巻』第8 章の「ソフトウェア内でのx87 FPU例外の処理」の説明を参照)。FPUの動作
モードを変更する際に例外を発生させないようにするには、新しい制御ワードをロードする前に、
(FCLEXまたはFNCLEX命令を使用して) すべての未処理例外をクリアする。
操作
FPUControlWord ← SRC;
FPU 影響を受けるフラグ
C0, C1, C2, C3 未定義。
浮動小数点例外
なし。ただし、この操作でFPU ステータス・ワード内の未処理例外のマスクを解除されることがあ
る。その場合は、次の「同期型」(waiting) 浮動小数点命令が実行されたときにその例外が発生する。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
オペコード命令説明
D9 /5 FLDCW m2byte m2byte からFPU 制御ワードをロードする。
3-245
命令セット・リファレンス
FLDCW?Load x87 FPU Control Word ( 続き)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-246
命令セット・リファレンス
FLDENV?Load x87 FPU Environment
説明
メモリからx87 FPU レジスタに完全なFPU 動作環境をロードする。ソース・オペランドは、メモリ
内の動作環境データの最初のバイトを指定する。このデータは、一般的に前もってFSTENV または
FNSTENV命令によって指定されたメモリ・ロケーションに書かれている。
FPU動作環境は、FPU制御ワード、ステータス・ワード、タグ・ワード、命令ポインタ、データ・ポ
インタ、および最後のオペコードからなっている。『IA-32 インテルR アーキテクチャ・ソフトウェ
ア・デベロッパーズ・マニュアル、上巻』の図8-9. から8-12. に、プロセッサの動作モード ( 保護ま
たは実アドレス) および現在のオペランド・サイズ属性 (16 ビットまたは32 ビット) に従って、メモ
リにロードされる動作環境情報のレイアウトを示してある。仮想8086 モードでは、実アドレス・モー
ドのレイアウトが使用される。
FLDENV命令は、対応するFSTENV/FNSTENV命令と同じ動作モードで実行する必要がある。
新しいFPUステータス・ワードに1 つ以上のマスクされていない例外フラグがセットされている場合
は、次の浮動小数点命令が実行されたときに浮動小数点例外が発生する ( ただし、「非同期型」(nowait)
浮動小数点命令の場合を除く。『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』第8 章の「ソフトウェア内でのx87 FPU の処理」の説明を参照)。新しい環
境をロードしたときに例外を発生させないようにするには、ロードされるFPUステータス・ワード内
のすべての例外フラグをクリアする。
操作
FPUControlWord ← SRC[FPUControlWord);
FPUStatusWord ← SRC[FPUStatusWord);
FPUTagWord ← SRC[FPUTagWord);
FPUDataPointer ← SRC[FPUDataPointer);
FPUInstructionPointer ← SRC[FPUInstructionPointer);
FPULastInstructionOpcode ← SRC[FPULastInstructionOpcode);
FPU 影響を受けるフラグ
C0、C1、C2、およびC3フラグがロードされる。
浮動小数点例外
なし。ただし、この操作でマスクされていない例外がステータス・ワードにロードされた場合は、次
の「同期型」(waiting) 浮動小数点命令が実行されたときにその例外が発生する。
オペコード命令説明
D9 /4 FLDENV m14/28byte m14byte またはm28byte からFPU 環境をロードする。
3-247
命令セット・リファレンス
FLDENV?Load x87 FPU Environment ( 続き)
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-248
命令セット・リファレンス
FMUL/FMULP/FIMUL?Multiply
説明
デスティネーション・オペランドとソース・オペランドとを掛け合わせ、結果をデスティネーショ
ン・ロケーションにストアする。デスティネーション・オペランドは常にFPU データ・レジスタで
ある。ソース・オペランドには、FPUデータ・レジスタまたはメモリ・ロケーションを使用できる。
メモリ内のソース・オペランドには、単精度浮動小数点、倍精度浮動小数点、ワード整数、または
ダブルワード整数のフォーマットを使用できる。
この命令のオペランドなしバージョンでは、ST(1) レジスタの内容にST(0) レジスタの内容を掛け、
結果をST(1) レジスタにストアする。1 オペランド・バージョンでは、ST(0) レジスタの内容にメモ
リ・ロケーション ( 浮動小数点値でも整数値でも可) を掛け、結果をST(0) にストアする。2 オペラン
ド・バージョンでは、ST(0) レジスタの内容にST(i) レジスタの内容を掛けるか、またはその逆に掛
け、結果を第1 オペランド ( デスティネーション・オペランド) によって指定されるレジスタにスト
アする。
FMULP命令は、結果をストアした後に、追加操作としてRPUレジスタ・スタックをポップする。レ
ジスタ・スタックをポップするため、プロセッサはST(0) レジスタを空としてマークし、スタック・
ポインタ (TOP) を1 インクリメントする。浮動小数点乗算命令のオペランドなしバージョンでは、常
にレジスタ・スタックのポップ操作を伴う。一部のアセンブラでは、この命令のニーモニックは
FMULPではなくFMULになっている。
FIMUL 命令は、整数ソース・オペランドを拡張倍精度浮動小数点フォーマットに変換してから乗算
を行う。
結果の符号は、掛け合わされる一方または両方の値が0 または∞であっても、常にソースとデスティ
ネーションの符号の排他的論理和である。ソース・オペランドは、整数0 の場合、+0 として取り扱
われる。
以下の表に、オーバフローもアンダフローも発生しないものとして、さまざまなクラスの数の乗算
を行ったときに得られる結果を示す。
オペコード命令説明
D8 /1 FMUL m32fp ST(0) にm32fp を掛け、結果をST(0) にストアする。
DC /1 FMUL m64fp ST(0) にm64fp を掛け、結果をST(0) にストアする。
D8 C8+i FMUL ST(0), ST(i) ST(0) にST(i) を掛け、結果をST(0) にストアする。
DC C8+i FMUL ST(i), ST(0) ST(i) にST(0) を掛け、結果をST(i) にストアする。
DE C8+i FMULP ST(i), ST(0) ST(i) にST(0) を掛け、結果をST(i) にストアし、レジス
タ・スタックをポップする。
DE C9 FMULP ST(1) にST(0) を掛け、結果をST(1) にストアし、レジス
タ・スタックをポップする。
DA /1 FIMUL m32int ST(0) にm32int を掛け、結果をST(0) にストアする。
DE /1 FIMUL m16int ST(0) にm16int を掛け、結果をST(0) にストアする。
3-249
命令セット・リファレンス
FMUL/FMULP/FIMUL?Multiply ( 続き)
注:
F 有限浮動小数点値を示す。
I 整数を示す。
* 無効算術オペランド (#IA) 例外を示す。
操作
IF instruction is FIMUL
THEN
DEST ← DEST ? ConvertToDoubleExtendedPrecisionFP(SRC);
ELSE (* source operand is floating-point value *)
DEST ← DEST ? SRC;
FI;
IF instruction ← FMULP
THEN
PopRegisterStack
FI;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C0、C2、C3 未定義。
DEST
?∞ ?F ?0 +0 +F +∞ NaN
?∞ +∞ +∞ * * ?∞ ?∞ NaN
?F +∞ +F +0 ?0 ?F ?∞ NaN
-I +∞ +F +0 ?0 ?F ?∞ NaN
SRC ?0 * +0 +0 ?0 ?0 * NaN
+0 * ?0 ?0 +0 +0 * NaN
+I ?∞ ?F ?0 +0 +F +∞ NaN
+F ?∞ ?F ?0 +0 +F +∞ NaN
+∞ ?∞ ?∞ * * +∞ +∞ NaN
NaN NaN NaN NaN NaN NaN NaN NaN
3-250
命令セット・リファレンス
FMUL/FMULP/FIMUL?Multiply ( 続き)
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、またはそのフォーマットがサ
ポートされていない場合。
一方のオペランドが± 0 であり、他方のオペランドが±∞の場合。
#D ソース・オペランドがデノーマル値である場合。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#O 結果が大きすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-251
命令セット・リファレンス
FNOP?No Operation
説明
何のFPU操作も実行されない。この命令は命令ストリーム上の空間を占めるが、EIP レジスタを除い
て、FPUにもマシン・コンテキストにも影響を与えない。
FPU 影響を受けるフラグ
C0, C1, C2, C3 未定義。
浮動小数点例外
なし。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
オペコード命令説明
D9 D0 FNOP 何の操作も実行されない。
3-252
命令セット・リファレンス
FPATAN?Partial Arctangent
説明
ST(1) レジスタ内のソース・オペランドをST(0) レジスタ内のソース・オペランドで割った値の逆正
接を計算し、結果をST(1) にストアし、FPU レジスタ・スタックをポップする。ST(0) レジスタ内の
結果の符号は、ソース・オペランドST(1) の符号と同じであり、結果の絶対値は+πより小さい。
FPATAN 命令は、X 軸と、原点と点 (X,Y) を結ぶ直線とのなす角度を返す。ただし、Y ( 縦座標) は
ST(1) であり、X ( 横座標) はST(0) である。この角度は、単にY/Xの比の符号だけでなく、XとYの
符号に別々に依存する。それは、点 (-X,Y) が第2 象限にあり、したがって角度の範囲はπ/2 からπ
までになるのに対し、点 (X,-Y) は第4 象限にあり、角度の範囲は0 から-π/2 までになるためである。
点 (-X,-Y) は第3 象限にあって、角度の範囲は-π/2 から-πまでとなる。
以下の表に、アンダフローが生じないものとして、さまざまなクラスの数の逆正接を計算したとき
に得られる結果を示す。
注:
F 有限実数を示す。
* 『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の表8-10. は、2 つ
の比0/0 および∞ / ∞が浮動小数点無効算術演算例外を発生し、かつ、この例外がマスクされている場合は、
浮動小数点QNaN の未定義値が返されるものと規定している。FPATAN 命令では、0/0 も∞ / ∞も実際には除
算を使って計算されない。その代わりに、引数として複素数を使用できるように一般化された標準的な数学的
定式化から、2 つの変数の間の逆正接が得られる。この複素変数の定式化では、arctangent(0,0) などの値は非
常に高精度で確定する。引数として浮動小数点値しか使用できないFPU 関数に基づいて、複素数の引数を使
用する超越関数を計算するには、それらの値のライブラリを作成する必要がある。
FPATAN命令が許容できるソース・オペランドの範囲に制約はない。
IA-32 アーキテクチャにおける互換性
80287 数値演算プロセッサでは、この命令の両方のソース・オペランドは下記の範囲に制限される。
0 ? |ST(1)| < |ST(0)| < +∞
オペコード命令説明
D9 F3 FPATAN ST(1) をarctan(ST(1)/ST(0)) で置き換え、レジスタ・ス
タックをポップする。
ST(0)
-∞ ?F ?0 +0 +F +∞ NaN
-∞ ?3π/4* ?π/2 ?π/2 ?π/2 ?π/2 ?π/4* NaN
ST(1) ?F -π ?π to ?π/2 ?π/2 ?π/2 ?π/2 to ?0 -0 NaN
?0 -π -π -π* ?0* ?0 ?0 NaN
+0 +π +π +π* +0* +0 +0 NaN
+F +π +π to +π/2 +π/2 +π/2 +π/2 to +0 +0 NaN
+∞ +3π/4* +π/2 +π/2 +π/2 +π/2 +π/4* NaN
NaN NaN NaN NaN NaN NaN NaN NaN
3-253
命令セット・リファレンス
FPATAN?Partial Arctangent ( 続き)
操作
ST(1) ← arctan(ST(1) / ST(0));
PopRegisterStack;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 = 切り上
げなし、1 = 切り上げ
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ス・オペランドがSNaN 値であるか、またはそのフォーマットがサポー
トされていない場合。
#D ソース・オペランドがデノーマル値である場合。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-254
命令セット・リファレンス
FPREM?Partial Remainder
説明
ST(0) レジスタの値 ( 被除数) をST(1) レジスタの値 ( 除数または法) で割って得られる剰余を計算し、
結果をST(0) にストアする。剰余の値は以下の式で表される。
剰余 ← ST(0) - (Q * ST(1))
ここで、Qは[ST(0)/ST(1)] の浮動小数点数の商をゼロに向けて切り捨てて得られる整数値である。剰
余の符号は被除数の符号と同じである。部分剰余が1 回も計算されていなくても、剰余の絶対値は法
の絶対値より小さい ( 下で説明)。
この命令は正確な結果を生じる。不正確な結果の例外は発生せず、丸め制御は効果をもたない。以
下の表に、アンダフローが発生しないものとして、さまざまなクラスの数の剰余を計算したときに
得られる結果を示す。
注:
F 有限浮動小数点値を示す。
* 浮動小数点無効算術オペランド (#IA) 例外を示す。
** 浮動小数点0 による除算 (#Z) 例外を示す。
結果が0 のときは、その符号は被除数の符号と同じである。法が∞のときは、結果はST(0) の値に等
しくなる。
FPREM命令は、IEEE規格754 で定義される剰余を計算しない。IEEE で定義される剰余を計算するに
は、FPREM1 命令を使用する必要がある。FPREM命令は、Intel 8087 およびIntel287 数値演算コプロ
セッサとの互換性のために用意されている。
オペコード命令説明
D9 F8 FPREM ST(0) をST(1) で割って得られる剰余でST(0) を置き換え
る。
ST(1)
?∞ ?F ?0 +0 +F +∞ NaN
?∞ * * * * * * NaN
ST(0) ?F ST(0) ?F or ?0 ** ** ?F or ?0 ST(0) NaN
?0 ?0 ?0 * * ?0 ?0 NaN
+0 +0 +0 * * +0 +0 NaN
+F ST(0) +F or +0 ** ** +F or +0 ST(0) NaN
+∞ * * * * * * NaN
NaN NaN NaN NaN NaN NaN NaN NaN
3-255
命令セット・リファレンス
FPREM?Partial Remainder ( 続き)
FPREM命令の「部分剰余」 (partial remainder) という名前は、その剰余の計算方法に由来している。こ
の命令は減算を反復して最終的に剰余を得る。すなわち、この命令の1 回の実行ではST(0) の指数を
63までしか縮小できない。法より小さい剰余を生じることができた場合に、この演算は完了し、FPU
ステータス・ワード内のC2 フラグがクリアされる。法より小さい剰余に達するまでは、C2 はセット
されており、ST(0) 内の結果は部分剰余と呼ばれる。部分剰余の指数は元の被除数の指数よりも最低
32 は小さくなっている。ソフトウェアは、C2 がクリアされるまで、(ST(0) 内の部分剰余を被除数と
して使用して) この命令を繰り返し実行できる。( そのような剰余計算ループを実行している間に、
FPUを必要とする、優先順位が高い割り込みルーチンが剰余計算ループ内の命令間でコンテキスト・
スイッチを強制することが考えられるので注意されたい。)
FPREM命令の重要な用途は、周期関数の引数を縮小することである。縮小が完了すると、この命令
は商の最下位3 ビットをFPU ステータス・ワードのC3、C1、およびC0 フラグにストアする。この
情報は、単位円の正しい8 等分 (π/4) 扇形内の元の角度を示してくれるので、( 法としてπ/4 を使用
した) 正接関数の引数の縮小に重要である。
操作
D ← exponent(ST(0)) ? exponent(ST(1));
IF D < 64
THEN
Q ← Integer(TruncateTowardZero(ST(0) / ST(1)));
ST(0) ← ST(0) ? (ST(1) ? Q);
C2 ← 0;
C0, C3, C1 ← LeastSignificantBits(Q); (* Q2, Q1, Q0 *)
ELSE
C2 ← 1;
N ← an implementation-dependent number between 32 and 63;
QQ ← Integer(TruncateTowardZero((ST(0) / ST(1)) / 2(D ? N)));
ST(0) ← ST(0) ? (ST(1) ? QQ ? 2(D ? N));
FI;
FPU 影響を受けるフラグ
C0 商のビット2 (Q2) にセットされる。
C1 スタック・アンダフローが発生した場合は0 にセットされ、発生しな
かった場合は商の最下位ビット (Q0) にセットされる。
C2 縮小が完了した場合は0 にセットされ、完了していない場合は1 にセッ
トされる。
C3 商のビット1 (Q1) にセットされる。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、法が0 であるか、被除数が∞
であるか、またはそれらのいずれかのフォーマットがサポートされてい
ない場合。
3-256
命令セット・リファレンス
FPREM?Partial Remainder ( 続き)
#D ソース・オペランドがデノーマル値である場合。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-257
命令セット・リファレンス
FPREM1?Partial Remainder
説明
ST(0) レジスタの値 ( 被除数) をST(1) レジスタの値 ( 除数または法) で割って得られるIEEE 剰余を計
算し、結果をST(0) にストアする。剰余の値は以下の式で表される。
剰余 ← ST(0) - (Q ? ST(1))
ここで、Qは[ST(0)/ST(1)] の浮動小数点数の商を最も近い整数値に向けて丸めて得られる整数値であ
る。部分剰余が1 回も計算されていなくても、剰余の絶対値は法の絶対値の1/2 より小さいか、また
は等しい ( 下で説明)。
この命令は正確な結果を生じる。精度 ( 不正確) 例外は発生せず、丸め制御は効果をもたない。以下
の表に、アンダフローが発生しないものとして、さまざまなクラスの数の剰余を計算したときに得
られる結果を示す。
注:
F 有限浮動小数点値を示す。
* 浮動小数点無効算術オペランド (#IA) 例外を示す。
** 浮動小数点0 による除算 (#Z) 例外を示す。
結果が0 のときは、その符号は被除数の符号と同じである。法が∞のときは、結果はST(0) の値に等
しくなる。
FPREM命令は、IEEE 規格754 に規定されている剰余を計算する。この命令の操作は、ST(0) をST(1)
で割った商を整数に丸める点でFPREM命令とは異なる ( 以下の「操作」の項を参照)。
オペコード命令説明
D9 F5 FPREM1 ST(0) をST(1) で割って得られるIEEE 剰余でST(0) を置き
換える。
ST(1)
?∞ ?F ?0 +0 +F +∞ NaN
?∞ * * * * * * NaN
ST(0) ?F ST(0) ±F or ?0 ** ** ±F or ?0 ST(0) NaN
?0 ?0 ?0 * * ?0 ?0 NaN
+0 +0 +0 * * +0 +0 NaN
+F ST(0) ±F or +0 ** ** ±F or +0 ST(0) NaN
+∞ * * * * * * NaN
NaN NaN NaN NaN NaN NaN NaN NaN
3-258
命令セット・リファレンス
FPREM1?Partial Remainder ( 続き)
FPREM1 命令は、FPREM命令と同様に、減算を反復して最終的に剰余を計算する。すなわち、この
命令の1 回の実行ではST(0) の指数を63までしか縮小できない。法より小さい剰余を生じることがで
きた場合に、この演算は完了し、FPUステータス・ワード内のC2フラグがクリアされる。法より小
さい剰余に達するまでは、C2 はセットされており、ST(0) 内の結果は部分剰余と呼ばれる。部分剰余
の指数は元の被除数の指数よりも最低32 は小さくなっている。ソフトウェアは、C2 がクリアされる
まで、(ST(0) 内の部分剰余を被除数として使用して) この命令を繰り返し実行できる。( そのような
剰余計算ループを実行している間に、FPU を必要とする、優先順位が高い割り込みルーチンが剰余
計算ループ内の命令間でコンテキスト・スイッチを強制する可能性があるので注意されたい。)
FPREM命令の重要な用途は、周期関数の引数を縮小することである。縮小が完了すると、この命令
は商の最下位3 ビットをFPU ステータス・ワードのC3、C1、およびC0 フラグにストアする。この
情報は、単位円の正しい8 等分 (π/4) 扇形内の元の角度を示してくれるので、( 法としてπ/4 を使用
した) 正接関数の引数の縮小に重要である。
操作
D ← exponent(ST(0)) ? exponent(ST(1));
IF D < 64
THEN
Q ← Integer(RoundTowardNearestInteger(ST(0) / ST(1)));
ST(0) ← ST(0) ? (ST(1) ? Q);
C2 ← 0;
C0, C3, C1 ← LeastSignificantBits(Q); (* Q2, Q1, Q0 *)
ELSE
C2 ← 1;
N ← an implementation-dependent number between 32 and 63;
QQ ← Integer(TruncateTowardZero((ST(0) / ST(1)) / 2(D ? N)));
ST(0) ← ST(0) ? (ST(1) ? QQ ? 2(D ? N));
FI;
FPU 影響を受けるフラグ
C0 商のビット2 (Q2) にセットされる。
C1 スタック・アンダフローが発生した場合は0 にセットされ、発生しな
かった場合は商の最下位ビット (Q0) にセットされる。
C2 縮小が完了した場合は0 にセットされ、完了していない場合は1 にセッ
トされる。
C3 商のビット1 (Q1) にセットされる。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、法が0 であるか、被除数が∞
であるか、またはそれらのいずれかのフォーマットがサポートされてい
ない場合。
3-259
命令セット・リファレンス
FPREM1?Partial Remainder ( 続き)
#D ソース・オペランドがデノーマル値である場合。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-260
命令セット・リファレンス
FPTAN?Partial Tangent
説明
ST(0) レジスタ内のソース・オペランドの正接を計算し、結果をST(0) にストアし、FPU レジスタ・
スタックに1.0 をプッシュする。ソース・オペランドはラジアン単位であり、± 263 の範囲内でなけ
ればならない。以下の表に、アンダフローが発生しないものとして、さまざまなクラスの数の部分
正接を計算したときに得られるマスクされていない結果を示す。
注:
F 有限浮動小数点値を示す。
* 浮動小数点無効算術オペランド (#IA) 例外を示す。
ソース・オペランドが許容可能な範囲外の場合は、FPUステータス・ワード内のC2 フラグがセット
され、ST(0) レジスタの値は変わらない。この命令は、ソース・オペランドが範囲外のときに例外を
発生しない。C2 フラグを調べて範囲外条件の有無を確認するのはプログラムの責任である。ソース
値が±263 の範囲外の場合は、除数を2πとしてFPREM命令を使用して、2πの該当する整数倍を減
算することにより、ソース値を命令の範囲内に縮小することができる。上記のような縮小演算でπ
に使用する適切な値については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』第8 章の「π」の説明を参照のこと。
Intel8087 およびIntel287 数値演算プロセッサとの互換性を保つため、正接の計算終了後に、レジス
タ・スタックに1.0 がプッシュされる。この操作によって、さらに他の三角関数の計算も単純化され
る。例えば、FPTAN命令の後でFDIVR命令を実行して余接 ( 正接の逆数) を計算できる。
オペコード命令Clocks 説明
D9 F2 FPTAN 17-173 ST(0) をその正接で置き換え、FPU スタックに1 を
プッシュする。
ST(0) SRC ST(0) DEST
?∞ *
?F ?F 〜 +F
?0 ?0
+0 +0
+F ?F 〜 +F
+∞ *
NaN NaN
3-261
命令セット・リファレンス
FPTAN?Partial Tangent ( 続き)
操作
IF ST(0) < 263
THEN
C2 ← 0;
ST(0) ← tan(ST(0));
TOP ← TOP ? 1;
ST(0) ← 1.0;
ELSE (*source operand is out-of-range *)
C2 ← 1;
FI;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされ、スタック・
オーバフローが発生した場合は1 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C2 ソース・オペランドが± 263 の範囲外の場合は1 にセットされ、範囲内
の場合は0 にクリアされる。
C0, C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、∞であるか、またはそのフォー
マットがサポートされていない場合。
#D ソース・オペランドがデノーマル値である場合。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-262
命令セット・リファレンス
FRNDINT?Round to Integer
説明
ST(0) レジスタのソース値を、現在の丸めモード (FPU制御ワードのRCフィールドの設定) に従って
最も近い整数値に丸め、結果をST(0) にストアする。
ソース値は、∞の場合は変更されない。ソース値が整数値でない場合は、浮動小数点不正確結果例
外 (#P) が発生する。
操作
ST(0) ← RoundToIntegralValue(ST(0));
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、またはそのフォーマットがサ
ポートされていない場合。
#D ソース・オペランドがデノーマル値である場合。
#P ソース・オペランドが整数値でない場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
オペコード命令説明
D9 FC FRNDINT ST(0) を整数に丸める。
3-263
命令セット・リファレンス
FRSTOR?Restore x87 FPU State
説明
ソース・オペランドで指定されるメモリ領域から、FPU 状態 ( 動作環境とレジスタ・スタック) を
ロードする。この状態データは、一般的に前もってFSAVE/FNSAVE命令によって指定されたメモリ・
ロケーションに書かれている。
FPU動作環境は、FPU制御ワード、ステータス・ワード、タグ・ワード、命令ポインタ、データ・ポ
インタ、および最後のオペコードからなっている。『IA-32 インテルR アーキテクチャ・ソフトウェ
ア・デベロッパーズ・マニュアル、上巻』の図8-9. から8-12. に、プロセッサの動作モード ( 保護ま
たは実アドレス) および現在のオペランド・サイズ属性 (16 ビットまたは32 ビット) に従って、メモ
リにストアされる動作環境情報のレイアウトを示してある。仮想8086 モードでは、実アドレス・モー
ドのレイアウトが使用される。FPUレジスタ・スタックの内容は、動作環境イメージの直後の80 バ
イト領域にストアされる。
FRSTOR命令は、対応するFSAVE/FNSAVE命令と同じ動作モードで実行する必要がある。
新しいFPU ステータス・ワード内でマスクされていない例外ビットが1 つ以上セットされている場
合は、浮動小数点例外が生成される。新しいオペレーティング環境をロードするときに例外が発生
しないようにするには、ロードされるFPUステータス・ワード内の例外フラグをすべてクリアする。
操作
FPUControlWord ← SRC[FPUControlWord);
FPUStatusWord ← SRC[FPUStatusWord);
FPUTagWord ← SRC[FPUTagWord);
FPUDataPointer ← SRC[FPUDataPointer);
FPUInstructionPointer ← SRC[FPUInstructionPointer);
FPULastInstructionOpcode ← SRC[FPULastInstructionOpcode);
ST(0) ← SRC[ST(0));
ST(1) ← SRC[ST(1));
ST(2) ← SRC[ST(2));
ST(3) ← SRC[ST(3));
ST(4) ← SRC[ST(4));
ST(5) ← SRC[ST(5));
ST(6) ← SRC[ST(6));
ST(7) ← SRC[ST(7));
FPU 影響を受けるフラグ
C0、C1、C2、C3 フラグがロードされる。
オペコード命令説明
DD /4 FRSTOR m94/108byte m94byte またはm108byte からFPU 状態をロードする。
3-264
命令セット・リファレンス
FRSTOR?Restore x87 FPU State ( 続き)
浮動小数点例外
なし。ただし、検出されたが、マスクされていたために発生しなかった既存の例外が、この操作に
よってマスクを解除されることがある。そのような例外は、ここで、FRSTOR 命令の終了後に発生
する。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-265
命令セット・リファレンス
FSAVE/FNSAVE?Store x87 FPU State
注:
* 下記の「IA-32 アーキテクチャにおける互換性」の項を参照。
説明
現在のFPU状態 ( 動作環境とレジスタ・スタック) を指定されたメモリ内のデスティネーションにス
トアし、次にFPUを再初期化する。FSAVE 命令は、未処理のマスクされていない浮動小数点例外の
有無をチェックし、処理してから、FPU 状態をストアする。FNSAVE 命令はこのチェックと処理を
行わない。
FPU動作環境は、FPU制御ワード、ステータス・ワード、タグ・ワード、命令ポインタ、データ・ポ
インタ、および最後のオペコードからなっている。『IA-32 インテルR アーキテクチャ・ソフトウェ
ア・デベロッパーズ・マニュアル、上巻』の図8-9. から8-12. に、プロセッサ の動作モード( 保護ま
たは実アドレス) および現在のオペランド・サイズ属性 (16 ビットまたは32 ビット) に従って、メモ
リにストアされる動作環境情報のレイアウトを示してある。仮想8086 モードでは、実アドレス・モー
ドのレイアウトが使用される。FPUレジスタ・スタックの内容は、動作環境イメージの直後の80 バ
イト領域にストアされる。
セーブされたイメージは、命令ストリーム内のFSAVE/FNSAVE 命令より前のすべての浮動小数点命
令が実行された後のFPUの状態を反映している。
FPU状態がセーブされた後、FPUはFINIT/FNINIT 命令で設定されるのと同じデフォルト値にリセッ
トされる ( 本章の「FINIT/FNINIT?Initialize Floating-Point Unit」を参照)。
FSAVE/FNSAVE 命令は、一般的にオペレーティング・システムがコンテキスト・スイッチを実行す
る必要があるとき、例外ハンドラがFPU を使用する必要があるとき、またはアプリケーション・プ
ログラムが「クリーン」な ( 初期状態の) FPUをプロシージャに渡す必要があるときに使用される。
FSAVE命令の場合、アセンブラは、2 つの命令を発行する( つまり、FWAIT命令に続けてFNSAVE命
令)。プロセッサは、これらの命令をそれぞれ個別に実行する。これらの命令のいずれかで例外が発
生すると、セーブEIP は、例外を発生させた命令をポイントする。
オペコード命令説明
9B DD /6 FSAVE m94/108byte 未処理のマスクされていない浮動小数点例外の有無を
チェックした後、FPU 状態をm94byte またはm108byte に
ストアし、次にFPU を初期化する。
DD /6 FNSAVE* m94/108byte 未処理のマスクされていない浮動小数点例外の有無を
チェックしないで、FPU 状態をm94byte またはm108byte
にストアし、次にFPU を初期化する。
3-266
命令セット・リファレンス
FSAVE/FNSAVE?Store x87 FPU State ( 続き)
IA-32 アーキテクチャにおける互換性
インテルPentium プロセッサより以前のインテル数値演算プロセッサおよびFPU の場合は、前の
FSAVE/ FNSAVE命令でストアされたメモリ・イメージから読み取る前に、FWAIT命令を実行された
い。このFWAIT命令によって、より確実にストア操作を完了することができる。
Pentium プロセッサまたはIntel486 プロセッサをMS-DOS互換性モードで動作させたときは、( 通常の
状況下で) 実行される前にFNSAVE 命令に割り込みをかけて、未処理のFPU 例外を処理させること
ができる。それらの状況については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッ
パーズ・マニュアル、上巻』付録D の「非同期型命令のウィンドウ内のx87 FPU 割り込み」の説明
を参照のこと。 Pentium Pro プロセッサでは、FNSAVE命令にこの方法では割り込みをかけられない。
操作
(* Save FPU State and Registers *)
DEST[FPUControlWord) ← FPUControlWord;
DEST[FPUStatusWord) ← FPUStatusWord;
DEST[FPUTagWord) ← FPUTagWord;
DEST[FPUDataPointer) ← FPUDataPointer;
DEST[FPUInstructionPointer) ← FPUInstructionPointer;
DEST[FPULastInstructionOpcode) ← FPULastInstructionOpcode;
DEST[ST(0)) ← ST(0);
DEST[ST(1)) ← ST(1);
DEST[ST(2)) ← ST(2);
DEST[ST(3)) ← ST(3);
DEST[ST(4)) ← ST(4);
DEST[ST(5)) ← ST(5);
DEST[ST(6)) ← ST(6);
DEST[ST(7)) ← ST(7);
(* Initialize FPU *)
FPUControlWord ← 037FH;
FPUStatusWord ← 0;
FPUTagWord ← FFFFH;
FPUDataPointer ← 0;
FPUInstructionPointer ← 0;
FPULastInstructionOpcode ← 0;
FPU 影響を受けるフラグ
C0、C1、C2、およびC3フラグがセーブされ、次にクリアされる。
浮動小数点例外
なし。
3-267
命令セット・リファレンス
FSAVE/FNSAVE?Store x87 FPU State ( 続き)
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-268
命令セット・リファレンス
FSCALE?Scale
説明
デスティネーション・オペランドに2 のソース・オペランド乗を掛け、結果をデスティネーション・
オペランドにストアする。デスティネーション・オペランドは、ST(0) レジスタにストアされている
浮動小数点値である。ソース・オペランドは、ST(1) レジスタの値より小さく、かつそれに最も近い
整数値である ( すなわち、ST(1) レジスタの値を0 に向かって切り捨てた、元の値に最も近い整数値
がソース・オペランドになっている)。この命令によって、2 の整数乗による高速の乗算または除算
が可能になる。それは、その乗除算が単に整数値 ( ソース・オペランド) をST(0) レジスタの値の指
数に加算することにより実現されるためである。以下の表に、オーバフローもアンダフローも発生
しないものとして、さまざまなクラスの数をスケーリングしたときに得られる結果を示す。
注:
F 有限浮動小数点値を示す。
N 整数を示す。
ほとんどの場合、指数だけが変更されて仮数は変更されない。ただし、ST(0) 内のスケーリングされ
る値がデノーマル値のときは、仮数も変更され、結果は正規化数になることがある。同様に、スケー
リング操作の結果オーバフローまたはアンダフローが発生した場合、結果の仮数はソースの仮数と
は異なることになる。
SCALE命令を使用して、以下の例に示すようにFXTRACT 命令の処理を逆にすることもできる。
FXTRACT;
FSCALE;
FSTP ST(1);
オペコード命令説明
D9 FD FSCALE ST(0) をST(1) でスケーリングする。
ST(1)
?N 0 +N
?∞ ?∞ ?∞ ?∞
ST(0) ?F ?F ?F ?F
?0 ?0 ?0 ?0
+0 +0 +0 +0
+F +F +F +F
+∞ +∞ +∞ +∞
NaN NaN NaN NaN
3-269
命令セット・リファレンス
FSCALE?Scale ( 続き)
この例では、FXTRACT命令がST(0) の値から仮数と指数を抽出し、それぞれST(0) とST(1) にストア
している。次に、FSCALE命令がST(0) 内の仮数をST(1) 内の指数でスケーリングし、FXTRACT操作
が行われる前の元の値を作成し直している。FSTP ST(1) 命令は作成し直された値で (FXTRACT命令
によって抽出された) 指数を上書きする。その結果、スタックはレジスタ[ST(0)] が1 つだけ占有され
た元の状態に戻る。
操作
ST(0) ← ST(0) ? 2ST(1);
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、またはそのフォーマットがサ
ポートされていない場合。
#D ソース・オペランドがデノーマル値である場合。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#O 結果が大きすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-270
命令セット・リファレンス
FSIN?Sine
説明
ST(0) レジスタ内のソース・オペランドの正弦を計算し、結果をST(0) レジスタにストアする。ソー
ス・オペランドはラジアン単位であり、±263の範囲内でなければならない。以下の表に、アンダフ
ローが発生しないものとして、さまざまなクラスの数の正弦を計算したときに得られる結果を示す。
注:
F 有限浮動小数点値を示す。
* 浮動小数点無効算術オペランド (#IA) 例外を示す。
ソース・オペランドが許容可能な範囲外の場合は、FPUステータス・ワード内のC2 フラグがセット
され、ST(0) レジスタの値は変わらない。この命令は、ソース・オペランドが範囲外のときに例外を
発生させない。C2 フラグを調べて範囲外条件の有無を確認するのはプログラムの責任である。ソー
ス値が±263の範囲外の場合は、2πの該当する整数倍を引くか、または除数を2πとしてFPREM命
令を使用することにより、ソース値を命令の許容範囲内に縮小することができる。上記のような縮
小を行う際のπに使用する適切な値については、『IA-32 インテルR アーキテクチャ・ソフトウェア・
デベロッパーズ・マニュアル、上巻』第8 章の「π」の説明を参照のこと。
操作
IF ST(0) < 263
THEN
C2 ← 0;
ST(0) ← sin(ST(0));
ELSE (* source operand out of range *)
C2 ← 1;
FI:
オペコード命令説明
D9 FE FSIN ST(0) をその正弦で置き換える。
SRC (ST(0)) DEST (ST(0))
?∞ *
?F ?1 〜 +1
?0 ?0
+0 +0
+F ?1 〜 +1
+∞ *
NaN NaN
3-271
命令セット・リファレンス
FSIN?Sine ( 続き)
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C2 ソース・オペランドが± 263 の範囲外の場合は1 にセットされ、範囲内
の場合は0 にクリアされる。
C0, C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、∞であるか、またはそのフォー
マットがサポートされていない場合。
#D ソース・オペランドがデノーマル値である場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-272
命令セット・リファレンス
FSINCOS?Sine and Cosine
説明
ST(0) レジスタ内のソース・オペランドの正弦と余弦を計算し、正弦をST(0) に、余弦をFPUレジス
タ・スタックのトップにプッシュする。( この命令は、FSINおよびFCOS命令を続けて実行するより
高速である。)
ソース・オペランドはラジアン単位であり、±263 の範囲内でなければならない。以下の表に、アン
ダフローが発生しないものとして、さまざまなクラスの数の正弦と余弦を計算したときに得られる
結果を示す。
注:
F 有限浮動小数点値を示す。
* 浮動小数点無効算術オペランド (#IA) 例外を示す。
ソース・オペランドが許容可能な範囲外の場合は、FPUステータス・ワード内のC2 フラグがセット
され、ST(0) レジスタの値は変わらない。この命令は、ソース・オペランドが範囲外のときに例外を
発生させない。C2 フラグを調べて範囲外条件の有無を確認するのはプログラムの責任である。ソー
ス値が±263の範囲外の場合は、2πの該当する整数倍を引くか、または除数を2πとしてFPREM命
令を使用することにより、ソース値を命令の許容範囲内に縮小することができる。上記のような縮
小を行う際のπに使用する適切な値については、『IA-32 インテルR アーキテクチャ・ソフトウェア・
デベロッパーズ・マニュアル、上巻』第8 章の「π」 の説明を参照のこと。
オペコード命令説明
D9 FB FSINCOS ST(0) の正弦と余弦を計算し、ST(0) を正弦で置き換え、余
弦をレジスタ・スタックにプッシュする。
SRC DEST
ST(0) ST(1) Cosine ST(0) Sine
?∞ * *
?F ?1 〜 +1 ?1 〜 +1
?0 +1 ?0
+0 +1 +0
+F ?1 〜 +1 ?1 〜 +1
+∞ * *
NaN NaN NaN
3-273
命令セット・リファレンス
FSINCOS?Sine and Cosine ( 続き)
操作
IF ST(0) < 263
THEN
C2 ← 0;
TEMP ← cosine(ST(0));
ST(0) ← sine(ST(0));
TOP ← TOP ? 1;
ST(0) ← TEMP;
ELSE (* source operand out of range *)
C2 ← 1;
FI:
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされ、スタック・
オーバフローが発生した場合は1 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C2 ソース・オペランドが± 263 の範囲外の場合は1 にセットされ、範囲内
の場合は0 にクリアされる。
C0, C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、∞であるか、またはそのフォー
マットがサポートされていない場合。
#D ソース・オペランドがデノーマル値である場合。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-274
命令セット・リファレンス
FSQRT?Square Root
説明
ST(0) レジスタのソース値の平方根を計算し、結果をST(0) にストアする。
以下の表に、オーバフローもアンダフローも発生しないものとして、さまざまなクラスの数の平方
根を計算したときに得られる結果を示す。
注:
F 有限浮動小数点値を示す。
* 浮動小数点無効算術オペランド (#IA) 例外を示す。
操作
ST(0) ← SquareRoot(ST(0));
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ←切り上げ。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、またはそのフォーマットがサ
ポートされていない場合。
ソース・オペランドが負の値 ( ただし、-0 は除く) である場合。
#D ソース・オペランドがデノーマル値である場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
オペコード命令説明
D9 FA FSQRT ST(0) の平方根を計算し、結果をSTO(0) にストアする。
SRC (ST(0)) DEST (ST(0))
?∞ *
?F *
?0 ?0
+0 +0
+F +F
+∞ +∞
NaN NaN
3-275
命令セット・リファレンス
FSQRT?Square Root ( 続き)
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-276
命令セット・リファレンス
FST/FSTP?Store Floating Point Value
説明
この命令は、ST(0) レジスタの値をデスティネーション・オペランドにコピーする。デスティネー
ション・オペランドには、メモリ・ロケーションまたはFPU レジスタ・スタック内の別のレジスタ
を使用できる。値をメモリにストアするときは、値は単精度浮動小数点または倍精度浮動小数点の
フォーマットに変換される。
FSTP 命令は、FST 命令と同じ操作を実行した後に、レジスタ・スタックをポップする。レジスタ・
スタックをポップするため、プロセッサはST(0) レジスタを空としてマークし、スタック・ポインタ
(TOP) を1 インクリメントする。FSTP 命令は、値をメモリに拡張倍精度浮動小数点フォーマットで
もストアできる。
デスティネーション・オペランドがメモリ・ロケーションの場合、このオペランドはデスティネー
ション値の最初のバイトがストアされるアドレスを指定する。デスティネーション・オペランドが
レジスタの場合、このオペランドはレジスタ・スタック内のスタックのトップから相対的にレジス
タを指定する。
デスティネーションのサイズが単精度浮動小数点または倍精度浮動小数点の場合、ストアされる値
の仮数は (FPU 制御ワードのRC フィールドによって指定された丸めモードに従って) デスティネー
ションの幅に丸められ、指数はデスティネーション・フォーマットの幅とバイアスに変換される。ス
トアされる値が大きすぎてデスティネーション・フォーマットで表現できない場合は、数値オーバ
フロー例外 (#0) が発生し、その例外がマスクされていない場合はデスティネーション・オペランド
には何の値もストアされない。ストアされる値がデノーマル値であっても、デノーマル例外 (#D) は
発生しない。この条件が単に数値アンダフロー例外 (#U) 条件として報告されるだけである。
ストアされる値が±0、±∞、またはNaNの場合は、仮数および指数の最下位ビットがデスティネー
ション・フォーマットに合わせて切り捨てられる。この操作では、値のアイデンティティが0、∞、
またはNaNとして保存される。
デスティネーション・オペランドが空でないレジスタの場合は、無効操作例外は発生しない。
操作
DEST ← ST(0);
IF instruction ← FSTP
THEN
PopRegisterStack;
FI;
オペコード命令説明
D9 /2 FST m32fp ST(0) をm32fp にコピーする。
DD /2 FST m64fp ST(0) をm64fp にコピーする。
DD D0+i FST ST(i) ST(0) をST(i) にコピーする。
D9 /3 FSTP m32fp ST(0) をm32fp にコピーし、レジスタ・スタックをポップする。
DD /3 FSTP m64fp ST(0) をm64fp にコピーし、レジスタ・スタックをポップする。
DB /7 FSTP m80fp ST(0) をm80fp にコピーし、レジスタ・スタックをポップする。
DD D8+i FSTP ST(i) ST(0) をST(i) にコピーし、レジスタ・スタックをポップする。
3-277
命令セット・リファレンス
FST/FSTP?Store Floating Point Value ( 続き)
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、またはそのフォーマットがサ
ポートされていない場合。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#O 結果が大きすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
3-278
命令セット・リファレンス
FST/FSTP?Store Floating Point Value ( 続き)
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-279
命令セット・リファレンス
FSTCW/FNSTCW?Store x87 FPU Control Word
注:
* 下記の「IA-32 アーキテクチャにおける互換性」の項を参照。
説明
FPU制御ワードの現在値をメモリ内の指定されたデスティネーションにストアする。FSTCW命令は、
未処理のマスクされていない浮動小数点例外の有無をチェックし、例外を処理してから、制御ワー
ドをストアする。FNSTCW命令はこのチェックを行わない。
FSTCW命令の場合、アセンブラは、2 つの命令を発行する( つまり、FWAIT 命令に続けてFNSTCW
命令)。プロセッサは、これらの命令をそれぞれ個別に実行する。これらの命令のいずれかで例外が
発生すると、セーブEIPは、例外を発生させた命令をポイントする。
IA-32 アーキテクチャにおける互換性
PentiumプロセッサまたはIntel486 プロセッサをMS-DOS互換モードで動作させたときは、( 通常の状
況下で) 実行される前にFNSTCW命令に割り込みをかけて、未処理のFPU例外を処理させることが
できる。それらの状況については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』付録D の「非同期型命令のウィンドウ内のx87 FPU 割り込み」の説明を参
照のこと。Pentium Pro プロセッサでは、FNSTCW命令にこの方法では割り込みをかけられない。
操作
DEST ← FPUControlWord;
FPU 影響を受けるフラグ
C0、C1、C2、およびC3フラグは未定義。
浮動小数点例外
なし。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
オペコード命令説明
9B D9 /7 FSTCW m2byte 未処理のマスクされていない浮動小数点定例外の有無をチェック
した後、FPU 制御ワードをm2byte にストアする。
D9 /7 FNSTCW* m2byte 未処理のマスクされていない浮動小数点定例外の有無をチェック
しないで、FPU 制御ワードをm2byte にストアする。
3-280
命令セット・リファレンス
FSTCW/FNSTCW?Store x87 FPU Control Word ( 続き)
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-281
命令セット・リファレンス
FSTENV/FNSTENV?Store x87 FPU Environment
注:
* 下記の「IA-32 アーキテクチャにおける互換性」の項を参照。
説明
現在のFPU 動作環境をデスティネーション・オペランドで指定されたメモリ・ロケーションにセー
ブし、次にすべての浮動小数点例外をマスクする。FPU動作環境は、FPU制御ワード、ステータス・
ワード、タグ・ワード、命令ポインタ、データ・ポインタ、および最後のオペコードからなっている。
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図8-9. か
ら8-12. に、プロセッサの動作モード ( 保護または実アドレス) および現在のオペランド・サイズ属性
(16 ビットまたは32 ビット) に応じて、メモリにストアされる動作環境のレイアウトが示してある。
仮想8086 モードでは、実アドレス・モードのレイアウトが使用される。
FSTENV 命令は、未処理のマスクされていない浮動小数点例外の有無をチェックし、例外を処理し
てから、FPU環境をストアする。FNSTENV命令はこのチェックを行わない。セーブされたイメージ
は、命令ストリーム内のFSTENV/FNSTENV命令より前のすべての浮動小数点命令が実行された後の
FPUの状態を反映している。
これらの命令は、FPU 命令およびデータ両ポインタへのアクセスを可能にするので、例外ハンドラ
に使用されることが多い。環境は一般的にスタックにセーブされる。環境をセーブした後にすべて
の例外をマスクすると、浮動小数点例外による例外ハンドラへの割り込みがかけられなくなる。
FSTENV命令の場合、アセンブラは、2 つの命令を発行する( つまり、FWAIT命令に続けてFNSTENV
命令)。プロセッサは、これらの命令をそれぞれ個別に実行する。これらの命令のいずれかで例外が
発生すると、セーブEIPは、例外を発生させた命令をポイントする。
IA-32 アーキテクチャにおける互換性
PentiumプロセッサまたはIntel486 プロセッサをMS-DOS互換モードで動作させたときは、( 通常の状
況下で) 実行される前にFNSTENV命令に割り込みをかけて、未処理のFPU例外を処理させることが
できる。それらの状況については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』付録D の「非同期型命令のウィンドウ内のx87 FPU 割り込み」の説明を参
照のこと。Pentium Pro プロセッサでは、FNSTENV命令にこの方法では割り込みをかけられない。
オペコード命令説明
9B D9 /6 FSTENV m14/28byte 未処理のマスクされていない浮動小数点例外の有無を
チェックした後、FPU 環境をm14byte またはm28byte にス
トアする。次に、すべての浮動小数点例外をマスクする。
D9 /6 FNSTENV* m14/28byte 未処理のマスクされていない浮動小数点例外の有無を
チェックしないで、FPU 環境をm14byte またはm28byte に
ストアする。次に、すべての浮動小数点例外をマスクする。
3-282
命令セット・リファレンス
FSTENV/FNSTENV?Store x87 FPU Environment ( 続き)
操作
DEST[FPUControlWord) ← FPUControlWord;
DEST[FPUStatusWord) ← FPUStatusWord;
DEST[FPUTagWord) ← FPUTagWord;
DEST[FPUDataPointer) ← FPUDataPointer;
DEST[FPUInstructionPointer) ← FPUInstructionPointer;
DEST[FPULastInstructionOpcode) ← FPULastInstructionOpcode;
FPU 影響を受けるフラグ
C0、C1、C2、およびC3フラグは未定義。
浮動小数点例外
なし。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
3-283
命令セット・リファレンス
FSTENV/FNSTENV?Store x87 FPU Environment ( 続き)
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-284
命令セット・リファレンス
FSTSW/FNSTSW?Store x87 FPU Status Word
注:
* 下記の「IA-32 アーキテクチャにおける互換性」の項を参照。
説明
x87 FPUステータス・ワードの現在値をデスティネーション・ロケーションにストアする。デスティ
ネーション・オペランドには、2 バイトのメモリ・ロケーションまたはAX レジスタを使用できる。
FSTSW命令は、未処理のマスクされていない浮動小数点例外の有無をチェックし、例外を処理して
から、ステータス・ワードをストアする。FNSTSW命令はこのチェックを行わない。
この命令のFNSTSW AX 形式は、主として分岐の方向がFPU 条件コード・フラグの状態に依存する
条件付き分岐 ( 例えば、FPUの比較命令、あるいはFPREM、FPREM1、またはFXAM命令の後) で使
用される。(『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上
巻』第8 章の「条件コードに基づく分岐と条件付き移動」の説明を参照のこと。) この命令は、さら
に、割り込みを使用しない環境で、( 例外フラグを調べることによって) 例外ハンドラを呼び出す場
合にも使用される。FNSTSW AX命令を実行すると、プロセッサは、AXレジスタを更新してからそ
の後の命令を実行する。したがって、AXレジスタにストアされているステータスは、その前のFPU
命令の実行結果から与えられたものであることが保証される。
FSTSW命令の場合、アセンブラは、2 つの命令を発行する( つまり、FWAIT 命令に続けてFNSTSW
命令)。プロセッサは、これらの命令をそれぞれ個別に実行する。これらの命令のいずれかで例外が
発生すると、セーブEIP は、例外を発生させた命令をポイントする。
IA-32 アーキテクチャにおける互換性
Pentium プロセッサまたはIntel486 プロセッサをMS-DOS互換モードで動作させたときは、( 通常の状
況下で) 実行される前にFNSTSW命令に割り込みをかけて、未処理のFPU 例外を処理させることが
できる。それらの状況については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』付録D の「非同期型命令のウィンドウ内のx87 FPU 割り込み」の説明を参
照のこと。Pentium 4 プロセッサまたはP6 ファミリ・プロセッサでは、FNSTSW命令にこの方法では
割り込みをかけられない。
オペコード命令説明
9B DD /7 FSTSW m2byte 未処理のマスクされていない浮動小数点例外の有無を
チェックした後、FPU ステータス・ワードをm2byte にス
トアする。
9B DF E0 FSTSW AX 未処理のマスクされていない浮動小数点例外の有無を
チェックした後、FPU ステータス・ワードをAX レジスタ
にストアする。
DD /7 FNSTSW* m2byte 未処理のマスクされていない浮動小数点例外の有無を
チェックしないで、FPU ステータス・ワードをm2byte に
ストアする。
DF E0 FNSTSW* AX 未処理のマスクされていない浮動小数点例外の有無を
チェックしないで、FPU ステータス・ワードをAX レジス
タにストアする。
3-285
命令セット・リファレンス
FSTSW/FNSTSW?Store x87 FPU Status Word ( 続き)
操作
DEST ← FPUStatusWord;
FPU 影響を受けるフラグ
C0、C1、C2、およびC3フラグは未定義。
浮動小数点例外
なし。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-286
命令セット・リファレンス
FSUB/FSUBP/FISUB?Subtract
説明
デスティネーション・オペランドからソース・オペランドを引き、結果をデスティネーション・ロ
ケーションにストアする。デスティネーション・オペランドは、常にFPUデータ・レジスタである。
ソース・オペランドには、レジスタまたはメモリ・ロケーションを使用できる。メモリ内のソース・
オペランドには、単精度浮動小数点、倍精度浮動小数点、ワード整数、またはダブルワード整数の
フォーマットを使用できる。
この命令のオペランドなしバージョンでは、ST(1) レジスタの内容からST(0) レジスタの内容を引き、
結果をST(1) レジスタにストアする。1 オペランド・バージョンでは、ST(0) レジスタの内容からメモ
リ・ロケーションの内容 ( 浮動小数点値または整数値) を引き、結果をST(0) にストアする。2 オペラ
ンド・バージョンでは、ST(i) レジスタの内容からST(0) レジスタの内容を引くか、またはその逆の
減算を行う。
FSUBP 命令は、減算の後に、追加操作としてFPUレジスタ・スタックをポップする。レジスタ・ス
タックをポップするため、プロセッサはST(0) レジスタを空としてマークし、スタック・ポインタ
(TOP) を1 インクリメントする。浮動小数点減算命令のオペランドなしバージョンでは、常にレジス
タ・スタックのポップ操作を伴う。一部のアセンブラでは、この命令のニーモニックはFSUBPでは
なくFSUBになっている。
FISUB 命令は、整数のソース・オペランドを拡張倍精度浮動小数点フォーマットに変換してから減
算を行う。
以下の表に、アンダフローもオーバフローも発生しないものとして、さまざまなクラスの数の減算
を行ったときに得られる結果を示す。この表では、DEST 値からSRC 値が引かれる (DEST - SRC ←
結果)。
同符号の2 つのオペランドの差が0 のときは、- ∞方向の丸めモードの場合を除いて、結果は+0 にな
る。- ∞方向の丸めモードの場合、結果は-0 になる。この命令は、+0 - (-0) ← +0、および-0 - (+0) ←
-0 の結果も保証する。ソース・オペランドは、整数0 のときは+0 として取り扱われる。
一方のオペランドが∞のときは、結果は予期される符号の∞になる。両方のオペランドが同じ符号
で無限大のときは、無効操作例外が発生する。
オペコード命令説明
D8 /4 FSUB m32fp ST(0) からm32fp を引き、結果をST(0) にストアする。
DC /4 FSUB m64fp ST(0) からm64fp を引き、結果をST(0) にストアする。
D8 E0+i FSUB ST(0), ST(i) ST(0) からST(i) を引き、結果をST(0) にストアする。
DC E8+i FSUB ST(i), ST(0) ST(i) からST(0) を引き、結果をST(i) にストアする。
DE E8+i FSUBP ST(i), ST(0) ST(i) からST(0) を引き、結果をST(i) にストアし、レジス
タ・スタックをポップする。
DE E9 FSUBP ST(1) からST(0) を引き、結果をST(1) にストアし、レジ
スタ・スタックをポップする。
DA /4 FISUB m32int ST(0) からm32int を引き、結果をST(0) にストアする。
DE /4 FISUB m16int ST(0) からm16int を引き、結果をST(0) にストアする。
3-287
命令セット・リファレンス
FSUB/FSUBP/FISUB?Subtract ( 続き)
注:
F 有限浮動小数点値を示す。
I 整数を示す。
* 浮動小数点無効算術オペランド (#IA) 例外 を示す。
操作
IF instruction is FISUB
THEN
DEST ← DEST ? ConvertToDoubleExtendedPrecisionFP(SRC);
ELSE (* source operand is floating-point value *)
DEST ← DEST ? SRC;
FI;
IF instruction is FSUBP
THEN
PopRegisterStack
FI;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、またはそのフォーマットがサ
ポートされていない場合。
両方のオペランドの符号が同じで、絶対値が無限大の場合。
#D ソース・オペランドがデノーマル値である場合。
SRC
?∞ ?F or ?I ?0 +0 +F or +I +∞ NaN
?∞ * ?∞ ?∞ ?∞ ?∞ ?∞ NaN
?F +∞ ±F or ±0 DEST DEST ?F ?∞ NaN
DEST ?0 +∞ ?SRC ±0 ?0 ?SRC ?∞ NaN
+0 +∞ ?SRC +0 ±0 ?SRC ?∞ NaN
+F +∞ +F DEST DEST ±F or ±0 ?∞ NaN
+∞ +∞ +∞ +∞ +∞ +∞ * NaN
NaN NaN NaN NaN NaN NaN NaN NaN
3-288
命令セット・リファレンス
FSUB/FSUBP/FISUB?Subtract ( 続き)
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#O 結果が大きすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-289
命令セット・リファレンス
FSUBR/FSUBRP/FISUBR?Reverse Subtract
説明
ソース・オペランドからデスティネーション・オペランドを引き、結果をデスティネーション・ロ
ケーションにストアする。デスティネーション・オペランドは、常にFPUデータ・レジスタである。
ソース・オペランドには、レジスタまたはメモリ・ロケーションを使用できる。メモリ内のソース・
オペランドには、単精度浮動小数点、倍精度浮動小数点、ワード整数、またはダブルワード整数の
フォーマットを使用できる。
これらの命令は、それぞれFSUB、FSUBP、およびFISUB 命令の逆の操作を行う。これらは、コー
ディングの効率向上をサポートする目的で設けられたものである。
この命令のオペランドなしバージョンでは、ST(0) レジスタの内容からST(1) レジスタの内容を引き、
結果をST(1) レジスタにストアする。1 オペランド・バージョンでは、メモリ・ロケーションの内容
( 浮動小数点値または整数値) からST(0) レジスタの内容を引き、結果をST(0) にストアする。2 オペ
ランド・バージョンでは、ST(0) レジスタの内容からST(i) レジスタの内容を引くか、またはその逆
の減算を行う。
FSUBRP 命令は、減算の後に、追加操作としてFPU レジスタ・スタックをポップする。レジスタ・
スタックをポップするため、プロセッサはST(0) レジスタを空としてマークし、スタック・ポインタ
(TOP) を1 インクリメントする。浮動小数点逆減算命令のオペランドなしバージョンでは、常にレジ
スタ・スタックのポップ操作を伴う。一部のアセンブラでは、この命令のニーモニックはFSUBRP
ではなくFSUBRになっている。
FISUBR命令は、整数のソース・オペランドを拡張倍精度浮動小数点フォーマットに変換してから減
算を行う。
以下の表に、アンダフローもオーバフローも発生しないものとして、さまざまなクラスの数の減算
を行ったときに得られる結果を示す。この表では、SRC 値からDEST 値が引かれる (SCR - DEST ←
結果)。
同符号の2 つのオペランドの差が0 のときは、- ∞方向の丸めモードの場合を除いて、結果は+0 にな
る。- ∞方向の丸めモードの場合、結果は-0 になる。この命令は、+0 - (-0) ← +0、および-0 - (+0) ←
-0 の結果も保証する。ソース・オペランドは、整数0 のときは+0 として取り扱われる。
一方のオペランドが∞のときは、結果は予期される符号の∞になる。両方のオペランドが同じ符号
で無限大のときは、無効操作例外が発生する。
オペコード命令説明
D8 /5 FSUBR m32fp m32fp からST(0) を引き、結果をST(0) にストアする。
DC /5 FSUBR m64fp m64fp からST(0) を引き、結果をST(0) にストアする。
D8 E8+i FSUBR ST(0), ST(i) ST(i) からST(0) を引き、結果をST(0) にストアする。
DC E0+i FSUBR ST(i), ST(0) ST(0) からST(i) を引き、結果をST(i) にストアする。
DE E0+i FSUBRP ST(i), ST(0) ST(0) からST(i) を引き、結果をST(i) にストアし、レジス
タ・スタックをポップする。
DE E1 FSUBRP ST(0) からST(1) を引き、結果をST(1) にストアし、レジ
スタ・スタックをポップする。
DA /5 FISUBR m32int m32int からST(0) を引き、結果をST(0) にストアする。
DE /5 FISUBR m16int m16int からST(0) を引き、結果をST(0) にストアする。
3-290
命令セット・リファレンス
FSUBR/FSUBRP/FISUBR?Reverse Subtract ( 続き)
注:
F 有限浮動小数点値を示す。
I 整数を示す。
* 浮動小数点無効算術オペランド (#IA) 例外を示す。
操作
IF instruction is FISUBR
THEN
DEST ← ConvertToDoubleExtendedPrecisionFP(SRC) ? DEST;
ELSE (* source operand is floating-point value *)
DEST ← SRC ? DEST;
FI;
IF instruction ← FSUBRP
THEN
PopRegisterStack
FI;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、またはそのフォーマットがサ
ポートされていない場合。
両方のオペランドの符号が同じで、絶対値が無限大の場合。
#D ソース・オペランドがデノーマル値である場合。
SRC
?∞ ?F or ?I ?0 +0 +F or +I +∞ NaN
?∞ * +∞ +∞ +∞ +∞ +∞ NaN
?F ?∞ ±F or ±0 ?DEST ?DEST +F +∞ NaN
DEST ?0 ?∞ SRC ±0 +0 SRC +∞ NaN
+0 ?∞ SRC ?0 ±0 SRC +∞ NaN
+F ?∞ ?F ?DEST ?DEST ±F or ±0 +∞ NaN
+∞ ?∞ ?∞ ?∞ ?∞ ?∞ * NaN
NaN NaN NaN NaN NaN NaN NaN NaN
3-291
命令セット・リファレンス
FSUBR/FSUBRP/FISUBR?Reverse Subtract ( 続き)
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#O 結果が大きすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のEM またはTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-292
命令セット・リファレンス
FTST?TEST
説明
ST(0) レジスタの値を0.0 と比較し、結果に従ってFPU ステータス・ワード内の条件コード・フラグ
C0、C2、およびC3 をセットする( 以下の表を参照)。
この命令は「順序化不可能比較」を行う。順序化不可能比較は、比較される両数値のクラスのチェッ
クも行う ( 本章の「FXAM?Examine」を参照)。ST(0) レジスタの値がNaN であるか、またはその
フォーマットが未定義の場合は、条件コード・フラグが「順序化不可能」に設定され、無効操作例
外が発生する。
ゼロの符号は無視される。すなわち、-0.0 ← +0.0 である。
操作
CASE (relation of operands) OF
Not comparable: C3, C2, C0 ← 111;
ST(0) > 0.0: C3, C2, C0 ← 000;
ST(0) < 0.0: C3, C2, C0 ← 001;
ST(0) ← 0.0: C3, C2, C0 ← 100;
ESAC;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされ、発生しな
かった場合は0 にクリアされる。
C0、C2、C3 上記の表を参照。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA ソース・オペランドがNaN 値であるか、またはそのフォーマットがサ
ポートされていない場合。
#D ソース・オペランドがデノーマル値である場合。
オペコード命令説明
D9 E4 FTST ST(0) を0.0 と比較する。
比較結果C3 C2 C0
ST(0) > 0.0 0 0 0
ST(0) < 0.0 0 0 1
ST(0) ← 0.0 1 0 0
順序化不可能1 1 1
3-293
命令セット・リファレンス
FTST?TEST ( 続き)
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-294
命令セット・リファレンス
FUCOM/FUCOMP/FUCOMPP?Unordered Compare Floating Point
Values
説明
ST(0) およびST(i) レジスタの内容の順序化不可能比較を行い、結果に従ってFPU ステータス・ワー
ド内の条件コード・フラグC0、C2、およびC3 をセットする ( 下記の表を参照)。オペランドを指定
しなかった場合は、ST(0) およびST(1) レジスタの内容が比較される。ゼロの符号は無視される。す
なわち、-0.0 ← +0.0 である。
注:
* マスクされていない無効算術オペランド (#IA) 例外が発生した場合、フラグはセットされない。
順序化不可能比較は、比較される両数値のクラスのチェックを行う ( 本章の「FXAM?Examine」を
参照)。FUCOM 命令では、一方または両方のオペランドがSNaN であるか、またはそれらのフォー
マットがサポートされていないときだけに無効算術オペランド例外 (#IA) を発生させるという点を
除いて、FUCOM命令の操作はFCOM命令の操作と同じである。QNaNの場合は、条件コード・フラ
グが順序化不可能に設定されるが、例外は発生しない。それに対して、一方または両方のオペラン
ドがいずれかの種類のNaN 値であるか、またはそれらのフォーマットがサポートされていないとき
は、FCOM命令は無効操作例外を発生させる。
FCOM 命令の場合と同様に、操作の結果によって無効算術オペランド例外が発生する場合は、例外
がマスクされている場合だけ条件コード・フラグがセットされる。
FUCOMP 命令は比較操作の後にレジスタ・スタックをポップし、FUCOMPP 命令は比較操作の後に
レジスタ・スタックを2 回ポップする。レジスタ・スタックをポップするため、プロセッサはST(0)
レジスタを空としてマークし、スタック・ポインタ (TOP) を1 インクリメントする。
オペコード命令説明
DD E0+i FUCOM ST(i) ST(0) をST(i) と比較する。
DD E1 FUCOM ST(0) をST(1) と比較する。
DD E8+i FUCOMP ST(i) ST(0) をST(i) と比較し、レジスタ・スタックをポップする。
DD E9 FUCOMP ST(0) をST(1) と比較し、レジスタ・スタックをポップする。
DA E9 FUCOMPP ST(0) をST(1) と比較し、レジスタ・スタックを2 回ポップする。
比較結果C3 C2 C0
ST0 > ST(i) 0 0 0
ST0 < ST(i) 0 0 1
ST0 ← ST(i) 1 0 0
順序化不可能1 1 1
3-295
命令セット・リファレンス
FUCOM/FUCOMP/FUCOMPP?Unordered Compare Floating Point
Values ( 続き)
操作
CASE (relation of operands) OF
ST > SRC: C3, C2, C0 ← 000;
ST < SRC: C3, C2, C0 ← 001;
ST ← SRC: C3, C2, C0 ← 100;
ESAC;
IF ST(0) or SRC ← QNaN, but not SNaN or unsupported format
THEN
C3, C2, C0 ← 111;
ELSE (* ST(0) or SRC is SNaN or unsupported format *)
#IA;
IF FPUControlWord.IM ← 1
THEN
C3, C2, C0 ← 111;
FI;
FI;
IF instruction ← FUCOMP
THEN
PopRegisterStack;
FI;
IF instruction ← FUCOMPP
THEN
PopRegisterStack;
PopRegisterStack;
FI;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
C0、C2、C3 前ページの表を参照。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA 一方または両方のオペランドがSNaN 値であるか、またはそれらの
フォーマットがサポートされていない場合。QNaN 値が検出されても、
無効オペランド例外は発生しない。
#D 一方または両方のオペランドがデノーマル値である場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-296
命令セット・リファレンス
FUCOM/FUCOMP/FUCOMPP?Unordered Compare Floating Point
Values ( 続き)
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-297
命令セット・リファレンス
FWAIT?Wait
本章の「WAIT/FWAIT?Wait」を参照のこと。
3-298
命令セット・リファレンス
FXAM?Examine
説明
ST(0) レジスタの内容を調べ、FPUステータス・ワード内の条件コード・フラグC0、C2、およびC3
を設定してST(0) レジスタの値または数値のクラスを示す ( 下表を参照)。
.
C1 フラグは、レジスタが空であるか値がロードされているかに関係なく、ST(0) の値の符号に設定さ
れる。
操作
C1 ← sign bit of ST; (* 0 for positive, 1 for negative *)
CASE (class of value or number in ST(0)) OF
Unsupported:C3, C2, C0 ← 000;
NaN: C3, C2, C0 ← 001;
Normal: C3, C2, C0 ← 010;
Infinity: C3, C2, C0 ← 011;
Zero: C3, C2, C0 ← 100;
Empty: C3, C2, C0 ← 101;
Denormal: C3, C2, C0 ← 110;
ESAC;
FPU 影響を受けるフラグ
C1 ST(0) の値の符号に設定される。
C0、C2、C3 上記の表を参照。
浮動小数点例外
なし。
オペコード命令説明
D9 E5 FXAM ST(0) の値または数値をクラスに分類する。
クラスC3 C2 C0
サポートされていない0 0 0
NaN 0 0 1
通常の有限値0 1 0
無限大0 1 1
ゼロ1 0 0
空1 0 1
デノーマル数1 1 0
3-299
命令セット・リファレンス
FXAM?Examine ( 続き)
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-300
命令セット・リファレンス
FXCH?Exchange Register Contents
説明
ST(0) レジスタの内容とST(i) レジスタの内容を入れ換える。ソース・オペランドが指定されていな
い場合は、ST(0) とST(1) の内容が入れ換えられる。
この命令によって、FPUレジスタ・スタックの値をスタックのトップである[ST(0)] に転送する単純
な手段が提供される。したがって、転送された値は、ST(0) の値だけを操作できる浮動小数点命令だ
けによって操作できるようになる。例えば、以下の命令シーケンスでは、レジスタ・スタックのトッ
プから3 番目のレジスタの平方根を計算する。
FXCH ST(3);
FSQRT;
FXCH ST(3);
操作
IF number-of-operands is 1
THEN
temp ← ST(0);
ST(0) ← SRC;
SRC ← temp;
ELSE
temp ← ST(0);
ST(0) ← ST(1);
ST(1) ← temp;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされ、発生しな
かった場合は0 にクリアされる。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
オペコード命令説明
D9 C8+i FXCH ST(i) ST(0) とST(i) の内容を入れ換える。
D9 C9 FXCH ST(0) とST(1) の内容を入れ換える。
3-301
命令セット・リファレンス
FXCH?Exchange Register Contents ( 続き)
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-302
命令セット・リファレンス
FXRSTOR?Restore x87 FPU, MMX, SSE, and SSE2 State
説明
ソース・オペランドに指定された512 バイトのメモリ・イメージから、x87 FPU、MMXテクノロジ、
XMM、MXCSR の各レジスタを再ロードする。再ロードされるデータは、FXSAVE 命令を使って予
めメモリに書き込まれていなければならない。また、再ロードされるデータの先頭のバイトは、16
バイト境界上に配置されていなければならない。表3-13. に、メモリ内の状態情報のレイアウトを示
し、FXRSTOR命令およびFXSAVE命令におけるメモリ・イメージの各フィールドを説明する。
FXRSTOR命令で参照される状態情報のイメージは、FXSAVE命令を使ってセーブしなければならな
い。あるいは、表3-13. で示されるのと同じフォーマットでなければならない。FSAVE命令やFNSAVE
命令を使ってセーブされた状態情報のイメージを参照すると、正しくない状態情報が復元される。
FXRSTOR 命令は、未処理のx87 FPU例外をフラッシュしない。FXRSTOR命令でx87 FPU状態情報
をロードするときに未処理の例外をチェックして処理するには、FXRSTOR 命令の後でFWAIT 命令
を使用する。
制御レジスタCR4 のOSFXSRビットを設定しないと、FXRSTOR命令を実行しても、XMMレジスタ
およびMXCSRレジスタの状態が復元されないことがある。この動作は、プロセッサによって異なる。
マスクされていない例外がMXCSR の状態に含まれていて、それに対応するステータス・フラグが
セットされている場合、FXRSTOR 命令でレジスタをロードしても、SIMD浮動小数点エラー条件は
発生しない。このマスクされていない例外が次に発生したときに、例外が発生する。
MXCSRレジスタのビット6 およびビット16 〜32 は予約済みとして定義されており、0 に設定する必
要がある。セーブされている状態情報のイメージのこれらのビットのいずれかに1 を書き込もうとす
ると、一般保護例外(#GP) が発生する。
操作
(x87 FPU, MMX, XMM7-XMM0, MXCSR) ← Load(SRC);
x87 FPU およびSIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。( 下記のアライメント・チェック例外[#AC] を
参照のこと)
#SS(0) SS セグメント内のアドレスが無効の場合。
オペコード命令説明
0F AE /1 FXRSTOR m512byte x87 FPU レジスタ状態、MMX テクノロジ・レジスタ状態、
XMM レジスタ状態、およびMXCSR レジスタ状態を
m512byte からリストアする。
3-303
命令セット・リファレンス
FXRSTOR?Restore x87 FPU, MMX, SSE, and SSE2 State ( 続き)
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされている場合。
#UD CR0 のEM がセットされている場合。
CPUID 機能フラグのFXSR が0 の場合。
命令の前にLOCK プリフィックスが置かれている場合。
#AC この例外がディスエーブルにされている場合、前述したようにメモリ・
オペランドが16 バイト境界上にアライメントされていなければ、一般
保護例外(#GP) が報告される。アライメント・チェック例外(#AC) がイ
ネーブルになっている場合( およびCPL が3 の場合)、#AC は必ずしも
報告されるとは限らない。これは、以下に示すように、プロセッサに
よって異なる。#AC が報告されないすべてのプロセッサでは、#GP が所
定の場所で報告される。また、アライメント・チェックの幅も、プロ
セッサによって異なる。例えば、あるプロセッサでは、2 バイトのミス
アライメントに対して#AC が報告され、2 バイト以外のすべてのミスア
ライメント(4 、18 、16 バイトのミスアライメント) に対しては#GP が
報告される。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされている場合。
CPUID 機能フラのグSSE2 が0 の場合。
命令の前にLOCKオーバーライド・プリフィックスが置かれている場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC 現行特権レベルが3 のときに、アライメントの合っていないメモリ参照
を行った場合。
3-304
命令セット・リファレンス
FXSAVE?Save x87 FPU, MMX, SSE, and SSE2 State
説明
x87 FPU、MMX テクノロジ、XMM、MXCSR の各レジスタの現在の状態を、デスティネーション・
オペランドで指定された512 バイトのメモリ・ロケーションにセーブする。表3-13. は、メモリ内の
状態情報のレイアウトを示している。
オペコード命令説明
0F AE /0 FXSAVE m512byte x87 FPU レジスタ状態、MMX テクノロジ・レジスタ状態、XMM レ
ジスタ状態、およびMXCSR レジスタ状態をm512byte に保存する。
表3-13. FXSAVE とFXRSTOR メモリ領域のレイアウト
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
予約CS FPU IP FOP FTW FSW FCW 0
MXCSR_MASK MXCSR 予約DS FPU DP 16
予約ST0/MM0 32
予約ST1/MM1 48
予約ST2/MM2 64
予約ST3/MM3 80
予約ST4/MM4 96
予約ST5/MM5 112
予約ST6/MM6 128
予約ST7/MM7 144
XMM0 160
XMM1 176
XMM2 192
XMM3 208
XMM4 224
XMM5 240
XMM6 256
XMM7 272
予約288
予約304
予約320
予約336
予約352
予約368
予約384
予約400
予約416
予約432
予約448
予約464
予約480
予約496
3-305
命令セット・リファレンス
FXSAVE?Save x87 FPU, MMX, SSE, and SSE2 State ( 続き)
デスティネーション・オペランドには、メモリ・イメージの最初のバイトが格納される。デスティ
ネーション・オペランドは、16 バイト境界上にアライメントされていなければならない。デスティ
ネーション・オペランドのアライメントが合っていないと、一般保護(#GP) 例外( 場合によっては、
アライメント・チェック例外[#AC]) が発生する。
FXSAVE 命令が使用されるのは、オペレーティング・システムがコンテキスト・スイッチを実行す
る必要がある場合、または、例外ハンドラが、x87 FPU、MMXテクノロジ、XMM、MXCSRの各レ
ジスタの現在の状態をセーブおよび検査する必要がある場合である。
表3-13. の各フィールドを以下に説明する。
FCW x87 FPU 制御ワード(16 ビット)。x87 FPU 制御ワードのレイアウトについては、
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、
上巻』の図8-6. を参照のこと。
FSW x87 FPUステータス・ワード(16 ビット)。x87 FPUステータス・ワードのレイアウ
トについては、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』の図8-4. を参照のこと。
FTW x87 FPUタグ・ワード(8 ビット)。ここにセーブされるタグ情報は短縮形式である。
詳しくは、以降の段落で説明する。x87 FPUタグ・ワードのレイアウトについては、
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、
上巻』の図8-7. を参照のこと。
FOP x87 FPU オペコード(16 ビット)。このフィールドの下位11 ビットにはオペコード
が入っており、上位5 ビットは予約されている。x87 FPUオペコード・フィールド
のレイアウトについては、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベ
ロッパーズ・マニュアル、上巻』の図8-8. を参照のこと。
FPU IP x87 FPU命令ポインタ・オフセット(32 ビット)。このフィールドの内容は、FXSAVE
命令の実行時にプロセッサのアドレス指定モードが32ビットまたは16 ビットのど
ちらであったかによって異なる。
? 32 ビット・モード - 32 ビットのIP オフセット。
? 16 ビット・モード - 下位16 ビットはIP オフセット。上位16 ビットは予約済み。
x87 FPU命令ポインタの説明については、『IA-32 インテルR アーキテクチャ・ソフ
トウェア・デベロッパーズ・マニュアル、上巻』の第8 章の「x87 FPU命令とオペ
ランド( データ) ポインタ」を参照のこと。
CS x87 FPU命令ポインタ・セレクタ(16 ビット)。
FPU DP x87 FPU 命令オペランド( データ) ポインタ・オフセット(32 ビット)。このフィー
ルドの内容は、FXSAVE命令の実行時にプロセッサのアドレス指定モードが32ビッ
トまたは16 ビットのどちらであったかによって異なる。
? 32 ビット・モード - 32 ビットのIP オフセット。
? 16 ビット・モード - 下位16 ビットはIP オフセット。上位16 ビットは予約済み。
x87 FPU オペランド・ポインタの説明については、『IA-32 インテルR アーキテク
チャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の第8 章の「x87 FPU
命令とデータ( オペランド) ポインタ」を参照のこと。
3-306
命令セット・リファレンス
FXSAVE?Save x87 FPU, MMX, SSE, and SSE2 State ( 続き)
FXSAVE 命令は、x87 FPUタグ・ワードの短縮形をFTWフィールドにセーブする( タグ・ワードを完
全な形でセーブするFSAVE命令とは異なる)。タグ情報は、トップオブスタック(TOS) の順序ではな
く、物理的なレジスタの順序(R0 からR7) でセーブされる。ただし、FXSAVE命令では、タグごとに
単一のビット(1 は有効、0 は空) しかセーブされない。例えば、現在、タグ・ワードが次のように設
定されていると仮定する。
R7 R6 R5 R4 R3 R2 R1 R0
11 xx xx xx 11 11 11 11
ここで、11B は空のスタック要素を表し、"xx" については、(00B) が有効、(01B) がゼロ、(10B) が特
殊を表す。
この例の場合、FXSAVE命令は、次に示すような8 ビットの情報しかセーブしない。
R7 R6 R5 R4 R3 R2 R1 R0
0 1 1 1 0 0 0 0
ここで、1 は有効、ゼロ、特殊のタグについてセーブされ、0 は空のタグについてセーブされる。
FXSAVE 命令の動作は、以下の点で、FSAVE命令とは異なっている。
DS x87 FPU命令オペランド( データ) ポインタ・セレクタ(16 ビット)。
MXCSR MXCSR レジスタ状態(32 ビット)。MXCSR レジスタのレイアウトについては、
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、
上巻』の図10-3. を参照のこと。制御レジスタCR4 のOSFXSR ビットが設定され
ていない場合、FXSAVE 命令を実行しても、このレジスタの値がセーブされない
場合がある。この動作は、プロセッサによって異なる。
MXCSR_
MASK
MXCSR_MASK(32 ビット)。この値を使用して、すべての予約ビットが0 に設定さ
れるように、MXCSRレジスタへ書き込む値を調整することができる。予約ビット
を0 に設定すると、FXRSTOR命令またはLDMXCSR 命令を使ってMXCSR レジス
タに書き込みを行なうときに、一般保護例外(#GP) が発生しない。MXCSR_MASK
値の決定や使用の方法については、『IA-32 インテルR アーキテクチャ・ソフトウェ
ア・デベロッパーズ・マニュアル、上巻』の第11 章の「MXCSRレジスタへの書き
込みに関するガイドライン」を参照のこと。
ST0/MM0
〜
ST7/MM7
x87 FPU/MMX テクノロジ・レジスタ。これらの80 ビットのフィールドには、
FXSAVE命令を実行する前のプロセッサの状態に応じて、x87 FPUデータ・レジス
タまたはMMXテクノロジ・レジスタの値が入る。FXSAVE命令の前にx87 FPU命
令が実行されていた場合は、x87 FPU データ・レジスタがセーブされる。MMX命
令( またはMMXテクノロジ・レジスタ上で動作していたSSE、SSE2 命令) が実行
されていた場合は、MMX テクノロジ・レジスタの値がセーブされる。MMX テク
ノロジ・レジスタの値がセーブされると、このフィールドの上位16 ビットは予約
される。
XMM0〜
XMM7
XMMレジスタ(1 フィールド当たり128 ビット)。制御レジスタCR4のOSFXSRビッ
トを設定しないと、FXSAVE命令を実行しても、これらのレジスタの値がセーブさ
れない場合がある。この動作は、プロセッサによって異なる。
3-307
命令セット・リファレンス
FXSAVE?Save x87 FPU, MMX, SSE, and SSE2 State ( 続き)
? FXSAVE命令は、未処理のマスクされていない浮動小数点例外のチェックを行わない。( この点
については、FXSAVE命令とFNSAVE命令の動作は同じである。)
? x87 FPU、MMXテクノロジ、XMM、MXCSRの各レジスタの状態がFXSAVE命令によってセー
ブされると、プロセッサは、これらのレジスタの内容を保持する。この動作のために、アプリ
ケーション・プログラムにおいてFXSAVE 命令を使って「きれいにした」x87 FPU 状態をプロ
シージャに渡すことはできない。FXSAVE命令では、現在の状態が保持されるためである。x87
FPU 状態をきれいにするには、アプリケーションにおいてFXSAVE 命令の後にFINIT 命令を明
示的に実行し、x87 FPU状態を再度初期化する必要がある。
? FXSAVE 命令でセーブされるメモリ・イメージのフォーマットは、現在のアドレス指定モー
ド(32 ビットまたは16 ビット) や、動作モード( 保護、実アドレス、またはシステム管理) に
かかわらず、一定である。この点は、アドレス指定モードや動作モードによってメモリ・イ
メージのフォーマットが変わるFSAVE命令とは異なっている。FXSAVE命令でセーブされた
メモリ・イメージは、イメージ・フォーマットが異なるため、FRSTOR 命令で正しく復元す
ることはできない。また、これと同様に、FSAVE 命令でセーブされた状態はFXRSTOR 命令
で正しく復元することはできない。
FSAVE 命令フォーマットのFTW については、以下の表を使用することにより、FTW の有効ビット
と、ストアされている80 ビットのFP データ( ストアされているデータがMMXテクノロジ・レジス
タの内容ではない場合) とから再作成することができる。
J ビットは、仮数の小数点の左側の1 ビットの2 進整数として定義される。Mビットは、仮数の小数
点以下の部分の最上位ビット( すなわち、小数点のすぐ右側のビット) として定義される。
M ビットが仮数の小数点以下の部分の最上位ビットのとき、その小数がすべて0 の場合は、M ビッ
トは0 でなければならない。
指数
すべて1
指数
すべて0
小数
すべて0
J ビットおよび
M ビット
FTW 有効
ビット
x87 FTW
0 0 0 0x 1 特殊10
0 0 0 1x 1 有効00
0 0 1 00 1 特殊10
0 0 1 10 1 有効00
0 1 0 0x 1 特殊10
0 1 0 1x 1 特殊10
0 1 1 00 1 ゼロ01
0 1 1 10 1 特殊10
1 0 0 1x 1 特殊10
1 0 0 1x 1 特殊10
1 0 1 00 1 特殊10
1 0 1 10 1 特殊10
上記のすべての有効な組み合わせ0 空11
3-308
命令セット・リファレンス
FXSAVE?Save x87 FPU, MMX, SSE, and SSE2 State ( 続き)
操作
DEST ← Save(x87 FPU, MMX, XXM7-XMM0, MXCSR);
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。( 下記のアライメント・チェック例外[#AC] の
説明を参照のこと)
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされている場合。
CPUID 機能フラグのFXSR が0 の場合。
命令の前にLOCK プリフィックスが置かれている場合。
#AC この例外がディスエーブルにされている場合、前述したようにメモリ・
オペランドが16 バイト境界上にアライメントされていなければ、一般
保護例外(#GP) が報告される。アライメント・チェック例外(#AC) がイ
ネーブルになっている場合( およびCPL が3 の場合)、#AC は必ずしも
報告されるとは限らない。これは、以下に示すように、プロセッサに
よって異なる。#AC が報告されないすべてのプロセッサでは、#GP が所
定の場所で報告される。また、アライメント・チェックの幅も、プロ
セッサによって異なる。例えば、あるプロセッサでは、2 バイトのミス
アライメントに対して#AC が報告され、2 バイト以外のすべてのミスア
ライメント(4 、18 、16 バイトのミスアライメント) に対しては#GP が
報告される。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされている場合。
CPUID 機能フラグのFXSR が0 の場合。
命令の前にLOCK プリフィックスが置かれている場合。
3-309
命令セット・リファレンス
FXSAVE?Save x87 FPU, MMX, SSE, and SSE2 State ( 続き)
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC 現行特権レベルが3 のときに、アライメントの合っていないメモリ参照
を行った場合。
プロセッサに関する注意
命令境界上で一般保護(#GP) 例外およびページ・フォルト(#PF) 例外の両方が発生した場合、プロセッ
サがこれらの例外を報告する順序は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッ
パーズ・マニュアル、下巻』の表5-2. に示すとおりである。別のIA-32 プロセッサのFXSAVE 命令で
は、この順序は異なる。
3-310
命令セット・リファレンス
FXTRACT?Extract Exponent and Significand
説明
T(0) レジスタ内のソース値をその指数と仮数に分け、指数をST(0) にストアし、仮数をレジスタ・ス
タックにプッシュする。この操作後は、新しいスタックのトップのST(0) レジスタの内容は元の仮数
の浮動小数点表現値になる。この値の符号と仮数は、ソース・オペランドにあった符号と仮数と同
じであり、指数は3FFFH ( 真のゼロの指数に対してバイアスがかけられた値) である。ST(1) レジス
タの内容は、元のオペランドの真の ( バイアスなし) 指数の浮動小数点表現値である。( この命令が
実行する操作は、IEEE推奨のlogbx 関数のスーパセットである。)
この命令とF2XM1 命令は、べき乗および範囲のスケーリング操作を行う場合に有用である。
FXTRACT 命令は、拡張倍精度浮動小数点フォーマットの数値を ( 例えば、印刷または表示するため
に) 10 進表現に変換する場合にも有用である。
浮動小数点ゼロでの除算例外 (#Z) がマスクされていて、ソース・オペランドがゼロである場合は、
指数値として- ∞がST(1) レジスタにストアされ、ソース・オペランドの符号と同じ符号の0 がST(0)
レジスタにストアされる。
操作
TEMP ← Significand(ST(0));
ST(0) ← Exponent(ST(0));
TOP← TOP ? 1;
ST(0) ← TEMP;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされ、スタック・
オーバフローが発生した場合は1 にセットされる。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
スタック・オーバフローが発生した場合。
#IA ソース・オペランドがSNaN 値であるか、またはそのフォーマットがサ
ポートされていない場合。
#Z ST(0) レジスタのオペランドが± 0。
#D ソース・オペランドがデノーマル値である場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
オペコード命令説明
D9 F4 FXTRACT ST(0) の値を指数と仮数に分け、指数をST(0) にストアし、
仮数をレジスタ・スタックにプッシュする。
3-311
命令セット・リファレンス
FXTRACT?Extract Exponent and Significand ( 続き)
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-312
命令セット・リファレンス
FYL2X?Compute y ? log2x
説明
(ST(1) ? log2(ST(0))) を計算し、結果をST(1) レジスタにストアし、FPUレジスタ・スタックをポップ
する。ST(0) のソース・オペランドはゼロでない正の数値でなければならない。
以下の表に、オーバフローもアンダフローも発生しないものとして、さまざまなクラスの数の対数
を計算したときに得られる結果を示す。
注:
F 有限浮動小数点値を示す。
* 浮動小数点無効操作 (#IA) 例外を示す。
** 浮動小数点ゼロでの除算 (#Z) 例外を示す。
ゼロでの除算例外がマスクされていて、ST(0) レジスタの内容が± 0 である場合、この命令は、ソー
ス・オペランドの符号と反対の符号の∞をST(1) レジスタに返す。
FYL2X 命令は、以下に示す組み込み関数乗算を使用して、任意の正の底をもつ対数の計算を最適化
するように設計されている。
logbx ← (log2b)-1 ? log2x
操作
ST(1) ← ST(1) ? log2ST(0);
PopRegisterStack;
オペコード命令説明
D9 F1 FYL2X ST(1) を(ST(1) ? log2ST(0)) で置き換え、レジスタ・ス
タックをポップする。
ST(0)
?∞ ?F ±0 +0 < +F < +1 +1 +F > +1 +∞ NaN
?∞ * * +∞ +∞ * ?∞ ?∞ NaN
ST(1) ?F * * ** +F ?0 ?F ?∞ NaN
?0 * * * +0 ?0 ?0 * NaN
+0 * * * ?0 +0 +0 * NaN
+F * * ** ?F +0 +F +∞ NaN
+∞ * * ?∞ ?∞ ? +∞ +∞ NaN
NaN NaN NaN NaN NaN NaN NaN NaN NaN
3-313
命令セット・リファレンス
FYL2X?Compute y ? log2x ( 続き)
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り上
げなし、1 ← 切り上げ。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA いずれかのオペランドがSNaN であるか、またはそのフォーマットがサ
ポートされていない場合。
ST(0) レジスタのソース・オペランドが負の有限値 (-0 は除く) である場
合。
#Z ST(0) レジスタのソース・オペランドが± 0 である場合。
#D ソース・オペランドがデノーマル値である場合。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#O 結果が大きすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-314
命令セット・リファレンス
FYL2XP1?Compute y ? log2(x +1)
説明
ε (0 の近似値) の対数 (ST(1) ? log2(ST(0) + 1.0)) を計算し、結果をST(1) レジスタにストアし、FPU
レジスタ・スタックをポップする。ST(0) のソース・オペランドは、下記の範囲でなければならない。
±(1 - √2/2)
ST(1) のソース・オペランドの範囲は、±∞である。ST(0) オペランドがその許容可能な範囲外の場
合は、結果は未定義になるので、ソフトウェアは例外が発生するすることに依存してはならない。特
定の状況下では、ST(0) が範囲外のとき例外が発生することがあるが、これはプロセッサ固有であり、
保証されているものではない。
以下の表に、アンダフローが発生しないものして、さまざまなクラスの数のε の対数を計算したと
きに得られる結果を示す。
注:
F 有限浮動小数点値を示す。
* 浮動小数点無効操作 (#IA) 例外を示す。
この命令は、0 の近似値ε[ST(0) レジスタの値] に対して最適精度を発揮する。εの値が小さい場合
は、(ε+1) を引数としてFYL2X命令を使用するよりも、FYL2XP1 命令を使用する方が、多くの有効
数字を残すことができる。(ε+1) という式は、複利や年金の計算によく見受けられる。結果は、ST(1)
ソース・オペランドのスケール・ファクタを含めることにより、簡単に別の対数の底の値に変換す
ることができる。以下の等式は、特定の対数の底のスケール・ファクタの計算に使用される。ここ
で、n はFYL2XP1 命令の結果に求められる対数の底である。
scale factor ← logn 2
オペコード命令説明
D9 F9 FYL2XP1 ST(1) を (ST(1) ? log2(ST(0) + 1.0)) で置き換え、レジスタ・
スタックをポップする。
ST(0)
?(1 ? ( )) 〜 ?0 ?0 +0 +0 〜 +(1 ? ( )) NaN
?∞ +∞ * * ?∞ NaN
ST(1) ?F +F +0 ?0 ?F NaN
?0 +0 +0 ?0 ?0 NaN
+0 ?0 ?0 +0 +0 NaN
+F ?F ?0 +0 +F NaN
+∞ ?∞ * * +∞ NaN
NaN NaN NaN NaN NaN NaN
2 ? 2 2 ? 2
3-315
命令セット・リファレンス
FYL2XP1?Compute y ? log2(x +1) ( 続き)
操作
ST(1) ← ST(1) ? log2(ST(0) + 1.0);
PopRegisterStack;
FPU 影響を受けるフラグ
C1 スタック・アンダフローが発生した場合は0 にセットされる。
不正確結果例外 (#P) が発生した場合は、丸めの方向を示す。0 ← 切り
上げなし、1 ← 切り上げ。
C0、C2、C3 未定義。
浮動小数点例外
#IS スタック・アンダフローが発生した場合。
#IA いずれかのオペランドがSNaN であるか、またはそのフォーマットがサ
ポートされていない場合。
#D ソース・オペランドがデノーマル値である場合。
#U 結果が小さすぎて、デスティネーション・フォーマットで表現できない
場合。
#O 結果が大きすぎて、デスティネーション・フォーマットで表現できない
場合。
#P 値がデスティネーション・フォーマットでは正確に表現できない場合。
保護モード例外
#NM CR0 のEM またはTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のEM またはTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のEM またはTS がセットされた場合。
3-316
命令セット・リファレンス
HLT?Halt
説明
命令の実行を停止し、プロセッサをHALT状態にする。イネーブルにされている割り込み(NMI およ
びSMI を含む)、デバッグ例外、BINIT# 信号、INIT# 信号、RESET#信号によって実行が再開される。
HLT 命令の後で割り込み (NMI を含む) を使用して実行を再開する場合、セーブされている命令ポイ
ンタ (CS:EIP) はHLT 命令の次の命令を指している。
HLT 命令は特権命令である。プロセッサが保護モードまたは仮想8086 モードで動作している場合は、
HLT 命令を実行するには、プログラムまたはプロシージャの特権レベルが0 でなければならない。
操作
Enter Halt state;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) 現行特権レベルが0 でない場合。
実アドレス・モード例外
なし。
仮想8086 モード例外
#GP(0) 現行特権レベルが0 でない場合。
オペコード命令説明
F4 HLT Halt
3-317
命令セット・リファレンス
IDIV?Signed Divide
説明
AX、DX:AX、EDX:EAXの各レジスタの値( 被除数) をソース・オペランド( 除数) で( 符号付きで) 除
算し、その結果をそれぞれAX(AH:AL)、DX:AX、EDX:EAX の各レジスタにストアする。ソース・
オペランドには、汎用レジスタまたはメモリ・ロケーションを使用できる。この命令の処理は、以
下の表に示すようにオペランド・サイズ( 被除数/ 除数) に依存する。
整数でない結果は0 に向かって切り捨てられる。剰余の符号は、常に被除数の符号と同じである。剰
余の絶対値は、常に除数の絶対値より小さい。オーバフローは、OF ( オーバフロー) フラグではな
く、#DE ( 除算エラー) 例外で示される。
操作
IF SRC ← 0
THEN #DE; (* divide error *)
FI;
IF OpernadSize ← 8 (* word/byte operation *)
THEN
temp ← AX / SRC; (* signed division *)
IF (temp > 7FH) OR (temp < 80H)
(* if a positive result is greater than 7FH or a negative result is less than 80H *)
THEN #DE; (* divide error *) ;
ELSE
AL ← temp;
AH ← AX SignedModulus SRC;
FI;
オペコード命令説明
F6 /7 IDIV r/m8 AX をr/m8 で符号付き除算する。結果は次のようにストアされ
る。
AL ←商、AH ←剰余
F7 /7 IDIV r/m16 DX:AX をr/m16 で符号付き除算する。結果は次のようにストアさ
れる。
AX ←商、DX ←剰余
F7 /7 IDIV r/m32 EDX:EAX をr/m32 で符号付き除算する。結果は次のようにスト
アされる。
EAX ←商、EDX ←剰余
オペランド・サイズ被除数除数商剰余商の範囲
ワード/ バイトAX r/m8 AL AH ?128 〜 +127
ダブルワード/ ワードDX:AX r/m16 AX DX ?32,768 〜 +32,767
クワッドワード/ ダブルワードEDX:EAX r/m32 EAX EDX ?231 〜 232 ? 1
3-318
命令セット・リファレンス
IDIV?Signed Divide ( 続き)
ELSE
IF OpernadSize ← 16 (* doubleword/word operation *)
THEN
temp ← DX:AX / SRC; (* signed division *)
IF (temp > 7FFFH) OR (temp < 8000H)
(* if a positive result is greater than 7FFFH *)
(* or a negative result is less than 8000H *)
THEN #DE; (* divide error *) ;
ELSE
AX ← temp;
DX ← DX:AX SignedModulus SRC;
FI;
ELSE (* quadword/doubleword operation *)
temp ← EDX:EAX / SRC; (* signed division *)
IF (temp > 7FFFFFFFH) OR (temp < 80000000H)
(* if a positive result is greater than 7FFFFFFFH *)
(* or a negative result is less than 80000000H *)
THEN #DE; (* divide error *) ;
ELSE
EAX ← temp;
EDX ← EDXE:AX SignedModulus SRC;
FI;
FI;
FI;
影響を受けるフラグ
CF、OF、SF、ZF、AF、およびPFフラグは未定義。
保護モード例外
#DE ソース・オペランド ( 除数) が0 である場合。
デスティネーションに対して符号付きの結果 ( 商) が大きすぎる場合。
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
3-319
命令セット・リファレンス
IDIV?Signed Divide ( 続き)
実アドレス・モード例外
#DE ソース・オペランド ( 除数) が0 である場合。
デスティネーションに対して符号付きの結果 ( 商) が大きすぎる場合。
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#DE ソース・オペランド ( 除数) が0 である場合。
デスティネーションに対して符号付きの結果 ( 商) が大きすぎる場合。
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-320
命令セット・リファレンス
IMUL?Signed Multiply
説明
2 つのオペランドの符号付き乗算を行う。この命令には、オペランドの数に応じて下記の3 つの形式
がある。
? 1 オペランド形式: この形式は、MUL 命令に使用されている形式と同じである。この形式では、
( 汎用レジスタまたはメモリ・ロケーション内の) ソース・オペランドに ( オペランド・サイズ
に応じて) AL、AX、またはEAXレジスタの値が掛けられ、結果がそれぞれAX、DX:AX、また
はEDX:EAXレジスタにストアされる。
? 2 オペランド形式: この形式では、デスティネーション・オペランド ( 第1 オペランド) にソー
ス・オペランド ( 第2 オペランド) が掛けられる。デスティネーション・オペランドは汎用レジ
スタであり、ソース・オペランドは即値、汎用レジスタ、またはメモリ・ロケーションである。
乗算後、結果はデスティネーション・オペランド・ロケーションにストアされる。
? 3 オペランド形式: この形式には、デスティネーション・オペランド ( 第1 オペランド) と2 つ
のソース・オペランド ( 第2 および第3 オペランド) が必要である。この形式では、第1 のソー
ス・オペランド ( 汎用レジスタまたはメモリ・ロケーション) に第2 のソース・オペランド ( 即
値) が掛けられる。結果はデスティネーション・オペランド ( 汎用レジスタ) にストアされる。
即値は、オペランドとして使用されると、デスティネーション・オペランドのフォーマットの長さ
に符号拡張される。
結果の上位半分への有効ビットのキャリーがあったときは、CF およびOFフラグがセットされる。結
果が結果の下位半分に収まったときは、CF およびOFフラグがクリアされる。
オペコード命令説明
F6 /5 IMUL r/m8 AX← AL? r/m バイト
F7 /5 IMUL r/m16 DX:AX ← AX ? r/m ワード
F7 /5 IMUL r/m32 EDX:EAX ← EAX ? r/m ダブルワード
0F AF /r IMUL r16,r/m16 ワード・レジスタ ← ワード・レジスタ ?r/m ワード
0F AF /r IMUL r32,r/m32 ダブルワード・レジスタ ← ダブルワード・レジスタ ? r/m ダ
ブルワード
6B /r ib IMUL r16,r/m16,imm8 ワード・レジスタ ← r/m16 ? 符号拡張即値バイト
6B /r ib IMUL r32,r/m32,imm8 ダブルワード・レジスタ ← r/m32 ? 符号拡張即値バイト
6B /r ib IMUL r16,imm8 ワード・レジスタ ← ワード・レジスタ ? 符号拡張即値バイト
6B /r ib IMUL r32,imm8 ダブルワード・レジスタ ← ダブルワード・レジスタ ? 符号拡
張即値バイト
69 /r iw IMUL r16,r/m16,imm16 ワード・レジスタ ← r/m16 ? 即値ワード
69 /r id IMUL r32,r/m32,imm32 ダブルワード・レジスタ ← r/m32 ? 即値ダブルワード
69 /r iw IMUL r16,imm16 ワード・レジスタ ← r/m16 ? 即値ワード
69 /r id IMUL r32,imm32 ダブルワード・レジスタ ← r/m32 ? 即値ダブルワード
3-321
命令セット・リファレンス
IMUL?Signed Multiply ( 続き)
IMUL 命令の3 つの形式は、積の長さが両オペランドの長さの2 倍に計算される点ではみな同じであ
る。1 オペランド形式では、結果はデスティネーションの長さでストアされる。しかし、2 および3
オペランド形式では、結果はデスティネーションの長さに切り捨てられてからデスティネーション・
レジスタにストアされる。この切り捨てがあるので、CF またはOF フラグをテストして、有効ビッ
トの脱落がないよう保証する必要がある。
2 および3 オペランド形式には、積の下位半分は両オペランドの符号のありなしに関係なく同じなの
で、符号なしオペランドに対しても使用できる。ただし、CF およびOF フラグを使用して、結果の
上位半分が非ゼロであるかどうかを判定することはできない。
操作
IF (NumberOfOperands ← 1)
THEN IF (OperandSize ← 8)
THEN
AX ← AL ? SRC (* signed multiplication *)
IF ((AH ← 00H) OR (AH ← FFH))
THEN CF ← 0; OF ← 0;
ELSE CF ← 1; OF ← 1;
FI;
ELSE IF OperandSize ← 16
THEN
DX:AX ← AX ? SRC (* signed multiplication *)
IF ((DX ← 0000H) OR (DX ← FFFFH))
THEN CF ← 0; OF ← 0;
ELSE CF ← 1; OF ← 1;
FI;
ELSE (* OperandSize ← 32 *)
EDX:EAX ← EAX ? SRC (* signed multiplication *)
IF ((EDX ← 00000000H) OR (EDX ← FFFFFFFFH))
THEN CF ← 0; OF ← 0;
ELSE CF ← 1; OF ← 1;
FI;
FI;
ELSE IF (NumberOfOperands ← 2)
THEN
temp ← DEST ? SRC (* signed multiplication; temp is double DEST size*)
DEST ← DEST ? SRC (* signed multiplication *)
IF temp ≠ DEST
THEN CF ← 1; OF ← 1;
ELSE CF ← 0; OF ← 0;
FI;
3-322
命令セット・リファレンス
IMUL?Signed Multiply ( 続き)
ELSE (* NumberOfOperands ← 3 *)
DEST ← SRC1 ? SRC2 (* signed multiplication *)
temp ← SRC1 ? SRC2 (* signed multiplication; temp is double SRC1 size *)
IF temp ≠ DEST
THEN CF ← 1; OF ← 1;
ELSE CF ← 0; OF ← 0;
FI;
FI;
FI;
影響を受けるフラグ
この命令の1 オペランド形式では、結果の上位半分への有効ビットのキャリーがあるときにCFおよ
びOF フラグがセットされ、結果が結果の下位半分に収まるときはクリアされる。命令の2 および3
オペランド形式では、デスティネーション・オペランド・サイズに合わせるために結果を切り捨て
なければならないときはCF およびOF フラグがセットされ、結果がデスティネーション・オペラン
ド・サイズに収まるときはクリアされる。SF、ZF、AF、およびPF フラグは未定義。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-323
命令セット・リファレンス
IN?Input from Port
説明
値をソース・オペランド ( 第2 オペランド) で指定されたI/O ポートからデスティネーション・オペ
ランド ( 第1 オペランド) にコピーする。ソース・オペランドには、バイト即値またはDXレジスタ
を使用できる。デスティネーション・オペランドには、アクセスされるポートのサイズ (8、16、ま
たは32 ビット) に応じて、それぞれ AL、AX、またはEAXレジスタを使用できる。ソース・オペラ
ンドとしてDX レジスタを使用すると、I/O ポート・アドレス0 〜 65,535 をアクセスすることができ
る。バイト即値を使用すると、I/Oポート・アドレス0 〜255 をアクセスすることができる。
アクセスされるI/Oポートのサイズは、8 ビットのI/O ポートではオペコードによって決まり、16 ビッ
トおよび32 ビットのI/O ポートでは命令のオペランド・サイズ属性によって決まる。
マシン・コード・レベルでは、I/O 命令は、8 ビットのI/Oポートをアクセスするときは短くなる。こ
の場合、ポート・アドレスの上位8 ビットは0 になる。
この命令は、プロセッサのI/Oアドレス空間にあるI/O ポートのアクセスだけに有用である。I/O アド
レス空間にあるI/Oポートのアクセスに関する詳細については、『IA-32 インテルR アーキテクチャ・
ソフトウェア・デベロッパーズ・マニュアル、上巻』第12章「入出力」を参照のこと。
操作
IF ((PE ← 1) AND ((CPL > IOPL) OR (VM ← 1)))
THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)
IF (Any I/O Permission Bit for I/O port being accessed ← 1)
THEN (* I/O operation is not allowed *)
#GP(0);
ELSE ( * I/O operation is allowed *)
DEST ← SRC; (* Reads from selected I/O port *)
FI;
ELSE (Real Mode or Protected Mode with CPL ? IOPL *)
DEST ← SRC; (* Reads from selected I/O port *)
FI;
影響を受けるフラグ
なし。
オペコード命令説明
E4 ib IN AL,imm8 I/O ポート・アドレスimm8 からAL にバイトを入力する。
E5 ib IN AX,imm8 I/O ポート・アドレスimm8 からAX にバイトを入力する。
E5 ib IN EAX,imm8 I/O ポート・アドレスimm8 からEAX にバイトを入力する。
EC IN AL,DX DX 内のI/O ポートからAL にバイトを入力する。
ED IN AX,DX DX 内のI/O ポートからAX にワードを入力する。
ED IN EAX,DX DX 内のI/O ポートからEAX にダブルワードを入力する。
3-324
命令セット・リファレンス
IN?Input from Port ( 続き)
保護モード例外
#GP(0) CPL がI/O 特権レベル (IOPL) より大きく ( 低い特権をもつ)、アクセス
されるI/O ポートのTSS にある対応するI/O パーミッション・ビットの
いずれかが1 である場合。
実アドレス・モード例外
なし。
仮想8086 モード例外
#GP(0) アクセスされるI/O ポートのTSS にある対応するI/O パーミッション・
ビットのいずれかが1 である場合。
3-325
命令セット・リファレンス
INC?Increment by 1
説明
CF フラグの状態を変えないで、デスティネーション・オペランドに1 を加える。デスティネーショ
ン・オペランドには、レジスタまたはメモリ・ロケーションを使用できる。この命令では、CF フラ
グの状態を変えることなくループ・カウンタを更新できる。(CF フラグを更新するインクリメント操
作を行うには、値1 の即値オペランドを使用してADD命令を実行する。)
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
DEST ← DEST +1;
影響を受けるフラグ
CFフラグは影響を受けない。OF、SF、ZF、AF、およびPFフラグが結果に従ってセットされる。
保護モード例外
#GP(0) デスティネーション・オペランドが書き込み不可能なセグメントにある
場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
オペコード命令説明
FE /0 INC r/m8 r/m バイトを1 インクリメントする。
FF /0 INC r/m16 r/m ワードを1 インクリメントする。
FF /0 INC r/m32 r/m ダブルワードを1 インクリメントする。
40+ rw INC r16 ワード・レジスタを1 インクリメントする。
40+ rd INC r32 ダブルワード・レジスタを1 インクリメントする。
3-326
命令セット・リファレンス
INC?Increment by 1 ( 続き)
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-327
命令セット・リファレンス
INS/INSB/INSW/INSD?Input from Port to String
説明
データをソース・オペランド ( 第2 オペランド) で指定されたI/O ポートからデスティネーション・
オペランド ( 第1 オペランド) にコピーする。ソース・オペランドはI/O ポート・アドレス (0 〜65,535)
であり、そのアドレスはDX レジスタから読み取られる。デスティネーション・オペランドはメモ
リ・ロケーションであり、そのアドレスは (32 ビットまたは16 ビットの命令のアドレス・サイズ属
性に応じて) ES:(E)DI またはES:DI レジスタから読み取られる。ES セグメントはセグメント・オー
バライド・プリフィックスでオーバライドすることはできない。 アクセスされるI/O ポートのサイズ
( すなわち、ソース・オペランドおよびデスティネーション・オペランドのサイズ) は、8 ビットの
I/O ポートではオペコードによって決まり、16 ビットまたは32 ビットのI/O ポートでは命令のオペ
ランド・サイズ属性によって決まる。
アセンブリ・コード・レベルでは、この命令の「明示オペランド」形式と「オペランドなし」形式
という2 つの形式が使用できる。(INS ニーモニックで指定される) 明示オペランド形式 では、ソー
ス・オペランドおよびデスティネーション・オペランドを明示的に指定できる。この場合、ソース・
オペランドは、 "DX" でなければならない。デスティネーション・オペランドは、I/Oポートのサイズ
とデスティネーション・アドレスを示す記号でなければならない。この明示オペランド形式は、ド
キュメンテーションを可能にするために設けられたものであるが、この形式によって提供されるド
キュメンテーションは誤解を招く場合があるので注意されたい。すなわち、デスティネーション・
オペランドの記号はオペランドの正しいタイプ ( サイズ: バイト、ワード、またはダブルワード) を
指定しなければならないが、正しいロケーションを指定する必要はない。ロケーションは、常に
ES:(E)DI レジスタによって指定されるので、INS 命令を実行する前に、これらのレジスタに正しく
ロードされていなければならない。
オペランドなし形式は、INS 命令のバイト、ワード、およびダブルワード各バージョンの「ショート
形式」を提供する。この場合も、DXレジスタがソース・オペランドであると想定され、ES:(E)DI レ
ジスタがデスティネーション・オペランドであると想定される。I/O ポートのサイズは、INSB ( バイ
ト)、INSW ( ワード)、またはINSD ( ダブルワード) の各ニーモニックの選択で指定される。
オペコード命令説明
6C INS m8, DX バイトをDX で指定された I/O ポートからES:(E)DI で指定
されたメモリ・ロケーションに入力する。
6D INS m16, DX ワードをDX で指定された I/O ポートからES:(E)DI で指定
されたメモリ・ロケーションに入力する。
6D INS m32, DX ダブルワードをDX で指定された I/O ポートからES:(E)DI
で指定されたメモリ・ロケーションに入力する。
6C INSB バイトをDX で指定された I/O ポートからES:(E)DI で指定
されたメモリ・ロケーションに入力する。
6D INSW ワードをDX で指定された I/O ポートからES:(E)DI で指定
されたメモリ・ロケーションに入力する。
6D INSD ダブルワードをDX で指定された I/O ポートからES:(E)DI
で指定されたメモリ・ロケーションに入力する。
3-328
命令セット・リファレンス
INS/INSB/INSW/INSD?Input from Port to String ( 続き)
バイト、ワード、またはダブルワードがI/Oポートからメモリ・ロケーションに転送された後、(E)DI
レジスタはEFLAGSレジスタ内のEFフラグの設定に従って自動的にインクリメントまたはデクリメ
ントされる。(DF フラグが0 である場合、(E)DI レジスタはインクリメントされる。DFフラグが1 で
ある場合、(E)DI レジスタはデクリメントされる。) (E)DI レジスタは、バイト操作の場合は1、ワー
ド操作の場合は2、ダブルワード操作の場合は4、それぞれインクリメントまたはデクリメントされ
る。
INS、INSB、INSW、およびINSD命令は、前にREP プリフィックスを付けることにより、ECXバイ
ト、ワード、またはダブルワードのブロック入力を行うことができる。REP プリフィックスの説明
については、本章の「REP/REPE/REPZ/REPNE /REPNZ?Repeat String Operation Prefix」を参照のこと。
これらの命令は、プロセッサのI/Oアドレス空間にあるI/O ポートのアクセスだけに有用である。I/O
アドレス空間にあるI/Oポートへのアクセスに関する詳細については、『IA-32 インテルR アーキテク
チャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』第12 章「入出力」を参照のこと。
操作
IF ((PE ← 1) AND ((CPL > IOPL) OR (VM ← 1)))
THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)
IF (Any I/O Permission Bit for I/O port being accessed ← 1)
THEN (* I/O operation is not allowed *)
#GP(0);
ELSE ( * I/O operation is allowed *)
DEST ← SRC; (* Reads from I/O port *)
FI;
ELSE (Real Mode or Protected Mode with CPL ? IOPL *)
DEST ← SRC; (* Reads from I/O port *)
FI;
IF (byte transfer)
THEN IF DF ← 0
THEN (E)DI ← (E)DI + 1;
ELSE (E)DI ← (E)DI ? 1;
FI;
ELSE IF (word transfer)
THEN IF DF ← 0
THEN (E)DI ← (E)DI + 2;
ELSE (E)DI ← (E)DI ? 2;
FI;
ELSE (* doubleword transfer *)
THEN IF DF ← 0
THEN (E)DI ← (E)DI + 4;
ELSE (E)DI ← (E)DI ? 4;
FI;
FI;
FI;
3-329
命令セット・リファレンス
INS/INSB/INSW/INSD?Input from Port to String ( 続き)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) CPL がI/O 特権レベル (IOPL) より大きく ( 低い特権をもつ)、アクセス
されるI/O ポートのTSS にある対応するI/O パーミッション・ビットの
いずれかが1 である場合。
デスティネーションが書き込み不可能なセグメントにある場合。
ES セグメントにイリーガルなメモリ・オペランドの実効アドレスが指
定された場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) アクセスされるI/O ポートのTSS にある対応するI/O パーミッション・
ビットのいずれかが1 である場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-330
命令セット・リファレンス
INT n/INTO/INT 3?Call to Interrupt Procedure
説明
INT n 命令は、デスティネーション・オペランドで指定された割り込みハンドラまたは例外ハンドラ
へのコールを生成する ( 詳細は『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・
マニュアル、上巻』第6 章の「割り込みと例外」の説明を参照)。デスティネーション・オペランド
は、8 ビットの符号なし中間値としてコード化された0 から255 までの割り込みベクタ番号を指定す
る。各割り込みベクタ番号は、IDT 内の特定のゲート・ディスクリプタへのインデックスになる。最
初の32 個の割り込みベクタ番号はシステム用に予約されている。これらの割り込みの一部は、内部的
に生成される例外に使用される。
INT n 命令は、ソフトウェアによって生成される割り込みハンドラへのコールを実行するための一般
的ニーモニックである。INTO 命令は、オーバフロー例外 (#OF)、すなわち割り込みベクタ番号4 を
コールするための特殊ニーモニックである。オーバフロー割り込みはEFLAGS レジスタ内のOF フラ
グをチェックし、それが1 にセットされている場合にオーバフロー例外ハンドラをコールする。
INT 3 命令は、デバッグ例外ハンドラをコールすることを目的とする特別な1 バイト・オペコード
(CC) を生成する。( この1 バイト形式は、それを使用すると他のコードを上書きすることなく、他の
1 バイト命令を含めて任意の命令の最初のバイトをブレークポイントで置き換えることができるの
で、貴重である。) デバッグ・ブレークポイントとしてのその機能をさらにサポートするため、CC
オペコードで生成される割り込みも、下記の点で正規のソフトウェア割り込みとは異なっている。
? VMEモードでは割り込みのリダイレクションが行われない。割り込みは、保護モード・ハンド
ラによって処理される。
? 仮想8086 モードのIOPL チェックが行われない。割り込みは、IOPL レベルでのフォルトを一切
伴わないで取り扱われる。
INT 3 の「通常」の2 バイト・オペコード (CD03) には、これらの特別な機能はないので注意された
い。インテルおよびMicrosoft アセンブラは、どのニーモニックからもCD03 オペコードを生成しな
い。その代わりに、このオペコードは直接数値コード定義または自己修正コードによって作成でき
る。
(INTOおよびINT 3 命令を含む) INT n命令の処理は、CALL命令によって行われるfar コールの処理に
似ている。最も大きな相違は、INT n 命令では、EFLAGS レジスタがリターン・アドレスより先にス
タックにプッシュされる点である。( リターン・アドレスは、CS およびEIP レジスタの現在値からな
るfar アドレスである。) 割り込みプロシージャからのリターンはIRET命令で処理される。IRET命令
はスタックからEFLAGS情報とリターン・アドレスをポップする。
オペコード命令説明
CC INT 3 割り込み3 - デバッガへのトラップ。
CD ib INT imm8 割り込みベクタ番号の即値バイトによる指定。
CE INTO 割り込み4 - オーバフロー・フラグが1 である場合。
3-331
命令セット・リファレンス
INT n/INTO/INT 3?Call to Interrupt Procedure ( 続き)
割り込みベクタ番号は、割り込みディスクリプタ・テーブル (IDT) 内の特定の割り込みディスクリプ
タを指定する。すなわち、この番号はIDT へのインデックスの役割を果たす。それに対し、選択さ
れた割り込みディスクリプタの内容は割り込みまたは例外ハンドラ・プロシージャへのポインタに
なっている。保護モードでは、IDTは、それぞれが割り込みゲート、トラップ・ゲート、またはタス
ク・ゲートである8 バイトのディスクリプタの配列になっている。実アドレス・モードでは、IDTは、
それぞれ選択されたセグメント内のプロシージャを直接指示先とする4 バイトのfar ポインタ (2 バイ
トのコード・セレクタと2 バイトの命令ポインタ) の配列である。( 実アドレス・モードでは、IDTは
割り込みベクタ・テーブルと呼ばれ、そのポインタがコール先割り込みベクタと呼ばれる。)
以下のデシジョン・テーブルは、テーブルの太線より上の部分の条件が与えられた場合に、太線よ
り下の部分のどの処置が行われるかを示している。デシジョン・テーブルの下の部分の各Y は、こ
の命令の「操作」の項に定義されているプロシージャ (#GPを除く) を表している。
注:
- 　　無指定。
Y 　　Yes) 行われる処置。
空白　 処置は行われない。
PE 0 1 1 1 1 1 1 1
VM ? ? ? ? ? 0 1 1
IOPL ? ? ? ? ? ? <3 =3
DPL/CPL の関係? DPL<
CPL
? DPL>
CPL
DPL=
CPL or C
DPL<
CPL &
NC
? ?
割り込みタイプ? S/W ? ? ? ? ? ?
ゲート・タイプ? ? タスクトラップ
または
割り込み
トラップ
または
割り込み
トラップ
または
割り込み
トラップ
または
割り込み
トラップ
または
割り込み
REAL-ADDRESSMODE
Y
PROTECTED-MODE Y Y Y Y Y Y Y
TRAP-ORINTERRUPT-
GATE
Y Y Y Y Y
INTER-PRIVILEGELEVEL-
INTERRUPT
Y
INTRA-PRIVILEGELEVEL-
INTERRUPT
Y
INTERRUPT-FROMVIRTUAL-
8086-
MODE
Y
TASK-GATE Y
#GP Y Y Y
3-332
命令セット・リファレンス
INT n/INTO/INT 3?Call to Interrupt Procedure ( 続き)
プロセッサが仮想8086 モードで動作しているときには、IOPLによってINT n 命令の処置が決まる。
IOPLが3 より小さい場合は、プロセッサは一般保護例外 (#GP) を生成する。IOPL が3 の場合は、プ
ロセッサは特権レベル0 への保護モード割り込みを実行する。特権レベル0 への保護モード割り込
みを実行するためには、割り込みゲートのDPLが3 に設定されていて、かつ割り込みハンドラ・プ
ロシージャのターゲットCPL が0 でなければならない。
割り込みディスクリプタ・テーブル・レジスタ (IDTR) には、IDT のベース・リニア・アドレスおよ
び範囲を指定する。プロセッサの電源投入後またはリセット後のIDTRの初期ベース・アドレス値は
0 である。
操作
以下の操作の記述は、INT n 命令およびINTO命令だけでなく、外部割り込みおよび例外にも適用さ
れる。
IF PE=0
THEN
GOTO REAL-ADDRESS-MODE;
ELSE (* PE=1 *)
IF (VM=1 AND IOPL < 3 AND INT n)
THEN
#GP(0);
ELSE (* protected mode or virtual-8086 mode interrupt *)
GOTO PROTECTED-MODE;
FI;
FI;
REAL-ADDRESS-MODE:
IF ((DEST ? 4) + 3) is not within IDT limit THEN #GP; FI;
IF stack not large enough for a 6-byte return information THEN #SS; FI;
Push (EFLAGS[15:0]);
IF ← 0; (* Clear interrupt flag *)
TF ← 0; (* Clear trap flag *)
AC ← 0; (*Clear AC flag*)
Push(CS);
Push(IP);
(* No error codes are pushed *)
CS ← IDT(Descriptor (vector_number ? 4), selector));
EIP ← IDT(Descriptor (vector_number ? 4), offset)); (* 16 bit offset AND 0000FFFFH *)
END;
PROTECTED-MODE:
IF ((DEST ? 8) + 7) is not within IDT limits
OR selected IDT descriptor is not an interrupt-, trap-, or task-gate type
THEN #GP((DEST ? 8) + 2 + EXT);
(* EXT is bit 0 in error code *)
FI;
3-333
命令セット・リファレンス
INT n/INTO/INT 3?Call to Interrupt Procedure ( 続き)
IF software interrupt (* generated by INT n, INT 3, or INTO *)
THEN
IF gate descriptor DPL < CPL
THEN #GP((vector_number ? 8) + 2 );
(* PE=1, DPL<CPL, software interrupt *)
FI;
FI;
IF gate not present THEN #NP((vector_number ? 8) + 2 + EXT); FI;
IF task gate (* specified in the selected interrupt table descriptor *)
THEN GOTO TASK-GATE;
ELSE GOTO TRAP-OR-INTERRUPT-GATE; (* PE=1, trap/interrupt gate *)
FI;
END;
TASK-GATE: (* PE=1, task gate *)
Read segment selector in task gate (IDT descriptor);
IF local/global bit is set to local
OR index not within GDT limits
THEN #GP(TSS selector);
FI;
Access TSS descriptor in GDT;
IF TSS descriptor specifies that the TSS is busy (low-order 5 bits set to 00001)
THEN #GP(TSS selector);
FI;
IF TSS not present
THEN #NP(TSS selector);
FI;
SWITCH-TASKS (with nesting) to TSS;
IF interrupt caused by fault with error code
THEN
IF stack limit does not allow push of error code
THEN #SS(0);
FI;
Push(error code);
FI;
IF EIP not within code segment limit
THEN #GP(0);
FI;
END;
TRAP-OR-INTERRUPT-GATE
Read segment selector for trap or interrupt gate (IDT descriptor);
IF segment selector for code segment is null
THEN #GP(0H + EXT); (* null selector with EXT flag set *)
FI;
3-334
命令セット・リファレンス
INT n/INTO/INT 3?Call to Interrupt Procedure ( 続き)
IF segment selector is not within its descriptor table limits
THEN #GP(selector + EXT);
FI;
Read trap or interrupt handler descriptor;
IF descriptor does not indicate a code segment
OR code segment descriptor DPL > CPL
THEN #GP(selector + EXT);
FI;
IF trap or interrupt gate segment is not present,
THEN #NP(selector + EXT);
FI;
IF code segment is non-conforming AND DPL < CPL
THEN IF VM=0
THEN
GOTO INTER-PRIVILEGE-LEVEL-INTERRUPT;
(* PE=1, interrupt or trap gate, nonconforming *)
(* code segment, DPL<CPL, VM=0 *)
ELSE (* VM=1 *)
IF code segment DPL ≠ 0 THEN #GP(new code segment selector); FI;
GOTO INTERRUPT-FROM-VIRTUAL-8086-MODE;
(* PE=1, interrupt or trap gate, DPL<CPL, VM=1 *)
FI;
ELSE (* PE=1, interrupt or trap gate, DPL ? CPL *)
IF VM=1 THEN #GP(new code segment selector); FI;
IF code segment is conforming OR code segment DPL ← CPL
THEN
GOTO INTRA-PRIVILEGE-LEVEL-INTERRUPT;
ELSE
#GP(CodeSegmentSelector + EXT);
(* PE=1, interrupt or trap gate, nonconforming *)
(* code segment, DPL>CPL *)
FI;
FI;
END;
INTER-PREVILEGE-LEVEL-INTERRUPT
(* PE=1, interrupt or trap gate, non-conforming code segment, DPL<CPL *)
(* Check segment selector and descriptor for stack of new privilege level in current TSS *)
IF current TSS is 32-bit TSS
THEN
TSSstackAddress ← (new code segment DPL ? 8) + 4
IF (TSSstackAddress + 7) > TSS limit
THEN #TS(current TSS selector); FI;
NewSS ← TSSstackAddress + 4;
NewESP ← stack address;
3-335
命令セット・リファレンス
INT n/INTO/INT 3?Call to Interrupt Procedure ( 続き)
ELSE (* TSS is 16-bit *)
TSSstackAddress ← (new code segment DPL ? 4) + 2
IF (TSSstackAddress + 4) > TSS limit
THEN #TS(current TSS selector); FI;
NewESP ← TSSstackAddress;
NewSS ← TSSstackAddress + 2;
FI;
IF segment selector is null THEN #TS(EXT); FI;
IF segment selector index is not within its descriptor table limits
OR segment selector's RPL ≠ DPL of code segment,
THEN #TS(SS selector + EXT);
FI;
Read segment descriptor for stack segment in GDT or LDT;
IF stack segment DPL ≠ DPL of code segment,
OR stack segment does not indicate writable data segment,
THEN #TS(SS selector + EXT);
FI;
IF stack segment not present THEN #SS(SS selector+EXT); FI;
IF 32-bit gate
THEN
IF new stack does not have room for 24 bytes (error code pushed)
OR 20 bytes (no error code pushed)
THEN #SS(segment selector + EXT);
FI;
ELSE (* 16-bit gate *)
IF new stack does not have room for 12 bytes (error code pushed)
OR 10 bytes (no error code pushed);
THEN #SS(segment selector + EXT);
FI;
FI;
IF instruction pointer is not within code segment limits THEN #GP(0); FI;
SS:ESP ← TSS(NewSS:NewESP) (* segment descriptor information also loaded *)
IF 32-bit gate
THEN
CS:EIP ← Gate(CS:EIP); (* segment descriptor information also loaded *)
ELSE (* 16-bit gate *)
CS:IP ← Gate(CS:IP); (* segment descriptor information also loaded *)
FI;
IF 32-bit gate
THEN
Push(far pointer to old stack); (* old SS and ESP, 3 words padded to 4 *);
Push(EFLAGS);
Push(far pointer to return instruction); (* old CS and EIP, 3 words padded to 4*);
Push(ErrorCode); (* if needed, 4 bytes *)
3-336
命令セット・リファレンス
INT n/INTO/INT 3?Call to Interrupt Procedure ( 続き)
ELSE(* 16-bit gate *)
Push(far pointer to old stack); (* old SS and SP, 2 words *);
Push(EFLAGS(15..0]);
Push(far pointer to return instruction); (* old CS and IP, 2 words *);
Push(ErrorCode); (* if needed, 2 bytes *)
FI;
CPL ← CodeSegmentDescriptor(DPL);
CS(RPL) ← CPL;
IF interrupt gate
THEN IF ← 0 (* interrupt flag to 0 (disabled) *); FI;
TF ← 0;
VM ← 0;
RF ← 0;
NT ← 0;
END;
INTERRUPT-FROM-VIRTUAL-8086-MODE:
(* Check segment selector and descriptor for privilege level 0 stack in current TSS *)
IF current TSS is 32-bit TSS
THEN
TSSstackAddress ← (new code segment DPL ? 8) + 4
IF (TSSstackAddress + 7) > TSS limit
THEN #TS(current TSS selector); FI;
NewSS ← TSSstackAddress + 4;
NewESP ← stack address;
ELSE (* TSS is 16-bit *)
TSSstackAddress ← (new code segment DPL ? 4) + 2
IF (TSSstackAddress + 4) > TSS limit
THEN #TS(current TSS selector); FI;
NewESP ← TSSstackAddress;
NewSS ← TSSstackAddress + 2;
FI;
IF segment selector is null THEN #TS(EXT); FI;
IF segment selector index is not within its descriptor table limits
OR segment selector's RPL ≠ DPL of code segment,
THEN #TS(SS selector + EXT);
FI;
Access segment descriptor for stack segment in GDT or LDT;
IF stack segment DPL ≠ DPL of code segment,
OR stack segment does not indicate writable data segment,
THEN #TS(SS selector + EXT);
FI;
IF stack segment not present THEN #SS(SS selector+EXT); FI;
3-337
命令セット・リファレンス
INT n/INTO/INT 3?Call to Interrupt Procedure ( 続き)
IF 32-bit gate
THEN
IF new stack does not have room for 40 bytes (error code pushed)
OR 36 bytes (no error code pushed);
THEN #SS(segment selector + EXT);
FI;
ELSE (* 16-bit gate *)
IF new stack does not have room for 20 bytes (error code pushed)
OR 18 bytes (no error code pushed);
THEN #SS(segment selector + EXT);
FI;
FI;
IF instruction pointer is not within code segment limits THEN #GP(0); FI;
tempEFLAGS ← EFLAGS;
VM ← 0;
TF ← 0;
RF ← 0;
IF service through interrupt gate THEN IF ← 0; FI;
TempSS ← SS;
TempESP ← ESP;
SS:ESP ← TSS(SS0:ESP0); (* Change to level 0 stack segment *)
(* Following pushes are 16 bits for 16-bit gate and 32 bits for 32-bit gates *)
(* Segment selector pushes in 32-bit mode are padded to two words *)
Push(GS);
Push(FS);
Push(DS);
Push(ES);
Push(TempSS);
Push(TempESP);
Push(TempEFlags);
Push(CS);
Push(EIP);
GS ← 0; (*segment registers nullified, invalid in protected mode *)
FS ← 0;
DS ← 0;
ES ← 0;
CS ← Gate(CS);
IF OperandSize=32
THEN
EIP ← Gate(instruction pointer);
ELSE (* OperandSize is 16 *)
EIP ← Gate(instruction pointer) AND 0000FFFFH;
FI;
(* Starts execution of new routine in Protected Mode *)
END;
3-338
命令セット・リファレンス
INT n/INTO/INT 3?Call to Interrupt Procedure ( 続き)
INTRA-PRIVILEGE-LEVEL-INTERRUPT:
(* PE=1, DPL ← CPL or conforming segment *)
IF 32-bit gate
THEN
IF current stack does not have room for 16 bytes (error code pushed)
OR 12 bytes (no error code pushed); THEN #SS(0);
FI;
ELSE (* 16-bit gate *)
IF current stack does not have room for 8 bytes (error code pushed)
OR 6 bytes (no error code pushed); THEN #SS(0);
FI;
IF instruction pointer not within code segment limit THEN #GP(0); FI;
IF 32-bit gate
THEN
Push (EFLAGS);
Push (far pointer to return instruction); (* 3 words padded to 4 *)
CS:EIP ← Gate(CS:EIP); (* segment descriptor information also loaded *)
Push (ErrorCode); (* if any *)
ELSE (* 16-bit gate *)
Push (FLAGS);
Push (far pointer to return location); (* 2 words *)
CS:IP ← Gate(CS:IP); (* segment descriptor information also loaded *)
Push (ErrorCode); (* if any *)
FI;
CS(RPL) ← CPL;
IF interrupt gate
THEN
IF ← 0; FI;
TF ← 0;
NT ← 0;
VM ← 0;
RF ← 0;
FI;
END;
影響を受けるフラグ
EFLAGSレジスタがスタックにプッシュされる。INT命令が実行されるときのプロセッサの動作モー
ドに応じて、IF、TF、NT、AC、RF、およびVMフラグがクリアされることがある (「操作」の項を
参照)。割り込みがタスク・ゲートを使用する場合は、新しいタスクのTSS内のEFLAGS イメージに
よる制御のもとに、任意のフラグがセットまたはクリアされることがある。
保護モード例外
#GP(0) IDT、割り込みゲート、トラップ・ゲート、またはタスク・ゲート内の
命令ポインタがコード・セグメントの範囲を超えている場合。
3-339
命令セット・リファレンス
INT n/INTO/INT 3?Call to Interrupt Procedure ( 続き)
#GP( セレクタ) 割り込みゲート、トラップ・ゲート、またはタスク・ゲート内のセグメ
ント・セレクタがヌルの場合。
割り込みゲート、トラップ・ゲート、タスク・ゲート、コード・セグメ
ント、またはTSS のセグメント・セレクタ・インデックスがそのディス
クリプタ・テーブルの範囲外の場合。
割り込みベクタ番号がIDT の範囲外の場合。
IDT ディスクリプタが、割り込みディスクリプタ、トラップ・ディスク
リプタ、またはタスク・ディスクリプタのいずれでもない場合。
INT n、INT 3、またはINTO 命令によって割り込みが発生し、割り込み
ディスクリプタ、トラップ・ディスクリプタ、またはタスク・ディスク
リプタのDPL がCPL より小さい場合。
割り込みゲートまたはトラップ・ゲート内のセグメント・セレクタの指
示先がコード・セグメントのセグメント・ディスクリプタでない場合。
TSS のセグメント・セレクタのローカル/ グローバル・ビットがローカ
ルに設定されている場合。
TSS のセグメント・ディスクリプタが、そのTSS がビジーであるか使用
不可能であると指定している場合。
#SS(0) リターン・アドレス、フラグ、またはエラー・コードをスタックにプッ
シュして、スタック・セグメントの範囲を超えたが、スタック・スイッ
チが行われなかった場合。
#SS( セレクタ) SS レジスタがロードされようとしたとき、指示先のセグメントが存在
しないとマークされていた場合。
スタック・スイッチが発生したとき、リターン・アドレス、フラグ、エ
ラー・コード、またはスタック・セグメント・ポインタをプッシュして、
新しいスタック・セグメントの範囲を超えた場合。
#NP( セレクタ) コード・セグメント、割り込みゲート、トラップ・ゲート、タスク・
ゲート、またはTSS が存在しない場合。
#TS( セレクタ) TSS 内のスタック・セグメント・セレクタのRPL が、割り込みゲートま
たはトラップ・ゲートによってアクセスされるコード・セグメントの
DPL に等しくない場合。
TSS 内のスタック・セグメント・セレクタによって指されているスタッ
ク・セグメント・ディスクリプタのDPL が割り込みゲートまたはトラッ
プ・ゲートのコード・セグメント・ディスクリプタのDPL に等しくな
い場合。
TSS 内のスタック・セグメント・セレクタがヌルの場合。
TSS のスタック・セグメントが書き込み可能なデータ・セグメントでな
い場合。
スタック・セグメントのセグメント・セレクタ・インデックスがディス
クリプタ・テーブルの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-340
命令セット・リファレンス
INT n/INTO/INT 3?Call to Interrupt Procedure ( 続き)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
割り込みベクタ番号がIDT の範囲外の場合。
#SS プッシュ時スタック範囲違反の場合。
リターン・アドレス、フラグ、またはエラー・コードをスタックにプッ
シュして、スタック・セグメントの範囲を超えた場合。
仮想8086 モード例外
#GP(0) (INT n、INTO、またはBOUND 命令の場合) IOPL が3 より小さいか、ま
たは割り込みゲート、トラップ・ゲート、またはタスク・ゲートのディ
スクリプタのDPL が3 に等しくない場合。
IDT、割り込みゲート、トラップ・ゲート、またはタスク・ゲート内の
命令ポインタがコード・セグメントの範囲を超えている場合。
#GP( セレクタ) 割り込みゲート、トラップ・ゲート、またはタスク・ゲート内のセグメ
ント・セレクタがヌルの場合。
割り込みゲート、トラップ・ゲート、タスク・ゲート、コード・セグメ
ント、またはTSS のセグメント・セレクタ・インデックスがそのディス
クリプタ・テーブルの範囲外の場合。
割り込みベクタ番号がIDT の範囲外の場合。
IDT ディスクリプタが、割り込みディスクリプタ、トラップ・ディスクリ
プタ、またはタスク・ディスクリプタのいずれでもない場合。
INT n 命令によって割り込みが発生し、割り込みディスクリプタ、トラッ
プ・ディスクリプタ、またはタスク・ディスクリプタのDPL がCPL よ
り小さい場合。
割り込みゲートまたはトラップ・ゲート内のセグメント・セレクタの指
示先がコード・セグメントのセグメント・ディスクリプタでない場合。
TSS のセグメント・セレクタのローカル/ グローバル・ビットがローカ
ルに設定されている場合。
#SS( セレクタ) SS レジスタがロードされようとしたとき、指示先のセグメントが存在
しないとマークされていた場合。
リターン・アドレス、フラグ、エラー・コード、スタック・セグメン
ト・ポインタ、またはデータ・セグメントをプッシュして、スタック・
セグメントの範囲を超えた場合。
#NP( セレクタ) コード・セグメント、割り込みゲート、トラップ・ゲート、タスク・
ゲート、またはTSS が存在しない場合。
3-341
命令セット・リファレンス
INT n/INTO/INT 3?Call to Interrupt Procedure ( 続き)
#TS( セレクタ) TSS 内のスタック・セグメント・セレクタのRPL が、割り込みゲートま
たはトラップ・ゲートによってアクセスされるコード・セグメントの
DPL に等しくない場合
TSS のスタック・セグメントに対するスタック・セグメント・ディスク
リプタのDPL が、割り込みゲートまたはトラップ・ゲートのコード・セ
グメント・ディスクリプタのDPL に等しくない場合。
TSS 内のスタック・セグメント・セレクタがヌルの場合。
TSS のスタック・セグメントが書き込み可能なデータ・セグメントでな
い場合。
スタック・セグメントのセグメント・セレクタ・インデックスがディス
クリプタ・テーブルの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#BP INT 3 命令が実行された場合。
#OF INTO 命令が実行され、OF フラグがセットされた場合。
3-342
命令セット・リファレンス
INVD?Invalidate Internal Caches
説明
プロセッサの内部キャッシュを無効化 ( フラッシュ) し、外部キャッシュにも自身をフラッシュする
よう指示する特殊機能バス・サイクルを発行する。内部キャッシュに保持されていたデータはメイ
ン・メモリにライトバックされない。
この命令を実行した後、プロセッサは、外部キャッシュのフラッシュ操作の完了を待たずに命令の
実行を継続する。キャッシュ・フラッシュ信号への応答は、ハードウェアによって行う。
INVD命令は特権命令である。プロセッサが保護モードで動作している場合は、この命令を実行する
には、プログラムまたはプロシージャのCPLが0 でなければならない。
この命令を使用する際は注意が必要である。内部でキャッシュされ、メイン・メモリにライトバッ
クされないデータは失われる。( 例えば、メイン・メモリとのキャッシュ・コヒーレンシが重要でな
いテストやフォルト・リカバリのように) 修正したキャッシュ・ラインをライトバックしないで
キャッシュをフラッシュする特別な必要性、またはそうすることに特別な利点がなければ、ソフト
ウェアにはWBINVD命令を使用すべきである。
IA-32 アーキテクチャにおける互換性
INVD命令はプロセッサに依存し、その機能は将来のIA-32 プロセッサでは異なってサポートされる
可能性もある。この命令は、Intel486 プロセッサより以前のIA-32 プロセッサではサポートされてい
ない。
操作
Flush(InternalCaches);
SignalFlush(ExternalCaches);
Continue (* Continue execution);
影響を受けるフラグ
なし。
保護モード例外
#GP(0) 現行特権レベルが0 でない場合。
実アドレス・モード例外
なし。
仮想8086 モード例外
#GP(0) INVD 命令は仮想8086 モードで実行することはできない。
オペコード命令説明
0F 08 INVD 内部キャッシュをフラッシュする。外部キャッシュのフ
ラッシュを開始させる。
3-343
命令セット・リファレンス
INVLPG?Invalidate TLB Entry
説明
ソース・オペランドで指定されたトランスレーション・ルックアサイド・バッファ (TLB) のエント
リを無効化 ( フラッシュ) する。ソース・オペランドは、メモリ・アドレスである。プロセッサは、
そのアドレスが含まれるページを判定し、そのページのTLBエントリをフラッシュする。
INVLPG命令は特権命令である。プロセッサが保護モードで動作している場合は、この命令を実行す
るには、プログラムまたはプロシージャのCPLが0 でなければならない。
通常、INVLPG 命令は指定されたページのTLB エントリだけをフラッシュするが、場合によっては
TLB 全体をフラッシュすることもある。TLB をフラッシュする操作の詳細については、本章の
「MOV?Move to/from Control Registers」を参照のこと。
IA-32 アーキテクチャにおける互換性
INVLPG命令はプロセッサに依存し、その機能は将来のIA-32 プロセッサでは異なってサポートされ
る可能性もある。この命令は、Intel486 プロセッサより以前のIA-32 プロセッサではサポートされて
いない。
操作
Flush(RelevantTLBEntries);
Continue (* Continue execution);
影響を受けるフラグ
なし。
保護モード例外
#GP(0) 現行特権レベルが0 でない場合。
#UD オペランドがレジスタである場合。
実アドレス・モード例外
#UD オペランドがレジスタである場合。
仮想8086 モード例外
#GP(0) INVLPG 命令は仮想8086 モードで実行することはできない。
オペコード命令説明
0F 01/7 INVLPG m m があるページのTLB エントリを無効にする。
3-344
命令セット・リファレンス
IRET/IRETD?Interrupt Return
説明
プログラム制御を例外ハンドラまたは割り込みハンドラから、例外、外部割り込み、またはソフト
ウェア生成割り込みによって中断されていたプログラムまたはプロシージャに戻す。これらの命令
は、ネストされたタスクからのリターンを行う場合にも使用される。( ネストされたタスクは、CALL
命令を使用してタスク・スイッチを開始したとき、あるいは割り込みまたは例外によって割り込み
ハンドラまたは例外ハンドラへのタスク・スイッチが行われたときに作成される。) 『IA-32 インテ
ルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、下巻』第6 章の「タスクのリン
ク」を参照のこと。
IRET およびIRETD は同じオペコードに対する2 つのニーモニックである。IRETD ニーモニック
(Interrupt Return Double) は、32 ビットのオペランド・サイズを使用しているときに割り込みから戻る
場合に使用することを目的としているが、ほとんどのアセンブラはどちらのオペランド・サイズに
対してもIRET ニーモニックを使用している。
実アドレス・モードでは、IRET 命令は割り込みによって中断されていたプログラムまたはプロシー
ジャへのfar リターンを実行する。この操作では、プロセッサはスタックからEIP、CS、およびEFLAGS
のレジスタにそれぞれリターン命令ポインタ、リターン・コード・セグメント・セレクタ、および
EFLAGS イメージをポップし、次に中断されていたプログラムまたはプロシージャの実行を再開す
る。
保護モードでは、IRET 命令の処理は、EFLAGS レジスタ内のNT ( ネストされたタスク) およびVM
フラグの設定と、現在のスタックにストアされているEFLAGS イメージのVM フラグの設定に依存
する。これらのフラグの設定に応じて、プロセッサは以下のタイプの割り込みリターンのいずれか
を実行する。
? 仮想8086 モードからのリターン
? 仮想8086 モードへのリターン
? 特権レベル内のリターン
? 特権レベル間のリターン
? ネストされたタスクからのリターン( タスク・スイッチ)
NT フラグ (EFLAGS レジスタ) がクリアされている場合は、IRET 命令はタスク・スイッチなしに割
り込みプロシージャからのfar リターンを実行する。リターン先のコード・セグメントは、特権レベ
ルが ( スタックからポップされたコード・セグメント・セレクタのRPL フィールドによって示され
る) 割り込みハンドラ・ルーチンの特権レベル以下でなければならない。実アドレス・モードの割り
込みリターンの場合と同様に、IRET命令はリターン命令ポインタ、リターン・コード・セグメント・
セレクタ、およびEFLAGS イメージをスタックからそれぞれEIP、CS、およびEFLAGS のレジスタ
にポップし、次に中断されていたプログラムまたはプロシージャの実行を再開する。別の特権レベ
ルへのリターンの場合は、IRET 命令は、スタックからさらにスタック・ポインタとSS レジスタも
ポップしてからプログラムの実行を再開する。仮想8086 モードへのリターンの場合は、プロセッサ
はスタックからさらにデータ・セグメント・レジスタもポップする。
オペコード命令説明
CF IRET 割り込みリターン ( オペランド・サイズ: 16 ビット)。
CF IRETD 割り込みリターン ( オペランド・サイズ: 32 ビット)。
3-345
命令セット・リファレンス
IRET/IRETD?Interrupt Return ( 続き)
NTフラグがセットされている場合は、IRET命令はネストされたタスク(CALL 命令、割り込み、また
は例外でコールされたタスク) からコール元または中断されていたタスクへのタスク・スイッチ( リ
ターン) を実行する。IRET命令を実行しているタスクの更新後の状態がそのTSS にセーブされる。こ
のタスクが後で再起動される場合は、IRET 命令の次からコードが実行される。
操作
IF PE ← 0
THEN
GOTO REAL-ADDRESS-MODE:;
ELSE
GOTO PROTECTED-MODE;
FI;
REAL-ADDRESS-MODE;
IF OperandSize ← 32
THEN
IF top 12 bytes of stack not within stack limits THEN #SS; FI;
IF instruction pointer not within code segment limits THEN #GP(0); FI;
EIP ← Pop();
CS ← Pop(); (* 32-bit pop, high-order 16 bits discarded *)
tempEFLAGS ← Pop();
EFLAGS ← (tempEFLAGS AND 257FD5H) OR (EFLAGS AND 1A0000H);
ELSE (* OperandSize ← 16 *)
IF top 6 bytes of stack are not within stack limits THEN #SS; FI;
IF instruction pointer not within code segment limits THEN #GP(0); FI;
EIP ← Pop();
EIP ← EIP AND 0000FFFFH;
CS ← Pop(); (* 16-bit pop *)
EFLAGS[15:0] ← Pop();
FI;
END;
PROTECTED-MODE:
IF VM ← 1 (* Virtual-8086 mode: PE=1, VM=1 *)
THEN
GOTO RETURN-FROM-VIRTUAL-8086-MODE; (* PE=1, VM=1 *)
FI;
IF NT ← 1
THEN
GOTO TASK-RETURN;( *PE=1, VM=0, NT=1 *)
FI;
IF OperandSize=32
THEN
IF top 12 bytes of stack not within stack limits
3-346
命令セット・リファレンス
IRET/IRETD?Interrupt Return ( 続き)
THEN #SS(0)
FI;
tempEIP ← Pop();
tempCS ← Pop();
tempEFLAGS ← Pop();
ELSE (* OperandSize ← 16 *)
IF top 6 bytes of stack are not within stack limits
THEN #SS(0);
FI;
tempEIP ← Pop();
tempCS ← Pop();
tempEFLAGS ← Pop();
tempEIP ← tempEIP AND FFFFH;
tempEFLAGS ← tempEFLAGS AND FFFFH;
FI;
IF tempEFLAGS(VM) ← 1 AND CPL=0
THEN
GOTO RETURN-TO-VIRTUAL-8086-MODE;
(* PE=1, VM=1 in EFLAGS image *)
ELSE
GOTO PROTECTED-MODE-RETURN;
(* PE=1, VM=0 in EFLAGS image *)
FI;
RETURN-FROM-VIRTUAL-8086-MODE:
(* Processor is in virtual-8086 mode when IRET is executed and stays in virtual-8086 mode *)
IF IOPL=3 (* Virtual mode: PE=1, VM=1, IOPL=3 *)
THEN IF OperandSize ← 32
THEN
IF top 12 bytes of stack not within stack limits THEN #SS(0); FI;
IF instruction pointer not within code segment limits THEN #GP(0); FI;
EIP ← Pop();
CS ← Pop(); (* 32-bit pop, high-order 16 bits discarded *)
EFLAGS ← Pop();
(*VM,IOPL,VIP,and VIF EFLAGS bits are not modified by pop *)
ELSE (* OperandSize ← 16 *)
IF top 6 bytes of stack are not within stack limits THEN #SS(0); FI;
IF instruction pointer not within code segment limits THEN #GP(0); FI;
EIP ← Pop();
EIP ← EIP AND 0000FFFFH;
CS ← Pop(); (* 16-bit pop *)
EFLAGS[15:0] ← Pop(); (* IOPL in EFLAGS is not modified by pop *)
FI;
ELSE
#GP(0); (* trap to virtual-8086 monitor: PE=1, VM=1, IOPL<3 *)
FI;
3-347
命令セット・リファレンス
IRET/IRETD?Interrupt Return ( 続き)
END;
RETURN-TO-VIRTUAL-8086-MODE:
(* Interrupted procedure was in virtual-8086 mode: PE=1, VM=1 in flags image *)
IF top 24 bytes of stack are not within stack segment limits
THEN #SS(0);
FI;
IF instruction pointer not within code segment limits
THEN #GP(0);
FI;
CS ← tempCS;
EIP ← tempEIP;
EFLAGS ← tempEFLAGS
TempESP ← Pop();
TempSS ← Pop();
ES ← Pop(); (* pop 2 words; throw away high-order word *)
DS ← Pop(); (* pop 2 words; throw away high-order word *)
FS ← Pop(); (* pop 2 words; throw away high-order word *)
GS ← Pop(); (* pop 2 words; throw away high-order word *)
SS:ESP ← TempSS:TempESP;
(* Resume execution in Virtual-8086 mode *)
END;
TASK-RETURN: (* PE=1, VM=1, NT=1 *)
Read segment selector in link field of current TSS;
IF local/global bit is set to local
OR index not within GDT limits
THEN #GP(TSS selector);
FI;
Access TSS for task specified in link field of current TSS;
IF TSS descriptor type is not TSS or if the TSS is marked not busy
THEN #GP(TSS selector);
FI;
IF TSS not present
THEN #NP(TSS selector);
FI;
SWITCH-TASKS (without nesting) to TSS specified in link field of current TSS;
Mark the task just abandoned as NOT BUSY;
IF EIP is not within code segment limit
THEN #GP(0);
FI;
END;
PROTECTED-MODE-RETURN: (* PE=1, VM=0 in flags image *)
IF return code segment selector is null THEN GP(0); FI;
IF return code segment selector addrsses descriptor beyond descriptor table limit
3-348
命令セット・リファレンス
IRET/IRETD?Interrupt Return ( 続き)
THEN GP(selector; FI;
Read segment descriptor pointed to by the return code segment selector
IF return code segment descriptor is not a code segment THEN #GP(selector); FI;
IF return code segment selector RPL < CPL THEN #GP(selector); FI;
IF return code segment descriptor is conforming
AND return code segment DPL > return code segment selector RPL
THEN #GP(selector); FI;
IF return code segment descriptor is not present THEN #NP(selector); FI:
IF return code segment selector RPL > CPL
THEN GOTO RETURN-OUTER-PRIVILEGE-LEVEL;
ELSE GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL
FI;
END;
RETURN-TO-SAME-PRIVILEGE-LEVEL: (* PE=1, VM=0 in flags image, RPL=CPL *)
IF EIP is not within code segment limits THEN #GP(0); FI;
EIP ← tempEIP;
CS ← tempCS; (* segment descriptor information also loaded *)
EFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) ← tempEFLAGS;
IF OperandSize=32
THEN
EFLAGS(RF, AC, ID) ← tempEFLAGS;
FI;
IF CPL ? IOPL
THEN
EFLAGS(IF) ← tempEFLAGS;
FI;
IF CPL ← 0
THEN
EFLAGS(IOPL) ← tempEFLAGS;
IF OperandSize=32
THEN EFLAGS(VM, VIF, VIP) ← tempEFLAGS;
FI;
FI;
END;
RETURN-TO-OUTER-PRIVILGE-LEVEL:
IF OperandSize=32
THEN
IF top 8 bytes on stack are not within limits THEN #SS(0); FI;
ELSE (* OperandSize=16 *)
IF top 4 bytes on stack are not within limits THEN #SS(0); FI;
FI;
Read return segment selector;
IF stack segment selector is null THEN #GP(0); FI;
IF return stack segment selector index is not within its descriptor table limits
3-349
命令セット・リファレンス
IRET/IRETD?Interrupt Return ( 続き)
THEN #GP(SSselector); FI;
Read segment descriptor pointed to by return segment selector;
IF stack segment selector RPL ≠ RPL of the return code segment selector
IF stack segment selector RPL ≠ RPL of the return code segment selector
OR the stack segment descriptor does not indicate a a writable data segment;
OR stack segment DPL ≠ RPL of the return code segment selector
THEN #GP(SS selector);
FI;
IF stack segment is not present THEN #SS(SS selector); FI;
IF tempEIP is not within code segment limit THEN #GP(0); FI;
EIP ← tempEIP;
CS ← tempCS;
EFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) ← tempEFLAGS;
IF OperandSize=32
THEN
EFLAGS(RF, AC, ID) ← tempEFLAGS;
FI;
IF CPL ? IOPL
THEN
EFLAGS(IF) ← tempEFLAGS;
FI;
IF CPL ← 0
THEN
EFLAGS(IOPL) ← tempEFLAGS;
IF OperandSize=32
THEN EFLAGS(VM, VIF, VIP) ← tempEFLAGS;
FI;
FI;
CPL ← RPL of the return code segment selector;
FOR each of segment register (ES, FS, GS, and DS)
DO;
IF segment register points to data or non-conforming code segment
AND CPL > segment descriptor DPL (* stored in hidden part of segment register *)
THEN (* segment register invalid *)
SegmentSelector ← 0; (* null segment selector *)
FI;
OD;
END:
影響を受けるフラグ
プロセッサの動作モードに応じて、EFLAGS レジスタ内のすべてのフラグおよびフィールドが修正
される可能性がある。ネストされたタスクから以前のタスクへのリターンを実行した場合は、
EFLAGSレジスタは前のタスクのTSS にストアされていたEFLAGS イメージに従って修正される。
3-350
命令セット・リファレンス
IRET/IRETD?Interrupt Return ( 続き)
保護モード例外
#GP(0) リターン・コードまたはスタック・セグメント・セレクタがヌルの場合。
リターン命令ポインタがリターン・コード・セグメントの範囲内にない
場合。
#GP( セレクタ) セグメント・セレクタ・インデックスがディスクリプタ・テーブルの範
囲外の場合。
リターン・コード・セグメント・セレクタのRPL がCPL より大きい場合。
コンフォーミング・コード・セグメントのDPL がリターン・コード・セ
グメント・セレクタのRPL より大きい場合。
非コンフォーミング・コード・セグメントのDPL がコード・セグメン
ト・セレクタのRPL に等しくない場合。
スタック・セグメント・ディスクリプタのDPL がリターン・コード・セ
グメント・セレクタのRPL に等しくない場合。
スタック・セグメントが書き込み可能なデータ・セグメントでない場合。
スタック・セグメント・セレクタのRPL がリターン・コード・セグメン
ト・セレクタのRPL に等しくない場合。
コード・セグメントのセグメント・ディスクリプタが、それがコード・
セグメントであることを示していない場合。
TSS のセグメント・セレクタのローカル/ グローバル・ビットがローカ
ルに設定されている場合。
TSS のセグメント・ディスクリプタが、そのTSS がビジーであるか使用
不可能であると指定している場合。
#SS(0) スタックのトップ・バイトがスタックの範囲内にない場合。
#NP( セレクタ) リターン・コードまたはスタック・セグメントが存在しない場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルにさ
れていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP リターン命令ポインタがリターン・コード・セグメントの範囲内にない
場合。
#SS スタックのトップ・バイトがスタックの範囲内にない場合。
3-351
命令セット・リファレンス
IRET/IRETD?Interrupt Return ( 続き)
仮想8086 モード例外
#GP(0) リターン命令ポインタがリターン・コード・セグメントの範囲内にない
場合。
IOPL が3 に等しくない場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#SS(0) スタックのトップ・バイトがスタックの範囲内にない場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-352
命令セット・リファレンス
Jcc?Jump if Condition Is Met
オペコード命令説明
77 cb JA rel8 より上 (CF=0 およびZF=0) の場合short ジャンプする。
73 cb JAE rel8 より上か等しい (CF=0) 場合short ジャンプする。
72 cb JB rel8 より下 (CF=1) の場合short ジャンプする。
76 cb JBE rel8 より下か等しい (CF=1 またはZF=1) 場合short ジャンプする。
72 cb JC rel8 キャリーがある (CF=1) 場合short ジャンプする。
E3 cb JCXZ rel8 CX レジスタが0 の場合short ジャンプする。
E3 cb JECXZ rel8 ECX レジスタが0 の場合short ジャンプする。
74 cb JE rel8 等しい (ZF=1) 場合short ジャンプする。
7F cb JG rel8 より大きい (ZF=0 およびSF=OF) 場合short ジャンプする。
7D cb JGE rel8 より大きいか等しい (SF=OF) 場合short ジャンプする。
7C cb JL rel8 より小さい (SF<>OF) 場合short ジャンプする。
7E cb JLE rel8 より小さいか等しい (ZF=1 またはSF<>OF) 場合short ジャンプする。
76 cb JNA rel8 より上でない (CF=1 またはZF=1) 場合short ジャンプする。
72 cb JNAE rel8 より上でなく等しくない (CF=1) 場合short ジャンプする。
73 cb JNB rel8 より下でない (CF=0) 場合short ジャンプする。
77 cb JNBE rel8 より下でなく等しくない(CF=0 およびZF=0) 場合short ジャンプする。
73 cb JNC rel8 キャリーがない (CF=0) 場合short ジャンプする。
75 cb JNE rel8 等しくない (ZF=0) 場合short ジャンプする。
7E cb JNG rel8 より大きくない (ZF=1 またはSF<>OF) 場合short ジャンプする。
7C cb JNGE rel8 より大きくなく等しくない (SF<>OF) 場合short ジャンプする。
7D cb JNL rel8 より小さくない (SF=OF) 場合short ジャンプする。
7F cb JNLE rel8 より小さくなく等しくない (ZF=0 およびSF=OF) 場合short ジャンプす
る。
71 cb JNO rel8 オーバフローがない (OF=0) 場合short ジャンプする。
7B cb JNP rel8 パリティがない (PF=0) 場合short ジャンプする。
79 cb JNS rel8 符号がない (SF=0) 場合short ジャンプする。
75 cb JNZ rel8 ゼロでない (ZF=0) 場合short ジャンプする。
70 cb JO rel8 オーバフローがある (OF=1) 場合short ジャンプする。
7A cb JP rel8 パリティがある (PF=1) 場合short ジャンプする。
7A cb JPE rel8 パリティが偶数 (PF=1) の場合short ジャンプする。
7B cb JPO rel8 パリティが奇数 (PF=0) の場合short ジャンプする。
78 cb JS rel8 符号がある (SF=1) 場合short ジャンプする。
74 cb JZ rel8 ゼロ (ZF=1) の場合short ジャンプする。
0F 87 cw/cd JA rel16/32 より上 (CF=0 およびZF=0) の場合near ジャンプ。
0F 83 cw/cd JAE rel16/32 より上か等しい (CF=0) 場合near ジャンプする。
0F 82 cw/cd JB rel16/32 より下 (CF=1) の場合near ジャンプする。
0F 86 cw/cd JBE rel16/32 より下か等しい (CF=1 またはZF=1) 場合near ジャンプする。
0F 82 cw/cd JC rel16/32 キャリーがある (CF=1) 場合near ジャンプする。
0F 84 cw/cd JE rel16/32 等しい (ZF=1) 場合near ジャンプする。
0F 84 cw/cd JZ rel16/32 ゼロ (ZF=1) の場合near ジャンプする。
3-353
命令セット・リファレンス
Jcc?Jump if Condition Is Met ( 続き)
説明
EFLAGSレジスタ内のステータス・フラグ (CF、OF、PF、SF、およびZF) の1 つ以上の状態を調べ、
それらのフラグが指定された状態 ( 条件) にある場合は、デスティネーション・オペランドによって
指定されたターゲット命令へのジャンプを実行する。各命令に特定の条件コード (cc) が対応してお
り、テストされる条件を示している。条件が満たされなかった場合は、ジャンプは実行されず、Jcc
命令の次の命令から実行が継続される。
ターゲット命令は相対オフセット (EIP レジスタ内の命令ポインタの現在値に相対的な符号付きオ
フセット) で指定される。相対オフセット (rel8、rel16、またはrel32) は、アセンブリ・コードでは
一般的にラベルとして指定されるが、マシン・コード・レベルでは、符号付きの8 ビットまたは32
ビットの即値としてコード化され、命令ポインタに加算される。この命令のコーディングは、-128
〜+127 のオフセットの場合に最も効率がよい。オペランド・サイズ属性が16 である場合は、EIP レ
ジスタの上位2 バイトは0 にクリアされ、命令ポインタの最大サイズは16 ビットになる。
各Jcc ニーモニックの条件は、前2 ページの表の「説明」欄に示してある。「より小さい」および「よ
り大きい」という表現は、符号付き整数の比較に使用され、「より上」および「より下」という表現
は、符号なし整数の比較に使用されている。
オペコード命令説明
0F 8F cw/cd JG rel16/32 より大きい (ZF=0 およびSF=OF) 場合near ジャンプする。
0F 8D cw/cd JGE rel16/32 より大きいか等しい (SF=OF) 場合near ジャンプする。
0F 8C cw/cd JL rel16/32 より小さい (SF<>OF) 場合near ジャンプする。
0F 8E cw/cd JLE rel16/32 より小さいか等しい (ZF=1 またはSF<>OF) 場合near ジャンプする。
0F 86 cw/cd JNA rel16/32 より上でない (CF=1 またはZF=1) 場合near ジャンプする。
0F 82 cw/cd JNAE rel16/32 より上でなく等しくない (CF=1) 場合near ジャンプする。
0F 83 cw/cd JNB rel16/32 より下でない (CF=0) 場合near ジャンプする。
0F 87 cw/cd JNBE rel16/32 より下でなく等しくない (CF=0 およびZF=0) 場合near ジャンプする。
0F 83 cw/cd JNC rel16/32 キャリーがない (CF=0) 場合near ジャンプする。
0F 85 cw/cd JNE rel16/32 等しくない (ZF=0) 場合near ジャンプする。
0F 8E cw/cd JNG rel16/32 より大きくない (ZF=1 またはSF<>OF) 場合near ジャンプする。
0F 8C cw/cd JNGE rel16/32 より大きくなく等しくない (SF<>OF) 場合near ジャンプする。
0F 8D cw/cd JNL rel16/32 より小さくない (SF=OF) 場合near ジャンプする。
0F 8F cw/cd JNLE rel16/32 より小さくなく等しくない (ZF=0 およびSF=OF) 場合near ジャンプする。
0F 81 cw/cd JNO rel16/32 オーバフローがない (OF=0) 場合near ジャンプする。
0F 8B cw/cd JNP rel16/32 パリティがない (PF=0) 場合near ジャンプする。
0F 89 cw/cd JNS rel16/32 符号がない (SF=0) 場合near ジャンプする。
0F 85 cw/cd JNZ rel16/32 ゼロでない (ZF=0) 場合near ジャンプする。
0F 80 cw/cd JO rel16/32 オーバフローがある (OF=1) 場合near ジャンプする。
0F 8A cw/cd JP rel16/32 パリティがある (PF=1) 場合near ジャンプする。
0F 8A cw/cd JPE rel16/32 パリティが偶数 (PF=1) の場合near ジャンプする。
0F 8B cw/cd JPO rel16/32 パリティが奇数 (PF=0) の場合near ジャンプする。
0F 88 cw/cd JS rel16/32 符号がある (SF=1) 場合near ジャンプする。
0F 84 cw/cd JZ rel16/32 0 (ZF=1) の場合near ジャンプする。
3-354
命令セット・リファレンス
Jcc?Jump if Condition Is Met ( 続き)
ステータス・フラグの特定の状態はときとして2 種類に解釈されることがあるので、一部のオペコー
ドに対しては2 つのニーモニックが定義されている。例えば、JA ( より上の場合ジャンプ) 命令と
JNBE ( より下でなく等しくない場合ジャンプ) 命令は、オペコード77Hに対する2 つのニーモニック
である。
Jcc 命令では、far ジャンプ ( 他のコード・セグメントへのジャンプ) をサポートしていない。条件付
きジャンプのターゲットが別のセグメントにある場合は、Jcc 命令に対するテスト対象の条件と反対
の条件を使用し、次に他のセグメントへの無条件far ジャンプ (JMP命令) でターゲットにアクセスす
る。例えば、以下の条件付きfar ジャンプは不当である。
JZ FARLABEL;
このfar ジャンプを行うには、以下の2 つの命令を使用する。
JNZ BEYOND;
JMP FARLABEL;
BEYOND:
JECXZ命令およびJCXZ 命令は、ステータス・フラグをチェックしない点で他のJcc 命令とは異なっ
ている。その代わりに、これらの命令はそれぞれECXおよびCXレジスタの内容が0かどうかをチェッ
クする。CX、ECXのどちらのレジスタを選ぶかは、アドレス・サイズ属性による。これらの命令は、
(LOOPNE などの) 条件付きループ命令で終了する条件付きループの先頭に使用すると役立つ。すな
わち、ECXまたはCXレジスタが0 に等しいときループに入らないようにして、ループがゼロ回でな
くそれぞれ232 または64K回実行してしまうのを回避する。
条件付きジャンプはすべて、ジャンプ・アドレスにも、キャッシュ可能かどうかにも関係なく、1 ま
たは2 キャッシュ・ラインのコード・フェッチに変換される。
操作
IF condition
THEN
EIP ← EIP + SignExtend(DEST);
IF OperandSize ← 16
THEN
EIP ← EIP AND 0000FFFFH;
FI;
ELSE (* OperandSize = 32 *)
IF EIP < CS.Base OR EIP > CS.Limit
#GP
FI;
FI;
影響を受けるフラグ
なし。
3-355
命令セット・リファレンス
Jcc?Jump if Condition Is Met ( 続き)
保護モード例外
#GP(0) ジャンプ先のオフセットがCS セグメントの範囲を超えている場合。
実アドレス・モード例外
#GP(0) ジャンプ先のオフセットがCS セグメントの範囲を超えているか、また
は0 〜 FFFFH の実効アドレス空間外の場合。この状態は、32 ビット・
アドレス・サイズ・オーバライド・プリフィックスを使用した場合に生
じることがある。
仮想8086 モード例外
実アドレスモードと同じ例外。
3-356
命令セット・リファレンス
JMP?Jump
説明
リターン情報を記録しないで、プログラムの制御を命令ストリーム内の別の点に移す。デスティネー
ション ( ターゲット) オペランドには、ジャンプ先の命令のアドレスを指定する。このオペランドに
は、即値、汎用レジスタ、またはメモリ・ロケーションを使用できる。
この命令を使用して、以下の異なる4 つのタイプのジャンプを実行することができる。
? near ジャンプ - 現在のコード・セグメント ( 現在のCS レジスタの指示先のセグメント) 内にあ
る命令へのジャンプ。セグメント内ジャンプともいう。
? short ジャンプ - ジャンプ範囲がEIPの現在値の-128 〜+127に限られるnear ジャンプ。
? far ジャンプ - 現在のコード・セグメントとは異なるが特権レベルは同じであるセグメント内に
ある命令へのジャンプ。セグメント間ジャンプともいう。
? タスク・スイッチ - 異なるタスク内にある命令へのジャンプ。
タスク・スイッチは保護モードでしか実行することができない。JMP 命令でのタスク・スイッチの
実行の詳細については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュ
アル、下巻』第6 章「タスク管理」を参照のこと。
near ジャンプとshort ジャンプ: near ジャンプを実行すると、プロセッサはターゲット・オペランド
で指定された ( 現在のコード・セグメント内の) アドレスにジャンプする。ターゲット・オペランド
は、絶対オフセット ( コード・セグメントのベースからのオフセット) か、または相対オフセット
(EIP レジスタ内の命令ポインタの現在値に相対的な符号付きディスプレースメント) を指定する。8
ビットの相対オフセット (rel8) へのnear ジャンプのことをshort ジャンプという。near ジャンプとshort
ジャンプではCSレジスタは変更されない。
絶対オフセットは、汎用レジスタまたはメモリ・ロケーション (r/m16 またはr/m32) で間接的に指定
される。ターゲット・オペランドのサイズ (16 または32 ビット) はオペランド・サイズ属性によって
決まる。絶対オフセットはEIP レジスタに直接ロードされる。オペランド・サイズ属性が16 である
場合は、EIPレジスタの上位2バイトは0にクリアされ、命令ポインタの最大サイズは16ビットになる。
オペコード命令説明
EB cb JMP rel8 次の命令との相対分量分だけ相対short ジャンプする。
E9 cw JMP rel16 次の命令との相対分量分だけ相対near ジャンプする。
E9 cd JMP rel32 次の命令との相対分量分だけ相対near ジャンプする。
FF /4 JMP r/m16 r/m16 で指定されるアドレスに絶対間接near ジャンプする。
FF /4 JMP r/m32 r/m32 で指定されるアドレスに絶対間接near ジャンプする。
EA cd JMP ptr16:16 オペランドで指定されるアドレスに絶対far ジャンプする。
EA cp JMP ptr16:32 オペランドで指定されるアドレスに絶対far ジャンプする。
FF /5 JMP m16:16 m16:16 で指定されるアドレスに絶対間接far ジャンプする。
FF /5 JMP m16:32 m16:32 で指定されるアドレスに絶対間接far ジャンプする。
3-357
命令セット・リファレンス
JMP?Jump ( 続き)
相対オフセット (rel8、rel16、またはrel32) は、アセンブリ・コードでは一般的にラベルとして指定
されるが、マシン・コード・レベルでは、符号付きの8、16、または32 ビットの即値としてコード
化され、命令ポインタに加算される。( これで、EIP レジスタの内容はJMP 命令の次の命令のアドレ
スになる。) 相対オフセットを使用するときは、ターゲット・オペランドのサイズ (8、16、または32
ビット) は、(short ジャンプかnear ジャンプかの) オペコードと ( 相対near ジャンプの) オペランド・
サイズ属性によって決まる。
実アドレス・モードまたは仮想8086 モードでのfar ジャンプ: 実アドレス・モードまたは仮想8086
モードでfar ジャンプを実行すると、プロセッサはターゲット・オペランドで指定されたコード・セ
グメントとオフセットにジャンプする。この場合は、ターゲット・オペランドは、絶対far アドレス
をポインタ (ptr16:16 またはptr16:32) で直接に、またはメモリ・ロケーション (m16:16 またはm16:32)
で間接的に指定する。ポインタ方式では、4 バイト (16 ビット・オペランド・サイズ) または 6 バイ
ト (32 ビット・オペランド・サイズ) のfar アドレス即値を使用して、コール先プロシージャのセグ
メントおよびアドレスが命令内にコード化される。間接方式では、ターゲット・オペランドが4 バイ
ト (16 ビット・オペランド・サイズ) または 6 バイト (32 ビット・オペランド・サイズ) のfar アドレ
スを内容とするメモリ・ロケーションを指定する。far アドレスは、CS およびEIP レジスタに直接
ロードされる。オペランド・サイズ属性が16 である場合は、EIP レジスタの上位2 バイトは0 にクリ
アされる。
保護モードでのfar ジャンプ: プロセッサが保護モードで動作しているときは、JMP 命令を使用して
以下の3 つのタイプのfar ジャンプを実行することができる。
? コンフォーミングまたは非コンフォーミングのコード・セグメントへのfar ジャンプ。
? コール・ゲートを介したfar ジャンプ。
? タスク・スイッチ。
(JMP命令を使用して特権レベル間のfar ジャンプを実行することはできない。)
保護モードでは、プロセッサは、常にfar アドレスのセグメント・セレクタ部を使用して、GDTまた
はLDT 内の対応するディスクリプタをアクセスする。ディスクリプタのタイプ ( コード・セグメン
ト、コール・ゲート、タスク・ゲート、またはTSS) およびアクセス権によって、実行されるジャン
プのタイプが決まる。
選択されたディスクリプタがコード・セグメントのディスクリプタである場合は、同じ特権レベル
のコード・セグメントへのfar ジャンプが実行される。( 選択されたコード・セグメントが異なる特
権レベルにあり、かつそのコード・セグメントが非コンフォーミングである場合は、一般保護例外
が発生する。) 保護モードでの同じ特権レベルへのfar ジャンプは、実アドレス・モードまたは仮想
8086 モードで実行されるfar ジャンプによく似ている。ターゲット・オペランドは、絶対far アドレ
スをポインタ (ptr16:16 またはptr16:32) で直接に、またはメモリ・ロケーション (m16:16 またはm16:32)
で間接的に指定する。オペランド・サイズ属性によって、far アドレス内のオフセットのサイズ (16
ビットまたは32 ビット) が決まる。新しいコード・セグメント・セレクタとそのディスクリプタが
CS レジスタにロードされ、命令からのオフセットがEIP レジスタにロードされる。コール・ゲート
( 次の段落で説明) を使用して、同じ特権レベルのコード・セグメントへのfar コールも実行すること
ができるので注意されたい。この仕組みを使用すると、特別レベルのインダイレクションが可能に
なり、これは16 ビットと32ビットとのコード・セグメント間のジャンプの優先実行方式になってい
る。
3-358
命令セット・リファレンス
JMP?Jump ( 続き)
コール・ゲートを介してfar ジャンプを実行するときは、ターゲット・オペランドによって指定され
たセグメント・セレクタによってコール・ゲートが識別される。( ターゲット・オペランドのオフ
セット部は無視される。) そこで、プロセッサはコール・ゲート・ディスクリプタで指定されたコー
ド・セグメントにジャンプし、コール・ゲートで指定されたオフセットから命令の実行を開始する。
スタック・スイッチは行われない。この場合もやはり、ターゲット・オペランドは、コール・ゲー
トのfar アドレスをポインタ (ptr16:16 またはptr16:32) で直接にも、メモリ・ロケーション (m16:16ま
たはm16:32) で間接的にも指定できる。
JMP 命令でタスク・スイッチを実行するのは、コール・ゲートを介したジャンプを実行するのに多
少似ている。タスク・スイッチの場合は、ターゲット・オペランドは、切り替え先タスクへのタス
ク・ゲートのセグメント・セレクタを指定する ( ターゲット・オペランドのオフセット部は無視され
る)。次に、選択されたタスク・ゲートが、タスクのコード・セグメントおよびスタック・セグメン
トのセグメント・セレクタがストアされているタスクのTSS を指す。TSS には、さらにタスクが中
断されなければ次に実行される予定であった命令のEIP 値も入っている。この命令ポインタ値はEIP
レジスタにロードされ、したがって、タスクはその実行されなかった最初の命令から実行を再開す
る。
JMP 命令は、TSS のセグメント・セレクタを直接指定することもでき、その結果タスク・ゲートの
インダイレクションの必要がなくなる。タスク・スイッチの仕組みの詳細については、『IA-32 イン
テルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、下巻』第6 章「タスク管理」
を参照のこと。
JMP 命令でタスク・スイッチを実行するときは、EFLAGS レジスタにネストされたタスク・フラグ
(NT) がセットされず、新しいTSS の以前のタスク・リンク・フィールドに前のタスクのTSS セレク
タがロードされないので注意されたい。したがって、前のタスクへのリターンはIRET 命令の実行で
は実現できない。JMP 命令でタスク・スイッチを実行するのは、その点でCALL 命令と異なる。す
なわち、CALL 命令はNTフラグをセットし、以前のタスク・リンク情報をセーブするので、IRET命
令でのコール元タスクへのリターンが可能になる。
操作
IF near jump
THEN IF near relative jump
THEN
tempEIP ← EIP + DEST; (* EIP is instruction following JMP instruction*)
ELSE (* near absolute jump *)
tempEIP ← DEST;
FI;
IF tempEIP is beyond code segment limit THEN #GP(0); FI;
IF OperandSize ← 32
THEN
EIP ← tempEIP;
ELSE (* OperandSize=16 *)
EIP ← tempEIP AND 0000FFFFH;
FI;
FI:
IF far jump AND (PE ← 0 OR (PE ← 1 AND VM ← 1)) (* real-address or virtual-8086 mode *)
3-359
命令セット・リファレンス
JMP?Jump ( 続き)
THEN
tempEIP ← DEST[offset); (* DEST is ptr16:32 or [m16:32] *)
IF tempEIP is beyond code segment limit THEN #GP(0); FI;
CS ← DEST[segment selector); (* DEST is ptr16:32 or [m16:32] *)
IF OperandSize ← 32
THEN
EIP ← tempEIP; (* DEST is ptr16:32 or [m16:32] *)
ELSE (* OperandSize ← 16 *)
EIP ← tempEIP AND 0000FFFFH; (* clear upper 16 bits *)
FI;
FI;
IF far jump AND (PE ← 1 AND VM ← 0) (* Protected mode, not virtual-8086 mode *)
THEN
IF effective address in the CS, DS, ES, FS, GS, or SS segment is illegal
OR segment selector in target operand null
THEN #GP(0);
FI;
IF segment selector index not within descriptor table limits
THEN #GP(new selector);
FI;
Read type and access rights of segment descriptor;
IF segment type is not a conforming or nonconforming code segment, call gate,
task gate, or TSS THEN #GP(segment selector); FI;
Depending on type and access rights
GO TO CONFORMING-CODE-SEGMENT;
GO TO NONCONFORMING-CODE-SEGMENT;
GO TO CALL-GATE;
GO TO TASK-GATE;
GO TO TASK-STATE-SEGMENT;
ELSE
#GP(segment selector);
FI;
CONFORMING-CODE-SEGMENT:
IF DPL > CPL THEN #GP(segment selector); FI;
IF segment not present THEN #NP(segment selector); FI;
tempEIP ← DEST[offset);
IF OperandSize=16
THEN tempEIP ← tempEIP AND 0000FFFFH;
FI;
IF tempEIP not in code segment limit THEN #GP(0); FI;
CS ← DEST[SegmentSelector); (* segment descriptor information also loaded *)
CS(RPL) ← CPL
EIP ← tempEIP;
END;
3-360
命令セット・リファレンス
JMP?Jump ( 続き)
NONCONFORMING-CODE-SEGMENT:
IF (RPL > CPL) OR (DPL ≠ CPL) THEN #GP(code segment selector); FI;
IF segment not present THEN #NP(segment selector); FI;
IF instruction pointer outside code segment limit THEN #GP(0); FI;
tempEIP ← DEST[offset);
IF OperandSize=16
THEN tempEIP ← tempEIP AND 0000FFFFH;
FI;
IF tempEIP not in code segment limit THEN #GP(0); FI;
CS ← DEST[SegmentSelector); (* segment descriptor information also loaded *)
CS(RPL) ← CPL
EIP ← tempEIP;
END;
CALL-GATE:
IF call gate DPL < CPL
OR call gate DPL < call gate segment-selector RPL
THEN #GP(call gate selector); FI;
IF call gate not present THEN #NP(call gate selector); FI;
IF call gate code-segment selector is null THEN #GP(0); FI;
IF call gate code-segment selector index is outside descriptor table limits
THEN #GP(code segment selector); FI;
Read code segment descriptor;
IF code-segment segment descriptor does not indicate a code segment
OR code-segment segment descriptor is conforming and DPL > CPL
OR code-segment segment descriptor is non-conforming and DPL ≠ CPL
THEN #GP(code segment selector); FI;
IF code segment is not present THEN #NP(code-segment selector); FI;
IF instruction pointer is not within code-segment limit THEN #GP(0); FI;
tempEIP ← DEST[offset);
IF GateSize=16
THEN tempEIP ← tempEIP AND 0000FFFFH;
FI;
IF tempEIP not in code segment limit THEN #GP(0); FI;
CS ← DEST[SegmentSelector); (* segment descriptor information also loaded *)
CS(RPL) ← CPL
EIP ← tempEIP;
END;
TASK-GATE:
IF task gate DPL < CPL
OR task gate DPL < task gate segment-selector RPL
THEN #GP(task gate selector); FI;
IF task gate not present THEN #NP(gate selector); FI;
Read the TSS segment selector in the task-gate descriptor;
3-361
命令セット・リファレンス
JMP?Jump ( 続き)
IF TSS segment selector local/global bit is set to local
OR index not within GDT limits
OR TSS descriptor specifies that the TSS is busy
THEN #GP(TSS selector); FI;
IF TSS not present THEN #NP(TSS selector); FI;
SWITCH-TASKS to TSS;
IF EIP not within code segment limit THEN #GP(0); FI;
END;
TASK-STATE-SEGMENT:
IF TSS DPL < CPL
OR TSS DPL < TSS segment-selector RPL
OR TSS descriptor indicates TSS not available
THEN #GP(TSS selector); FI;
IF TSS is not present THEN #NP(TSS selector); FI;
SWITCH-TASKS to TSS
IF EIP not within code segment limit THEN #GP(0); FI;
END;
影響を受けるフラグ
タスク・スイッチが行われた場合はすべてのフラグが影響を受け、タスク・スイッチが行われなかっ
た場合はどのフラグも影響を受けない。
保護モード例外
#GP(0) ターゲット・オペランド、コール・ゲート、またはTSS 内のオフセット
がコード・セグメントの範囲を超えている場合。
デスティネーション・オペランド、コール・ゲート、タスク・ゲート、
またはTSS 内のセグメント・セレクタがヌルの場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#GP( セレクタ) セグメント・セレクタ・インデックスがディスクリプタ・テーブルの範
囲外の場合。
デスティネーション・オペランド内のセグメント・セレクタによって指
されているセグメント・ディスクリプタが、コンフォーミング・コー
ド・セグメント、非コンフォーミング・コード・セグメント、コール・
ゲート、タスク・ゲート、タスク・ステート・セグメントのいずれの
ディスクリプタでもない場合。
非コンフォーミング・コード・セグメントのDPL がCPL に等しくない
場合。
( コール・ゲートを使用しない場合) セグメントのセグメント・セレク
タのRPL がCPL より大きい場合。
3-362
命令セット・リファレンス
JMP?Jump ( 続き)
コンフォーミング・コード・セグメントのDPL がCPL より大きい場合。
コール・ゲート、タスク・ゲート、またはTSS のセグメント・ディスク
リプタからのDPL がCPL より小さいか、あるいはコール・ゲート、タ
スク・ゲート、またはTSSのセグメント・セレクタのRPLより小さい場合。
コール・ゲート内のセレクタのセグメント・ディスクリプタが、それが
コード・セグメントであることを示していない場合。
タスク・ゲート内のセグメント・セレクタのセグメント・ディスクリプ
タが使用可能なTSS を示していない場合。
TSS のセグメント・セレクタのローカル/ グローバル・ビットがローカ
ルに設定されている場合。
TSS のセグメント・ディスクリプタが、そのTSS がビジーであるか使用
不可能であると指定している場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NP ( セレクタ) アクセスされるコード・セグメントが存在しない場合。
コール・ゲート、タスク・ゲート、またはTSS が存在しない場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。( メ
モリからターゲットをフェッチするときだけ発生する。)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) ターゲット・オペランドがコード・セグメントの範囲を超えている場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。( メモリからターゲットをフェッチ
するときだけ発生する。)
3-363
命令セット・リファレンス
LAHF?Load Status Flags into AH Register
説明
EFLAGSレジスタの下位バイト ( ここにはステータス・フラグSF、ZF、AF、PF、およびCFがある)
をAHレジスタに転送する。EFLAGS レジスタの予約ビット1、3、および5 は、AH レジスタ内では
下記の「操作」の項に示すように設定される。
操作
AH ← EFLAGS(SF:ZF:0:AF:0:PF:1:CF);
影響を受けるフラグ
なし ( すなわち、EFLAGSレジスタ内のフラグの状態は影響を受けない)。
例外 ( すべての操作モード)
なし。
オペコード命令説明
9F LAHF AH ← EFLAGS(SF:ZF:0:AF:0:PF:1:CF) をロードする。
3-364
命令セット・リファレンス
LAR?Load Access Rights Byte
説明
第2 オペランド ( ソース・オペランド) によって指定されたセグメント・ディスクリプタから第1 オ
ペランド ( デスティネーション・オペランド) にアクセス権をロードし、EFLAGS レジスタ内のZFフ
ラグをセットする。ソース・オペランド ( レジスタまたはメモリ・ロケーション) の内容は、アクセ
スされるセグメント・ディスクリプタのセグメント・セレクタである。デスティネーション・オペ
ランドは、汎用レジスタである。
プロセッサは、ロード・プロセスの一環としてアクセス・チェックを行う。デスティネーション・
レジスタにロードされると、ソフトウェアはアクセス権情報をさらに追加チェックすることができ
る。
オペランド・サイズが32 ビットのときは、セグメント・ディスクリプタに対するアクセス権には、タ
イプ・フィールドおよびDPLフィールドと、S、P、AVL、D/B、およびGフラグが含まれ、これらは
すべてセグメント・ディスクリプタの2番目のダブルワード ( バイト4〜7) 内にある。このダブルワー
ドは、00FXFF00H でマスクされてからデスティネーション・オペランドにロードされる。オペラン
ド・サイズが16 ビットのときは、アクセス権にはタイプ・フィールドおよびDPL フィールドが含ま
れる。この場合は、ダブルワードの下位2 バイトがFF00H でマスクされてからデスティネーション・
オペランドにロードされる。
この命令では、アクセス権をデスティネーション・レジスタにロードする前に以下のチェックを行
う。
? セグメント・セレクタがヌルでないことを確認する。
? セグメント・セレクタの指示先がアクセスされるGDT またはLDT の範囲内のディスクリプタ
であることを確認する。
? ディスクリプタのタイプがこの命令に対して有効であることを確認する。LAR命令に対しては、
すべてのコード・セグメント・ディスクリプタとデータ・セグメント・ディスクリプタが有効
である ( すなわち、LAR命令でアクセスできる)。有効なシステム・セグメントおよびゲートの
ディスクリプタ・タイプが下記の表に示してある。
? セグメントがコンフォーミング・コード・セグメントでない場合は、この命令は指定されたセ
グメント・ディスクリプタがCPLでアクセスできる( すなわち、CPLとセグメント・セレクタの
RPLがセグメント・セレクタのDPL以下である) かを確認する。
セグメント・ディスクリプタがアクセスできないか、またはこの命令にとって無効なタイプである
場合は、ZF フラグがクリアされ、アクセス権は何もデスティネーション・オペランドにロードされ
ない。
LAR命令は保護モードでしか実行することができない。
オペコード命令説明
0F 02 /r LAR r16,r/m16 r16 ← FF00H でマスクされたr/m16。
0F 02 /r LAR r32,r/m32 r32 ← 00FxFF00H でマスクされたr/m32。
3-365
命令セット・リファレンス
LAR?Load Access Rights Byte ( 続き)
操作
IF SRC[Offset) > descriptor table limit THEN ZF ← 0; FI;
Read segment descriptor;
IF SegmentDescriptor(Type) ≠ conforming code segment
AND (CPL > DPL) OR (RPL > DPL)
OR Segment type is not valid for instruction
THEN
ZF ← 0
ELSE
IF OperandSize ← 32
THEN
DEST ← [SRC] AND 00FxFF00H;
ELSE (*OperandSize ← 16*)
DEST ← [SRC] AND FF00H;
FI;
FI;
影響を受けるフラグ
アクセス権が正常にロードされた場合はZF フラグが1 にセットされ、ロードできなかった場合は0
にクリアされる。
タイプ名前有効/ 無効
0 予約済み無効
1 使用可能16 ビットTSS 有効
2 LDT 有効
3 ビジー16 ビットTSS 有効
4 16 ビット・コール・ゲート有効
5 16 ビット/32 ビット・タスク・ゲート有効
6 16 ビット割り込みゲート無効
7 16 ビット・トラップ・ゲート無効
8 予約済み無効
9 使用可能32 ビットTSS 有効
A 予約済み無効
B ビジー32 ビットTSS 有効
C 32 ビット・コール・ゲート有効
D 予約済み無効
E 32 ビット割り込みゲート無効
F 32 ビット・トラップ・ゲート無効
3-366
命令セット・リファレンス
LAR?Load Access Rights Byte ( 続き)
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。( メ
モリからターゲットをフェッチするときだけ発生する。)
実アドレス・モード例外
#UD LAR 命令は実アドレス・モードでは認識されない。
仮想8086 モード例外
#UD LAR 命令は仮想8086 モードでは認識されない。
3-367
命令セット・リファレンス
LDMXCSR?Load MXCSR Register
説明
ソース・オペランドをMXCSR 制御/ ステータス・レジスタへロードする。ソース・オペランドは、
32ビット・メモリ・ロケーションである。MXCSRレジスタおよびその内容については、『IA-32 イン
テルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の第10 章の「MXCSR
制御およびステータス・レジスタ」を参照のこと。
一般に、LDMXCSR命令はSTMXCSR命令と一緒に使用される。STMXCSR命令は、MXCSRレジス
タの内容をメモリにストアする。
リセットしたときのMXCSRのデフォルト値は1F80Hである。
LDMXCSR 命令によってSIMD 浮動小数点例外マスク・ビットをクリアし、対応する例外フラグ・
ビットを設定した場合、SIMD浮動小数点例外はすぐには発生しない。この例外が発生するのは、こ
の命令の後に引き続いて、特定のSIMD浮動小数点例外を報告させるSSE命令またはSSE2 命令を実
行したときだけである。
操作
MXCSR ← m32;
同等のインテルC/C++ コンパイラ組み込み関数
_mm_setcsr(unsigned int i)
数値例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
0F,AE,/2 LDMXCSR m32 m32 からMXCSR レジスタをロードする。
3-368
命令セット・リファレンス
LDMXCSR?Load MXCSR Register ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-369
命令セット・リファレンス
LDS/LES/LFS/LGS/LSS?Load Far Pointer
説明
第2 オペランド ( ソース・オペランド) からセグメント・レジスタおよび第1 オペランド ( デスティ
ネーション・オペランド) にfar ポインタ ( セグメント・セレクタとオフセット) をロードする。ソー
ス・オペランドには、オペランド・サイズ属性の現在の設定 (32 ビットまたは16 ビット) に応じて、
48ビットまたは32ビットのメモリ内ポインタを指定する。命令のオペコードとデスティネーション・
オペランドには、セグメント・レジスタ/ 汎用レジスタ・ペアを指定する。ソース・オペランドから
の16 ビット・セグメント・セレクタは、オペコードで指定されたセグメント・レジスタ (DS、SS、
ES、FS、またはGS) にロードされる。32 ビットまたは16ビットのオフセットは、デスティネーショ
ン・オペランドで指定されたレジスタにロードされる。
これらの命令の1 つを保護モードで実行した場合は、ソース・オペランドのセグメント・セレクタが
指しているセグメント・ディスクリプタからの追加情報が、選択されたセグメント・レジスタの隠
蔽部分にロードされる。
保護モードでも、保護例外を発生させることなく、DS、ES、FS、またはGS レジスタにヌル・セレ
クタ (0000 〜0003 の値) をロードすることができる。( ロードされると、以降は、対応するセグメン
ト・レジスタにヌル・セレクタがロードされているセグメントを参照しようとすると、必ず一般保
護例外 (#GP) が発生し、そのセグメントへのメモリ参照は行われない。)
操作
IF ProtectedMode
THEN IF SS is loaded
THEN IF SegementSelector ← null
THEN #GP(0);
FI;
ELSE IF Segment selector index is not within descriptor table limits
OR Segment selector RPL ≠ CPL
OR Access rights indicate nonwritable data segment
OR DPL ≠ CPL
オペコード命令説明
C5 /r LDS r16,m16:16 メモリからDS:r16 にfar ポインタをロードする。
C5 /r LDS r32,m16:32 メモリからDS:r32 にfar ポインタをロードする。
0F B2 /r LSS r16,m16:16 メモリからSS:r16 にfar ポインタをロードする。
0F B2 /r LSS r32,m16:32 メモリからSS:r32 にfar ポインタをロードする。
C4 /r LES r16,m16:16 メモリからES:r16 にfar ポインタをロードする。
C4 /r LES r32,m16:32 メモリからES:r32 にfar ポインタをロードする。
0F B4 /r LFS r16,m16:16 メモリからFS:r16 にfar ポインタをロードする。
0F B4 /r LFS r32,m16:32 メモリからFS:r32 にfar ポインタをロードする。
0F B5 /r LGS r16,m16:16 メモリからGS:r16 にfar ポインタをロードする。
0F B5 /r LGS r32,m16:32 メモリからGS:r32 にfar ポインタをロードする。
3-370
命令セット・リファレンス
LDS/LES/LFS/LGS/LSS?Load Far Pointer ( 続き)
THEN #GP(selector);
FI;
ELSE IF Segment marked not present
THEN #SS(selector);
FI;
SS ← SegmentSelector(SRC);
SS ← SegmentDescriptor([SRC]);
ELSE IF DS, ES, FS, or GS is loaded with non-null segment selector
THEN IF Segment selector index is not within descriptor table limits
OR Access rights indicate segment neither data nor readable code segment
OR (Segment is data or nonconforming-code segment
AND both RPL and CPL > DPL)
THEN #GP(selector);
FI;
ELSE IF Segment marked not present
THEN #NP(selector);
FI;
SegmentRegister ← SegmentSelector(SRC) AND RPL;
SegmentRegister ← SegmentDescriptor([SRC]);
ELSE IF DS, ES, FS, or GS is loaded with a null selector:
SegmentRegister ← NullSelector;
SegmentRegister(DescriptorValidBit) ← 0; (*hidden flag; not accessible by software*)
FI;
FI;
IF (Real-Address or Virtual-8086 Mode)
THEN
SegmentRegister ← SegmentSelector(SRC);
FI;
DEST ← Offset(SRC);
影響を受けるフラグ
なし。
保護モード例外
#UD ソース・オペランドがメモリ・ロケーションでない場合。
#GP(0) SS レジスタにヌル・セレクタがロードされた場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
3-371
命令セット・リファレンス
LDS/LES/LFS/LGS/LSS?Load Far Pointer ( 続き)
#GP( セレクタ) SS レジスタがロードされようとしたとき、次のいずれかが真であった
場合。(1) セグメント・セレクタ・インデックスがディスクリプタ・テー
ブルの範囲内でない。(2) セグメント・セレクタのRPL がCPL に等しく
ない。(3) セグメントが書き込み不可能なデータ・セグメントである。 (4)
DPL がCPL に等しくない。
DS、ES、FS、またはGS レジスタにヌルでないセグメント・セレクタが
ロードされようとしたとき、次のいずれかが真であった場合。(1) セグ
メント・セレクタ・インデックスがディスクリプタ・テーブルの範囲内
でない。(2) セグメントがデータ・セグメントでも読み出し可能なコー
ド・セグメントでもない。 (3) セグメントがデータ・セグメントまたは非
コンフォーミング・コード・セグメントであり、かつRPL とCPL がと
もにDPL より大きい。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#SS( セレクタ) SS レジスタがロードされようとしたとき、セグメントが存在しないと
マークされていた場合。
#NP( セレクタ) DS、ES、FS、またはGS レジスタにヌルでないセグメント・セレクタが
ロードされようとしたとき、セグメントが存在しないとマークされてい
た場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD ソース・オペランドがメモリ・ロケーションでない場合。
仮想8086 モード例外
#UD ソース・オペランドがメモリ・ロケーションでない場合。
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-372
命令セット・リファレンス
LEA?Load Effective Address
説明
第2 オペランド ( ソース・オペランド) の実効アドレスを計算し、第1 オペランド ( デスティネーショ
ン・オペランド) にストアする。ソース・オペランドは、プロセッサのアドレス指定モードの1 つで
指定されたメモリ・アドレス ( オフセット部) である。デスティネーション・オペランドは、汎用レ
ジスタである。この命令が実行する処理は、以下の表に示すように、アドレス・サイズ属性および
オペランド・サイズ属性によって変わる。この命令のオペランド・サイズ属性は選択されたレジス
タによって決まり、アドレス・サイズ属性はコード・セグメントの属性によって決まる。
アセンブラが異なると、ソース・オペランドのサイズ属性と記号参照に基づいて、使用されるアル
ゴリズムが変わることもある。
操作
IF OperandSize ← 16 AND AddressSize ← 16
THEN
DEST ← EffectiveAddress(SRC); (* 16-bit address *)
ELSE IF OperandSize ← 16 AND AddressSize ← 32
THEN
temp ← EffectiveAddress(SRC); (* 32-bit address *)
DEST ← temp[0..15]; (* 16-bit address *)
ELSE IF OperandSize ← 32 AND AddressSize ← 16
THEN
temp ← EffectiveAddress(SRC); (* 16-bit address *)
DEST ← ZeroExtend(temp); (* 32-bit address *)
ELSE IF OperandSize ← 32 AND AddressSize ← 32
THEN
オペコード命令説明
8D /r LEA r16,m m の実効アドレスをレジスタr16 にストアする。
8D /r LEA r32,m m の実効アドレスをレジスタr32 にストアする。
オペランド・サイズアドレス・サイズ実行される処理
16 16 16 ビットの実効アドレスが計算され、要求された16 ビット・
レジスタのデスティネーションにストアされる。
16 32 32 ビットの実効アドレスが計算される。そのアドレスの下位
16 ビットが要求された16 ビット・レジスタのデスティネー
ションにストアされる。
32 16 16 ビットの実効アドレスが計算される。16 ビット・アドレス
はゼロ拡張され、要求された32 ビット・レジスタのデスティ
ネーションにストアされる。
32 32 32 ビットの実効アドレスが計算され、要求された32 ビット・
レジスタのデスティネーションにストアされる。
3-373
命令セット・リファレンス
LEA?Load Effective Address ( 続き)
DEST ← EffectiveAddress(SRC); (* 32-bit address *)
FI;
FI;
影響を受けるフラグ
なし。
保護モード例外
#UD ソース・オペランドがメモリ・ロケーションでない場合。
実アドレス・モード例外
#UD ソース・オペランドがメモリ・ロケーションでない場合。
仮想8086 モード例外
#UD ソース・オペランドがメモリ・ロケーションでない場合。
3-374
命令セット・リファレンス
LEAVE?High Level Procedure Exit
説明
先行のENTER 命令によってセットアップされたスタック・フレームをリリースする。LEAVE 命令
は、 (EBP レジスタ内の) フレーム・ポインタをスタック・ポインタ・レジスタ (ESP) にコピーし、そ
れによってスタック・フレームに割り当てられていたスタック空間がリリースされる。次に、古い
フレーム・ポインタ (ENTER 命令によってセーブされたコール元プロシージャのフレーム・ポイン
タ) がスタックからEBP レジスタにポップされ、コール元プロシージャのスタック・フレームがリ
ストアされる。
一般的に、LEAVE命令の次にRET命令が実行されて、プログラム制御がコール元プロシージャに返
される。
ENTER命令およびLEAVE 命令の使用の詳細については、『IA-32 インテルR アーキテクチャ・ソフト
ウェア・デベロッパーズ・マニュアル、上巻』第6 章の「ブロック構造言語でのプロシージャ・コー
ル」を参照のこと。
操作
IF StackAddressSize ← 32
THEN
ESP ← EBP;
ELSE (* StackAddressSize ← 16*)
SP ← BP;
FI;
IF OperandSize ← 32
THEN
EBP ← Pop();
ELSE (* OperandSize ← 16*)
BP ← Pop();
FI;
影響を受けるフラグ
なし。
保護モード例外
#SS(0) EBP レジスタの指示先のロケーションが現在のスタック・セグメントの
範囲内にない場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
オペコード命令説明
C9 LEAVE SP をBP に設定し、次にBP をポップする。
C9 LEAVE ESP をEBP に設定し、次にEBP をポップする。
3-375
命令セット・リファレンス
LEAVE?High Level Procedure Exit ( 続き)
実アドレス・モード例外
#GP EBP レジスタの指示先のロケーションが0 〜 FFFFH の実効アドレス空
間の範囲外の場合。
仮想8086 モード例外
#GP(0) EBP レジスタの指示先のロケーションが0 〜 FFFFH の実効アドレス空
間の範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-376
命令セット・リファレンス
LES?Load Full Pointer
「LDS/LES/LFS/LGS/LSS?Load Far Pointer」を参照のこと。
3-377
命令セット・リファレンス
LFENCE?Load Fence
説明
LFENCE 命令より前に発行されたすべてのメモリからのロード命令に対して、シリアル化操作を実
行する。このシリアル化操作は、プログラムの順序でLFENCE 命令に先行するすべてのロード命令
が、LFENCE 命令に後続するロード命令より前に、グローバルにアクセス可能になることを保証す
る。LFENCE 命令は、ロード命令、他のLFENCE命令、すべてのMFENCE命令、およびすべてのシ
リアル化命令（CPUID命令など）に対して順序付けされる。LFENCE命令は、ストア命令やSFENCE
命令に対しては順序付けされない。
順序設定の緩いメモリ・タイプを使用して、アウト・オブ・オーダー発行や見込み的な読み込みな
どの手法により、プロセッサ・パフォーマンスの向上を達成する。データを参照する側のルーチン
が、順序設定の緩いデータであることをどの程度認識しているかは、アプリケーションによって異
なり、データを生成する側のルーチンにはわからない。LFENCE 命令は、順序設定の緩い結果を生
成するルーチンとそのデータを参照するルーチンの間のロードの順序付けを保証するための効率的
な方法である。
プロセッサは、見込み的な読み込みが許されるメモリ・タイプ（すなわち、WB、WC、およびWT
メモリ・タイプ）が割り当てられたシステム・メモリ領域から、いつでもデータを見込み的にフェッ
チしてキャッシュに入れることができる。PREFETCHh 命令は、この見込み的な動作に対するヒント
と見なされる。この見込み的なフェッチ動作は、命令の実行には拘束されず、任意の時点で発生す
る。したがって、LFENCE命令は、PREFETCHh 命令などの見込み的なフェッチ機構に対して順序付
けされない（つまり、LFENCE 命令の実行の直前、実行中、または実行後に、データがキャッシュ
に見込み的にロードされる可能性がある）。
操作
Wait_On_Following_Loads_Until(preceding_loads_globally_visible);
同等のインテルC/C++ コンパイラ組み込み関数
void_mm_lfence(void)
例外（すべての動作モード）
なし。
オペコード命令説明
0F AE /5 LFENCE ロード操作をシリアル化する。
3-378
命令セット・リファレンス
LFS?Load Full Pointer
「LDS/LES/LFS/LGS/LSS?Load Far Pointer」を参照のこと。
3-379
命令セット・リファレンス
LGDT/LIDT?Load Global/Interrupt Descriptor Table Register
説明
ソース・オペランド内の値をグローバル・ディスクリプタ・テーブル・レジスタ (GDTR) または割
り込みディスクリプタ・テーブル・レジスタ (IDTR) にロードする。ソース・オペランドでは、グ
ルーバル・ディスクリプタ・テーブル (GDT) または割り込みディスクリプタ・テーブル (IDT) の
ベース・アドレス ( リニア・アドレス) と範囲 ( バイト単位のテーブル・サイズ) を内容とする6 バ
イトのメモリ・ロケーションを指定する。オペランド・サイズ属性が32 ビットである場合は、16
ビットの範囲 (6 バイトのデータ・オペランドの下位2 バイト) と32 ビットのベース・アドレス ( デー
タ・オペランドの上位4 バイト) がレジスタにロードされる。オペランド・サイズ属性が16 ビット
である場合は、16 ビットの範囲 ( 下位2 バイト) と24 ビットのベース・アドレス ( 第3、第4、およ
び第5 バイト) がロードされる。この場合は、オペランドの上位バイトは使用されず、GDTR また
はIDTR のベース・アドレスの上位バイトにはゼロが埋められる。
LGDT命令およびLIDT命令は、オペレーティング・システム・ソフトウェアだけで使用される。こ
れらの命令は、アプリケーション・プログラムでは使用されない。保護モードでリニア・アドレス
( すなわち、セグメントに相対的でないアドレス) と範囲を直接ロードするのはこれらの命令だけで
ある。LGDT命令およびLIDT 命令は、一般的に、保護モードへの切り替え前にプロセッサの初期化
を可能にするために、実アドレス・モードで実行される。
GDTRとIDTRの内容のストアについては、本章の「SFENCE?Store Fence」を参照のこと。
操作
IF instruction is LIDT
THEN
IF OperandSize ← 16
THEN
IDTR(Limit) ← SRC[0:15];
IDTR(Base) ← SRC[16:47] AND 00FFFFFFH;
ELSE (* 32-bit Operand Size *)
IDTR(Limit) ← SRC[0:15];
IDTR(Base) ← SRC[16:47];
FI;
ELSE (* instruction is LGDT *)
IF OperandSize ← 16
THEN
GDTR(Limit) ← SRC[0:15];
GDTR(Base) ← SRC[16:47] AND 00FFFFFFH;
ELSE (* 32-bit Operand Size *)
GDTR(Limit) ← SRC[0:15];
GDTR(Base) ← SRC[16:47];
FI; FI;
オペコード命令説明
0F 01 /2 LGDT m16&32 m をGDTR にロードする。
0F 01 /3 LIDT m16&32 m をIDTR にロードする。
3-380
命令セット・リファレンス
LGDT/LIDT?Load Global/Interrupt Descriptor Table Register ( 続き)
影響を受けるフラグ
なし。
保護モード例外
#UD ソース・オペランドがメモリ・ロケーションでない場合。
#GP(0) 現行特権レベルが0 でない場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
実アドレス・モード例外
#UD ソース・オペランドがメモリ・ロケーションでない場合。
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
3-381
命令セット・リファレンス
LGS?Load Full Pointer
「LDS/LES/LFS/LGS/LSS?Load Far Pointer」を参照のこと。
3-382
命令セット・リファレンス
LLDT?Load Local Descriptor Table Register
説明
ソース・オペランドをローカル・ディスクリプタ・テーブル・レジスタ (LDTR) のセグメント・セレ
クタ・フィールドにロードする。ソース・オペランド ( 汎用レジスタまたはメモリ・ロケーション)
の内容 は、ローカル・ディスクリプタ・テーブル (LDT) を指示先とするセグメント・セレクタであ
る。セグメント・セレクタがLDTR にロードされた後に、プロセッサはそのセグメント・セレクタ
を使用して、グローバル・ディスクリプタ・テーブル (GDT) 内にあるLDTのセグメント・ディスク
リプタの位置を探す。次に、セグメント・ディスクリプタからLDTRにLDTのセグメント範囲とベー
ス・アドレスをロードする。DS、ES、SS、FS、GS、およびCSの各セグメント・レジスタはこの命
令の影響を受けない。現在のタスクに対するタスク・ステート・セグメント (TSS) 内のLDTRフィー
ルドも影響を受けない。
ソース・オペランドが0 である場合は、LDTRは無効とマークされ、LDT内のディスクリプタへのす
べての参照 (LAR、VERR、VERW、またはLSL命令によるものを除く) によって一般保護例外 (#GP)
が発生する。
オペランド・サイズ属性は、この命令には効果をもたない。
LLDT 命令は、オペレーティング・システム・ソフトウェアで使用するために設けられたものであ
り、アプリケーション・プログラムでは使用してはならない。さらに、この命令は保護モードでし
か実行することができない。
操作
IF SRC[Offset) > descriptor table limit THEN #GP(segment selector); FI;
Read segment descriptor;
IF SegmentDescriptor(Type) ≠ LDT THEN #GP(segment selector); FI;
IF segment descriptor is not present THEN #NP(segment selector);
LDTR(SegmentSelector) ← SRC;
LDTR(SegmentDescriptor) ← GDTSegmentDescriptor;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) 現行特権レベルが0 でない場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
オペコード命令説明
0F 00 /2 LLDT r/m16 セグメント・セレクタr/m16 をLDTR にロードする。
3-383
命令セット・リファレンス
LLDT?Load Local Descriptor Table Register ( 続き)
#GP( セレクタ) セレクタ・オペランドの指示先がグローバル・ディスクリプタ・テーブ
ル(GDT) でない場合、またはGDT 内のエントリがローカル・ディスク
リプタ・テーブルでない場合。
セグメント・セレクタがGDT の範囲を超えている場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NP( セレクタ) LDT ディスクリプタが存在しない場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
実アドレス・モード例外
#UD LLDT 命令は実アドレス・モードでは認識されない。
仮想8086 モード例外
#UD LLDT 命令は仮想8086 モードでは認識されない。
3-384
命令セット・リファレンス
LIDT?Load Interrupt Descriptor Table Register
「LGDT/LIDT?Load Global/Interrupt Descriptor Table Register」を参照のこと。
3-385
命令セット・リファレンス
LMSW?Load Machine Status Word
説明
ソース・オペランドをマシン・ステータス・ワード、すなわちCR0 レジスタのビット0 〜 15 にロー
ドする。ソース・オペランドには、16 ビット汎用レジスタまたはメモリ・ロケーションを使用でき
る。ソース・オペランドの下位4 ビット (PE、MP、EM、およびTS フラグ) だけがCR0 にロードされ
る。CR0 のPG、CD、NW、AM、WP、NE、およびETフラグは影響を受けない。オペランド・サイ
ズ属性は、この命令には効果をもたない。
ソース・オペランドのPEフラグ ( ビット0) が1 にセットされている場合は、この命令によってプロ
セッサは保護モードに切り替わる。保護モードでは、LMSW命令を使用してPE フラグをクリアし、
実アドレス・モードへのスイッチ・バックを強制することはできない。
LMSW 命令は、オペレーティング・システム・ソフトウェアで使用するために設けられたものであ
り、アプリケーション・プログラムでは使用してはならない。保護モードまたは仮想8086 モードで
は、この命令はCPL 0 でしか実行することができない。
この命令は、Intel 286プロセッサとの互換性を保つために設けられたものである。Pentium 4 プロセッ
サ、P6 ファミリ、Pentiumプロセッサ、Intel486 プロセッサ、およびIntel386 プロセッサで実行するよ
うに意図されたプログラムおよびプロシージャでは、MOV ( 制御レジスタ) 命令を使用してCR0 レ
ジスタ全体をロードする必要がある。MOV CR0 命令を使用すると、CR0 のPE フラグをセットおよ
びクリアすることができ、プログラムやプロシージャによる保護モードと実アドレス・モードとの
間の切り替えが可能になる。
この命令はシリアル化命令である。
操作
CR0[0:3] ← SRC[0:3];
影響を受けるフラグ
なし。
保護モード例外
#GP(0) 現行特権レベルが0 でない場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
オペコード命令説明
0F 01 /6 LMSW r/m16 r/m16 をCR0 のマシン・ステータス・ワードにロードす
る。
3-386
命令セット・リファレンス
LMSW?Load Machine Status Word ( 続き)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
仮想8086 モード例外
#GP(0) 現行特権レベルが0 でない場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-387
命令セット・リファレンス
LOCK?Assert LOCK# Signal Prefix
説明
このプリフィックスの後の命令の実行中、プロセッサのLOCK# 信号をアサートさせる ( すなわち、
その命令をアトム命令に変える)。マルチプロセッサ環境では、LOCK# 信号は、それがアサートされ
ている間プロセッサが任意の共有メモリを独占的に使用できるよう保証する。
(Pentium Pro プロセッサなどの) 後から現れたIA-32 プロセッサでは、LOCK#信号をアサートさせな
いでロックを行うこともできる。下記の「IA-32 アーキテクチャにおける互換性」の項を参照のこと。
LOCKプリフィックスは、ADD、ADC、AND、BTC、BTR、BTS、CMPXCHG、CMPXCH8B、DEC、
INC、NEG、NOT、OR、SBB、SUB、XOR、XADD、XCHG の各命令の前、および、デスティネー
ション・オペランドがメモリ・オペランドである形式の命令の前にのみ使用できる。LOCK プリ
フィックスがこれらの命令のいずれかに使用され、しかもソース・オペランドがメモリ・オペラン
ドである場合には、未定義のオペコード例外(#UD) が発生することがある。LOCKプリフィックスを
上記以外の命令に使用した場合は、未定義のオペコード例外が発生する。XCHG命令は、LOCKプリ
フィックスの有無に関係なく、常にLOCK#信号をアサートする。
一般的に、LOCKプリフィックスは、共有メモリ環境内のメモリ・ロケーションでの読み取り/ 修正
/ 書き込み操作を実行する場合にBTS 命令に付けて使用される。
LOCK プリフックスの有効性はメモリ・フィールドのアライメントによって損なわれない。アライ
メントがどのようにずれているメモリ・フィールドに対しても、メモリ・ロックは変わりなく有効
である。
IA-32 アーキテクチャにおける互換性
Pentium Pro プロセッサ以降では、命令の前にLOCK プリフィックスを付けて、アクセスするメモリ
領域をプロセッサ内で内部的にキャッシュさせるときは、一般的にLOCK#信号はアサートされない。
その代わりに、プロセッサのキャッシュだけがロックされる。その場合、プロセッサのキャッシュ・
コヒーレンシのメカニズムによって、メモリに関しては操作がアトミックに実行されるよう保証さ
れる。キャッシュのロック操作の詳細については、『IA-32 インテルR アーキテクチャ・ソフトウェ
ア・デベロッパーズ・マニュアル、下巻』第7 章の「プロセッサ内部キャッシュ上のロック操作」を
参照のこと。
操作
AssertLOCK#(DurationOfAccompaningInstruction)
影響を受けるフラグ
なし。
オペコード命令説明
F0 LOCK 後の命令の実行中LOCK# 信号をアサートする。
3-388
命令セット・リファレンス
LOCK?Assert LOCK# Signal Prefix ( 続き)
保護モード例外
#UD LOCK プリフィックスが、上記の「説明」の項に示していない命令に使
用された場合。この、LOCK プリフックスが適用されようとした命令か
らは、他にも例外が発生する可能性がある。
実アドレス・モード例外
#UD LOCK プリフィックスが、上記の「説明」の項に示していない命令に使
用された場合。この、LOCK プリフックスが適用されようとした命令か
らは、他にも例外が発生する可能性がある。
仮想8086 モード例外
#UD LOCK プリフィックスが、上記の「説明」の項に示していない命令に使
用された場合。この、LOCK プリフックスが適用されようとした命令か
らは、他にも例外が発生する可能性がある。
3-389
命令セット・リファレンス
LODS/LODSB/LODSW/LODSD?Load String
説明
ソース・オペランドからAL、AX、またはEAXレジスタに、バイト、ワード、またはダブルワード
をロードする。ソース・オペランドはメモリ・ロケーションであり、そのアドレスは、 ( 命令のアド
レス・サイズ属性、32 または16に応じて) それぞれ DS:EDI またはDS:SI レジスタから読み取られる。
DSセグメントは、セグメント・オーバライド・プリフィックスでオーバライドすることができる。
アセンブリ・コード・レベルでは、この命令の「明示オペランド」形式および「オペランドなし」形
式という2つの形式が使用できる。 (LODSニーモニックで指定される) 明示オペランド形式では、ソー
ス・オペランドを明示的に指定することができる。この場合、ソース・オペランドは、ソース値の
サイズとロケーションを示す記号でなければならない。デスティネーション・オペランドは、この
場合にはソース・オペランドのサイズに一致するように自動的に選択される ( バイト・オペランドで
はAL、ワード・オペランドではAX、ダブルワード・オペランドではEAX)。この明示オペランド形
式は、ドキュメンテーションを可能にするために設けられたものであるが、この形式によって提供
されるドキュメンテーションは誤解を招く場合があるので注意されたい。すなわち、ソース・オペ
ランドの記号は、オペランドの正しいタイプ( サイズ: バイト、ワード、またはダブルワード) を指
定しなければならないが、正しいロケーションを指定する必要はない。ロケーションは、常にDS:(E)SI
レジスタによって指定されるので、ストリング・ロード命令が実行される前に、これらのレジスタ
に正しくロードされていなければならない。
オペランドなし形式は、LODS命令のバイト、ワード、およびダブルワード各バージョンの「ショー
ト形式」を提供する。この場合も、DS:(E)SI がソース・オペランドであると想定され、AL、AX、ま
たはEAXレジスタがデスティネーション・オペランドであると想定される。ソース・オペランドと
デスティネーション・オペランドのサイズは、LODSB(ALレジスタへのバイトのロード)、LODSW(AX
レジスタへのワードのロード)、またはLODSD(EAX レジスタへのダブルワードのロード) の各ニー
モニックで選択される。
バイト、ワード、またはダブルワードがメモリ・ロケーションからAL、AX、またはEAX レジスタ
に転送された後、(E)SI レジスタはEFLAGS レジスタ内のDF フラグの設定に従って自動的にインク
リメントまたはデクリメントされる。(DF フラグが0 である場合は、(E)SI レジスタはインクリメン
トされる。DF フラグが1 である場合は、(E)SI レジスタはデクリメントされる。) (E)SI レジスタは、
バイト操作の場合は1、ワード操作の場合は2、またダブルワードの場合は4、それぞれインクリメ
ントまたはデクリメントされる。
オペコード命令説明
AC LODS m8 アドレスDS:(E)SI のバイトをAL にロードする。
AD LODS m16 アドレスDS:(E)SI のワードをAX にロードする。
AD LODS m32 アドレスDS:(E)SI のダブルワードをEAX にロードする。
AC LODSB アドレスDS:(E)SI のバイトをAL にロードする。
AD LODSW アドレスDS:(E)SI のワードをAX にロードする。
AD LODSD アドレスDS:(E)SI のダブルワードをEAX にロードする。
3-390
命令セット・リファレンス
LODS/LODSB/LODSW/LODSD?Load String ( 続き)
LODS、LODSB、LODSW、およびLODSD 命令は、前にREP プリフィックスを付けることにより、
ECXバイト、ワード、またはダブルワードのブロック・ロードを行うことができる。しかし通常は、
レジスタに転送されたデータを次の転送が行われる前にさらに処理する必要があるので、これらの
命令はLOOP 構成体で使用されることの方が多い。REP プリフィックスの説明については、本章の
「REP/REPE/REPZ/REPNE /REPNZ?Repeat String Operation Prefix」を参照のこと。
操作
IF (byte load)
THEN
AL ← SRC; (* byte load *)
THEN IF DF ← 0
THEN (E)SI ← (E)SI + 1;
ELSE (E)SI ← (E)SI ? 1;
FI;
ELSE IF (word load)
THEN
AX ← SRC; (* word load *)
THEN IF DF ← 0
THEN (E)SI ← (E)SI + 2;
ELSE (E)SI ← (E)SI ? 2;
FI;
ELSE (* doubleword transfer *)
EAX ← SRC; (* doubleword load *)
THEN IF DF ← 0
THEN (E)SI ← (E)SI + 4;
ELSE (E)SI ← (E)SI ? 4;
FI;
FI;
FI;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
3-391
命令セット・リファレンス
LODS/LODSB/LODSW/LODSD?Load String ( 続き)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-392
命令セット・リファレンス
LOOP/LOOPcc?Loop According to ECX Counter
説明
ECXまたはCXレジスタをカウンタとして使用して、ループ操作を実行する。LOOP命令が実行され
るたびに、カウント・レジスタが1 デクリメントされ、次に0 かどうかチェックされる。カウントが
0 である場合は、ループは終了し、LOOP命令の次の命令からプログラムの実行が継続される。カウ
ントが0 でない場合は、デスティネーション ( ターゲット) オペランドへのnear ジャンプが行われる。
ターゲットはおそらくはループの先頭である。アドレス・サイズ属性が32 ビットである場合は、カ
ウント・レジスタとしてECXレジスタが使用される。そうでない場合は、CXレジスタが使用される。
ターゲット命令は相対オフセット (EIP レジスタ内の命令ポインタの現在値に相対的な符号付きオフ
セット) で指定される。相対オフセットは、アセンブリ・コードでは一般的にラベルとして指定され
るが、マシン・コード・レベルでは、符号付きの8 ビット即値としてコード化され、命令ポインタに
加算される。この命令には、-128 〜+127 までのオフセットが使用できる。
ループ命令 (LOOPcc) の一部の形式では、カウントが0 に達する前にループを終了させるための条件
としてZF フラグも指定できる。それらの形式の命令には、各命令に条件コード（cc が対応してお
り、それぞれにテストされる条件を示している。その場合、LOOPcc 命令そのものはZF フラグの状
態を変えない。ZF フラグを変更するのは、ループ内の他の命令である。
操作
IF AddressSize ← 32
THEN
Count is ECX;
ELSE (* AddressSize ← 16 *)
Count is CX;
FI;
Count ← Count ? 1;
IF instruction is not LOOP
THEN
IF (instruction ← LOOPE) OR (instruction ← LOOPZ)
THEN
IF (ZF =1) AND (Count ≠ 0)
THEN BranchCond ← 1;
オペコード命令説明
E2 cb LOOP rel8 カウントをデクリメントし、カウント ≠ 0 の場合short
ジャンプする。
E1 cb LOOPE rel8 カウントをデクリメントし、カウント ≠ 0 でかつZF=1 の
場合short ジャンプする。
E1 cb LOOPZ rel8 カウントをデクリメントし、カウント ≠ 0 でかつZF=1 の
場合short ジャンプする。
E0 cb LOOPNE rel8 カウントをデクリメントし、カウント ≠ 0 でかつZF=0 の
場合short ジャンプする。
E0 cb LOOPNZ rel8 カウントをデクリメントし、カウント ≠ 0 でかつZF=0 の
場合short ジャンプする。
3-393
命令セット・リファレンス
LOOP/LOOPcc?Loop According to ECX Counter ( 続き)
ELSE BranchCond ← 0;
FI;
FI;
IF (instruction ← LOOPNE) OR (instruction ← LOOPNZ)
THEN
IF (ZF =0 ) AND (Count ≠ 0)
THEN BranchCond ← 1;
ELSE BranchCond ← 0;
FI;
FI;
ELSE (* instruction ← LOOP *)
IF (Count ≠ 0)
THEN BranchCond ← 1;
ELSE BranchCond ← 0;
FI;
FI;
IF BranchCond ← 1
THEN
EIP ← EIP + SignExtend(DEST);
IF OperandSize ← 16
THEN
EIP ← EIP AND 0000FFFFH;
ELSE (* OperandSize = 32 *)
IF EIP < CS.Base OR EIP > CS.Limit
#GP
FI;
ELSE
Terminate loop and continue program execution at EIP;
FI;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) ジャンプ先のオフセットがCS セグメントの範囲を超えている場合。
実アドレス・モード例外
#GP ジャンプ先のオフセットがCS セグメントの範囲を超えている場合、ま
たは、0 〜 FFFFH の実効アドレス空間から外れている場合。この状態
は、32 ビットのアドレス・サイズ・オーバーライド・プリフィックスを
使用した場合に起きることがある。
仮想8086 モード例外
実アドレス・モードと同じ例外。
3-394
命令セット・リファレンス
LSL?Load Segment Limit
説明
スクランブルされていないセグメント範囲を第2 オペランド ( ソース・オペランド) で指定されたセ
グメント・ディスクリプタから第1 オペランド ( デスティネーション・オペランド) にロードし、
EFLAGSレジスタ内のZFフラグをセットする。ソース・オペランド ( レジスタまたはメモリ・ロケー
ション) の内容は、アクセスされるセグメント・ディスクリプタのセグメント・セレクタである。デ
スティネーション・オペランドは、汎用レジスタである。
プロセッサは、ロード・プロセスの一環としてアクセス・チェックを行う。デスティネーション・
レジスタにロードされると、ソフトウェアはセグメント範囲をポインタのオフセットと比較するこ
とができる。
セグメント範囲は、セグメント・ディスクリプタのバイト0 と1、およびバイト6 の最初の4 ビット
を含む20 ビットの値である。ディスクリプタのセグメント範囲がバイトを最小単位とする ( グラ
ニュラリティ・フラグが0 にされている) 場合は、デスティネーション・オペランドにバイト単位
値 ( バイト範囲) がロードされる。ディスクリプタのセグメント範囲がページを最小単位とする ( グ
ラニュラリティ・フラグが1 にセットされている) 場合は、LSL 命令はセグメント範囲をページ単
位範囲 ( ページ範囲) からバイト範囲に変換してから、それをデスティネーション・オペランドに
ロードする。この変換は、20 ビットの「生」の範囲を左に12 ビットシフトし、下位12 ビットを1
で埋めて行われる。
オペランド・サイズが32 ビットのときは、32 ビットのバイト範囲がデスティネーション・オペラン
ドにストアされる。オペランド・サイズが16 ビットのときは、有効な32ビットのバイト範囲が計算
されるが、上位16 ビットは切り捨てられ、下位16 ビットだけがデスティネーション・オペランドに
ロードされる。
この命令では、セグメント範囲をデスティネーション・レジスタにロードする前に以下のチェック
を行う。
? セグメント・セレクタがヌルでないことを確認する。
? セグメント・セレクタの指示先がアクセスされるGDT またはLDT の範囲内のディスクリプタ
であることを確認する。
? ディスクリプタのタイプがこの命令に対して有効であることを確認する。LSL 命令に対しては、
すべてのコード・セグメント・ディスクリプタとデータ・セグメント・ディスクリプタが有効
である ( すなわちLSL 命令でアクセスできる)。有効な特殊なセグメントおよびゲートのディス
クリプタ・タイプが下記の表に示してある。
? セグメントがコンフォーミング・コード・セグメントでない場合は、この命令は指定されたセ
グメント・ディスクリプタがCPLでアクセスできる ( すなわち、CPLとセグメント・セレクタの
RPLがセグメント・セレクタのDPL以下である) かを確認する。
セグメント・ディスクリプタがアクセスできないか、またはこの命令にとって無効なタイプである
場合は、ZF フラグがクリアされ、値は何もデスティネーション・オペランドにロードされない。
オペコード命令説明
0F 03 /r LSL r16,r/m16 "r16 ← セグメント範囲、セレクタr/m16 " のロードを行う。
0F 03 /r LSL r32,r/m32 "r32 ← セグメント範囲、セレクタr/m32 " のロードを行う。
3-395
命令セット・リファレンス
LSL?Load Segment Limit ( 続き)
操作
IF SRC[Offset) > descriptor table limit
THEN ZF ← 0; FI;
Read segment descriptor;
IF SegmentDescriptor(Type) ≠ conforming code segment
AND (CPL > DPL) OR (RPL > DPL)
OR Segment type is not valid for instruction
THEN
ZF ← 0
ELSE
temp ← SegmentLimit([SRC]);
IF (G ← 1)
THEN
temp ← ShiftLeft(12, temp) OR 00000FFFH;
FI;
IF OperandSize ← 32
THEN
DEST ← temp;
ELSE (*OperandSize ← 16*)
タイプ名前有効/ 無効
0 予約済み無効
1 使用可能16 ビットTSS 有効
2 LDT 有効
3 ビジー16 ビットTSS 有効
4 16 ビット・コール・ゲート無効
5 16 ビット/32 ビット・タスク・ゲート無効
6 16 ビット割り込みゲート無効
7 16 ビット・トラップ・ゲート無効
8 予約済み無効
9 使用可能32 ビットTSS 有効
A 予約済み無効
B ビジー32 ビットTSS 有効
C 32 ビット・コール・ゲート無効
D 予約済み無効
E 32 ビット割り込みゲート無効
F 32 ビット・トラップ・ゲート無効
3-396
命令セット・リファレンス
LSL?Load Segment Limit ( 続き)
DEST ← temp AND FFFFH;
FI;
FI;
影響を受けるフラグ
セグメント範囲が正常にロードされた場合はZF フラグが1 にセットされ、ロードできなかった場合
は0 にクリアされる。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#UD LSL 命令は実アドレス・モードでは認識されない。
仮想8086 モード例外
#UD LSL 命令は仮想8086 モードでは認識されない。
3-397
命令セット・リファレンス
LSS?Load Full Pointer
「LDS/LES/LFS/LGS/LSS?Load Far Pointer」を参照のこと。
3-398
命令セット・リファレンス
LTR?Load Task Register
説明
ソース・オペランドをタスク・レジスタのセグメント・セレクタ・フィールドにロードする。ソース・
オペランド ( 汎用レジスタまたはメモリ・ロケーション) の内容は、タスク・ステート・セグメント
(TSS) を指示先とするセグメント・セレクタである。セグメント・セレクタがタスク・レジスタにロー
ドされた後に、プロセッサはそのセグメント・セレクタを使用して、グローバル・ディスクリプタ・
テーブル (GDT) 内にあるTSS のセグメント・ディスクリプタの位置を探す。次に、セグメント・ディ
スクリプタからタスク・レジスタにTSSのセグメント範囲とベース・アドレスをロードする。タスク・
レジスタの指示先のタスクはビジーとマークされが、そのタスクへの切り替えは行われない。
LTR命令はオペレーティング・システム・ソフトウェアで使用するために設けられたものであり、ア
プリケーション・プログラムでは使用してはならない。この命令は、CPLが0 のときは保護モードで
しか実行することができない。LTR 命令は、最初に実行されるタスクを設定する初期化コードでよ
く使用される。
オペランド・サイズ属性は、この命令に影響を与えない。
操作
IF SRC[Offset) > descriptor table limit OR IF SRC[type) ≠ global
THEN #GP(segment selector);
FI;
Read segment descriptor;
IF segment descriptor is not for an available TSS THEN #GP(segment selector); FI;
IF segment descriptor is not present THEN #NP(segment selector);
TSSsegmentDescriptor(busy) ← 1;
(* Locked read-modify-write operation on the entire descriptor when setting busy flag *)
TaskRegister(SegmentSelector) ← SRC;
TaskRegister(SegmentDescriptor) ← TSSSegmentDescriptor;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) 現行特権レベルが0 でない場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
オペコード命令説明
0F 00 /3 LTR r/m16 r/m16 をタスク・レジスタにロードする。
3-399
命令セット・リファレンス
LTR?Load Task Register ( 続き)
#GP( セレクタ) ソース・セレクタの指示先のセグメントがTSS でないか、またはそのセ
グメントのタスクがすでにビジーの場合。
セレクタがLDT を指しているか、またはGDT の範囲を超えている場合。
#NP( セレクタ) TSS が存在しないとマークされている場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
実アドレス・モード例外
#UD LTR 命令は実アドレス・モードでは認識されない。
仮想8086 モード例外
#UD LTR 命令は仮想8086 モードでは認識されない。
3-400
命令セット・リファレンス
MASKMOVDQU?Store Selected Bytes of Double Quadword
説明
ソース・オペランド（第1 オペランド）の選択されたバイトを、128 ビットのメモリ・ロケーション
にストアする。マスク・オペランド（第2 オペランド）は、ソース・オペランド内のどのバイトがメ
モリに書き込まれるかを選択する。ソース・オペランドとマスク・オペランドはXMMレジスタであ
る。メモリ・ロケーションの最初のバイトの位置は、DI/EDI レジスタとDS レジスタで指定される。
メモリ・ロケーションのアライメントは、自然境界に合わせる必要はない（ストア・アドレスのサ
イズは、アドレス・サイズ属性によって異なる）。
マスク・オペランドの各バイトの最上位ビットは、ソース・オペランド内の対応するバイトがメモ
リ内の対応するバイト位置に書き込まれるかどうかを指定する。0 の場合は書き込みは行われず、1
の場合は書き込まれる。
MASKMOVEDQU 命令は、キャッシュの汚染を最小限に抑えるために、プロセッサに対して非テン
ポラルなヒントを生成する。非テンポラルなヒントは、WC(Write Combining) メモリ・タイプのプロ
トコルを使用して実現される( 詳しくは、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベ
ロッパーズ・マニュアル、上巻』の第10章の「テンポラルなデータと非テンポラルなデータのキャッ
シュ処理」を参照のこと)。WCプロトコルでは、順序設定のゆるいメモリ整合性モデルを使用する。
そのため、複数のプロセッサが異なるメモリ・タイプを使用してデスティネーション・メモリ・ロ
ケーションの読み込み/ 書き込みを実行する可能性がある場合は、SFENCE命令またはMFENCE命令
で実現されるフェンス操作をMASKMOVEDQU命令と一緒に使用する必要がある。
マスクがすべて0 の場合、この命令の動作は次のようになる。
? データはメモリに書き込まれない。
? ブレークポイント（コードまたはデータ）の報告は保証されていない。これらのブレークポイ
ントが報告されるかどうかは、プロセッサによって異なる。
? この場合も、メモリのアドレス指定に関連する例外とページ・フォルトは報告されることがあ
る（プロセッサによって異なる）。
? デスティネーション・メモリ領域がUCまたはWPとしてマッピングされている場合、これらの
メモリ・タイプに関連するセマンティクスの実行は保証されていない（つまり、予約されてい
る）。これらのセマンティクスが実行されるかどうかは、プロセッサによって異なる。
MASKMOVDQU命令を使用して、バイトごとに選択した上でデータをマージする必要があるアルゴ
リズムのパフォーマンスを向上させることができる。ただし、MASKMOVDQU命令で所有権の読み
込みを行ってはならない。これを行うと、ストアの前に元のデータを割り当てることなく、バイト・
マスクを使用してデータが直接書き込まれるため、不要な帯域幅が発生する。
オペコード命令説明
66 0F F7 /r MASKMOVDQU xmm1, xmm2 xmm2 のバイト・マスクを使用して、xmm1 のバイ
トを選択した上でメモリ・ロケーションに書き込む。
3-401
命令セット・リファレンス
MASKMOVDQU?Store Selected Bytes of Double Quadword ( 続き)
操作
IF (MASK[7] = 1)
THEN DEST[DI/EDI] ← SRC[7-0] ELSE * memory location unchanged *; FI;
IF (MASK[15] = 1)
THEN DEST[DI/EDI+1] ← SRC[15-8] ELSE * memory location unchanged *; FI;
* Repeat operation for 3rd through 14th bytes in source operand *;
IF (MASK[127] = 1)
THEN DEST[DI/EDI+15] ← SRC[127-120] ELSE * memory location unchanged *; FI;
同等のインテルC/C++ コンパイラ組み込み関数
void_mm_maskmoveu_si128(__m128i d, __m128i n, char * p)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合（マスクがすべて0 の場合にも発生する）。
#SS(0) SS セグメント内のアドレスが無効の場合（マスクがすべて0 の場合に
も発生する）。
#PF( フォルト・コード) ページ・フォルトが発生した場合（プロセッサ固有）。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合（マ
スクがすべて0 の場合にも発生する）。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合（プロセッサ固有）。
3-402
命令セット・リファレンス
MASKMOVQ?Store Selected Bytes of Quadword
説明
ソース・オペランド（第1 オペランド）の選択されたバイトを、64 ビットのメモリ・ロケーション
にストアする。マスク・オペランド（第2 オペランド）は、ソース・オペランド内のどのバイトがメ
モリに書き込まれるかを選択する。ソース・オペランドとマスク・オペランドはMMXテクノロジ・
レジスタである。メモリ・ロケーションの最初のバイトの位置は、DI/EDI レジスタとDSレジスタで
指定される（ストア・アドレスのサイズは、アドレス・サイズ属性によって異なる）。
マスク・オペランドの各バイトの最上位ビットは、ソース・オペランド内の対応するバイトがメモ
リ内の対応するバイト位置に書き込まれるかどうかを指定する。0 の場合は書き込みは行われず、1
の場合は書き込まれる。
MASKMOVQ 命令は、キャッシュの汚染を最小限に抑えるために、プロセッサに対して非テンポナ
ルなヒントを生成する。非テンポナルなヒントは、WC(Write Combining) メモリ・タイプのプロトコ
ルを使用して実現される( 詳しくは、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッ
パーズ・マニュアル、上巻』の第10 章の「テンポラルなデータと非テンポラルなデータのキャッシュ
処理」を参照のこと)。WCプロトコルでは、順序設定のゆるいメモリ整合性モデルを使用する。そ
のため、複数のプロセッサが異なるメモリ・タイプを使用してデスティネーション・メモリ・ロケー
ションの読み込み/ 書き込みを実行する可能性がある場合は、SFENCEまたはMFENCE命令で実現さ
れるフェンス操作をMASKMOVEDQU命令と一緒に使用する必要がある。
この命令を使用すると、x87 FPU ステートからMMX テクノロジ・ステートへの移行が発生する
（つまり、x87 FPU のトップオブスタック・ポインタは0 に設定され、x87 FPUタグ・ワードはすべ
て0[ 有効] に設定される）。
マスクがすべて0 の場合、MASKMOVQ命令の動作は次のようになる。
? データはメモリに書き込まれない。
? x87 FPUステートからMMXテクノロジ・ステートへの移行が発生する。
? この場合も、メモリのアドレス指定に関連する例外とページ・フォルトは報告されることがあ
る（プロセッサによって異なる）。
? ブレークポイント( コードまたはデータ) の報告については保証していない( プロセッサによっ
て異なる)。
? デスティネーション・メモリ領域がUCまたはWPとしてマッピングされる場合、これらのメモ
リ・タイプ用の関連するセマンティクスの実装については保証していない( 予約済みである)。
セマンティクスの実装については、プロセッサによって異なる。
MASKMOVQ 命令を使用して、バイトごとに選択した上で最小単位としてデータをマージする必要
があるアルゴリズムのパフォーマンスを強化することができる。MASKMOVQ 命令で所有権の読み
込みを行ってはならない。これを行うと、ストアの前に元のデータを割り当てずに、バイト・マス
クを使用してデータが直接書き込まれるため、不要な帯域幅が発生する。
オペコード命令説明
0F F7 /r MASKMOVQ mm1, mm2 mm2 のバイト・マスクを使用して、mm1 のバイトを選択
した上でメモリ・ロケーションに書き込む。
3-403
命令セット・リファレンス
MASKMOVQ?Store Selected Bytes of Quadword ( 続き)
操作
IF (MASK[7] = 1)
THEN DEST[DI/EDI] ← SRC[7-0] ELSE * memory location unchanged *; FI;
IF (MASK[15] = 1)
THEN DEST[DI/EDI+1] ← SRC[15-8] ELSE * memory location unchanged *; FI;
* Repeat operation for 3rd through 6th bytes in source operand *;
IF (MASK[63] = 1)
THEN DEST[DI/EDI+15] ← SRC[63-56] ELSE * memory location unchanged *; FI;
同等のインテルC/C++ コンパイラ組み込み関数
void_mm_maskmove_si64(__m64d, __m64n, char * p)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合( マスクがすべて0 の場合)。
#SS(0) SS セグメント内のアドレスが無効の場合( マスクがすべて0 の場合)。
#PF( フォルト・コード) ページ・フォルトが発生した場合( プロセッサ固有)。
#NM CR0 のTS がセットされた場合。
#MF 未処理のFPU 例外がある場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
ModR/M バイトのMod フィールドが11B でない場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFHの実効アドレス空間の範囲外の場合( マ
スクがすべて0 の場合)。
#NM CR0 のTS がセットされた場合。
#MF 未処理のFPU 例外がある場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
3-404
命令セット・リファレンス
MASKMOVQ?Store Selected Bytes of Quadword ( 続き)
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合( プロセッサ固有)。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-405
命令セット・リファレンス
MAXPD?Return Maximum Packed Double-Precision Floating-Point
Values
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の
パックド倍精度浮動小数点値のSIMD 比較を実行し、それぞれの値のペアの最大値をデスティネー
ション・オペランドに返す。ソース・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロ
ケーションである。デスティネーション・オペランドはXMMレジスタである。
比較される値が両方とも0.0 の場合は、第2 オペランド（ソース・オペランド）の値が返される。第
2 オペランドの値がSNaN の場合は、そのSNaN がそのままデスティネーションに転送される（つま
り、SNaN のQNaN版は返されない）。
この命令では、オペランド値のうち一方だけがNaN(SNaN またはQNaN) である場合は、第2 オペラ
ンド( ソース・オペランド) の値、すなわちNaN または有効な浮動小数点値が結果に書き込まれる。
これによって、コンパイラは、一般的なC の条件付き構造にMAXPD 命令を使用できる。この動作
の代わりに( 第1 または第2 オペランドの)NaNのソース・オペランドを返す必要がある場合は、一連
の命令( たとえば、比較の後にAND、ANDN、ORなど) を使用して、MAXPDのアクションをエミュ
レートする必要がある。
操作
DEST[63-0] ← IF ((DEST[63-0] == 0.0) AND (SRC[63-0] == 0.0)) THEN SRC[63-0]
ELSE IF (DEST[63-0] == SNaN) THEN SRC[63-0];
ELSE IF SRC[63-0] == SNaN) THEN SRC[63-0];
ELSE IF (DEST[63-0] > SRC[63-0])
THEN DEST[63-0]
ELSE SRC[63-0];
FI;
DEST[127-64] ← IF ((DEST[127-64] == 0.0) AND (SRC[127-64] == 0.0))
THEN SRC[127-64]
ELSE IF (DEST[127-64] == SNaN) THEN SRC[127-64];
ELSE IF SRC[127-64] == SNaN) THEN SRC[127-64];
ELSE IF (DEST[127-64] > SRC[63-0])
THEN DEST[127-64]
ELSE SRC[127-64];
FI;
同等のインテルC/C++ コンパイラ組み込み関数
__m128d _mm_max_pd(__m128d a, __m128d b)
オペコード命令説明
66 0F 5F /r MAXPD xmm1, xmm2/m128 xmm2/m128 とxmm1 の間で倍精度浮動小数点値の最大
値を返す。
3-406
命令セット・リファレンス
MAXPD?Return Maximum Packed Double-Precision Floating-Point
Values ( 続き)
SIMD 浮動小数点例外
無効（QNaNソース・オペランドの場合を含む）、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-407
命令セット・リファレンス
MAXPS?Return Maximum Packed Single-Precision Floating-Point
Values
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の
パックド単精度浮動小数点値のSIMD 比較を実行し、それぞれの値のペアの最大値をデスティネー
ション・オペランドに返す。ソース・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロ
ケーションである。デスティネーション・オペランドはXMMレジスタである。
比較される値が両方とも0.0 の場合は、第2 オペランド（ソース・オペランド）の値が返される。第
2 オペランドの値がSNaNの場合は、そのSNaNがそのままデスティネーションに返される（つまり、
SNaNのQNaN版は返されない）。
この命令では、オペランド値のうち一方だけがNaN(SNaN またはQNaN) である場合は、第2 オペラ
ンド( ソース・オペランド) の値、すなわちNaN または有効な浮動小数点値が結果に書き込まれる。
この動作により、コンパイラは、一般的なCの条件付き構造にMAXPS 命令を使用できる。この動作
の代わりに( 第1 または第2 オペランドの)NaNのソース・オペランドを返す必要がある場合は、一連
の命令( たとえば、比較の後にAND、ANDN、ORなど) を使用して、MAXPS のアクションをエミュ
レートする必要がある。
操作
DEST[31-0] ← IF ((DEST[31-0] == 0.0) AND (SRC[31-0] == 0.0)) THEN SRC[31-0]
ELSE IF (DEST[31-0] == SNaN) THEN SRC[31-0];
ELSE IF SRC[31-0] == SNaN) THEN SRC[31-0];
ELSE IF (DEST[31-0] > SRC[31-0])
THEN DEST[31-0]
ELSE SRC[31-0];
FI;
* repeat operation for 2nd and 3rd doublewords *;
DEST[127-64] ← IF ((DEST[127-96] == 0.0) AND (SRC[127-96] == 0.0))
THEN SRC[127-96]
ELSE IF (DEST[127-96] == SNaN) THEN SRC[127-96];
ELSE IF SRC[127-96] == SNaN) THEN SRC[127-96];
ELSE IF (DEST[127-96] > SRC[127-96])
THEN DEST[127-96]
ELSE SRC[127-96];
FI;
同等のインテルC/C++ コンパイラ組み込み関数
__m128d _mm_max_ps(__m128d a, __m128d b)
オペコード命令説明
0F 5F /r MAXPS xmm1, xmm2/m128 xmm2/m128 とxmm1 の単精度浮動小数点値を比較し
て、各要素の最大値を返す。
3-408
命令セット・リファレンス
MAXPS?Return Maximum Packed Single-Precision Floating-Point
Values ( 続き)
SIMD 浮動小数点例外
無効(QNaNソース・オペランドを含む)、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-409
命令セット・リファレンス
MAXSD?Return Maximum Scalar Double-Precision Floating-Point
Value
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の下
位の倍精度浮動小数点値を比較し、最大値をデスティネーション・オペランドの下位クワッドワー
ドに返す。ソース・オペランドは、XMMレジスタまたは64ビットのメモリ・ロケーションである。
デスティネーション・オペランドはXMMレジスタである。ソース・オペランドがメモリ・オペラン
ドの場合は、64 ビットだけがアクセスされる。デスティネーション・オペランドの上位クワッドワー
ドは、変更されない。
比較される値が両方とも0.0 の場合は、第2 オペランド（ソース・オペランド）の値が返される。第
2 オペランドの値がSNaNの場合は、そのSNaNがそのままデスティネーションに返される（つまり、
SNaNのQNaN版は返されない）。
この命令では、オペランド値のうち一方だけがNaN（SNaNまたはQNaN) である場合は、第2 オペラ
ンド( ソース・オペランド) の値、すなわちNaN または有効な浮動小数点値が結果に書き込まれる。
これによって、コンパイラは、一般的なC の条件付き構造にMAXSD 命令を使用できる。この動作
の代わりに（第1 または第2 オペランドの）NaNのソース・オペランドを返す必要がある場合は、一
連の命令( たとえば、比較の後にAND、ANDN、OR など) を使用して、MAXSD のアクションをエ
ミュレートする必要がある。
操作
DEST[63-0] ← IF ((DEST[63-0] == 0.0) AND (SRC[63-0] == 0.0)) THEN SRC[63-0]
IF (DEST[63-0] == SNaN) THEN SRC[63-0];
ELSE IF SRC[63-0] == SNaN) THEN SRC[63-0];
ELSE IF (DEST[63-0] > SRC[63-0])
THEN DEST[63-0]
ELSE SRC[63-0];
FI;
* DEST[127-64] is unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
__m128d _mm_max_sd(__m128d a, __m128d b)
SIMD 浮動小数点例外
無効（QNaN ソース・オペランドの場合を含む）、デノーマル。
オペコード命令説明
F2 0F 5F /r MAXSD xmm1, xmm2/m64 xmm2/mem64 とxmm1 の間でスカラ倍精度浮動小数点
値の最大値を返す。
3-410
命令セット・リファレンス
MAXSD?Return Maximum Scalar Double-Precision Floating-Point
Value ( 続き)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-411
命令セット・リファレンス
MAXSS?Return Maximum Scalar Single-Precision Floating-Point
Value
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の最
下位の単精度浮動小数点値を比較し、最大値をデスティネーション・オペランドの最下位のダブル
ワードに返す。ソース・オペランドは、XMM レジスタまたは32 ビットのメモリ・ロケーションで
ある。デスティネーション・オペランドはXMMレジスタである。ソース・オペランドがメモリ・オ
ペランドの場合は、32 ビットだけがアクセスされる。デスティネーション・オペランドの上位3 ダ
ブルワードは、変更されない。
比較される値が両方とも0.0 の場合は、第2 オペランド（ソース・オペランド）の値が返される。第
2 オペランドの値がSNaNの場合は、そのSNaNがそのままデスティネーションに返される（つまり、
SNaNのQNaN版は返されない）。
この命令では、オペランド値のうち一方だけがNaN(SNaN またはQNaN) である場合は、第2 オペラ
ンド( ソース・オペランド) の値、すなわちNaN または有効な浮動小数点値が結果に書き込まれる。
この動作により、コンパイラは、一般的なCの条件付き構造にMAXSS 命令を使用できる。この動作
の代わりに( 第1 または第2 オペランドの)NaNのソース・オペランドを返す必要がある場合は、一連
の命令( たとえば、比較の後にAND、ANDN、ORなど) を使用して、MAXSS のアクションをエミュ
レートする必要がある。
操作
DEST[63-0] ← IF ((DEST[31-0] == 0.0) AND (SRC[31-0] == 0.0)) THEN SRC[31-0]
ELSE IF (DEST[31-0] == SNaN) THEN SRC[31-0];
ELSE IF SRC[31-0] == SNaN) THEN SRC[31-0];
ELSE IF (DEST[31-0] > SRC[31-0])
THEN DEST[31-0]
ELSE SRC[31-0];
FI;
* DEST[127-32] is unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
__m128d _mm_max_ss(__m128d a, __m128d b)
SIMD 浮動小数点例外
無効(QNaNソース・オペランドを含む)、デノーマル。
オペコード命令説明
F3 0F 5F /r MAXSS xmm1, xmm2/m32 xmm2/mem32 とxmm1 のスカラ単精度浮動小数点値を
比較して、各要素の最大値を返す。
3-412
命令セット・リファレンス
MAXSS?Return Maximum Scalar Single-Precision Floating-Point
Value ( 続き)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-413
命令セット・リファレンス
MFENCE?Memory Fence
説明
MFENCE 命令より前に発行されたすべてのメモリからのロード命令とメモリからのストア命令に対
して、シリアル化操作を実行する。このシリアル化操作は、プログラムの順序でMFENCE命令に先
行するすべてのロード命令とストア命令が、MFENCE 命令に後続するロード命令とストア命令より
前に、グローバルにアクセス可能になることを保証する。MFENCE 命令は、すべてのロード命令と
ストア命令、他のMFENCE命令、すべてのSFENCE命令とLFENCE命令、およびすべてのシリアル
化命令（CPUID命令など）に対して順序付けされる。
順序設定の緩いメモリ・タイプを使用して、アウト・オブ・オーダー発行、見込み的な読み込み、ラ
イト・コンバイニング、およびライト・コラプシングなどの手法により、プロセッサ・パフォーマ
ンスの向上を達成する。データを参照する側のルーチンが、順序設定の緩いデータであることをど
の程度認識しているかは、アプリケーションによって異なり、データを生成する側のルーチンには
わからない。MFENCE命令は、順序設定の緩い結果を生成するルーチンとそのデータを参照するルー
チンの間のロードとストアの順序付けを保証するための効率的な方法である。
プロセッサは、見込み的な読み込みが許されるメモリ・タイプ（すなわち、WB、WC、およびWT
メモリ・タイプ）が割り当てられたシステム・メモリ領域から、いつでもデータを見込み的にフェッ
チしてキャッシュに入れることができる。PREFETCHh 命令は、この見込み的な動作に対するヒント
と見なされる。この見込み的なフェッチ動作は、命令の実行には拘束されず、任意の時点で発生す
る。したがって、MFENCE命令は、PREFETCHh 命令などの見込み的なフェッチ機構に対して順序付
けされない（つまり、MFENCE 命令の実行の直前、実行中、または実行後に、データがキャッシュ
に見込み的にロードされる可能性がある）。
操作
Wait_On_Following_Loads_And_Stores_Until(preceding_loads_and_stores_globally_visible);
同等のインテルC/C++ コンパイラ組み込み関数
void_mm_mfence(void)
例外（すべての動作モード）
なし。
オペコード命令説明
0F AE /6 MFENCE ロード操作とストア操作をシリアル化する。
3-414
命令セット・リファレンス
MINPD?Return Minimum Packed Double-Precision Floating-Point
Values
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の
パックド倍精度浮動小数点値のSIMD 比較を実行し、それぞれの値のペアの最小値をデスティネー
ション・オペランドに返す。ソース・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロ
ケーションである。デスティネーション・オペランドはXMMレジスタである。
比較される値が両方とも0.0 の場合は、第2 オペランド（ソース・オペランド）の値が返される。第
2 オペランドの値がSNaNの場合は、そのSNaNがそのままデスティネーションに返される（つまり、
SNaNのQNaN版は返されない）。
この命令では、オペランド値のうち一方だけがNaN(SNaN またはQNaN) である場合は、第2 オペラ
ンド( ソース・オペランド) の値、すなわちNaN または有効な浮動小数点値が結果に書き込まれる。
これによって、コンパイラは、一般的なCの条件付き構造にMINPD命令を使用できる。この動作の
代わりに( 第1 または第2 オペランドの)NaNのソース・オペランドを返す必要がある場合は、一連の
命令( たとえば、比較の後にAND、ANDN、OR など) を使用して、MINPD のアクションをエミュ
レートする必要がある。
操作
DEST[63-0] ← IF ((DEST[63-0] == 0.0) AND (SRC[63-0] == 0.0)) THEN SRC[63-0]
ELSE IF (DEST[63-0] == SNaN) THEN SRC[63-0];
ELSE IF SRC[63-0] == SNaN) THEN SRC[63-0];
ELSE IF (DEST[63-0] < SRC[63-0])
THEN DEST[63-0]
ELSE SRC[63-0];
FI;
DEST[127-64] ← IF ((DEST[127-64] == 0.0) AND (SRC[127-64] == 0.0))
THEN SRC[127-64]
ELSE IF (DEST[127-64] == SNaN) THEN SRC[127-64];
ELSE IF SRC[127-64] == SNaN) THEN SRC[127-64];
ELSE IF (DEST[127-64] < SRC[63-0])
THEN DEST[127-64]
ELSE SRC[127-64];
FI;
同等のインテルC/C++ コンパイラ組み込み関数
__m128d _mm_min_pd(__m128d a, __m128d b)
オペコード命令説明
66 0F 5D /r MINPD xmm1, xmm2/m128 xmm2/m128 とxmm1 の間で倍精度浮動小数点値の最小
値を返す。
3-415
命令セット・リファレンス
MINPD?Return Minimum Packed Double-Precision Floating-Point
Values ( 続き)
SIMD 浮動小数点例外
無効（QNaN ソース・オペランドの場合を含む）、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-416
命令セット・リファレンス
MINPS?Return Minimum Packed Single-Precision Floating-Point
Values
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の
パックド単精度浮動小数点値のSIMD 比較を実行し、それぞれの値のペアの最小値をデスティネー
ション・オペランドに返す。ソース・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロ
ケーションである。デスティネーション・オペランドはXMMレジスタである。
比較される値が両方とも0.0 の場合は、第2 オペランド（ソース・オペランド）の値が返される。第
2 オペランドの値がSNaNの場合は、そのSNaNがそのままデスティネーションに返される（つまり、
SNaNのQNaN版は返されない）。
この命令では、オペランド値のうち一方だけがNaN(SNaN またはQNaN) である場合は、第2 オペラ
ンド( ソース・オペランド) の値、すなわちNaN または有効な浮動小数点値が結果に書き込まれる。
この動作により、コンパイラは、一般的なCの条件付き構造にMINPS 命令を使用できる。この動作
の代わりに( 第1 または第2 オペランドの)NaN のソース・オペランドを返す必要がある場合は、一連
の命令( たとえば、比較の後にAND、ANDN、ORなど) を使用して、MINPS のアクションをエミュ
レートする必要がある。
操作
DEST[63-0] ← IF ((DEST[31-0] == 0.0) AND (SRC[31-0] == 0.0)) THEN SRC[31-0]
ELSE IF (DEST[31-0] == SNaN) THEN SRC[31-0];
ELSE IF SRC[31-0] == SNaN) THEN SRC[31-0];
ELSE IF (DEST[31-0] > SRC[31-0])
THEN DEST[31-0]
ELSE SRC[31-0];
FI;
* repeat operation for 2nd and 3rd doublewords *;
DEST[127-64] ← IF ((DEST127-96] == 0.0) AND (SRC[127-96] == 0.0))
THEN SRC[127-96]
ELSE IF (DEST[127-96] == SNaN) THEN SRC[127-96];
ELSE IF SRC[127-96] == SNaN) THEN SRC[127-96];
ELSE IF (DEST[127-96] < SRC[127-96])
THEN DEST[127-96]
ELSE SRC[127-96];
FI;
同等のインテルC/C++ コンパイラ組み込み関数
__m128d _mm_min_ps(__m128d a, __m128d b)
オペコード命令説明
0F 5D /r MINPS xmm1, xmm2/m128 xmm2/m128 とxmm1 の単精度浮動小数点値を比較し
て、各要素の最小値を返す。
3-417
命令セット・リファレンス
MINPS?Return Minimum Packed Single-Precision Floating-Point
Values ( 続き)
SIMD 浮動小数点例外
無効(QNaNソース・オペランドを含む)、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-418
命令セット・リファレンス
MINSD?Return Minimum Scalar Double-Precision Floating-Point
Value
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の下
位の倍精度浮動小数点値を比較し、最小値をデスティネーション・オペランドの下位クワッドワー
ドに返す。ソース・オペランドは、XMMレジスタまたは64 ビットのメモリ・ロケーションである。
デスティネーション・オペランドはXMMレジスタである。ソース・オペランドがメモリ・オペラン
ドの場合は、64 ビットだけがアクセスされる。デスティネーション・オペランドの上位クワッドワー
ドは、変更されない。
比較される値が両方とも0.0 の場合は、第2 オペランド（ソース・オペランド）の値が返される。第
2 オペランドの値がSNaNの場合は、そのSNaNがそのままデスティネーションに返される（つまり、
SNaNのQNaN版は返されない）。
この命令では、オペランド値のうち一方だけがNaN(SNaN またはQNaN) である場合は、第2 オペラ
ンド( ソース・オペランド) の値、すなわちNaN または有効な浮動小数点値が結果に書き込まれる。
これによって、コンパイラは、一般的なCの条件付き構造にMINSD命令を使用できる。この動作の
代わりに( 第1 または第2 オペランドの)NaNのソース・オペランドを返す必要がある場合は、一連の
命令( たとえば、比較の後にAND、ANDN、OR など) を使用して、MINSD のアクションをエミュ
レートする必要がある。
操作
DEST[63-0] ← IF ((DEST[63-0] == 0.0) AND (SRC[63-0] == 0.0)) THEN SRC[63-0]
ELSE IF (DEST[63-0] == SNaN) THEN SRC[63-0];
ELSE IF SRC[63-0] == SNaN) THEN SRC[63-0];
ELSE IF (DEST[63-0] < SRC[63-0])
THEN DEST[63-0]
ELSE SRC[63-0];
FI;
* DEST[127-64] is unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
__m128d _mm_min_sd(__m128d a, __m128d b)
SIMD 浮動小数点例外
無効（QNaNソース・オペランドの場合を含む）、デノーマル。
オペコード命令説明
F2 0F 5D /r MINSD xmm1, xmm2/m64 xmm2/mem64 とxmm1 の間でスカラ倍精度浮動小数点
値の最小値を返す。
3-419
命令セット・リファレンス
MINSD?Return Minimum Scalar Double-Precision Floating-Point Value
( 続き)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-420
命令セット・リファレンス
MINSS?Return Minimum Scalar Single-Precision Floating-Point Value
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の最
下位の単精度浮動小数点値を比較し、最小値をデスティネーション・オペランドの最下位のダブル
ワードに返す。ソース・オペランドは、XMM レジスタまたは32 ビットのメモリ・ロケーションで
ある。デスティネーション・オペランドはXMMレジスタである。ソース・オペランドがメモリ・オ
ペランドの場合は、32 ビットだけがアクセスされる。デスティネーション・オペランドの上位3 ダ
ブルワードは、変更されない。
比較される値が両方とも0.0 の場合は、第2 オペランド（ソース・オペランド）の値が返される。第
2 オペランドの値がSNaNの場合は、そのSNaNがそのままデスティネーションに返される（つまり、
SNaNのQNaN版は返されない）。
この命令では、オペランド値のうち一方だけがNaN(SNaN またはQNaN) である場合は、第2 オペラ
ンド( ソース・オペランド) の値、すなわちNaN または有効な浮動小数点値が結果に書き込まれる。
この動作により、コンパイラは、一般的なCの条件付き構造にMINSS 命令を使用できる。この動作
の代わりに( 第1 または第2 オペランドの)NaN のソース・オペランドを返す必要がある場合は、一連
の命令( たとえば、比較の後にAND、ANDN、ORなど) を使用して、MINSS のアクションをエミュ
レートする必要がある。
操作
DEST[63-0] ← IF ((DEST[31-0] == 0.0) AND (SRC[31-0] == 0.0)) THEN SRC[31-0]
ELSE IF (DEST[31-0] == SNaN) THEN SRC[31-0];
ELSE IF SRC[31-0] == SNaN) THEN SRC[31-0];
ELSE IF (DEST[31-0] < SRC[31-0])
THEN DEST[31-0]
ELSE SRC[31-0];
FI;
* DEST[127-32] is unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
__m128d _mm_min_ss(__m128d a, __m128d b)
SIMD 浮動小数点例外
無効(QNaNソース・オペランドを含む)、デノーマル。
オペコード命令説明
F3 0F 5D /r MINSS xmm1, xmm2/m32 xmm2/mem32 とxmm1 のスカラ単精度浮動小数点値を
比較して、最小値を返す。
3-421
命令セット・リファレンス
MINSS?Return Minimum Scalar Single-Precision Floating-Point Value
( 続き)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-422
命令セット・リファレンス
MOV?Move
注:
* moffs8、moffs16、moffs32 オペランドは、8、16、32 がデータのサイズを参照するセグメント・ベースに相
対的な単純オフセットを指定する。命令のアドレス・サイズ属性によって、オフセットのサイズ(16 ビットま
たは32 ビット) が決まる。
** 32 ビット・モードでは、アセンブラは、この命令に16 ビット・オペランド・サイズ・プリフィックスを挿入
することがある( 詳細については、以下の「説明」の項を参照のこと)。
説明
第2 オペランド( ソース・オペランド) を第1 オペランド( デスティネーション・オペランド) にコピー
する。ソース・オペランドには、即値、汎用レジスタ、セグメント・レジスタ、またはメモリ・ロ
ケーションを使用できる。デスティネーション・オペランドには、汎用レジスタ、セグメント・レ
ジスタ、またはメモリ・ロケーションを使用できる。両方のオペランドとも、同じサイズ( バイト、
ワード、またはダブルワード) でなければならない。
MOV命令を使用してCS レジスタをロードすることはできない。そうしようとすると、無効オペコー
ド例外(#UD)が発生する。CSレジスタをロードするには、far JMP、CALL、またはRET命令を使用する。
オペコード命令説明
88 /r MOV r/m8,r8 r8 をr/m8 に転送する。
89 /r MOV r/m16,r16 r16 をr/m16 に転送する。
89 /r MOV r/m32,r32 r32 をr/m32 に転送する。
8A /r MOV r8,r/m8 r/m8 をr8 に転送する。
8B /r MOV r16,r/m16 r/m16 をr16 に転送する。
8B /r MOV r32,r/m32 r/m32 をr32 に転送する。
8C /r MOV r/m16,Sreg** セグメント・レジスタをr/m16 に転送する。
8E /r MOV Sreg,r/m16** r/m16 をセグメント・レジスタに転送する。
A0 MOV AL,moffs8* ( セグメント: オフセット) のバイトをAL に転送する。
A1 MOV AX,moffs16* ( セグメント: オフセット) のワードをAX に転送する。
A1 MOV EAX,moffs32* ( セグメント: オフセット) のダブルワードをEAX に転送する。
A2 MOV moffs8*,AL AL を( セグメント: オフセット) に転送する。
A3 MOV moffs16*,AX AX を( セグメント: オフセット) に転送する。
A3 MOV moffs32*,EAX EAX を( セグメント: オフセット) に転送する。
B0+ rb MOV r8,imm8 imm8 をr8 に転送する。
B8+ rw MOV r16,imm16 imm16 をr16 に転送する。
B8+ rd MOV r32,imm32 imm32 をr32 に転送する。
C6 /0 MOV r/m8,imm8 imm8 をr/m8 に転送する。
C7 /0 MOV r/m16,imm16 imm16 をr/m16 に転送する。
C7 /0 MOV r/m32,imm32 imm32 をr/m32 に転送する。
3-423
命令セット・リファレンス
MOV?Move ( 続き)
デスティネーション・オペランドがセグメント・レジスタ(DS、ES、FS、GS、またはSS) である場
合は、ソース・オペランドは有効なセグメント・セレクタでなければならない。保護モードでは、セ
グメント・セレクタをセグメント・レジスタに転送すると、そのセグメント・セレクタに関連する
セグメント・ディスクリプタ情報が自動的にセグメント・レジスタの隠蔽( シャドー) 部分にロード
される。この情報をロードしている間は、セグメント・セレクタおよびセグメント・ディスクリプ
タ情報が有効になる( 下記の「操作」のアルゴリズムを参照)。セグメント・ディスクリプタ・デー
タは、指定したセグメント・セレクタのGDTエントリまたはLDTエントリから得られる。
ヌルのセグメント・セレクタ( 値0000 〜0003) を保護例外を発生させずにDS、ES、FS、およびGSレ
ジスタにロードすることができる。ただし、その対応するセグメント・レジスタがヌル値をロード
されているセグメントをその後に参照しようとすると、一般保護例外(#GP) が発生し、メモリ参照は
行われない。
SSレジスタをMOV命令でロードすると、次の命令の実行後まですべての割り込みが禁止される。こ
の操作によって、割り込みが発生する前に、次の命令(MOV ESP、スタック・ポインタ値) でESP レ
ジスタにスタック・ポインタをロードすることができる1。LSS 命令によって、SSレジスタとESP レ
ジスタをより効率的にロードすることができる。
32 ビット・モードで動作しているときにセグメント・レジスタと汎用レジスタとの間でデータを転
送すると、32 ビットのIA-32 プロセッサでは、この命令で16 ビット・オペランド・サイズ・プリ
フィックス( 値66Hをもつバイト) を使用する必要はないが、ほとんどのアセンブラでは、命令の標
準形式( 例えば、MOV DS,AX) が使用されているとそのプリフィックスを挿入する。プロセッサは、
この命令を正しく実行するが、通常は余分なクロックを必要とする。ほとんどのアセンブラでは、命
令形式MOV DS,EAXを使用すると、この不必要な66Hプリフィックスを避けられる。プロセッサは、
32ビット汎用レジスタを使用する命令を実行するときは、汎用レジスタの下位16 ビットがデスティ
ネーション・オペランドまたはソース・オペランドであると想定する。レジスタがデスティネーショ
ン・オペランドである場合は、レジスタの上位2 バイトにある結果の値は、プロセッサに依存する。
Pentium Pro プロセッサでは、上位2 バイトにはゼロが入る。それより以前の32 ビットのIA-32 プロ
セッサでは、上位2 バイトは未定義である
操作
DEST ← SRC;
保護モードの間にセグメント・レジスタをロードすると、以下のリストで説明しているように特殊
なチェックと処置が行われる。これらのチェックは、セグメント・セレクタおよびそれが指してい
るセグメント・ディスクリプタに対して行われる。
1. 以下の命令を過ぎて割り込みを個別にディレイさせる命令シーケンスでは、シーケンスの最初の命令は、割り
込みをディレイさせることが保証されるが、後続の割り込みディレイ命令は、割り込みをディレイさせない場
合があることに注意されたい。そのため、以下の命令シーケンスでは、
STI
MOV SS, EAX
MOV ESP, EBP
STI も1 命令の間割り込みをディレイさせるので、MOV ESP,EBP が実行される前に、割り込みが認識される
こともある。
3-424
命令セット・リファレンス
MOV?Move ( 続き)
IF SS is loaded;
THEN
IF segment selector is null
THEN #GP(0);
FI;
IF segment selector index is outside descriptor table limits
OR segment selector's RPL ≠ CPL
OR segment is not a writable data segment
OR DPL ≠ CPL
THEN #GP(selector);
FI;
IF segment not marked present
THEN #SS(selector);
ELSE
SS ← segment selector;
SS ← segment descriptor;
FI;
FI;
IF DS, ES, FS, or GS is loaded with non-null selector;
THEN
IF segment selector index is outside descriptor table limits
OR segment is not a data or readable code segment
OR ((segment is a data or nonconforming code segment)
AND (both RPL and CPL > DPL))
THEN #GP(selector);
IF segment not marked present
THEN #NP(selector);
ELSE
SegmentRegister ← segment selector;
SegmentRegister ← segment descriptor;
FI;
FI;
IF DS, ES, FS, or GS is loaded with a null selector;
THEN
SegmentRegister ← segment selector;
SegmentRegister ← segment descriptor;
FI;
影響を受けるフラグ
なし。
3-425
命令セット・リファレンス
MOV?Move ( 続き)
保護モード例外
#GP(0) ヌル・セグメント・セレクタでSS レジスタをロードしようとした場合。
デスティネーション・オペランドが書き込み不可能なセグメントにある
場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#GP( セレクタ) セグメント・セレクタ・インデックスがディスクリプタ・テーブルの範
囲外の場合。
SS レジスタがロードされ、セグメント・セレクタのRPL およびセグメ
ント・ディスクリプタのDPL がCPL に等しくない場合。
SS レジスタがロードされ、指示先のセグメントが書き込み不可能なデー
タ・セグメントである場合。
DS、ES、FS、またはGS レジスタがロードされ、指示先のセグメントが
データ・セグメントまたは書き込み可能なコード・セグメントでない場
合。
DS、ES、FS、またはGS レジスタがロードされ、指示先のセグメントが
データ・セグメントまたは非コンフォーミング・コード・セグメントで
あるが、RPL とCPL の両方ともDPL より大きい場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#SS( セレクタ) SS レジスタがロードされ、指示先のセグメントが存在しないとマーク
されている場合。
#NP DS、ES、FS、またはGS レジスタがロードされ、指示先のセグメントが
存在しないとマークされている場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
#UD CS レジスタをロードしようとした場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CS レジスタをロードしようとした場合。
3-426
命令セット・リファレンス
MOV?Move ( 続き)
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
#UD CS レジスタをロードしようとした場合。
3-427
命令セット・リファレンス
MOV?Move to/from Control Registers
説明
制御レジスタ(CR0、CR2、CR3、またはCR4) の内容を汎用レジスタに、またはその逆に転送する。
これらの命令のオペランド・サイズは、オペランド・サイズ属性に関係なく常に32 ビットである。
制御レジスタのフラグとフィールドの詳細な説明については、『IA-32 インテルR アーキテクチャ・ソ
フトウェア・デベロッパーズ・マニュアル、下巻』第2 章の「制御レジスタ」を参照のこと。この命
令は、現在の特権レベルが0 である場合にだけ実行できる。
制御レジスタをロードするときは、プログラムはどの予約ビットの変更も試みてはならない。すな
わち、常に前に読み取られた値に予約ビットを設定する。
オペコード・レベルでは、ModR/M バイト内のreg フィールドは、どの制御レジスタをロードするか
または読み取るかを指定する。mod フィールドの2 ビットは、常に11B である。r/m フィールドは、
ロードされるかまたは読み取られる汎用レジスタを指定する。
これらの命令は、以下の二次的な影響も与える。
? 制御レジスタCR3 に書き込むと、すべての非グローバルTLB エントリがフラッシュされる。制
御レジスタのフラグとフィールドの詳細な説明については、『IA-32 インテルR アーキテクチャ・
ソフトウェア・デベロッパーズ・マニュアル、下巻』第3 章の「トランスレーション・ルックア
サイド・バッファ(TLB)」を参照のこと。
以下の二次的な影響は、Pentium Pro プロセッサではプロセッサ固有である。将来および以前のIA-32
プロセッサでは、ソフトウェアはこの機能に依存してはならない。
? 制御レジスタのページング・フラグ(CR0 レジスタのPE とPG、CR4 レジスタのPGE、PSE、お
よびPAE) のいずれかを修正すると、グローバル・エントリを含めたすべてのTLBエントリがフ
ラッシュされる。
? PG フラグを1 にセットし、( 物理アドレス拡張モードをイネーブルにするために)PAE フラグを
1 にセットするように制御レジスタCR4 に書き込むと、ページ・ディレクトリ・ポインタ・テー
ブルのポインタ(PDPTR) がプロセッサに( 内部非アーキテクチャ・レジスタに) ロードされる。
? PAE フラグを1 にセットし、PG フラグを1 にセットしている場合に、制御レジスタCR3 に書き
込むと、PDPTRがプロセッサに再ロードされる。
? PAE フラグを1 にセットし、PG フラグをセットするように制御レジスタCR0 に書き込むと、
PDPTRがプロセッサに再ロードされる。
オペコード命令説明
0F 22 /r MOV CR0,r32 0F 22 r32 をCR0 に転送する。
0F 22 /r MOV CR2,r32 0F 22 r32 をCR2 に転送する。
0F 22 /r MOV CR3,r32 0F 22 r32 をCR3 に転送する。
0F 22 /r MOV CR4,r32 0F 22 r32 をCR4 に転送する。
0F 20 /r MOV r32,CR0 0F 20 CR0 をr32 に転送する。
0F 20 /r MOV r32,CR2 0F 20 CR2 をr32 に転送する。
0F 20 /r MOV r32,CR3 0F 20 CR3 をr32 に転送する。
0F 20 /r MOV r32,CR4 0F 20 CR4 をr32 に転送する。
3-428
命令セット・リファレンス
MOV?Move to/from Control Registers ( 続き)
操作
DEST ← SRC;
影響を受けるフラグ
OF、SF、ZF、AF、PF、およびCFフラグは未定義。
保護モード例外
#GP(0) 現行特権レベルが0 でない場合。
(PE フラグが0 にセットされているときにPG フラグを1 にセットする
か、またはNW フラグが1 にセットされているときにCD フラグを0 に
セットするなど) 無効なビット組み合わせの書き込みをCR0 に行おうと
した場合。
CR4 の予約ビットに1 を書き込もうとした場合。
実アドレス・モード例外
#GP CR4 の予約ビットに1 を書き込もうとした場合。
仮想8086 モード例外
#GP(0) これらの命令は、仮想8086 モードで実行することはできない。
3-429
命令セット・リファレンス
MOV?Move to/from Debug Registers
説明
デバッグ・レジスタ(DR0、DR1、DR2、DR3、DR4、DR5、DR6、またはDR7) の内容を汎用レジス
タに、またはその逆に転送する。これらの命令のオペランド・サイズは、オペランド・サイズ属性
に関係なく常に32 ビットである。デバッグ・レジスタのフラグとフィールドの詳細な説明について
は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、下巻』第14
章「デバッグと性能モニタリング」を参照のこと。
これらの命令は、特権レベル0 または実アドレス・モードで実行しなければならない。
CR4 レジスタのデバッグ拡張(DE) フラグをクリアすると、これらの命令は、Intel386 プロセッサおよ
びIntel486プロセッサと互換性があるようにデバック・レジスタを操作する。このモードでは、DR4
およびDR5 への参照は、それぞれDR6 およびDR7 を参照する。CR4 のDEをセットすると、DR4 お
よびDR5 への参照の試みは、未定義オペコード(#UD)例外を発生させる。(CR4 レジスタは、Pentium
プロセッサで初めてIA-32 アーキテクチャに追加された。)
オペコード・レベルでは、ModR/Mバイトのreg フィールドは、どのデバッグ・レジスタをロードす
るかまたは読み取るかを指定する。mod フィールドの2 ビットは、常に11 である。r/mフィールドは、
ロードされるかまたは読み取られる汎用レジスタを指定する。
操作
IF ((DE ← 1) and (SRC or DEST ← DR4 or DR5))
THEN
#UD;
ELSE
DEST ← SRC;
影響を受けるフラグ
OF、SF、ZF、AF、PF、およびCF フラグは未定義。
保護モード例外
#GP(0) 現行特権レベルが0 でない場合。
#UD CR4 のDE( デバッグ拡張) ビットがセットされていて、MOV 命令がDR4
またはDR5 を伴って実行された場合。
#DB デバッグ・レジスタDR7 のGD フラグがセットされている間に、いずれ
かのデバッグ・レジスタがアクセスされた場合。
オペコード命令説明
0F 21/r MOV r32, DR0-DR7 デバッグ・レジスタをr32 に転送する。
0F 23 /r MOV DR0-DR7,r32 r32 をデバッグ・レジスタに転送する。
3-430
命令セット・リファレンス
MOV?Move to/from Debug Registers ( 続き)
実アドレス・モード例外
#UD CR4 のDE( デバッグ拡張) ビットがセットされていて、MOV 命令がDR4
またはDR5 を伴って実行された場合。
#DB デバッグ・レジスタDR7 のGD フラグがセットされている間に、いずれ
かのデバッグ・レジスタがアクセスされた場合。
仮想8086 モード例外
#GP(0) 仮想8086 モードになっているときに、デバッグ・レジスタをロードす
るかまたは読み取ることはできない。
3-431
命令セット・リファレンス
MOVAPD?Move Aligned Packed Double-Precision Floating-Point
Values
説明
2 つのパックド倍精度浮動小数点値が入っているダブル・クワッドワードを、ソース・オペランド
( 第2 オペランド) からデスティネーション・オペランド( 第1 オペランド) に移動する。この命令を
使用して、XMMレジスタを128 ビットのメモリ・ロケーションからロードする操作、XMMレジス
タの内容を128 ビットのメモリ・ロケーションにストアする操作、または2 つのXMM レジスタの
間でデータを転送する操作が可能である。ソース・オペランドまたはデスティネーション・オペラ
ンドがメモリ・オペランドの場合は、そのオペランドのアライメントは16 バイトに合っていなけれ
ばならない。アライメントが合っていない場合は、一般保護例外（#GP）が発生する。
アライメントの合っていないメモリ・ロケーションとの間で倍精度浮動小数点値を移動する場合は、
MOVUPD命令を使用する。
操作
DEST ← SRC;
同等のインテルC/C++ コンパイラ組み込み関数
__m128 _mm_load_pd(double * p)
void_mm_store_pd(double *p, __m128 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
66 0F 28 /r MOVAPD xmm1,
xmm2/m128
パックド倍精度浮動小数点値を、xmm2/m128 からxmm1
に移動する。
66 0F 29 /r MOVAPD xmm2/m128,
xmm1
パックド倍精度浮動小数点値を、xmm1 からxmm2/m128
に移動する。
3-432
命令セット・リファレンス
MOVAPD?Move Aligned Packed Double-Precision Floating-Point
Values ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-433
命令セット・リファレンス
MOVAPS?Move Aligned Packed Single-Precision Floating-Point
Values
説明
4 つのパックド単精度浮動小数点値が入っているダブル・クワッドワードを、ソース・オペランド
( 第2 オペランド) からデスティネーション・オペランド( 第1 オペランド) に移動する。この命令を
使用して、XMMレジスタを128 ビットのメモリ・ロケーションからロードする操作、XMMレジス
タの内容を128 ビットのメモリ・ロケーションにストアする操作、または2 つのXMM レジスタの
間でデータを転送する操作が可能である。ソース・オペランドまたはデスティネーション・オペラ
ンドがメモリ・オペランドの場合は、そのオペランドのアライメントは16 バイトに合っていなけれ
ばならない。アライメントが合っていない場合は、一般保護例外（#GP）が発生する。
アライメントの合っていないメモリ・ロケーションとの間でパックド単精度浮動小数点値を移動す
る場合は、MOVUPS 命令を使用する。
操作
DEST ← SRC;
同等のインテルC/C++ コンパイラ組み込み関数
__m128 _mm_load_ps (float * p)
void_mm_store_ps (float *p, __m128 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
0F 28 /r MOVAPS xmm1,
xmm2/m128
パックド単精度浮動小数点値を、xmm2/m128 からxmm1
レジスタに移動する。
0F 29 /r MOVAPS xmm2/m128,
xmm1
パックド単精度浮動小数点値を、xmm1 レジスタから
xmm2/m128 に移動する。
3-434
命令セット・リファレンス
MOVAPS?Move Aligned Packed Single-Precision Floating-Point
Values ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-435
命令セット・リファレンス
MOVD?Move Doubleword
説明
ダブルワードをソース・オペランド( 第2 オペランド) からデスティネーション・オペランド( 第1 オ
ペランド) にコピーする。ソース・オペランドとデスティネーション・オペランドには、汎用レジス
タ、MMXテクノロジ・レジスタ、XMMレジスタ、または32 ビット・メモリ・ロケーションを使用
できる。この命令を使用して、MMXテクノロジ・レジスタの下位ダブルワードと汎用レジスタまた
は32 ビットのメモリ・ロケーションの間、またはXMMレジスタの最下位のダブルワードと汎用レ
ジスタまたは32 ビットのメモリ・ロケーションの間で、ダブルワードを転送することができる。た
だし、この命令は、2 つのMMXテクノロジ・レジスタの間、2 つのXMMレジスタの間、2 つの汎用
レジスタの間、または2 つのメモリ・ロケーションの間のデータ転送には使用できない。
デスティネーション・オペランドがMMXテクノロジ・レジスタの場合は、ソース・オペランドはそ
のレジスタの下位ダブルワードに書き込まれ、レジスタは64 ビットにゼロ拡張される。デスティネー
ション・オペランドがXMMレジスタの場合は、ソース・オペランドはそのレジスタの最下位のダブ
ルワードに書き込まれ、レジスタは128 ビットにゼロ拡張される。
操作
MOVD instruction when destination operand is MMX register:
DEST[31-0] ← SRC;
DEST[63-32] ← 00000000H;
MOVD instruction when destination operand is XMM register:
DEST[31-0] ← SRC;
DEST[127-32] ← 000000000000000000000000H;
MOVD instruction when source operand is MMX or XXM register:
DEST ← SRC[31-0];
同等のインテルC/C++ コンパイラ組み込み関数
MOVD __m64 _mm_cvtsi32_si64 (int i )
MOVD int _mm_cvtsi64_si32 ( __m64m )
MOVD __m128i _mm_cvtsi32_si128 (int a)
MOVD int _mm_cvtsi128_si32 ( __m128i a)
影響を受けるフラグ
なし。
オペコード命令説明
0F 6E /r MOVD mm, r/m32 ダブルワードをr/m32 からmm に転送する。
0F 7E /r MOVD r/m32, mm ダブルワードをmm からr/m32 に転送する。
66 0F 6E /r MOVD xmm, r/m32 ダブルワードをr/m32 からxmm に転送する。
66 0F 7E /r MOVD r/m32, xmm ダブルワードをxmm レジスタからr/m32 に転送する。
3-436
命令セット・リファレンス
MOVD?Move Doubleword ( 続き)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) デスティネーション・オペランドが書き込み不可能なセグメントにある
場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（XMMレジスタ操作のみ）CR4 のOSFXSR が0 の場合。
（XMMレジスタ操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （MMX テクノロジ・レジスタ操作のみ）未処理のFPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（XMMレジスタ操作のみ）CR4 のOSFXSR が0 の場合。
（XMMレジスタ操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （MMX テクノロジ・レジスタ操作のみ）未処理のFPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-437
命令セット・リファレンス
MOVDQA?Move Aligned Double Quadword
説明
ソース・オペランド( 第2 オペランド) からデスティネーション・オペランド( 第1 オペランド) にダ
ブル・クワッドワードを移動する。この命令を使用して、128 ビット・メモリ・ロケーションから
XMMレジスタへのロード、128 ビット・メモリ・ロケーションへのXMMレジスタの内容のストア、
あるいは、2 つのXMMレジスタ間でのデータの移動を行なうことができる。ソース・オペランドま
たはデスティネーション・オペランドがメモリ・オペランドの場合は、そのオペランドのアライメ
ントは16 バイトに合っていなければならない。アライメントが合っていない場合は、一般保護例外
（#GP）が発生する。
アライメントの合っていないメモリ・ロケーションとの間でダブル・クワッドワードを移動する場
合は、MOVDQU命令を使用する。
操作
DEST ← SRC;
* #GP if SRC or DEST unaligned memory operand *;
同等のインテルC/C++ コンパイラ組み込み関数
MOVDQA __m128i _mm_load_si128 ( __m128i *p)
MOVDQA void _mm_store_si128 ( __m128i *p, __m128i a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のTS がセットされた場合。
オペコード命令説明
66 0F 6F /r MOVDQA xmm1,
xmm2/m128
アライメントの合ったダブル・クワッドワードを、
xmm2/m128 からxmm1 に移動する。
66 0F 7F /r MOVDQA xmm2/m128,
xmm1
アライメントの合ったダブル・クワッドワードを、xmm1
からxmm2/m128 に移動する。
3-438
命令セット・リファレンス
MOVDQA?Move Aligned Double Quadword ( 続き)
実アドレス・モード例外
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-439
命令セット・リファレンス
MOVDQU?Move Unaligned Double Quadword
説明
ソース・オペランド( 第2 オペランド) からデスティネーション・オペランド( 第1 オペランド) にダ
ブル・クワッドワードを移動する。この命令を使用して、128 ビット・メモリ・ロケーションから
XMMレジスタへのロード、128 ビット・メモリ・ロケーションへのXMMレジスタの内容のストア、
あるいは、2 つのXMMレジスタ間でのデータの移動を行なうことができる。ソース・オペランドま
たはデスティネーション・オペランドがメモリ・オペランドの場合、そのオペランドのアライメン
トが16 バイトに合っていなくても、一般保護例外（#GP）は発生しない。
ダブル・クワッドワードの転送先または転送元のメモリ・ロケーションのアライメントが16 バイト
に合っていることがわかっている場合は、MOVDQA命令を使用する。
16ビット・アドレス指定モードでの実行中は、128 ビット・データ・アクセスのリニア・アドレスが
16 ビット・セグメントの終点からはみ出すことは許されない。これは、予約済みの動作として定義
されている。この場合に一般保護例外(#GP) が発生するかどうかは、プロセッサによって異なる。16
ビット・セグメントの範囲を超えたアドレスは、そのセグメントの始点にラップアラウンドされる
こともあるし、ラップアラウンドされないこともある。
操作
DEST ← SRC;
同等のインテルC/C++ コンパイラ組み込み関数
MOVDQU void _mm_storeu_si128 ( __m128i *p, __m128i a)
MOVDQU __m128i _mm_loadu_si128 ( __m128i *p)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#NM CR0 のTS がセットされた場合。
オペコード命令説明
F3 0F 6F /r MOVDQU xmm1,
xmm2/m128
アライメントの合わないダブル・クワッドワードを、
xmm2/m128 からxmm1 に移動する。
F3 0F 7F /r MOVDQU xmm2/m128,
xmm1
アライメントの合わないダブル・クワッドワードを、
xmm1 からxmm2/m128 に移動する。
3-440
命令セット・リファレンス
MOVDQU?Move Unaligned Double Quadword ( 続き)
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
実アドレス・モード例外
#GP(0) オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-441
命令セット・リファレンス
MOVDQ2Q?Move Quadword from XMM to MMX Register
説明
ソース・オペランド（第2 オペランド）の下位クワッドワードをデスティネーション・オペランド
（第1 オペランド）に移動する。ソース・オペランドはXMMレジスタである。デスティネーション・
オペランドはMMXテクノロジ・レジスタである。
この命令を使用すると、x87 FPU 操作からMMX テクノロジ操作への移行が発生する（つまり、x87
FPUのトップオブスタック・ポインタは0 に設定され、x87 FPUタグ・ワードはすべて0[ 有効] に設
定される）。未処理のx87 FPU 浮動小数点例外があるときにこの命令を実行しようとすると、
MOVDQ2Q命令を実行する前にその例外が処理される。
操作
DEST ← SRC[63-0]
同等のインテルC/C++ コンパイラ組み込み関数
MOVDQ2Q __m64 _mm_movepi64_pi64 ( __m128i a)
SIMD 浮動小数点例外
なし。
保護モード例外
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#MF 未処理のx87 FPU 例外がある場合。
実アドレス・モード例外
保護モードと同じ例外。
仮想8086 モード例外
保護モードと同じ例外。
オペコード命令説明
F2 0F D6 MOVDQ2Q mm, xmm xmm レジスタの下位クワッドワードをmmx テクノロジ・
レジスタに移動する。
3-442
命令セット・リファレンス
MOVHLPS?Move Packed Single-Precision Floating-Point Values High
to Low
説明
2 つのパックド単精度浮動小数点値を、ソース・オペランド（第2 オペランド）の上位クワッドワー
ドからデスティネーション・オペランド（第1 オペランド）の下位クワッドワードに移動する。デス
ティネーション・オペランドの上位クワッドワードは変更されない。
操作
DEST[63-0] ← SRC[127-64];
* DEST[127-64] unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
MOVHLPS __m128 _mm_movehl_ps(__m128 a, __m128 b)
SIMD 浮動小数点例外
なし。
保護モード例外
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
実アドレス・モード例外
保護モードと同じ例外。
仮想8086 モード例外
保護モードと同じ例外。
オペコード命令説明
OF 12 /r MOVHLPS xmm1, xmm2 2 つのパックド単精度浮動小数点値を、xmm2 の上位ク
ワッドワードからxmm1 の下位クワッドワードに移動す
る。
3-443
命令セット・リファレンス
MOVHPD?Move High Packed Double-Precision Floating-Point Value
説明
ソース・オペランド( 第2 オペランド) からデスティネーション・オペランド( 第1 オペランド) に倍
精度浮動小数点値を移動する。ソース・オペランドとデスティネーション・オペランドは、XMMレ
ジスタまたは64 ビットのメモリ・ロケーションである。この命令を使用して、XMM レジスタの上
位クワッドワードとメモリの間で、倍精度浮動小数点値を転送することができる。ただし、この命
令は、レジスタ同士の間またはメモリ同士の間のデータ転送には使用できない。デスティネーショ
ン・オペランドがXMMレジスタの場合は、レジスタの下位クワッドワードは変更されない。
操作
MOVHPD instruction for memory to XMM move:
DEST[127-64] ← SRC ;
* DEST[63-0] unchanged *;
MOVHPD instruction for XMM to memory move:
DEST ← SRC[127-64] ;
同等のインテルC/C++ コンパイラ組み込み関数
MOVHPD __m128d _mm_loadh_pd ( __m128d a, double *p)
MOVHPD void _mm_storeh_pd (double *p, __m128d a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が0 の場合。
オペコード命令説明
66 0F 16 /r MOVHPD xmm, m64 m64 からxmm の上位クワッドワードに倍精度浮動小数点
値を移動する。
66 0F 17 /r MOVHPD m64, xmm xmm の上位クワッドワードからm64 に倍精度浮動小数点
値を移動する。
3-444
命令セット・リファレンス
MOVHPD?Move High Packed Double-Precision Floating-Point Value
( 続き)
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-445
命令セット・リファレンス
MOVHPS?Move High Packed Single-Precision Floating-Point Values
説明
2 つのパックド単精度浮動小数点値を、ソース・オペランド（第2 オペランド）からデスティネー
ション・オペランド（第1 オペランド）に移動する。ソース・オペランドとデスティネーション・オ
ペランドは、XMMレジスタまたは64 ビットのメモリ・ロケーションである。この命令を使用して、
XMMレジスタの上位クワッドワードとメモリの間で、2 つの単精度浮動小数点値を転送することが
できる。ただし、この命令は、レジスタ同士の間またはメモリ同士の間のデータ転送には使用でき
ない。デスティネーション・オペランドがXMMレジスタの場合は、レジスタの下位クワッドワード
は変更されない。
操作
MOVHPD instruction for memory to XMM move:
DEST[127-64] ← SRC ;
* DEST[63-0] unchanged *;
MOVHPD instruction for XMM to memory move:
DEST ← SRC[127-64] ;
同等のインテルC/C++ コンパイラ組み込み関数
MOVHPS __m128d _mm_loadh_pi ( __m128d a, __m64 *p)
MOVHPS void _mm_storeh_pi (__m64 *p, __m128d a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
オペコード命令説明
0F 16 /r MOVHPS xmm, m64 2 つのパックド単精度浮動小数点値を、m64 からxmm の
上位クワッドワードに移動する。
0F 17 /r MOVHPS m64, xmm 2 つのパックド単精度浮動小数点値を、xmm の上位クワッ
ドワードからm64 に移動する。
3-446
命令セット・リファレンス
MOVHPS?Move High Packed Single-Precision Floating-Point Values
( 続き)
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-447
命令セット・リファレンス
MOVLHPS?Move Packed Single-Precision Floating-Point Values Low
to High
説明
2 つのパックド単精度浮動小数点値を、ソース・オペランド（第2 オペランド）の下位クワッドワー
ドからデスティネーション・オペランド（第1 オペランド）の上位クワッドワードに移動する。デス
ティネーション・オペランドの下位クワッドワードは変更されない。
操作
DEST[127-64] ← SRC[63-0];
* DEST[63-0] unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
MOVHLPS __m128 _mm_movelh_ps(__m128 a, __m128 b)
SIMD 浮動小数点例外
なし。
保護モード例外
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
実アドレス・モード例外
保護モードと同じ例外。
仮想8086 モード例外
保護モードと同じ例外。
オペコード命令説明
OF 16 /r MOVLHPS xmm1, xmm2 2 つのパックド単精度浮動小数点値を、xmm2 の下位ク
ワッドワードからxmm1 の上位クワッドワードに移動す
る。
3-448
命令セット・リファレンス
MOVLPD?Move Low Packed Double-Precision Floating-Point Value
説明
ソース・オペランド( 第2 オペランド) からデスティネーション・オペランド( 第1 オペランド) に倍
精度浮動小数点値を移動する。ソース・オペランドとデスティネーション・オペランドは、XMMレ
ジスタまたは64 ビットのメモリ・ロケーションである。この命令を使用して、XMM レジスタの下
位クワッドワードとメモリの間で、倍精度浮動小数点値を転送することができる。ただし、この命
令は、レジスタ同士の間またはメモリ同士の間のデータ転送には使用できない。デスティネーショ
ン・オペランドがXMMレジスタの場合は、レジスタの上位クワッドワードは変更されない。
操作
MOVLPD instruction for memory to XMM move:
DEST[63-0] ← SRC ;
* DEST[127-64] unchanged *;
MOVLPD instruction for XMM to memory move:
DEST ← SRC[63-0] ;
同等のインテルC/C++ コンパイラ組み込み関数
MOVLPD __m128d _mm_loadl_pd ( __m128d a, double *p)
MOVLPD void _mm_storel_pd (double *p, __m128d a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が0 の場合。
オペコード命令説明
66 0F 12 /r MOVLPD xmm, m64 m64 からxmm レジスタの下位クワッドワードに倍精度浮
動小数点値を移動する。
66 0F 13 /r MOVLPD m64, xmm xmm レジスタの下位クワッドワードからm64 に倍精度浮
動小数点値を移動する。
3-449
命令セット・リファレンス
MOVLPD?Move Low Packed Double-Precision Floating-Point Value
( 続き)
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-450
命令セット・リファレンス
MOVLPS?Move Low Packed Single-Precision Floating-Point Values
説明
2 つのパックド単精度浮動小数点値を、ソース・オペランド（第2 オペランド）からデスティネー
ション・オペランド（第1 オペランド）に移動する。ソース・オペランドとデスティネーション・オ
ペランドは、XMMレジスタまたは64ビットのメモリ・ロケーションである。この命令を使用して、
XMMレジスタの下位クワッドワードとメモリの間で、2 つの単精度浮動小数点値を転送することが
できる。ただし、この命令は、レジスタ同士の間またはメモリ同士の間のデータ転送には使用でき
ない。デスティネーション・オペランドがXMMレジスタの場合は、レジスタの上位クワッドワード
は変更されない。
操作
MOVLPD instruction for memory to XMM move:
DEST[63-0] ← SRC ;
* DEST[127-64] unchanged *;
MOVLPD instruction for XMM to memory move:
DEST ← SRC[63-0] ;
同等のインテルC/C++ コンパイラ組み込み関数
MOVLPS __m128 _mm_loadl_pi ( __m128 a, __m64 *p)
MOVLPS void _mm_storel_pi (__m64 *p, __m128 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
オペコード命令説明
0F 12 /r MOVLPS xmm, m64 2 つのパックド単精度浮動小数点値を、m64 からxmm の
下位クワッドワードに移動する。
0F 13 /r MOVLPS m64, xmm 2 つのパックド単精度浮動小数点値を、xmm の下位クワッ
ドワードからm64 に移動する。
3-451
命令セット・リファレンス
MOVLPS?Move Low Packed Single-Precision Floating-Point Values
( 続き)
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-452
命令セット・リファレンス
MOVMSKPD?Extract Packed Double-Precision Floating-Point Sign
Mask
説明
ソース・オペランド（第2 オペランド）のパックド倍精度浮動小数点値から符号ビットを抽出して、
2 ビット・マスクとしてフォーマットし、デスティネーション・オペランド（第1 オペランド）に格
納する。ソース・オペランドはXMMレジスタである。デスティネーション・オペランドは汎用レジ
スタである。マスクはデスティネーション・オペランドの最下位2 ビットに格納される。
操作
DEST[0] ← SRC[63];
DEST[1] ← SRC[127];
DEST[3-2] ← 00B;
DEST[31-4] ← 0000000H;
同等のインテルC/C++ コンパイラ組み込み関数
MOVMSKPD int _mm_movemask_pd ( __m128 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
保護モードと同じ例外。
仮想8086 モード例外
保護モードと同じ例外。
オペコード命令説明
66 0F 50 /r MOVMSKPD r32, xmm xmm から2 ビットの符号マスクを抽出し、r32 に格納する。
3-453
命令セット・リファレンス
MOVMSKPS?Extract Packed Single-Precision Floating-Point Sign
Mask
説明
ソース・オペランド（第2 オペランド）のパックド単精度浮動小数点値から符号ビットを抽出して、
4 ビット・マスクとしてフォーマットし、デスティネーション・オペランド（第1 オペランド）に格
納する。ソース・オペランドはXMMレジスタである。デスティネーション・オペランドは汎用レジ
スタである。マスクはデスティネーション・オペランドの最下位4 ビットに格納される。
操作
DEST[0] ← SRC[31];
DEST[1] ← SRC[63];
DEST[1] ← SRC[95];
DEST[1] ← SRC[127];
DEST[31-4] ← 000000H;
同等のインテルC/C++ コンパイラ組み込み関数
int_mm_movemask_ps(__m128 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
実アドレス・モード例外
保護モードと同じ例外。
仮想8086 モード例外
保護モードと同じ例外。
オペコード命令説明
0F 50 /r MOVMSKPS r32, xmm xmm から4 ビットの符号マスクを抽出し、r32 に格納する。
3-454
命令セット・リファレンス
MOVNTDQ?Store Double Quadword Using Non-Temporal Hint
説明
非テンポラルなヒントを使用して、メモリへの書き込み時にデータがキャッシュしないように防ぎ、
ソース・オペランド（第2 オペランド）のダブル・クワッドワードをデスティネーション・オペラン
ド（第1 オペランド）に移動する。ソース・オペランドはXMMレジスタであり、整数データ（パッ
クド・バイト、パックド・ワード、パックド・ダブルワード、またはパックド・クワッドワード）が
入っていると見なされる。デスティネーション・オペランドは128 ビットのメモリ・ロケーションで
ある。
非テンポラルなヒントを有効にするために、メモリにデータを書き込むとき、ライト・コンバイニ
ング（WC）メモリ・タイプ・プロトコルが使用される。このプロトコルを使用した場合、プロセッ
サは、キャッシュ階層へのデータの書き込みを行わず、メモリからキャッシュ階層内にキャッシュ・
ラインをフェッチしない。非テンポラルなストア先に指定されたメモリ・アドレスが、キャッシュ
不可（UC）または書き込み禁止（WP）メモリ領域内にある場合は、書き込み先領域のメモリ・タ
イプのために非テンポラルなヒントが無効になる可能性がある。非テンポラルなストアについての
詳細は『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の
第10 章「テンポラルなデータと非テンポラルなデータのキャッシュ処理」を参照のこと。
WCプロトコルは、順序設定の緩いメモリ整合性モデルを使用する。したがって、複数のプロセッサ
が、異なるメモリ・タイプを使用して、同じデスティネーション・メモリ・ロケーションの読み込
み/ 書き込みを実行する可能性がある場合は、MOVNTDQ 命令と合わせてSFENCE 命令または
MFENCE命令で実装されるフェンス操作を使用する必要がある。
操作
DEST ← SRC;
同等のインテルC/C++ コンパイラ組み込み関数
MOVNTDQ void_mm_stream_si128 ( __m128i *p, __m128i a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
オペコード命令説明
66 0F E7 /r MOVNTDQ m128, xmm 非テンポラルなヒントを使用して、xmm からm128 にダブ
ル・クワッドワードを移動する。
3-455
命令セット・リファレンス
MOVNTDQ?Store Double Quadword Using Non-Temporal Hint ( 続き)
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-456
命令セット・リファレンス
MOVNTI?Store Doubleword Using Non-Temporal Hint
説明
非テンポラルなヒントを使用して、メモリへの書き込み時のキャッシュ汚染を最小限に抑え、ソー
ス・オペランド（第2 オペランド）のダブルワード整数をデスティネーション・オペランド（第1 オ
ペランド）に移動する。ソース・オペランドは汎用レジスタである。デスティネーション・オペラ
ンドは32 ビットのメモリ・ロケーションである。
非テンポラルなヒントを有効にするために、メモリにデータを書き込むとき、ライト・コンバイニ
ング（WC）メモリ・タイプ・プロトコルが使用される。このプロトコルを使用した場合、プロセッ
サは、キャッシュ階層へのデータの書き込みを行わず、メモリからキャッシュ階層内にキャッシュ・
ラインをフェッチしない。非テンポラルなストア先に指定されたメモリ・アドレスが、キャッシュ
不可（UC）または書き込み禁止（WP）メモリ領域内にある場合は、書き込み先領域のメモリ・タ
イプのために非テンポラルなヒントが無効になる可能性がある。非テンポラルなストアについての
詳細は『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の
第10 章「テンポラルなデータと非テンポラルなデータのキャッシュ処理」を参照のこと。
WCプロトコルは、順序設定の緩いメモリ整合性モデルを使用する。したがって、複数のプロセッサ
が、異なるメモリ・タイプを使用して、同じデスティネーション・メモリ・ロケーションの読み込
み/ 書き込みを実行する可能性がある場合は、MOVNTI 命令と合わせてSFENCE命令またはMFENCE
命令で実装されるフェンス操作を使用する必要がある。
操作
DEST ← SRC;
同等のインテルC/C++ コンパイラ組み込み関数
MOVNTDQ void_mm_stream_si32 (int *p, int a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#UD CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
0F C3 /r MOVNI m32, r32 非テンポラルなヒントを使用して、r32 からm32 にダブル
ワードを移動する。
3-457
命令セット・リファレンス
MOVNTI?Store Doubleword Using Non-Temporal Hint ( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-458
命令セット・リファレンス
MOVNTPD?Store Packed Double-Precision Floating-Point Values
Using Non-Temporal Hint
説明
非テンポラルなヒントを使用して、メモリへの書き込み時のキャッシュ汚染を最小限に抑え、ソー
ス・オペランド（第2 オペランド）のダブル・クワッドワードをデスティネーション・オペランド
（第1 オペランド）に移動する。ソース・オペランドはXMMレジスタであり、2 つのパックド倍精度
浮動小数点値が入っていると見なされる。デスティネーション・オペランドは128 ビットのメモリ・
ロケーションである。
非テンポラルなヒントを有効にするために、メモリにデータを書き込むとき、ライト・コンバイニ
ング（WC）メモリ・タイプ・プロトコルが使用される。このプロトコルを使用した場合、プロセッ
サは、キャッシュ階層へのデータの書き込みを行わず、メモリからキャッシュ階層内にキャッシュ・
ラインをフェッチしない。非テンポラルなストア先に指定されたメモリ・アドレスが、キャッシュ
不可（UC）または書き込み禁止（WP）メモリ領域内にある場合は、書き込み先領域のメモリ・タ
イプのために非テンポラルなヒントが無効になる可能性がある。非テンポラルなストアについての
詳細は『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の
第10 章「テンポラルなデータと非テンポラルなデータのキャッシュ処理」を参照のこと。
WCプロトコルは、順序設定の緩いメモリ整合性モデルを使用する。したがって、複数のプロセッサ
が、異なるメモリ・タイプを使用して、同じデスティネーション・メモリ・ロケーションの読み込
み/ 書き込みを実行する可能性がある場合は、MOVNTPD 命令と合わせてSFENCE 命令または
MFENCE命令で実装されるフェンス操作を使用する必要がある。
操作
DEST ← SRC;
同等のインテルC/C++ コンパイラ組み込み関数
MOVNTDQ void_mm_stream_pd(double *p, __m128i a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
オペコード命令説明
66 0F 2B /r MOVNTPD m128, xmm 非テンポラルなヒントを使用して、xmm からm128 にパッ
クド倍精度浮動小数点値を移動する。
3-459
命令セット・リファレンス
MOVNTPD?Store Packed Double-Precision Floating-Point Values
Using Non-Temporal Hint ( 続き)
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-460
命令セット・リファレンス
MOVNTPS?Store Packed Single-Precision Floating-Point Values
Using Non-Temporal Hint
説明
非テンポラルなヒントを使用して、メモリへの書き込み時のキャッシュ汚染を最小限に抑え、ソー
ス・オペランド（第2 オペランド）のダブル・クワッドワードをデスティネーション・オペランド
（第1 オペランド）に移動する。ソース・オペランドはXMMレジスタであり、4 つのパックド単精度
浮動小数点値が入っていると見なされる。デスティネーション・オペランドは128 ビットのメモリ・
ロケーションである。
非テンポラルなヒントを有効にするために、メモリにデータを書き込むとき、ライト・コンバイニ
ング（WC）メモリ・タイプ・プロトコルが使用される。このプロトコルを使用した場合、プロセッ
サは、キャッシュ階層へのデータの書き込みを行わず、メモリからキャッシュ階層内にキャッシュ・
ラインをフェッチしない。非テンポラルなストア先に指定されたメモリ・アドレスが、キャッシュ
不可（UC）または書き込み禁止（WP）メモリ領域内にある場合は、書き込み先領域のメモリ・タ
イプのために非テンポラルなヒントが無効になる可能性がある。非テンポラルなストアについての
詳細は『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の
第10 章「テンポラルなデータと非テンポラルなデータのキャッシュ処理」を参照のこと。
WCプロトコルは、順序設定の緩いメモリ整合性モデルを使用する。したがって、複数のプロセッサ
が、異なるメモリ・タイプを使用して、デスティネーション・メモリ・ロケーションの読み込み/ 書
き込みを実行する可能性がある場合は、MOVNTPS 命令と合わせてSFENCE 命令またはMFENCE 命
令で実装されるフェンス操作を使用する必要がある。
操作
DEST ← SRC;
同等のインテルC/C++ コンパイラ組み込み関数
MOVNTDQ void_mm_stream_ps(float * p, __m128 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
オペコード命令説明
0F 2B /r MOVNTPS m128, xmm 非テンポラルなヒントを使用して、4 つのパックド単精度
浮動小数点値を、xmm からm128 に移動する。
3-461
命令セット・リファレンス
MOVNTPS?Store Packed Single-Precision Floating-Point Values
Using Non-Temporal Hint ( 続き)
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-462
命令セット・リファレンス
MOVNTQ?Store of Quadword Using Non-Temporal Hint
説明
非テンポラルなヒントを使用して、メモリへの書き込み時のキャッシュ汚染を最小限に抑え、ソー
ス・オペランド（第2 オペランド）のクワッドワードをデスティネーション・オペランド（第1 オペ
ランド）に移動する。ソース・オペランドはMMXテクノロジ・レジスタであり、パックド整数デー
タ（パックド・バイト、パックド・ワード、またはパックド・ダブルワード）が入っていると見な
される。デスティネーション・オペランドは64 ビットのメモリ・ロケーションである。
非テンポラルなヒントを有効にするために、メモリにデータを書き込むとき、ライト・コンバイニ
ング（WC）メモリ・タイプ・プロトコルが使用される。このプロトコルを使用した場合、プロセッ
サは、キャッシュ階層へのデータの書き込みを行わず、メモリからキャッシュ階層内にキャッシュ・
ラインをフェッチしない。非テンポラルなストア先に指定されたメモリ・アドレスが、キャッシュ
不可（UC）または書き込み禁止（WP）メモリ領域内にある場合は、書き込み先領域のメモリ・タ
イプのために非テンポラルなヒントが無効になる可能性がある。非テンポラルなストアについての
詳細は『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の
第10 章「テンポラルなデータと非テンポラルなデータのキャッシュ処理」を参照のこと。
WCプロトコルは、順序設定の緩いメモリ整合性モデルを使用する。したがって、複数のプロセッサ
が、異なるメモリ・タイプを使用して、同じデスティネーション・メモリ・ロケーションの読み込
み/書き込みを実行する可能性がある場合は、MOVNTQ命令と合わせてSFENCE命令またはMFENCE
命令で実装されるフェンス操作を使用する必要がある。
操作
DEST ← SRC;
同等のインテルC/C++ コンパイラ組み込み関数
MOVNTQ void_mm_stream_pi(__m64 * p, __m64 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
オペコード命令説明
0F E7 /r MOVNTQ m64, mm 非テンポラルなヒントを使用してクワッドワードを、mm
からmm64 に移動する。
3-463
命令セット・リファレンス
MOVNTQ?Store of Quadword Using Non-Temporal Hint ( 続き)
#UD CR0 のEM がセットされた場合。
CPUID 機能フラグSSE が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#MF 保留中のx87 FPU 例外がある場合。
#UD CR0 のEM がセットされた場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-464
命令セット・リファレンス
MOVQ?Move Quadword
説明
クワッドワードをソース・オペランド( 第2 オペランド) からデスティネーション・オペランド( 第1
オペランド) にコピーする。ソース・オペランドまたはデスティネーション・オペランドには、MMX
テクノロジ・レジスタ、XMMレジスタ、または64 ビット・メモリ・ロケーションを使用できる。こ
の命令を使用して、2 つのMMXテクノロジ・レジスタの間、MMXテクノロジ・レジスタと64 ビッ
トのメモリ・ロケーションの間でクワッドワードを転送するか、2 つのXMMレジスタの間、または
XMM レジスタと64 ビットのメモリ・ロケーションの間で、データを転送することができる。ただ
し、この命令は、2 つのメモリ・ロケーションの間のデータ転送には使用できない。
ソース・オペランドがXMM レジスタの場合は、下位クワッドワードが転送される。デスティネー
ション・オペランドがXMMレジスタの場合は、転送されたクワッドワードはXMMレジスタの下位
クワッドワードに格納され、上位クワッドワードはすべて0 にクリアされる。
操作
MOVQ instruction when operating on MMX registers and memory locations:
DEST ← SRC;
MOVQ instruction when source and destination operands are XMM registers:
DEST[63-0] ← SRC[63-0];
MOVQ instruction when source opernad is XMM register and destination
operand is memory location:
DEST ← SRC[63-0];
MOVQ instruction when source operand is memory location and destination
operand is XMM register:
DEST[63-0] ← SRC;
DEST[127-64] ← 0000000000000000H;
影響を受けるフラグ
なし。
SIMD 浮動小数点例外
なし。
オペコード命令説明
0F 6F /r MOVQ mm, mm/m64 クワッドワードをmm/m64 からmm に転送する。
0F 7F /r MOVQ mm/m64, mm クワッドワードをmm からmm/m64 に転送する。
F3 0F 7E MOVQ xmm1, xmm2/m64 クワッドワードをxmm2/mem64 からxmm1 に転送する。
66 0F D6 MOVQ xmm2/m64, xmm1 クワッドワードをxmm1 からxmm2/mem64 に転送する。
3-465
命令セット・リファレンス
MOVQ?Move Quadword ( 続き)
保護モード例外
#GP(0) デスティネーション・オペランドが書き込み不可能なセグメントにある
場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（XMMレジスタ操作のみ）CR4 のOSFXSR が0 の場合。
（XMMレジスタ操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （MMX テクノロジ・レジスタ操作のみ）未処理のFPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（XMMレジスタ操作のみ）CR4 のOSFXSR が0 の場合。
（XMMレジスタ操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （MMX テクノロジ・レジスタ操作のみ）未処理のFPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-466
命令セット・リファレンス
MOVQ2DQ?Move Quadword from MMX to XMM Register
説明
ソース・オペランド（第2 オペランド）のクワッドワードを、デスティネーション・オペランド（第
1 オペランド）の下位クワッドワードに移動する。ソース・オペランドはMMXテクノロジ・レジス
タである。デスティネーション・オペランドはXMMレジスタである。
この命令を使用すると、x87 FPU 操作からMMX テクノロジ操作への移行が発生する（つまり、x87
FPUのトップオブスタック・ポインタは0 に設定され、x87 FPUタグ・ワードはすべて0[ 有効] に設
定される）。未処理のx87 FPU 浮動小数点例外があるときにこの命令を実行しようとすると、
MOVQ2DQ命令を実行する前にその例外が処理される。
操作
DEST[63-0] ← SRC[63-0];
DEST[127-64] ← 00000000000000000H;
同等のインテルC/C++ コンパイラ組み込み関数
MOVQ2DQ __128i _mm_movpi64_pi64 ( __m64 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#NM CR0 のTS がセットされた場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#MF 未処理のx87 FPU 例外がある場合。
実アドレス・モード例外
保護モードと同じ例外。
仮想8086 モード例外
保護モードと同じ例外。
オペコード命令説明
F3 0F D6 MOVQ2DQ xmm, mm mmx のクワッドワードをxmm の下位クワッドワードに移
動する。
3-467
命令セット・リファレンス
MOVS/MOVSB/MOVSW/MOVSD?Move Data from String to String
説明
第2 オペランド( ソース・オペランド) で指定されたバイト、ワード、またはダブルワードを第1 オ
ペランド( デスティネーション・オペランド) で指定されたロケーションに転送する。ソース・オペ
ランドとデスティネーション・オペランドの両方とも、メモリに位置している。ソース・オペラン
ドのアドレスは、( 命令のアドレス・サイズ属性、32 または16 に応じて) それぞれDS:ESI レジスタ
またはDS:SI レジスタから読み取られる。デスティネーション・オペランドのアドレスは、( やはり
命令のアドレス・サイズ属性に応じて)ES:EDI レジスタまたはES:DI レジスタから読み取られる。DS
セグメントは、セグメント・オーバライド・プリフィックスでオーバライドすることができるが、ES
セグメントをオーバライドすることはできない。
アセンブリ・コード・レベルでは、この命令の「明示オペランド」形式と「オペランドなし」形式
という2 つの形式が使用できる。(MOVS ニーモニックで指定される) 明示オペランド形式では、ソー
ス・オペランドとデスティネーション・オペランドを明示的に指定できる。この場合、ソース・オ
ペランドとデスティネーション・オペランドは、それぞれソース値とデスティネーションのサイズ
とロケーションを示す記号でなければならない。この明示オペランド形式は、ドキュメンテーショ
ンを可能にするために設けらたものであるが、この形式によって提供されるドキュメンテーション
は誤解を招く場合があるので注意されたい。すなわち、ソース・オペランドとデスティネーション・
オペランドの記号は、オペランドの正しいタイプ( サイズ: バイト、ワード、またはダブルワード)
を指定しなければならないが、正しいロケーションを指定する必要はない。ソース・オペランドと
デスティネーション・オペランドのロケーションは、常にDS:(E)SI レジスタとES:(E)DI レジスタに
よって指定されるので、ストリング移動命令を実行する前に、これらのレジスタに正しくロードさ
れていなければならない。
オペランドなし形式は、MOVS命令のバイト、ワード、およびダブルワード各バージョンの「ショー
ト形式」を提供する。この場合も、DS:(E)SI とES:(E)DI がそれぞれソース・オペランドとデスティ
ネーション・オペランドであると想定される。ソース・オペランドとデスティネーション・オペラ
ンドのサイズは、MOVSB( バイト移動)、MOVSW( ワード移動)、またはMOVSD( ダブルワード移
動) の各ニーモニックで選択される。
移動操作の後、(E)SI レジスタと(E)DI レジスタは、EFLAGS レジスタ内のDFフラグの設定に従って
自動的にインクリメントまたはデクリメントされる。(DF フラグが0 である場合は、(E)SI レジスタ
と(E)DI レジスタはインクリメントされ、DFフラグが1 である場合は、(E)SI レジスタと(E)DI レジス
タはデクリメントされる。) これらのレジスタは、バイト操作の場合は1、ワード操作の場合は2、ダ
ブルワード操作の場合は4、それぞれインクリメントまたはデクリメントされる。
オペコード命令説明
A4 MOVS m8, m8 アドレスDS:(E)SI のバイトをアドレスES:(E)DI に転送する。
A5 MOVS m16, m16 アドレスDS:(E)SI のワードをアドレスES:(E)DI に転送する。
A5 MOVS m32, m32 アドレスDS:(E)SI のダブルワードをアドレスES:(E)DI に転送
する。
A4 MOVSB アドレスDS:(E)SI のバイトをアドレスES:(E)DI に転送する。
A5 MOVSW アドレスDS:(E)SI のワードをアドレスES:(E)DI に転送する。
A5 MOVSD アドレスDS:(E)SI のダブルワードをアドレスES:(E)DI に転送
する。
3-468
命令セット・リファレンス
MOVS/MOVSB/MOVSW/MOVSD?Move Data from String to String
( 続き)
MOVS、MOVSB、MOVSW、およびMOVSD命令は、前にREPプリフィックスを付けることによ
り、ECXバイト、ワード、またはダブルワードのブロック転送を行うことができる。( 本章の
「REP/REPE/REPZ/REPNE /REPNZ?Repeat String Operation Prefix」を参照)。
操作
DEST ←SRC;
IF (byte move)
THEN IF DF ← 0
THEN
(E)SI ← (E)SI + 1;
(E)DI ← (E)DI + 1;
ELSE
(E)SI ← (E)SI ? 1;
(E)DI ← (E)DI ? 1;
FI;
ELSE IF (word move)
THEN IF DF ← 0
(E)SI ← (E)SI + 2;
(E)DI ← (E)DI + 2;
ELSE
(E)SI ← (E)SI ? 2;
(E)DI ← (E)DI ? 2;
FI;
ELSE (* doubleword move*)
THEN IF DF ← 0
(E)SI ← (E)SI + 4;
(E)DI ← (E)DI + 4;
ELSE
(E)SI ← (E)SI ? 4;
(E)DI ← (E)DI ? 4;
FI;
FI;
影響を受けるフラグ
なし。
3-469
命令セット・リファレンス
MOVS/MOVSB/MOVSW/MOVSD?Move Data from String to String
( 続き)
保護モード例外
#GP(0) デスティネーション・オペランドが書き込み不可能なセグメントにある
場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-470
命令セット・リファレンス
MOVSD?Move Scalar Double-Precision Floating-Point Value
説明
ソース・オペランド( 第2 オペランド) からデスティネーション・オペランド( 第1 オペランド) にス
カラ倍精度浮動小数点値を移動する。ソース・オペランドとデスティネーション・オペランドは、
XMMレジスタまたは64 ビットのメモリ・ロケーションである。この命令を使用して、XMMレジス
タの下位クワッドワードと64 ビットのメモリ・ロケーションの間、または2 つのXMM レジスタの
下位クワッドワードの間で、倍精度浮動小数点値を転送することができる。ただし、この命令は、2
つのメモリ・ロケーションの間のデータ転送には使用できない。
ソース・オペランドとデスティネーション・オペランドがXMM レジスタの場合は、デスティネー
ション・オペランドの上位クワッドワードは変更されない。ソース・オペランドがメモリ・ロケー
ションで、デスティネーション・オペランドがXMMレジスタの場合は、デスティネーション・オペ
ランドの上位クワッドワードはすべて0 にクリアされる。
操作
MOVSD instruction when source and destination operands are XMM registers:
DEST[63-0] ← SRC[63-0];
* DEST[127-64] remains unchanged *;
MOVSD instruction when source operand is XMM register and destination
operand is memory location:
DEST ← SRC[63-0];
MOVSD instruction when source operand is memory location and destination
operand is XMM register:
DEST[63-0] ← SRC;
DEST[127-64] ← 0000000000000000H;
同等のインテルC/C++ コンパイラ組み込み関数
MOVSD __m128d _mm_load_sd (double *p)
MOVSD void _mm_store_sd (double *p, __m128d a)
MOVSD __m128d _mm_store_sd (__m128d a, __m128d b)
SIMD 浮動小数点例外
なし。
オペコード命令説明
F2 0F 10 /r MOVSD xmm1, xmm2/m64 スカラ倍精度浮動小数点値をxmm2/m64 からxmm1 レ
ジスタに移動する。
F2 0F 11 /r MOVSD xmm2/m64, xmm スカラ倍精度浮動小数点値をxmm1 レジスタから
xmm2/m64 に移動する。
3-471
命令セット・リファレンス
MOVSD?Move Scalar Double-Precision Floating-Point Value ( 続き)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-472
命令セット・リファレンス
MOVSS?Move Scalar Single--Precision Floating-Point Values
説明
ソース・オペランド( 第2 オペランド) からデスティネーション・オペランド( 第1 オペランド) にス
カラ単精度浮動小数点値を移動する。ソース・オペランドとデスティネーション・オペランドは、
XMMレジスタまたは32 ビットのメモリ・ロケーションである。この命令を使用して、XMMレジス
タの最下位のダブルワードと32 ビットのメモリ・ロケーションの間、または2 つのXMMレジスタ
の最下位のダブルワードの間で、単精度浮動小数点値を転送することができる。ただし、この命令
は、2 つのメモリ・ロケーションの間のデータ転送には使用できない。
ソース・オペランドとデスティネーション・オペランドがXMM レジスタの場合は、デスティネー
ション・オペランドの上位3 つのダブルワードは変更されない。ソース・オペランドがメモリ・ロ
ケーションで、デスティネーション・オペランドがXMMレジスタの場合は、デスティネーション・
オペランドの上位3 つのダブルワードはすべて0 にクリアされる。
操作
MOVSS instruction when source and destination operands are XMM registers:
DEST[31-0] ← SRC[31-0];
* DEST[127-32] remains unchanged *;
MOVSS instruction when source operand is XMM register and destination
operand is memory location:
DEST ← SRC[31-0];
MOVSS instruction when source operand is memory location and destination
operand is XMM register:
DEST[31-0] ← SRC;
DEST[127-32] ← 000000000000000000000000H;
同等のインテルC/C++ コンパイラ組み込み関数
MOVSS __m128 _mm_load_ss(float * p)
MOVSS void_mm_store_ss(float * p, __m128 a)
MOVSS __m128 _mm_move_ss(__m128 a, __m128 b)
SIMD 浮動小数点例外
なし。
オペコード命令説明
F3 0F 10 /r MOVSS xmm1, xmm2/m32 スカラ単精度浮動小数点値を、xmm2/m64 からxmm1
レジスタに移動する。
F3 0F 11 /r MOVSS xmm2/m32, xmm1 スカラ単精度浮動小数点値を、xmm1 レジスタから
xmm2/m64 に移動する。
3-473
命令セット・リファレンス
MOVSS?Move Scalar Single--Precision Floating-Point Values ( 続き)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-474
命令セット・リファレンス
MOVSX?Move with Sign-Extension
説明
ソース・オペランド( レジスタまたはメモリ・ロケーション) の内容をデスティネーション・オペラ
ンド( レジスタ) にコピーし、値を16ビットまたは32ビットに符号拡張する。詳細は『IA-32 インテ
ルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図7-6. を参照。変換さ
れた値のサイズは、オペランド・サイズ属性に依存する。
操作
DEST ← SignExtend(SRC);
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
オペコード命令説明
0F BE /r MOVSX r16,r/m8 バイトをワードに符号拡張して転送する。
0F BE /r MOVSX r32,r/m8 バイトをダブルワードに符号拡張して転送する。
0F BF /r MOVSX r32,r/m16 ワードをダブルワードに符号拡張して転送する。
3-475
命令セット・リファレンス
MOVUPD?Move Unaligned Packed Double-Precision Floating-Point
Values
説明
2 つのパックド倍精度浮動小数点値が入っているダブル・クワッドワードを、ソース・オペランド
( 第2 オペランド) からデスティネーション・オペランド( 第1 オペランド) に移動する。この命令を
使用して、XMMレジスタを128 ビットのメモリ・ロケーションからロードする操作、XMMレジス
タの内容を128 ビットのメモリ・ロケーションにストアする操作、または2 つのXMM レジスタの
間でデータを転送する操作が可能である。ソース・オペランドまたはデスティネーション・オペラ
ンドがメモリ・オペランドの場合、そのオペランドのアライメントが16 バイトに合っていなくて
も、一般保護例外（#GP）は発生しない。
倍精度浮動小数点値の転送先または転送元のメモリ・ロケーションのアライメントが16 バイトに
合っていることがわかっている場合は、MOVAPD命令を使用する。
16ビット・アドレス指定モードでの実行中に、128 ビット・データ・アクセスのリニア・アドレスが
16 ビット・セグメントの終点からはみ出すことは許されない。これは予約済みの動作として定義さ
れている。この場合に一般保護例外（#GP）が発生するかどうかは、プロセッサによって異なる。16
ビット・セグメントの範囲を超えたアドレスは、そのセグメントの始点にラップアラウンドされる
ことも、ラップアラウンドされないこともある。
操作
DEST ← SRC;
* #GP if SRC or DEST unaligned memory operand *;
同等のインテルC/C++ コンパイラ組み込み関数
MOVUPD __m128 _mm_loadu_pd(double * p)
MOVUPD void_mm_storeu_pd(double *p, __m128 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
オペコード命令説明
66 0F 10 /r MOVUPD xmm1,
xmm2/m128
パックド倍精度浮動小数点値を、xmm2/m128 からxmm1
に移動する。
66 0F 11 /r MOVUPD xmm2/m128,
xmm
パックド倍精度浮動小数点値を、xmm1 からxmm2/m128
に移動する。
3-476
命令セット・リファレンス
MOVUPD?Move Unaligned Packed Double-Precision Floating-Point
Values ( 続き)
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-477
命令セット・リファレンス
MOVUPS?Move Unaligned Packed Single-Precision Floating-Point
Values
説明
4 つのパックド単精度浮動小数点値が入っているダブル・クワッドワードを、ソース・オペランド
( 第2 オペランド) からデスティネーション・オペランド( 第1 オペランド) に移動する。この命令を
使用して、XMMレジスタを128 ビットのメモリ・ロケーションからロードする操作、XMMレジス
タの内容を128 ビットのメモリ・ロケーションにストアする操作、または2 つのXMM レジスタの
間でデータを転送する操作が可能である。ソース・オペランドまたはデスティネーション・オペラ
ンドがメモリ・オペランドの場合、そのオペランドのアライメントが16 バイトに合っていなくて
も、一般保護例外（#GP）は発生しない。
パックド単精度浮動小数点値の転送先または転送元のメモリ・ロケーションのアライメントが16 バ
イトに合っていることがわかっている場合は、MOVAPS 命令を使用する。
16ビット・アドレス指定モードでの実行中に、128 ビット・データ・アクセスのリニア・アドレスが
16 ビット・セグメントの終わりと重複することは許されない。この場合に一般保護例外（#GP）が
発生するかどうかは、プロセッサによって異なる。16 ビット・セグメントの範囲を超えたアドレス
は、そのセグメントの始点にラップアラウンドされることも、ラップアラウンドされないこともあ
る。
操作
DEST ← SRC;
* #GP if SRC or DEST unaligned memory operand *;
同等のインテルC/C++ コンパイラ組み込み関数
MOVUPS __m128 _mm_loadu_ps(double * p)
MOVUPS void_mm_storeu_ps(double *p, __m128 a)
SIMD 浮動小数点例外
なし。
オペコード命令説明
0F 10 /r MOVUPS xmm1,
xmm2/m128
パックド単精度浮動小数点値を、xmm2/m128 からxmm1
レジスタに移動する。
0F 11 /r MOVUPS xmm2/m128,
xmm1
パックド単精度浮動小数点値を、xmm1 レジスタから
xmm2/m128 に移動する。
3-478
命令セット・リファレンス
MOVUPS?Move Unaligned Packed Single-Precision Floating-Point
Values ( 続き)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-479
命令セット・リファレンス
MOVZX?Move with Zero-Extend
説明
ソース・オペランド( レジスタまたはメモリ・ロケーション) の内容をデスティネーション・オペラ
ンド( レジスタ) にコピーし、値を16 ビットまたは32 ビットにゼロ拡張する。変換された値のサイ
ズは、オペランド・サイズ属性に依存する。
操作
DEST ← ZeroExtend(SRC);
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
オペコード命令説明
0F B6 /r MOVZX r16,r/m8 バイトをワードにゼロ拡張して転送する。
0F B6 /r MOVZX r32,r/m8 バイトをダブルワードにゼロ拡張して転送する。
0F B7 /r MOVZX r32,r/m16 ワードをダブルワードにゼロ拡張して転送する。
3-480
命令セット・リファレンス
MUL?Unsigned Multiply
説明
第1 オペランド( デスティネーション・オペランド) と第2 オペランド( ソース・オペランド) との符
号なし乗算を行い、結果をデスティネーション・オペランドにストアする。デスティネーション・
オペランドは、( オペランドのサイズに応じて)AL、AX、またはEAX レジスタとなる暗黙のオペラ
ンドである。ソース・オペランドは、汎用レジスタまたはメモリ・ロケーションである。この命令
の処置と結果のロケーションは、以下の表に示すようにオペコードとオペランド・サイズによって
変わる。
:
結果は、( オペランド・サイズに応じて) レジスタAX、レジスタ・ペアDX:AX、またはレジスタ・
ペアEDX:EAX にストアされ、積の上位ビットは、それぞれAH、DX、またはEDX に入る。積の上
位ビットが0 である場合は、CF フラグとOFフラグがクリアされ、そうでない場合は、これらのフラ
グが1 にセットされる。
操作
IF byte operation
THEN
AX ← AL ? SRC
ELSE (* word or doubleword operation *)
IF OperandSize ← 16
THEN
DX:AX ← AX ? SRC
ELSE (* OperandSize ← 32 *)
EDX:EAX ← EAX ? SRC
FI;
FI;
影響を受けるフラグ
結果の上半分が0 である場合は、OFフラグとCFフラグが0 にクリアされる。そうでない場合は、そ
れらのフラグが1 にセットされる。SF、ZF、AF、およびPF フラグは未定義。
オペコード命令説明
F6 /4 MUL r/m8 符号なし乗算(AX ← AL? r/m8)
F7 /4 MUL r/m16 符号なし乗算(DX:AX ← AX ? r/m16)
F7 /4 MUL r/m32 符号なし乗算(EDX:EAX ← EAX? r/m32)
オペランド・サイズソース 1 ソース 2 デスティネーション
バイトAL r/m8 AX
ワードAX r/m16 DX:AX
ダブルワードEAX r/m32 EDX:EAX
3-481
命令セット・リファレンス
MUL?Unsigned Multiply ( 続き)
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-482
命令セット・リファレンス
MULPD?Multiply Packed Double-Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の2
つのパックド倍精度浮動小数点値のSIMD乗算を実行し、結果のパックド倍精度浮動小数点値をデス
ティネーション・オペランドに格納する。ソース・オペランドは、XMMレジスタまたは128 ビット
のメモリ・ロケーションである。デスティネーション・オペランドはXMMレジスタである。倍精度
浮動小数点値のSIMD演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』の図11-3. を参照のこと。
操作
DEST[63-0] ← DEST[63-0] ? SRC[63-0];
DEST[127-64] ← DEST[127-64] ? SRC[127-64];
同等のインテルC/C++ コンパイラ組み込み関数
MULPD __m128d _mm_mul_pd (m128d a, m128d b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
66 0F 59 /r MULPD xmm1, xmm2/m128 xmm2/m128 のパックド倍精度浮動小数点値にxmm1 の
パックド倍精度浮動小数点値を掛ける。
3-483
命令セット・リファレンス
MULPD?Multiply Packed Double-Precision Floating-Point Values
( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-484
命令セット・リファレンス
MULPS?Multiply Packed Single-Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の4
つのパックド単精度浮動小数点値のSIMD乗算を実行し、結果のパックド単精度浮動小数点値をデス
ティネーション・オペランドに格納する。ソース・オペランドは、XMMレジスタまたは128 ビット
のメモリ・ロケーションである。デスティネーション・オペランドはXMMレジスタである。単精度
浮動小数点値のSIMD演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』の図10-5. を参照のこと。
操作
DEST[31-0] ← DEST[31-0] ? SRC[31-0];
DEST[63-32] ← DEST[63-32] ? SRC[63-32];
DEST[95-64] ← DEST[95-64] ? SRC[95-64];
DEST[127-96] ← DEST[127-96] ? SRC[127-96];
同等のインテルC/C++ コンパイラ組み込み関数
MULPS __m128 _mm_mul_ps(__m128 a, __m128 b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
0F 59 /r MULPS xmm1, xmm2/m128 xmm1 のパックド単精度浮動小数点値にxmm2/mem の
パックド単精度浮動小数点値を掛けて、結果をxmm1
レジスタにストアする。
3-485
命令セット・リファレンス
MULPS?Multiply Packed Single-Precision Floating-Point Values
( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-486
命令セット・リファレンス
MULSD?Multiply Scalar Double-Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）の下位の倍精度浮動小数点値にデスティネーション・オペラ
ンド（第1 オペランド）の下位の倍精度浮動小数点値を掛けて、結果の倍精度浮動小数点値をデス
ティネーション・オペランドに格納する。ソース・オペランドは、XMM レジスタまたは64 ビット
のメモリ・ロケーションである。デスティネーション・オペランドはXMM レジスタである。デス
ティネーション・オペランドの上位クワッドワードは変更されない。倍精度浮動小数点値のスカラ
演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上
巻』の図11-4. を参照のこと。
操作
DEST[63-0] ← DEST[63-0] * xmm2/m64[63-0];
* DEST[127-64] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
MULSD __m128d _mm_mul_sd (m128d a, m128d b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
F2 0F 59 /r MULSD xmm1, xmm2/m64 xmm2/mem64 の下位の倍精度浮動小数点値にxmm1 の
下位の倍精度浮動小数点値を掛ける。
3-487
命令セット・リファレンス
MULSD?Multiply Scalar Double-Precision Floating-Point Values
( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC 現行特権レベルが3 のときに、アライメントの合っていないメモリ参照
を行った場合。
3-488
命令セット・リファレンス
MULSS?Multiply Scalar Single-Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）の最下位の単精度浮動小数点値にデスティネーション・オペ
ランド（第1 オペランド）の最下位の単精度浮動小数点値を掛けて、結果の単精度浮動小数点値をデ
スティネーション・オペランドに格納する。ソース・オペランドは、XMMレジスタまたは32 ビッ
トのメモリ・ロケーションである。デスティネーション・オペランドはXMMレジスタである。デス
ティネーション・オペランドの上位3 つのダブルワードは変更されない。単精度浮動小数点値のスカ
ラ演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上
巻』の図10-6. を参照のこと。
操作
DEST[31-0] ← DEST[31-0] ? SRC[31-0];
* DEST[127-32] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
MULSS __m128 _mm_mul_ss(__m128 a, __m128 b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
F3 0F 59 /r MULSS xmm1, xmm2/m32 xmm1 の下位の単精度浮動小数点値にxmm2/mem の下
位の単精度浮動小数点値を掛けて、結果をxmm1 レジ
スタにストアする。
3-489
命令セット・リファレンス
MULSS?Multiply Scalar Single-Precision Floating-Point Values ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC 現行特権レベルが3 のときに、アライメントの合っていないメモリ参照
を行った場合。
3-490
命令セット・リファレンス
NEG?Two's Complement Negation
説明
オペランド( デスティネーション・オペランド) の値をその2 の補数で置き換える。( この操作は、オ
ペランドの0 からの減算と同等である。) デスティネーション・オペランドは、汎用レジスタまたは
メモリ・ロケーションである。
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
IF DEST ← 0
THEN CF ← 0
ELSE CF ← 1;
FI;
DEST ← ? (DEST)
影響を受けるフラグ
ソース・オペランドが0 である場合は、CF フラグが0 にクリアされる。そうでない場合は、CF フラ
グが1 にセットされる。OF、SF、ZF、AF、およびPF フラグが結果に従ってセットされる。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
オペコード命令説明
F6 /3 NEG r/m8 2 の補数がr/m8 をネゲートする。
F7 /3 NEG r/m16 2 の補数がr/m16 をネゲートする。
F7 /3 NEG r/m32 2 の補数がr/m32 をネゲートする。
3-491
命令セット・リファレンス
NEG?Two's Complement Negation ( 続き)
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-492
命令セット・リファレンス
NOP?No Operation
説明
何の操作も実行されない。この命令は、命令ストリーム内で空間を占めるが、EIP レジスタを除い
て、マシン・コンテキストに影響を与えない1 バイト命令である。
NOP 命令は、XCHG (E)AX、(E)AX命令の別名ニーモニックである。
影響を受けるフラグ
なし。
例外 ( すべての操作モード)
なし。
オペコード命令説明
90 NOP 操作なし
3-493
命令セット・リファレンス
NOT?One's Complement Negation
説明
デスティネーション・オペランドにビット単位のNOT( 否定) 演算( 各1 が0 にクリアされ、各0 が1
にセットされる) を実行し、結果をデスティネーション・オペランド・ロケーションにストアする。
デスティネーション・オペランドには、レジスタまたはメモリ・ロケーションを使用できる。
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
DEST ← NOT DEST;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) デスティネーション・オペランドが書き込み不可能なセグメントを指し
ている場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
オペコード命令説明
F6 /2 NOT r/m8 r/m8 の各ビットを反転する。
F7 /2 NOT r/m16 r/m16 の各ビットを反転する。
F7 /2 NOT r/m32 r/m32 の各ビットを反転する。
3-494
命令セット・リファレンス
NOT?One's Complement Negation ( 続き)
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-495
命令セット・リファレンス
OR?Logical Inclusive OR
説明
デスティネーション・オペランド( 第1 オペランド) とソース・オペランド( 第2 オペランド) との間
のビット単位のOR( 論理和) 演算を実行し、結果をデスティネーション・オペランド・ロケーション
にストアする。ソース・オペランドには、即値、レジスタ、またはメモリ・ロケーションを使用で
きる。デスティネーション・オペランドには、レジスタまたはメモリ・ロケーションを使用できる。
( ただし、1 つの命令に2 つのメモリ・オペランドを使用することはできない。) OR 命令の各ビット
の結果は、第1 オペランドと第2 オペランドの対応するビットが両方とも0 である場合は0 にセット
され、そうでない場合は1 にセットされる。
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
DEST ← DEST OR SRC;
影響を受けるフラグ
OF およびCF フラグがクリアされ、SF、ZF、およびPF フラグが結果に従ってセットされる。AF フ
ラグの状態は未定義。
保護モード例外
#GP(0) デスティネーション・オペランドが書き込み不可能なセグメントを指し
ている場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
オペコード命令説明
0C ib OR AL,imm8 AL とimm8 とのOR をとる。
0D iw OR AX,imm16 AX とimm16 とのOR をとる。
0D id OR EAX,imm32 EAX とimm32 とのOR をとる。
80 /1 ib OR r/m8,imm8 r/m8 とimm8 とのOR をとる。
81 /1 iw OR r/m16,imm16 r/m16 とimm16 とのOR をとる。
81 /1 id OR r/m32,imm32 r/m32 とimm32 とのOR をとる。
83 /1 ib OR r/m16,imm8 r/m16 とimm8( 符号拡張) とのOR をとる。
83 /1 ib OR r/m32,imm8 r/m32 とimm8( 符号拡張) とのOR をとる。
08 /r OR r/m8,r8 r/m8 とr8 とのOR をとる。
09 /r OR r/m16,r16 r/m16 とr16 とのOR をとる。
09 /r OR r/m32,r32 r/m32 とr32 とのOR をとる。
0A /r OR r8,r/m8 r8 とr/m8 とのOR をとる。
0B /r OR r16,r/m16 r16 とr/m16 とのOR をとる。
0B /r OR r32,r/m32 r32 とr/m32 とのOR をとる。
3-496
命令セット・リファレンス
OR?Logical Inclusive OR ( 続き)
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-497
命令セット・リファレンス
ORPD?Bitwise Logical OR of Packed Double-Precision Floating-Point
Values
説明
ソース・オペランド（第2 オペランド）の2 つのパックド倍精度浮動小数点値とデスティネーショ
ン・オペランド（第1 オペランド）の2 つのパックド倍精度浮動小数点値の間でビット単位のOR（論
理和）演算を実行し、結果をデスティネーション・オペランドに格納する。ソース・オペランドは、
XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・オペランド
はXMMレジスタである。
操作
DEST[127-0] ← DEST[127-0] BitwiseOR SRC[127-0];
同等のインテルC/C++ コンパイラ組み込み関数
ORPD __m128d _mm_or_pd(__m128d a, __m128d b)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
66 0F 56 /r ORPD xmm1, xmm2/m128 xmm2/m128 とxmm1 のビット単位のOR（論理和）演
算を実行する。
3-498
命令セット・リファレンス
ORPD?Bitwise Logical OR of Packed Double-Precision Floating-Point
Values ( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-499
命令セット・リファレンス
ORPS?Bitwise Logical OR of Packed Single-Precision Floating-Point
Values
説明
ソース・オペランド（第2 オペランド）の4 つのパックド単精度浮動小数点値とデスティネーショ
ン・オペランド（第1 オペランド）の4 つのパックド単精度浮動小数点値の間でビット単位のOR（論
理和）演算を実行し、結果をデスティネーション・オペランドに格納する。ソース・オペランドは、
XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・オペランド
はXMMレジスタである。
操作
DEST[127-0] ← DEST[127-0] BitwiseOR SRC[127-0];
同等のインテルC/C++ コンパイラ組み込み関数
ORPS __m128 _mm_or_ps(__m128 a, __m128 b)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
オペコード命令説明
0F 56 /r ORPS xmm1, xmm2/m128 xmm2/m128 とxmm1 のビット単位のOR（論理和）演
算を実行する。
3-500
命令セット・リファレンス
ORPS?Bitwise Logical OR of Packed Single-Precision Floating-Point
Values ( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-501
命令セット・リファレンス
OUT?Output to Port
説明
値を第2 オペランド( ソース・オペランド) からデスティネーション・オペランド( 第1 オペランド)
で指定されたI/O ポートにコピーする。ソース・オペランドには、アクセスされるポートのサイズ
(8、16、または32 ビット) に応じてそれぞれAL、AX、またはEAXレジスタを使用できる。デスティ
ネーション・オペランドには、バイト即値またはDXレジスタを使用できる。バイト即値を使用する
と、I/O ポート・アドレス0 〜255をアクセスすることができる。ソース・オペランドとしてDXレジ
スタを使用すると、I/Oポート0 〜65,535 をアクセスすることができる。
アクセスされるI/Oポートのサイズは、8 ビットのI/O ポートではオペコードによって決まり、16 ビッ
トまたは32 ビットのI/O ポートでは命令のオペランド・サイズ属性によって決まる。
マシン・コード・レベルでは、I/O 命令は、8 ビットのI/Oポートをアクセスするときは短くなる。こ
の場合は、ポート・アドレスの上位8 ビットは0 になる。
この命令は、プロセッサのI/Oアドレス空間にあるI/O ポートのアクセスだけに有用である。I/O アド
レス空間にあるI/Oポートのアクセスに関する詳細については、『IA-32 インテルR アーキテクチャ・
ソフトウェア・デベロッパーズ・マニュアル、上巻』第12章「入出力」を参照のこと。
IA-32 アーキテクチャにおける互換性
OUT 命令を実行した後、Pentium プロセッサは、次の命令の実行を開始する前に、EWBE# ピンがアク
ティブにサンプリングされていることを保証する。(EWBE# がアクティブでない場合でも命令をプリ
フェッチすることはできるが、EWBE#ピンがアクティブにサンプリングされるまで命令は実行されな
いことに注意すること。) Pentiumプロセッサ・ファミリだけにEWBE#ピンがあり、他のIA-32プロセッ
サにはない。
操作
IF ((PE ← 1) AND ((CPL > IOPL) OR (VM ← 1)))
THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)
IF (Any I/O Permission Bit for I/O port being accessed ← 1)
THEN (* I/O operation is not allowed *)
#GP(0);
ELSE ( * I/O operation is allowed *)
DEST ← SRC; (* Writes to selected I/O port *)
FI;
オペコード命令説明
E6 ib OUT imm8, AL AL にあるバイトをI/O ポート・アドレスimm8 に出力する。
E7 ib OUT imm8, AX AX にあるワードをI/O ポート・アドレスimm8 に出力する。
E7 ib OUT imm8, EAX EAX にあるダブルワードをI/O ポート・アドレスimm8 に出力する。
EE OUT DX, AL AL にあるバイトをDX にあるI/O ポート・アドレスに出力する。
EF OUT DX, AX AX にあるワードをDX にあるI/O ポート・アドレスに出力する。
EF OUT DX, EAX EAX にあるダブルワードをDX にあるI/O ポート・アドレスに出力する。
3-502
命令セット・リファレンス
OUT?Output to Port ( 続き)
ELSE (Real Mode or Protected Mode with CPL ? IOPL *)
DEST ← SRC; (* Writes to selected I/O port *)
FI;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) CPL がI/O 特権レベル(IOPL) より大きく( 低い特権をもつ)、アクセス
されるI/O ポートのTSS にある対応するI/O パーミッション・ビットの
いずれかが1 である場合。
実アドレス・モード例外
なし。
仮想8086 モード例外
#GP(0) アクセスされるI/O ポートのTSS にある対応するI/O パーミッション・
ビットのいずれかが1 である場合。
3-503
命令セット・リファレンス
OUTS/OUTSB/OUTSW/OUTSD?Output String to Port
説明
データをソース・オペランド( 第2 オペランド) からデスティネーション・オペランド( 第1 オペラン
ド) で指定されたI/O ポートにコピーする。ソース・オペランドはメモリ・ロケーションであり、そ
のアドレスは、( 命令のアドレス・サイズ属性、32 または16 に応じて) それぞれDS:EDI レジスタま
たはDS:DI レジスタから読み取られる。DSセグメントをセグメント・オーバライド・プリフィック
スでオーバライドすることができる。 デスティネーション・オペランドは、DXレジスタから読み取
られるI/Oポート・アドレス(0 〜65,535) である。アクセスされるI/O ポートのサイズ( すなわち、ソー
ス・オペランドとデスティネーション・オペランドのサイズ) は、8 ビットのI/O ポートではオペコー
ドによって決まり、16 ビットまたは32 ビットのI/O ポートでは命令のオペランド・サイズ属性によっ
て決まる。
アセンブリ・コード・レベルでは、この命令の「明示オペランド」形式と「オペランドなし」形式
という2 つの形式が使用できる。(OUTSニーモニックで指定される) 明示オペランド形式では、ソー
ス・オペランドとデスティネーション・オペランドを明示的に指定できる。この場合、ソース・オ
ペランドは、I/Oポートのサイズとソース・アドレスを示す記号でなければならない。デスティネー
ション・オペランドは、DXでなければならない。この明示オペランド形式は、ドキュメンテーショ
ンを可能にするために設けられたものであるが、この形式によって提供されるドキュメンテーショ
ンは誤解を招く場合があるので注意されたい。すなわち、ソース・オペランドの記号は、オペラン
ドの正しいタイプ( サイズ: バイト、ワード、またはダブルワード) を指定しなければならないが、正
しいロケーションを指定する必要はない。ロケーションは、常にDS:(E)SI レジスタによって指定さ
れるので、OUTS 命令を実行する前に、このレジスタに正しくロードされていなければならない。
オペランドなし形式は、OUTS 命令のバイト、ワード、およびダブルワード各バージョンの「ショー
ト形式」を提供する。この場合も、DS:(E)SI がソース・オペランドであると想定され、DXがデス
ティネーション・オペランドであると想定される。I/O ポートのサイズは、OUTSB( バイト)、OUTSW
( ワード)、またはOUTSD( ダブルワード) の各ニーモニックの選択で指定される。
オペコード命令説明
6E OUTS DX, m8 バイトをDS:(E)SI に指定されたメモリ・ロケーションから
DX に指定されたI/O ポートに出力する。
6F OUTS DX, m16 ワードをDS:(E)SI に指定されたメモリ・ロケーションから
DX に指定されたI/O ポートに出力する。
6F OUTS DX, m32 ダブルワードをDS:(E)SI に指定されたメモリ・ロケーショ
ンからDX に指定されたI/O ポートに出力する。
6E OUTSB バイトをDS:(E)SI に指定されたメモリ・ロケーションから
DX に指定されたI/O ポートに出力する。
6F OUTSW ワードをDS:(E)SI に指定されたメモリ・ロケーションから
DX に指定されたI/O ポートに出力する。
6F OUTSD ダブルワードをDS:(E)SI に指定されたメモリ・ロケーショ
ンからDX に指定されたI/O ポートに出力する。
3-504
命令セット・リファレンス
OUTS/OUTSB/OUTSW/OUTSD?Output String to Port ( 続き)
バイト、ワード、またはダブルワードがメモリ・ロケーションからI/Oポートに転送された後、(E)SI
レジスタはEFLAGSレジスタ内のDFフラグの設定に従って自動的にインクリメントまたはデクリメ
ントされる。(DF フラグが0 である場合は、(E)SI レジスタはインクリメントされる。DF フラグが1
である場合は、(E)SI レジスタはデクリメントされる。) (E)SI レジスタは、バイト操作の場合は1、
ワード操作の場合は2、ダブルワード操作の場合は4、それぞれインクリメントまたはデクリメント
される。
OUTS、OUTSB、OUTSW、およびOUTSD 命令は、前にREP プリフィックスを付けることにより、
ECX バイト、ワード、またはダブルワードのブロック入力を行うことができる。REP プリフィック
スの説明については、本章の「REP/REPE/REPZ/REPNE /REPNZ?Repeat String Operation Prefix」を参
照のこと。
この命令は、プロセッサのI/Oアドレス空間にあるI/O ポートのアクセスだけに有用である。I/Oアド
レス空間にあるI/Oポートへのアクセスに関する詳細については、『IA-32インテルR アーキテクチャ・
ソフトウェア・デベロッパーズ・マニュアル、上巻』第12 章「入出力」を参照のこと。
IA-32 アーキテクチャにおける互換性
OUTS、OUTSB、OUTSW、またはOUTSD命令を実行した後、Pentiumプロセッサは、次の命令の実
行を開始する前に、EWBE# ピンがアクティブにサンプリングされていることを保証する。(EWBE#
がアクティブでない場合でも命令をプリフェッチすることはできるが、EWBE# ピンがアクティブに
サンプリングされるまで命令は実行されないことに注意すること。) Pentium プロセッサ・ファミリ
だけにEWBE# ピンがあり、他のIA-32 プロセッサにはない。Pentium 4 プロセッサおよびP6 ファミ
リのプロセッサは、OUTS、OUTSB、OUTSW、またはOUTSD命令の実行時に、そのトランザクショ
ンのデータ・フェーズが完了してから次の命令を実行する。
操作
IF ((PE ← 1) AND ((CPL > IOPL) OR (VM ← 1)))
THEN (* Protected mode with CPL > IOPL or virtual-8086 mode *)
IF (Any I/O Permission Bit for I/O port being accessed ← 1)
THEN (* I/O operation is not allowed *)
#GP(0);
ELSE ( * I/O operation is allowed *)
DEST ← SRC; (* Writes to I/O port *)
FI;
ELSE (Real Mode or Protected Mode with CPL ? IOPL *)
DEST ← SRC; (* Writes to I/O port *)
FI;
IF (byte transfer)
THEN IF DF ← 0
THEN (E)SI ← (E)SI + 1;
ELSE (E)SI ← (E)SI ? 1;
FI;
3-505
命令セット・リファレンス
OUTS/OUTSB/OUTSW/OUTSD?Output String to Port ( 続き)
ELSE IF (word transfer)
THEN IF DF ← 0
THEN (E)SI ← (E)SI + 2;
ELSE (E)SI ← (E)SI ? 2;
FI;
ELSE (* doubleword transfer *)
THEN IF DF ← 0
THEN (E)SI ← (E)SI + 4;
ELSE (E)SI ← (E)SI ? 4;
FI;
FI;
FI;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) CPL がI/O 特権レベル(IOPL) より大きく( 低い特権をもつ)、アクセス
されるI/O ポートのTSS にある対応するI/O パーミッション・ビットの
いずれかが1 である場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
セグメント・レジスタの内容がヌル・セグメント・セレクタの場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) アクセスされるI/O ポートのTSS にある対応するI/O パーミッション・
ビットのいずれかが1 である場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-506
命令セット・リファレンス
PACKSSWB/PACKSSDW?Pack with Signed Saturation
説明
オーバーフロー条件を処理する飽和処理を使用して、パックド符号付きワード整数をパックド符号
付きバイト整数に変換する(PACKSSWBの場合) か、あるいはパックド符号付きダブルワード整数を
パックド符号付きワード整数に変換する(PACKSSDWの場合)。パック操作の例については、図3-5.
を参照のこと。
PACKSSWB 命令は、デスティネーション・オペランド( 第1 オペランド) の4 個または8 個の符号付
きワード整数とソース・オペランド( 第2 オペランド) の4 個または8 個の符号付きワード整数を、8
個または16 個の符号付きバイト整数に変換し、デスティネーション・オペランドにその結果をスト
アする。符号付きワード整数値が符号付きバイト整数の範囲を超える場合( すなわち、正の整数では
7FH より大きく、負の整数では80H より大きい場合) は、飽和された符号付きバイト整数値である
7FHまたは80Hがデスティネーションにストアされる。
PACKSSDW命令は、デスティネーション・オペランド( 第1 オペランド) の2 個または4 個の符号付
きダブルワードとソース・オペランド( 第2 オペランド) の2 個または4 個の符号付きダブルワード
を、デスティネーション・オペランドの4 個または8 個の符号付きワードにパックする( 図3-5. を参
照)。符号付きダブルワード整数値が符号付きワードの範囲を超える場合( すなわち、正の整数では
7FFFHより大きく、負の整数では8000Hより大きい場合) は、飽和された符号付きワード整数値であ
る7FFFHまたは8000Hがデスティネーションにストアされる。
オペコード命令説明
0F 63 /r PACKSSWB mm1,
mm2/m64
符号付き飽和処理を使用して、mm1 とmm2/m64 の4 個のパック
ド符号付きワード整数を、mm1 の8 個のパックド符号付きバイト
整数に変換する。
66 0F 63 /r PACKSSWB xmm1,
xmm2/m128
符号付き飽和処理を使用して、xmm1 とxxm2/m128 の8 個のパッ
クド符号付きワード整数を、xxm1 の16 個のパックド符号付きバイ
ト整数に変換する。
0F 6B /r PACKSSDW mm1,
mm2/m64
符号付き飽和処理を使用して、mm1 とmm2/m64 の2 個のパック
ド符号付きダブルワード整数を、mm1 の4 個のパックド符号付き
ワード整数に変換する。
66 0F 6B /r PACKSSDW xmm1,
xmm2/m128
符号付き飽和処理を使用して、xmm1 とxxm2/m128 の4 個のパッ
クド符号付きダブルワード整数を、xxm1 の8 個のパックド符号付
きワード整数に変換する。
図3-5. 64 ビット・オペランドを使用してのPACKSSDW 命令の操作
D C
64 ビットDEST
64 ビットDEST
D’ C’ B’ A’
64 ビットSRC
B A
3-507
命令セット・リファレンス
PACKSSWB/PACKSSDW?Pack with Signed Saturation ( 続き)
PACKSSWB 命令およびPACKSSDW 命令は、64 ビット・オペランドまたは128 ビット・オペランド
のいずれかを操作する。64 ビット・オペランドを操作する場合、デスティネーション・オペランド
にはMMXテクノロジ・レジスタを使用しなければならないが、ソース・オペランドにはMMXテク
ノロジ・レジスタまたは64 ビット・メモリ・ロケーションのどちらを使用しても構わない。128 ビッ
ト・オペランドを操作する場合は、デスティネーション・オペランドにはXXMレジスタを使用しな
ければならないが、ソース・オペランドにはXMMレジスタまたは128 ビット・メモリ・ロケーショ
ンのどちらを使用しても構わない。
操作
PACKSSWB instruction with 64-bit operands
DEST[7..0] ← SaturateSignedWordToSignedByte DEST[15..0];
DEST[15..8] ← SaturateSignedWordToSignedByte DEST[31..16];
DEST[23..16] ← SaturateSignedWordToSignedByte DEST[47..32];
DEST[31..24] ← SaturateSignedWordToSignedByte DEST[63..48];
DEST[39..32] ← SaturateSignedWordToSignedByte SRC[15..0];
DEST[47..40] ← SaturateSignedWordToSignedByte SRC[31..16];
DEST[55..48] ← SaturateSignedWordToSignedByte SRC[47..32];
DEST[63..56] ← SaturateSignedWordToSignedByte SRC[63..48];
PACKSSDW instruction with 64-bit operands
DEST[15..0] ← SaturateSignedDoublewordToSignedWord DEST[31..0];
DEST[31..16] ← SaturateSignedDoublewordToSignedWord DEST[63..32];
DEST[47..32] ← SaturateSignedDoublewordToSignedWord SRC[31..0];
DEST[63..48] ← SaturateSignedDoublewordToSignedWord SRC[63..32];
PACKSSWB instruction with 128-bit operands
DEST[7-0] ← SaturateSignedWordToSignedByte (DEST[15-0]);
DEST[15-8] ← SaturateSignedWordToSignedByte (DEST[31-16]);
DEST[23-16] ← SaturateSignedWordToSignedByte (DEST[47-32]);
DEST[31-24] ← SaturateSignedWordToSignedByte (DEST[63-48]);
DEST[39-32] ← SaturateSignedWordToSignedByte (DEST[79-64]);
DEST[47-40] ← SaturateSignedWordToSignedByte (DEST[95-80]);
DEST[55-48] ← SaturateSignedWordToSignedByte (DEST[111-96]);
DEST[63-56] ← SaturateSignedWordToSignedByte (DEST[127-112]);
DEST[71-64] ← SaturateSignedWordToSignedByte (SRC[15-0]);
DEST[79-72] ← SaturateSignedWordToSignedByte (SRC[31-16]);
DEST[87-80] ← SaturateSignedWordToSignedByte (SRC[47-32]);
DEST[95-88] ← SaturateSignedWordToSignedByte (SRC[63-48]);
DEST[103-96] ← SaturateSignedWordToSignedByte (SRC[79-64]);
DEST[111-104] ← SaturateSignedWordToSignedByte (SRC[95-80]);
DEST[119-112] ← SaturateSignedWordToSignedByte (SRC[111-96]);
DEST[127-120] ← SaturateSignedWordToSignedByte (SRC[127-112]);
3-508
命令セット・リファレンス
PACKSSWB/PACKSSDW?Pack with Signed Saturation ( 続き)
PACKSSDW instruction with 128-bit operands
DEST[15-0] ← SaturateSignedDwordToSignedWord (DEST[31-0]);
DEST[31-16] ← SaturateSignedDwordToSignedWord (DEST[63-32]);
DEST[47-32] ← SaturateSignedDwordToSignedWord (DEST[95-64]);
DEST[63-48] ← SaturateSignedDwordToSignedWord (DEST[127-96]);
DEST[79-64] ← SaturateSignedDwordToSignedWord (SRC[31-0]);
DEST[95-80] ← SaturateSignedDwordToSignedWord (SRC[63-32]);
DEST[111-96] ← SaturateSignedDwordToSignedWord (SRC[95-64]);
DEST[127-112] ← SaturateSignedDwordToSignedWord (SRC[127-96]);
同等のインテルC/C++ コンパイラ組み込み関数
__m64 _mm_packs_pi16(__m64 m1, __m64 m2)
__m64 _mm_packs_pi32 (__m64 m1, __m64 m2)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
3-509
命令セット・リファレンス
PACKSSWB/PACKSSDW?Pack with Signed Saturation ( 続き)
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モード例外と同じ。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
3-510
命令セット・リファレンス
PACKUSWB?Pack with Unsigned Saturation
説明
デスティネーション・オペランド( 第1 オペランド) の4 個または8 個の符号付きワード整数とソー
ス・オペランド( 第2 オペランド) の4 個または8 個の符号付きワード整数を、8 個または16個の符号
なしバイト整数に変換し、デスティネーション・オペランドにその結果をストアする( パック操作の
例については、図3-5. を参照のこと)。 符号付きワード整数値が符号なしバイト整数の範囲を超える
場合( すなわち、FFH より大きいか、00H より小さい場合) は、飽和された符号なしバイト整数値で
あるFFHまたは00Hがデスティネーションにストアされる。
PACKUSWB 命令は、64 ビット・オペランドまたは128 ビット・オペランドのいずれかを操作する。
64 ビット・オペランドを操作する場合、デスティネーション・オペランドにはMMXテクノロジ・レ
ジスタを使用しなければならないが、ソース・オペランドにはMMX テクノロジ・レジスタまたは
64 ビット・メモリ・ロケーションのどちらを使用しても構わない。128 ビット・オペランドを操作す
る場合は、デスティネーション・オペランドにはXXMレジスタを使用しなければならないが、ソー
ス・オペランドにはXMMレジスタまたは128 ビット・メモリ・ロケーションのどちらを使用しても
構わない。
操作
PACKUSWB instruction with 64-bit operands:
DEST[7..0] ← SaturateSignedWordToUnsignedByte DEST[15..0];
DEST[15..8] ← SaturateSignedWordToUnsignedByte DEST[31..16];
DEST[23..16] ← SaturateSignedWordToUnsignedByte DEST[47..32];
DEST[31..24] ← SaturateSignedWordToUnsignedByte DEST[63..48];
DEST[39..32] ← SaturateSignedWordToUnsignedByte SRC[15..0];
DEST[47..40] ← SaturateSignedWordToUnsignedByte SRC[31..16];
DEST[55..48] ← SaturateSignedWordToUnsignedByte SRC[47..32];
DEST[63..56] ← SaturateSignedWordToUnsignedByte SRC[63..48];
PACKUSWB instruction with 128-bit operands:
DEST[7-0] ← SaturateSignedWordToUnsignedByte (DEST[15-0]);
DEST[15-8] ← SaturateSignedWordToUnsignedByte (DEST[31-16]);
DEST[23-16] ← SaturateSignedWordToUnsignedByte (DEST[47-32]);
DEST[31-24] ← SaturateSignedWordToUnsignedByte (DEST[63-48]);
DEST[39-32] ← SaturateSignedWordToUnsignedByte (DEST[79-64]);
DEST[47-40] ← SaturateSignedWordToUnsignedByte (DEST[95-80]);
DEST[55-48] ← SaturateSignedWordToUnsignedByte (DEST[111-96]);
DEST[63-56] ← SaturateSignedWordToUnsignedByte (DEST[127-112]);
オペコード命令説明
0F 67 /r PACKUSWB mm,
mm/m64
符号なし飽和処理を使用して、mm の4 個の符号付きワード整数と
mm/m64 の4 個の符号付きワード整数を、mm の8 個の符号なしバ
イト整数に変換する。
66 0F 67 /r PACKUSWB xmm1,
xmm2/m128
符号なし飽和処理を使用して、xmm1 の8 個の符号付きワード整数
とxmm2/m128 の8 個の符号付きワード整数を、xmm1 の16 個の
符号なしバイト整数に変換する。
3-511
命令セット・リファレンス
PACKUSWB?Pack with Unsigned Saturation ( 続き)
DEST[71-64] ← SaturateSignedWordToUnsignedByte (SRC[15-0]);
DEST[79-72] ← SaturateSignedWordToUnsignedByte (SRC[31-16]);
DEST[87-80] ← SaturateSignedWordToUnsignedByte (SRC[47-32]);
DEST[95-88] ← SaturateSignedWordToUnsignedByte (SRC[63-48]);
DEST[103-96] ← SaturateSignedWordToUnsignedByte (SRC[79-64]);
DEST[111-104] ← SaturateSignedWordToUnsignedByte (SRC[95-80]);
DEST[119-112] ← SaturateSignedWordToUnsignedByte (SRC[111-96]);
DEST[127-120] ← SaturateSignedWordToUnsignedByte (SRC[127-112]);
同等のインテルC/C++ コンパイラ組み込み関数
__m64 _mm_packs_pu16(__m64 m1, __m64 m2)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
3-512
命令セット・リファレンス
PACKUSWB?Pack with Unsigned Saturation ( 続き)
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
3-513
命令セット・リファレンス
PADDB/PADDW/PADDD?Add Packed Integers
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の
パックド整数のSIMD加算を実行し、結果のパックド整数をデスティネーション・オペランドに格納
する。SIMD 演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マ
ニュアル、上巻』の図9-4. を参照のこと。以降の段落で説明するように、オーバーフローはラップ
アラウンドを使用して処理される。
上記の命令は、64 ビット・オペランドまたは128 ビット・オペランドのいずれかを操作する。64 ビッ
ト・オペランドを操作する場合、デスティネーション・オペランドにはMMXテクノロジ・レジスタ
を使用しなければならないが、ソース・オペランドにはMMX テクノロジ・レジスタまたは64 ビッ
ト・メモリ・ロケーションのどちらを使用しても構わない。128 ビット・オペランドを操作する場合
は、デスティネーション・オペランドにはXXMレジスタを使用しなければならないが、ソース・オ
ペランドにはXMMレジスタまたは128 ビット・メモリ・ロケーションのどちらを使用しても構わな
い。
PADDB 命令は、パックド・バイト整数に加算する。個別の結果が8 ビットで表現するには大きすぎ
るとき( オーバーフロー)、結果はラップアラウンドされ、下位8 ビットがデスティネーション・オ
ペランドに書き込まれる。
PADDW 命令は、パックド・ワード整数に加算する。個別の結果が16 ビットで表現するには大きす
ぎるとき( オーバーフロー)、結果はラップアラウンドされ、下位16 ビットがデスティネーション・
オペランドに書き込まれる。
PADDD命令は、パックド・ダブルワード整数を加算する。個別の結果が32 ビットで表現するには大
きすぎるとき( オーバーフロー)、結果はラップアラウンドされ、下位32 ビットがデスティネーショ
ン・オペランドに書き込まれる。
PADDB、PADDW、およびPADDD命令は、符号なしまたは符号付き(2 の補数表記) のパックド整数
を操作できることに注意すること。ただし、これらの命令は、オーバーフローやキャリーを示す
EFLAGS レジスタ内のビットをセットしない。このため、検出されないオーバーフロー状態が発生
しないように、操作される値の範囲をソフトウェアによって制御しなければならない。
オペコード命令説明
0F FC /r PADDB mm, mm/m64 mm/m64 とmm のパックド・バイト整数を加算する。
66 0F FC /r PADDB xmm1, mm2/m128 xmm2/m128 とxmm1 のパックド・バイト整数を加算す
る。
0F FD /r PADDW mm, mm/m64 mm/m64 とmm のパックド・ワード整数を加算する。
66 0F FD /r PADDW xmm1, xmm2/m128 xmm2/m128 とxmm1 のパックド・ワード整数を加算す
る。
0F FE /r PADDD mm, mm/m64 mm/m64 とmm のパックド・ダブルワード整数を加算
する。
66 0F FE /r PADDD xmm1, xmm2/m128 xmm2/m128 とxmm1 のパックド・ダブルワード整数を
加算する。
3-514
命令セット・リファレンス
PADDB/PADDW/PADDD?Add Packed Integers ( 続き)
操作
PADDB instruction with 64-bit operands:
DEST[7..0] ← DEST[7..0] + SRC[7..0];
* repeat add operation for 2nd through 7th byte *;
DEST[63..56] ← DEST[63..56] + SRC[63..56];
PADDB instruction with 128-bit operands:
DEST[7-0] ← DEST[7-0] + SRC[7-0];
* repeat add operation for 2nd through 14th byte *;
DEST[127-120] ← DEST[111-120] + SRC[127-120];
PADDW instruction with 64-bit operands:
DEST[15..0] ← DEST[15..0] + SRC[15..0];
* repeat add operation for 2nd and 3th word *;
DEST[63..48] ← DEST[63..48] + SRC[63..48];
PADDW instruction with 128-bit operands:
DEST[15-0] ← DEST[15-0] + SRC[15-0];
* repeat add operation for 2nd through 7th word *;
DEST[127-112] ← DEST[127-112] + SRC[127-112];
PADDD instruction with 64-bit operands:
DEST[31..0] ← DEST[31..0] + SRC[31..0];
DEST[63..32] ← DEST[63..32] + SRC[63..32];
PADDD instruction with 128-bit operands:
DEST[31-0] ← DEST[31-0] + SRC[31-0];
* repeat add operation for 2nd and 3th doubleword *;
DEST[127-96] ← DEST[127-96] + SRC[127-96];
同等のインテルC/C++ コンパイラ組み込み関数
PADDB __m64 _mm_add_pi8(__m64 m1, __m64 m2)
PADDB __m128i_mm_add_epi8 (__m128ia,__m128ib )
PADDW __m64 _mm_addw_pi16(__m64 m1, __m64 m2)
PADDW __m128i _mm_add_epi16 ( __m128i a, __m128i b)
PADDD __m64 _mm_add_pi32(__m64 m1, __m64 m2)
PADDD __m128i _mm_add_epi32 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
3-515
命令セット・リファレンス
PADDB/PADDW/PADDD?Add Packed Integers ( 続き)
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
3-516
命令セット・リファレンス
PADDQ?Add Packed Quadword Integers
説明
第1 オペランド（デスティネーション・オペランド）と第2 オペランド（ソース・オペランド）を加
算して、結果をデスティネーション・オペランドに格納する。ソース・オペランドは、MMXテクノ
ロジ・レジスタまたは64 ビットのメモリ・ロケーションに格納される1 つのクワッドワード整数か、
XMMレジスタまたは128 ビットのメモリ・ロケーションに格納される2 つのパックド・クワッドワー
ド整数である。デスティネーション・オペランドは、MMXテクノロジ・レジスタに格納される1 つ
のクワッドワード整数か、XMMレジスタに格納される2 つのパックド・クワッドワード整数である。
パックド・クワッドワードのオペランドを使用する場合は、SIMD加算が実行される。結果のクワッ
ドワードが大きすぎて64ビットで表現できない場合は（オーバーフロー）、結果はラップアラウンド
され、下位64 ビットがデスティネーション要素に書き込まれる（すなわち、キャリーは無視される）。
PADDQ 命令は、符号なし整数と符号付き整数（2 の補数記法）のどちらを操作することもできる。
ただし、この命令は、オーバーフローやキャリーを示すEFLAGS レジスタ内のビットをセットしな
い。このため、検出されないオーバーフロー状態が発生しないように、操作される値の範囲をソフ
トウェアによって制御しなければならない。
操作
PADDQ instruction with 64-Bit operands:
DEST[63-0] ¨ DEST[63-0] + SRC[63-0];
PADDQ instruction with 128-Bit operands:
DEST[63-0] ¨ DEST[63-0] + SRC[63-0];
DEST[127-64] ¨ DEST[127-64] + SRC[127-64];
同等のインテルC/C++ コンパイラ組み込み関数
PADDQ __m64 _mm_add_si64 (__m64 a, __m64 b)
PADDQ __m128i _mm_add_epi64 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
オペコード命令説明
0F D4 /r PADDQ mm1,mm2/m64 mm2/m64 とmm1 のクワッドワード整数を加算し、結
果をmm1 に格納する。
66 0F D4 /r PADDQ xmm1,xmm2/m128 xmm2/m128 とxmm1 のパックド・クワッドワード整数
を加算し、結果をxmm1 に格納する。
3-517
命令セット・リファレンス
PADDQ?Add Packed Quadword Integers ( 続き)
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスが、CS、DS、ES、FS、またはGS
セグメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックが有効になっており、現
行特権レベルが3 のときにアライメントの合っていないメモリ参照を
行った場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックが有効になっており、ア
ライメントの合っていないメモリ参照を行った場合。
数値例外
なし。
3-518
命令セット・リファレンス
PADDSB/PADDSW?Add Packed Signed Integers with Signed
Saturation
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の
パックド符号付き整数のSIMD加算を実行し、結果のパックド整数をデスティネーション・オペラン
ドに格納する。SIMD演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』の図9-4. を参照のこと。以降の段落で説明するように、オーバーフローは
符号付き飽和処理を使用して処理される。
上記の命令は、64 ビット・オペランドまたは128 ビット・オペランドのいずれかを操作する。64 ビッ
ト・オペランドを操作する場合、デスティネーション・オペランドにはMMXテクノロジ・レジスタ
を使用しなければならないが、ソース・オペランドにはMMX テクノロジ・レジスタまたは64 ビッ
ト・メモリ・ロケーションのどちらを使用しても構わない。128 ビット・オペランドを操作する場合
は、デスティネーション・オペランドにはXXMレジスタを使用しなければならないが、ソース・オ
ペランドにはXMMレジスタまたは128 ビット・メモリ・ロケーションのどちらを使用しても構わな
い。
PADDSB 命令は、パックド符号付きバイト整数を加算する。個別のバイトの結果が符号付きバイト
整数の範囲を超える場合( すなわち、7FHより大きいかまたは80Hより小さい場合) は、それぞれ7FH
または80Hの飽和された値がデスティネーション・オペランドに書き込まれる。
PADDSW命令は、パックド符号付きワード整数を加算する。個別のワードの結果が符号付きワード
整数の範囲を超える場合( すなわち、7FFFHより大きいかまたは8000Hより小さい場合) は、それぞ
れ7FFFHまたは8000Hの飽和された値がデスティネーション・オペランドに書き込まれる。
操作
PADDSB instruction with 64-bit operands:
DEST[7..0] ← SaturateToSignedByte(DEST[7..0] + SRC (7..0]) ;
* repeat add operation for 2nd through 7th bytes *;
DEST[63..56] ← SaturateToSignedByte(DEST[63..56] + SRC[63..56] );
PADDSB instruction with 128-bit operands:
DEST[7-0] ← SaturateToSignedByte (DEST[7-0] + SRC[7-0]);
* repeat add operation for 2nd through 14th bytes *;
DEST[127-120] ← SaturateToSignedByte (DEST[111-120] + SRC[127-120]);
オペコード命令説明
0F EC /r PADDSB mm, mm/m64 mm/m64 とmm のパックド符号付きバイト整数を加
算し、結果を飽和処理する。
66 0F EC /r PADDSB xmm1, xmm2/m128 xmm2/m128 とxmm1 のパックド符号付きバイト整
数を加算し、結果を飽和処理する。
0F ED /r PADDSW mm, mm/m64 mm/m64 とmm のパックド符号付きワード整数を加
算し、結果を飽和処理する。
66 0F ED /r PADDSW xmm1, xmm2/m128 xmm2/m128 とxmm1 のパックド符号付きワード整
数を加算し、結果を飽和処理する。
3-519
命令セット・リファレンス
PADDSB/PADDSW?Add Packed Signed Integers with Signed
Saturation ( 続き)
PADDSW instruction with 64-bit operands
DEST[15..0] ← SaturateToSignedWord(DEST[15..0] + SRC[15..0] );
* repeat add operation for 2nd and 7th words *;
DEST[63..48] ← SaturateToSignedWord(DEST[63..48] + SRC[63..48] );
PADDSW instruction with 128-bit operands
DEST[15-0] ← SaturateToSignedWord (DEST[15-0] + SRC[15-0]);
* repeat add operation for 2nd through 7th words *;
DEST[127-112] ← SaturateToSignedWord (DEST[127-112] + SRC[127-112]);
同等のインテルC/C++ コンパイラ組み込み関数
PADDSB __m64 _mm_adds_pi8(__m64 m1, __m64 m2)
PADDSB __m128i _mm_adds_epi8 ( __m128i a, __m128i b)
PADDSW __m64 _mm_adds_pi16(__m64 m1, __m64 m2)
PADDSW __m128i _mm_adds_epi16 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
3-520
命令セット・リファレンス
PADDSB/PADDSW?Add Packed Signed Integers with Signed
Saturation ( 続き)
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
3-521
命令セット・リファレンス
PADDUSB/PADDUSW?Add Packed Unsigned Integers with Unsigned
Saturation
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の
パックド符号なし整数のSIMD加算を実行し、結果のパックド整数をデスティネーション・オペラン
ドに格納する。SIMD演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』の図9-4. を参照のこと。以降の段落で説明するように、オーバーフローは
符号なし飽和処理を使用して処理される。
上記の命令は、64 ビット・オペランドまたは128 ビット・オペランドのいずれかを操作する。64 ビッ
ト・オペランドを操作する場合、デスティネーション・オペランドにはMMXテクノロジ・レジスタ
を使用しなければならないが、ソース・オペランドにはMMX テクノロジ・レジスタまたは64 ビッ
ト・メモリ・ロケーションのどちらを使用しても構わない。128 ビット・オペランドを操作する場合
は、デスティネーション・オペランドにはXXMレジスタを使用しなければならないが、ソース・オ
ペランドにはXMMレジスタまたは128 ビット・メモリ・ロケーションのどちらを使用しても構わな
い。
PADDUSB命令は、パックド符号なしバイト整数を加算する。個別のバイトの結果が符号なしバイト
整数の範囲を超える場合( すなわち、FFHより大きい場合) は、FFHの飽和された符号なし値がデス
ティネーション・オペランドに書き込まれる。
PADDUSW 命令は、パックド符号なしワード整数を加算する。個別のワードの結果が符号なしワー
ド整数の範囲を超える場合( すなわち、FFFFHより大きい場合) は、FFFFHの飽和された符号なし値
がデスティネーション・オペランドに書き込まれる。
操作
PADDUSB instruction with 64-bit operands:
DEST[7..0] ← SaturateToUnsignedByte(DEST[7..0] + SRC (7..0] );
* repeat add operation for 2nd through 7th bytes *:
DEST[63..56] ← SaturateToUnsignedByte(DEST[63..56] + SRC[63..56]
PADDUSB instruction with 128-bit operands:
DEST[7-0] ← SaturateToUnsignedByte (DEST[7-0] + SRC[7-0]);
* repeat add operation for 2nd through 14th bytes *:
DEST[127-120] ← SaturateToUnSignedByte (DEST[127-120] + SRC[127-120]);
オペコード命令説明
0F DC /r PADDUSB mm, mm/m64 mm/m64 とmm のパックド符号なしバイト整数を加
算し、結果を飽和処理する。
66 0F DC /r PADDUSB xmm1, xmm2/m128 xmm2/m128 とxmm1 のパックド符号なしバイト整
数を加算し、結果を飽和処理する。
0F DD /r PADDUSW mm, mm/m64 mm/m64 とmm のパックド符号なしワード整数を加
算し、結果を飽和処理する。
66 0F DD /r PADDUSW xmm1, xmm2/m128 xmm2/m128 とxmm1 のパックド符号なしワード整
数を加算し、結果を飽和処理する。
3-522
命令セット・リファレンス
PADDUSB/PADDUSW?Add Packed Unsigned Integers with Unsigned
Saturation ( 続き)
PADDUSW instruction with 64-bit operands:
DEST[15..0] ← SaturateToUnsignedWord(DEST[15..0] + SRC[15..0] );
* repeat add operation for 2nd and 3rd words *:
DEST[63..48] ← SaturateToUnsignedWord(DEST[63..48] + SRC[63..48] );
PADDUSW instruction with 128-bit operands:
DEST[15-0] ← SaturateToUnsignedWord (DEST[15-0] + SRC[15-0]);
* repeat add operation for 2nd through 7th words *:
DEST[127-112] ← SaturateToUnSignedWord (DEST[127-112] + SRC[127-112]);
同等のインテルC/C++ コンパイラ組み込み関数
PADDUSB __m64 _mm_adds_pu8(__m64 m1, __m64 m2)
PADDUSW __m64 _mm_adds_pu16(__m64 m1, __m64 m2)
PADDUSB __m128i _mm_adds_epu8 ( __m128i a, __m128i b)
PADDUSW __m128i _mm_adds_epu16 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
3-523
命令セット・リファレンス
PADDUSB/PADDUSW?Add Packed Unsigned Integers with Unsigned
Saturation ( 続き)
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-524
命令セット・リファレンス
PAND?Logical AND
説明
ソース・オペランド( 第2 オペランド) とデスティネーション・オペランド( 第1 オペランド) との間
のビット単位のAND( 論理積) 演算を実行し、結果をデスティネーション・オペランドにストアする。
ソース・オペランドには、MMX テクノロジ・レジスタか64 ビット・メモリ・ロケーションを使用
でき、またはXMMレジスタか128 ビット・メモリ・ロケーションを使用できる。デスティネーショ
ン・オペランドは、MMXテクノロジ・レジスタまたはXMMレジスタでなければならない。各ビッ
トの結果は、第1 と第2 オペランドの対応するビットが両方とも1 である場合は1 にセットされ、そ
うでない場合はゼロにセットされる。
操作
DEST ← DEST AND SRC;
同等のインテルC/C++ コンパイラ組み込み関数
PAND __m64 _mm_and_si64 (__m64 m1, __m64 m2)
PAND __m128i _mm_and_si128 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
オペコード命令説明
0F DB /r PAND mm, mm/m64 mm/m64 とmm のビット単位のAND（論理積）演算を
実行する。
66 0F DB /r PAND xmm1, xmm2/m128 xmm2/m128 とxmm1 のビット単位のAND（論理積）
演算を実行する。
3-525
命令セット・リファレンス
PAND?Logical AND ( 続き)
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-526
命令セット・リファレンス
PANDN?Logical AND NOT
説明
デスティネーション・オペランド（第1 オペランド）のビット単位のNOT（否定）演算を実行した
後、反転されたデスティネーション・オペランドとソース・オペランド（第2 オペランド）の間で
ビット単位のAND（論理積）演算を実行する。結果はデスティネーション・オペランドに格納され
る。ソース・オペランドは、MMX テクノロジ・レジスタまたは64 ビットのメモリ・ロケーション
か、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・オペラ
ンドは、MMXテクノロジ・レジスタまたはXMMレジスタである。結果の各ビットは、第1 オペラ
ンド内の対応するビットが0 で第2 オペランド内の対応するビットが1 の場合は1 に設定され、それ
以外の場合は0 に設定される。
操作
DEST ← (NOT DEST) AND SRC;
同等のインテルC/C++ コンパイラ組み込み関数
PANDN __m64 _mm_andnot_si64 (__m64 m1, __m64 m2)
PANDN __m128i _mm_andnot_si128 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
オペコード命令説明
0F DF /r PANDN mm, mm/m64 mm/m64 とmm のビット単位のAND NOT（否定論理
積）演算を実行する。
66 0F DF /r PANDN xmm1, xmm2/m128 xmm2/m128 とxmm1 のビット単位のAND NOT（否定
論理積）演算を実行する。
3-527
命令セット・リファレンス
PANDN?Logical AND NOT ( 続き)
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-528
命令セット・リファレンス
PAUSE?Spin Loop Hint
説明
spin-wait ループのパフォーマンスを向上させる。「spin-wait ループ」を実行すると、Pentium 4 プロ
セッサは起こり得るメモリ順序違反を検出したとき、パフォーマンスの面で厳しい制限を受ける。
PAUSE 命令は、コード・シーケンスがspin-wait ループになっているプロセッサにヒントを提供する。
プロセッサはこのヒントを使用して、大抵の状況におけるメモリ順序違反を回避する。これにより、
プロセッサのパフォーマンスは大幅に向上する。こうした理由により、PAUSE 命令をすべてのspinwait
ループに配置することが推奨される。
PAUSE 命令は、spin ループの実行時にPentium 4 プロセッサの消費電力を低減させる追加機能を備え
ている。Pentium 4 プロセッサはspin-wait ループを極めて高速に実行できるため、リソースの待機中
に電力を大量に消費する。spin-wait ループにPAUSE 命令を挿入することで、プロセッサの消費電力
が大幅に低減される。
この命令はPentium 4 プロセッサで導入されたが、すべてのIA-32 プロセッサに対して互換性がある。
初期のIA-32 プロセッサにおいては、PAUSE 命令はNOP命令と同じような動作をする。
Pentium 4 プロセッサは、事前定義された待ち時間としてPAUSE 命令を実装している。この待ち時間
は有限であり、プロセッサによってはゼロである場合もある。この命令は、プロセッサのアーキテ
クチャ上の状態を変更することはない( つまり、この命令は、基本的には、ノー・オペレーションを
実行することで次の命令の実行を遅らせる)。
操作
Execute_Next_Instruction(DELAY);
保護モード例外
なし。
実アドレス・モード例外
なし。
仮想8086 モード例外
なし。
数値例外
なし。
オペコード命令説明
F3 90 PAUSE spin-wait ループのパフォーマンスを向上させるためのヒン
トをプロセッサに提供する。
3-529
命令セット・リファレンス
PAVGB/PAVGW?Average Packed Integers
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の
パックド符号なし整数のSIMD平均値計算を実行し、結果をデスティネーション・オペランドに格納
する。第1 オペランドと第2 オペランドの対応するデータ要素の各ペアについて、データ要素同士を
加算して、その和に1 を加算し、結果を1 ビット右にシフトする。ソース・オペランドは、MMXテ
クノロジ・レジスタまたは64 ビットのメモリ・ロケーションか、XMMレジスタまたは128 ビットの
メモリ・ロケーションである。デスティネーション・オペランドは、MMXテクノロジ・レジスタま
たはXMMレジスタである。
PAVGB 命令は、符号なしパックド・バイトを処理する。PAVGW 命令は、符号なしパックド・ワー
ドを処理する。
操作
PAVGB instruction with 64-bit operands:
SRC[7-0) ← (SRC[7-0) + DEST[7-0) + 1) >> 1; * temp sum before shifting is 9 bits *
* repeat operation performed for bytes 2 through 6;
SRC[63-56) ← (SRC[63-56) + DEST[63-56) + 1) >> 1;
PAVGW instruction with 64-bit operands:
SRC[15-0) ← (SRC[15-0) + DEST[15-0) + 1) >> 1; * temp sum before shifting is 17 bits *
* repeat operation performed for words 2 and 3;
SRC[63-48) ← (SRC[63-48) + DEST[63-48) + 1) >> 1;
PAVGB instruction with 128-bit operands:
SRC[7-0) ← (SRC[7-0) + DEST[7-0) + 1) >> 1; * temp sum before shifting is 9 bits *
* repeat operation performed for bytes 2 through 14;
SRC[63-56) ← (SRC[63-56) + DEST[63-56) + 1) >> 1;
PAVGW instruction with 128-bit operands:
SRC[15-0) ← (SRC[15-0) + DEST[15-0) + 1) >> 1; * temp sum before shifting is 17 bits *
* repeat operation performed for words 2 through 6;
SRC[127-48) ← (SRC[127-112) + DEST[127-112) + 1) >> 1;
オペコード命令説明
0F E0 /r PAVGB mm1, mm2/m64 丸めを使用して、mm2/m64 とmm1 のパックド符号な
しバイト整数の平均を求める。
66 0F E0, /r PAVGB xmm1, xmm2/m128 丸めを使用して、xmm2/m128 とxmm1 のパックド符号
なしバイト整数の平均を求める。
0F E3 /r PAVGW mm1, mm2/m64 丸めを使用して、mm2/m64 とmm1 のパックド符号な
しワード整数の平均を求める。
66 0F E3 /r PAVGW xmm1, xmm2/m128 丸めを使用して、xmm2/m128 とxmm1 のパックド符号
なしワード整数の平均を求める。
3-530
命令セット・リファレンス
PAVGB/PAVGW?Average Packed Integers ( 続き)
同等のインテルC/C++ コンパイラ組み込み関数
PAVGB __m64_mm_avg_pu8 (__m64 a, __m64 b)
PAVGW __m64_mm_avg_pu16 (__m64 a, __m64 b)
PAVGB __m128i _mm_avg_epu8 ( __m128i a, __m128i b)
PAVGW __m128i _mm_avg_epu16 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
3-531
命令セット・リファレンス
PAVGB/PAVGW?Average Packed Integers ( 続き)
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-532
命令セット・リファレンス
PCMPEQB/PCMPEQW/PCMPEQD?Compare Packed Data for Equal
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の
パックド・バイト/ ワード/ ダブルワードが等しいかどうかのSIMD比較を実行する。データ要素の
ペアが等しい場合は、デスティネーション・オペランドの対応するデータ要素はすべて1 に設定され
る。そうでない場合は、すべてゼロに設定される。ソース・オペランドは、MMXテクノロジ・レジ
スタまたは64 ビットのメモリ・ロケーション、XMM レジスタまたは128 ビットのメモリ・ロケー
ションを使用できる。デスティネーション・オペランドには、MMX テクノロジ・レジスタまたは
XMMレジスタを使用できる。
PCMPEQB命令は、デスティネーション・オペランドおよびソース・オペランドの対応するバイトを
比較する。PCMPEQW 命令は、デスティネーション・オペランドおよびソース・オペランドの対応
するワードを比較する。PCMPEQD 命令は、デスティネーション・オペランドおよびソース・オペ
ランドの対応するダブルワードを比較する。
操作
PCMPEQB instruction with 64-bit operands:
IF DEST[7..0] = SRC[7..0]
THEN DEST[7 0) ← FFH;
ELSE DEST[7..0] ← 0;
* Continue comparison of 2nd through 7th bytes in DEST and SRC *
IF DEST[63..56] = SRC[63..56]
THEN DEST[63..56] ← FFH;
ELSE DEST[63..56] ← 0;
PCMPEQB instruction with 128-bit operands:
IF DEST[7..0] = SRC[7..0]
THEN DEST[7 0) ← FFH;
ELSE DEST[7..0] ← 0;
* Continue comparison of 2nd through 15th bytes in DEST and SRC *
オペコード命令説明
0F 74 /r PCMPEQB mm, mm/m64 mm/m64 とmm のパックド・バイトを等しいか比
較する。
66 0F 74 /r PCMPEQB xmm1, xmm2/m128 xmm2/m128 とxmm1 のパックド・バイトを等し
いか比較する。
0F 75 /r PCMPEQW mm, mm/m64 mm/m64 とmm のパックド・ワードを等しいか比
較する。
66 0F 75 /r PCMPEQW xmm1, xmm2/m128 xmm2/m128 とxmm1 のパックド・ワードを等し
いか比較する。
0F 76 /r PCMPEQD mm, mm/m64 mm/m64 とmm のパックド・ダブルワードを等し
いか比較する。
66 0F 76 /r PCMPEQD xmm1, xmm2/m128 xmm2/m128 とxmm1 のパックド・ダブルワード
を等しいか比較する。
3-533
命令セット・リファレンス
PCMPEQB/PCMPEQW/PCMPEQD?Compare Packed Data for Equal
( 続き)
IF DEST[63..56] = SRC[63..56]
THEN DEST[63..56] ← FFH;
ELSE DEST[63..56] ← 0;
PCMPEQW instruction with 64-bit operands:
IF DEST[15..0] = SRC[15..0]
THEN DEST[15..0] ← FFFFH;
ELSE DEST[15..0] ← 0;
* Continue comparison of 2nd and 3rd words in DEST and SRC *
IF DEST[63..48] = SRC[63..48]
THEN DEST[63..48] ← FFFFH;
ELSE DEST[63..48] ← 0;
PCMPEQW instruction with 128-bit operands:
IF DEST[15..0] = SRC[15..0]
THEN DEST[15..0] ← FFFFH;
ELSE DEST[15..0] ← 0;
* Continue comparison of 2nd through 7th words in DEST and SRC *
IF DEST[63..48] = SRC[63..48]
THEN DEST[63..48] ← FFFFH;
ELSE DEST[63..48] ← 0;
PCMPEQD instruction with 64-bit operands:
IF DEST[31..0] = SRC[31..0]
THEN DEST[31..0] ← FFFFFFFFH;
ELSE DEST[31..0] ← 0;
IF DEST[63..32] = SRC[63..32]
THEN DEST[63..32] ← FFFFFFFFH;
ELSE DEST[63..32] ← 0;
PCMPEQD instruction with 128-bit operands:
IF DEST[31..0] = SRC[31..0]
THEN DEST[31..0] ← FFFFFFFFH;
ELSE DEST[31..0] ← 0;
* Continue comparison of 2nd and 3rd doublewords in DEST and SRC *
IF DEST[63..32] = SRC[63..32]
THEN DEST[63..32] ← FFFFFFFFH;
ELSE DEST[63..32] ← 0;
3-534
命令セット・リファレンス
PCMPEQB/PCMPEQW/PCMPEQD?Compare Packed Data for Equal
( 続き)
同等のインテルC/C++ コンパイラ組み込み関数
PCMPEQB __m64 _mm_cmpeq_pi8 (__m64 m1, __m64 m2)
PCMPEQW __m64 _mm_cmpeq_pi16 (__m64 m1, __m64 m2)
PCMPEQD __m64 _mm_cmpeq_pi32 (__m64 m1, __m64 m2)
PCMPEQB __m128i _mm_cmpeq_epi8 ( __m128i a, __m128i b)
PCMPEQW __m128i _mm_cmpeq_epi16 ( __m128i a, __m128i b)
PCMPEQD __m128i _mm_cmpeq_epi32 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のX87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
3-535
命令セット・リファレンス
PCMPEQB/PCMPEQW/PCMPEQD?Compare Packed Data for Equal
( 続き)
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のX87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-536
命令セット・リファレンス
PCMPGTB/PCMPGTW/PCMPGTD?Compare Packed Signed
Integers for Greater Than
説明
デスティネーション・オペランド（第1 オペランド）のパックド・バイト整数/ ワード整数/ ダブル
ワード整数の値が、ソース・オペランド（第2 オペランド）のパックド・バイト整数/ ワード整数/
ダブルワード整数の値より大きいかどうかのSIMD符号付き比較を実行する。デスティネーション・
オペランドのデータ要素がソース・オペランドの対応するデータ要素より大きい場合は、デスティ
ネーション・オペランドの対応するデータ要素はすべて1 に設定される。そうでない場合は、すべて
0 に設定される。ソース・オペランドは、MMXテクノロジ・レジスタまたは64 ビットのメモリ・ロ
ケーション、XMMレジスタまたは128 ビットのメモリ・ロケーションを使用できる。デスティネー
ション・オペランドには、MMXテクノロジ・レジスタまたはXMMレジスタを使用できる。
PCMPGTB命令は、デスティネーション・オペランドおよびソース・オペランドの対応する符号付き
バイト整数を比較する。PCMPGTW命令は、デスティネーション・オペランドおよびソース・オペ
ランドの対応する符号付きワード整数を比較する。PCMPGTD 命令は、デスティネーション・オペ
ランドおよびソース・オペランドの対応する符号付きダブルワード整数を比較する。
操作
PCMPGTB instruction with 64-bit operands:
IF DEST[7..0] > SRC[7..0]
THEN DEST[7 0) ← FFH;
ELSE DEST[7..0] ← 0;
* Continue comparison of 2nd through 7th bytes in DEST and SRC *
IF DEST[63..56] > SRC[63..56]
THEN DEST[63..56] ← FFH;
ELSE DEST[63..56] ← 0;
PCMPGTB instruction with 128-bit operands:
IF DEST[7..0] > SRC[7..0]
THEN DEST[7 0) ← FFH;
ELSE DEST[7..0] ← 0;
オペコード命令説明
0F 64 /r PCMPGTB mm, mm/m64 mm とmm/m64 のパックド符号付きバイト整数を、
「より大きい」の条件で比較する。
66 0F 64 /r PCMPGTB xmm1, xmm2/m128 xmm1 とxmm2/m128 のパックド符号付きバイト
整数を、「より大きい」の条件で比較する。
0F 65 /r PCMPGTW mm, mm/m64 mm とmm/m64 のパックド符号付きワード整数を、
「より大きい」の条件で比較する。
66 0F 65 /r PCMPGTW xmm1, xmm2/m128 xmm1 とxmm2/m128 のパックド符号付きワード
整数を、「より大きい」の条件で比較する。
0F 66 /r PCMPGTD mm, mm/m64 mm とmm/m64 のパックド符号付きダブルワード
整数を、「より大きい」の条件で比較する。
66 0F 66 /r PCMPGTD xmm1, xmm2/m128 xmm1 とxmm2/m128 のパックド符号付きダブル
ワード整数を、「より大きい」の条件で比較する。
3-537
命令セット・リファレンス
PCMPGTB/PCMPGTW/PCMPGTD?Compare Packed Signed Integers
for Greater Than ( 続き)
* Continue comparison of 2nd through 15th bytes in DEST and SRC *
IF DEST[63..56] > SRC[63..56]
THEN DEST[63..56] ← FFH;
ELSE DEST[63..56] ← 0;
PCMPGTW instruction with 64-bit operands:
IF DEST[15..0] > SRC[15..0]
THEN DEST[15..0] ← FFFFH;
ELSE DEST[15..0] ← 0;
* Continue comparison of 2nd and 3rd words in DEST and SRC *
IF DEST[63..48] > SRC[63..48]
THEN DEST[63..48] ← FFFFH;
ELSE DEST[63..48] ← 0;
PCMPGTW instruction with 128-bit operands:
IF DEST[15..0] > SRC[15..0]
THEN DEST[15..0] ← FFFFH;
ELSE DEST[15..0] ← 0;
* Continue comparison of 2nd through 7th words in DEST and SRC *
IF DEST[63..48] > SRC[63..48]
THEN DEST[63..48] ← FFFFH;
ELSE DEST[63..48] ← 0;
PCMPGTD instruction with 64-bit operands:
IF DEST[31..0] > SRC[31..0]
THEN DEST[31..0] ← FFFFFFFFH;
ELSE DEST[31..0] ← 0;
IF DEST[63..32] > SRC[63..32]
THEN DEST[63..32] ← FFFFFFFFH;
ELSE DEST[63..32] ← 0;
PCMPGTD instruction with 128-bit operands:
IF DEST[31..0] > SRC[31..0]
THEN DEST[31..0] ← FFFFFFFFH;
ELSE DEST[31..0] ← 0;
* Continue comparison of 2nd and 3rd doublewords in DEST and SRC *
IF DEST[63..32] > SRC[63..32]
THEN DEST[63..32] ← FFFFFFFFH;
ELSE DEST[63..32] ← 0;
3-538
命令セット・リファレンス
PCMPGTB/PCMPGTW/PCMPGTD?Compare Packed Signed Integers
for Greater Than ( 続き)
同等のインテルC/C++ コンパイラ組み込み関数
PCMPGTB __m64 _mm_cmpgt_pi8 (__m64 m1, __m64 m2)
PCMPGTW __m64 _mm_pcmpgt_pi16 (__m64 m1, __m64 m2)
DCMPGTD __m64 _mm_pcmpgt_pi32 (__m64 m1, __m64 m2)
PCMPGTB __m128i _mm_cmpgt_epi8 ( __m128i a, __m128i b)
PCMPGTW __m128i _mm_cmpgt_epi16 ( __m128i a, __m128i b)
DCMPGTD __m128i _mm_cmpgt_epi32 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
3-539
命令セット・リファレンス
PCMPGTB/PCMPGTW/PCMPGTD?Compare Packed Signed Integers
for Greater Than ( 続き)
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-540
命令セット・リファレンス
PEXTRW?Extract Word
説明
カウント・オペランド（第3 オペランド）で指定されたソース・オペランド（第2 オペランド）内の
ワードを、デスティネーション・オペランド（第1 オペランド）にコピーする。ソース・オペランド
は、MMXテクノロジ・レジスタまたはXMMレジスタである。デスティネーション・オペランドは
汎用レジスタの下位ワードである。カウント・オペランドは8 ビットの即値である。MMXテクノロ
ジ・レジスタにワード・ロケーションを指定する場合、カウント・オペランドの下位2 ビットによっ
てそのロケーションを指定する。XMMレジスタの場合は、下位4 ビットによってそのロケーション
を指定する。デスティネーション・オペランドの上位ワードはクリアされる( すべて0 に設定される)。
操作
PEXTRW instruction with 64-bit source operand:
SEL ← COUNT AND 3H;
TEMP ← (SRC >> (SEL ? 16)) AND FFFFH;
r32[15-0] ← TEMP[15-0];
r32[31-16] ← 0000H;
PEXTRW instruction with 128-bit source operand:
SEL ← COUNT AND 7H;
TEMP ← (SRC >> (SEL ? 16)) AND FFFFH;
r32[15-0] ← TEMP[15-0];
r32[31-16] ← 0000H;
同等のインテルC/C++ コンパイラ組み込み関数
PEXTRW int_mm_extract_pi16 (__m64 a, int n)
PEXTRW int _mm_extract_epi16 ( __m128i a, int imm)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
オペコード命令説明
0F C5 /r ib PEXTRW r32, mm, imm8 imm8 によって指定されたワードをmm から抽出し、
r32 に移動する。
66 0F C5 /r ib PEXTRW r32, xmm, imm8 imm8 によって指定されたワードをxmm から抽出し、
r32 に移動する。
3-541
命令セット・リファレンス
PEXTRW?Extract Word ( 続き)
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-542
命令セット・リファレンス
PINSRW?Insert Word
説明
ソース・オペランド（第2 オペランド）から1 ワードをコピーして、カウント・オペランド（第3 オ
ペランド）で指定されたデスティネーション・オペランド（第1 オペランド）内の位置に挿入する
（デスティネーション・レジスタのその他のワードは変更されない）。ソース・オペランドは、汎用
レジスタまたは16 ビットのメモリ・ロケーションである（ソース・オペランドが汎用レジスタの場
合は、レジスタの下位ワードがコピーされる）。デスティネーション・オペランドは、MMX テクノ
ロジ・レジスタまたはXMMレジスタである。カウント・オペランドは8 ビットの即値である。MMX
テクノロジ・レジスタにワード・ロケーションを指定する場合、カウント・オペランドの下位2 ビッ
トによってそのロケーションを指定する。XMM レジスタの場合は、下位4 ビットによってそのロ
ケーションを指定する。
操作
PINSRW instruction with 64-bit source operand:
SEL ← COUNT AND 3H;
CASE (determine word position) OF
SEL ← 0: MASK ← 000000000000FFFFH;
SEL ← 1: MASK ← 00000000FFFF0000H;
SEL ← 2: MASK ← 0000FFFF00000000H;
SEL ← 3: MASK ← FFFF000000000000H;
DEST ← (DEST AND NOT MASK) OR (((SRC << (SEL ? 16)) AND MASK);
PINSRW instruction with 128-bit source operand:
SEL ← COUNT AND 7H;
CASE (determine word position) OF
SEL ← 0: MASK ← 0000000000000000000000000000FFFFH;
SEL ← 1: MASK ← 000000000000000000000000FFFF0000H;
SEL ← 2: MASK ← 00000000000000000000FFFF00000000H;
SEL ← 3: MASK ← 0000000000000000FFFF000000000000H;
SEL ← 4: MASK ← 000000000000FFFF0000000000000000H;
SEL ← 5: MASK ← 00000000FFFF00000000000000000000H;
SEL ← 6: MASK ← 0000FFFF000000000000000000000000H;
SEL ← 7: MASK ← FFFF0000000000000000000000000000H;
DEST ← (DEST AND NOT MASK) OR (((SRC << (SEL ? 16)) AND MASK);
同等のインテルC/C++ コンパイラ組み込み関数
PINSRW __m64 _mm_insert_pi16 (__m64 a, int d, int n)
PINSRW __m128i _mm_insert_epi16 ( __m128i a, int b, int imm)
オペコード命令説明
0F C4 /r ib PINSRW mm, r32/m16, imm8 r32 またはm16 の下位ワードを、imm8 で指定され
たmm 内のワード位置に挿入する。
66 0F C4 /r ib PINSRW xmm, r32/m16, imm8 r32 またはm16 の下位ワードを、imm8 で指定され
たxmm 内のワード位置に移動する。
3-543
命令セット・リファレンス
PINSRW?Insert Word ( 続き)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
3-544
命令セット・リファレンス
PINSRW?Insert Word ( 続き)
数値例外
なし。
3-545
命令セット・リファレンス
PMADDWD?Multiply and Add Packed Integers
説明
デスティネーション・オペランド( 第1 オペランド) の個別のパックド符号付きワードにソース・オ
ペランド( 第2 オペランド) の対応する符号付きワードを掛け、仮の符号付きダブルワードの結果を
生成する。次に、得られた隣接するダブルワードを合計して、デスティネーション・オペランドに
格納する。例えば、ソース・オペランドとデスティネーション・オペランド内の対応する下位ワー
ド（15 〜 0）および（31 〜 16）同士がそれぞれ乗算されて、得られたダブルワードが加算され、デ
スティネーション・レジスタの下位ダブルワード（31 〜0）に格納される。その他の隣接するワード
についても、同じ操作が実行される（図3-6. は、64 ビット・オペランドを使用する場合の操作を示
している）。ソース・オペランドは、MMXテクノロジ・レジスタまたは64 ビットのメモリ・ロケー
ションか、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・
オペランドは、MMXテクノロジ・レジスタまたはXMMレジスタである。
PMADD命令は、1 つのグループ内の操作される2 対のワードがすべて8000Hである場合にのみ、ラッ
プアラウンドを使用する。この場合、結果は80000000Hにラップアラウンドされる。
オペコード命令説明
0F F5 /r PMADDWD mm, mm/m64 mm のパックド・ワードにmm/m64 のパックド・
ワードを掛ける。結果の隣接するダブルワードを
加算してmm にストアする。
66 0F F5 /r PMADDWD xmm1, xmm2/m128 xmm1 のパックド・ワード整数にxmm2/m128 の
パックド・ワード整数を掛けて、得られた隣接す
るダブルワードを加算してxmm1 にストアする。
図3-6. 64 ビット・オペランドを使用したPMADDWD 実行モデル
X3 X2 X1 X0
X3 ? Y3 X2 ? Y2 X1 ? Y1 X0 ? Y0
SRC
DEST
DEST
Y3 Y2 Y1 Y0
((X3?Y3) + X2?Y2) ((X1?Y1) + X0?Y0)
TEMP
3-546
命令セット・リファレンス
PMADDWD?Multiply and Add Packed Integers ( 続き)
操作
PMADDWD instruction with 64-bit operands:
DEST[31..0] ← (DEST[15..0] ? SRC[15..0]) + (DEST[31..16] ? SRC[31..16]);
DEST[63..32] ← (DEST[47..32] ? SRC[47..32]) + (DEST[63..48] ? SRC[63..48]);
PMADDWD instruction with 128-bit operands:
DEST[31..0] ← (DEST[15..0] ? SRC[15..0]) + (DEST[31..16] ? SRC[31..16]);
DEST[63..32] ← (DEST[47..32] ? SRC[47..32]) + (DEST[63..48] ? SRC[63..48]);
DEST[95..64) ← (DEST[79..64) ? SRC[79..64)) + (DEST[95..80) ? SRC[95..80));
DEST[127..96) ← (DEST[111..96) ? SRC[111..96)) + (DEST[127..112) ? SRC[127..112));
同等のインテルC/C++ コンパイラ組み込み関数
PMADDWD __m64 _mm_madd_pi16(__m64 m1, __m64 m2)
PMADDWD __m128i _mm_madd_epi16 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
3-547
命令セット・リファレンス
PMADDWD?Multiply and Add Packed Integers ( 続き)
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-548
命令セット・リファレンス
PMAXSW?Maximum of Packed Signed Word Integers
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の
パックド符号付きワード整数のSIMD 比較を実行し、それぞれのワード整数のペアの最大値をデス
ティネーション・オペランドに返す。ソース・オペランドは、MMXテクノロジ・レジスタまたは64
ビットのメモリ・ロケーションか、XMMレジスタまたは128 ビットのメモリ・ロケーションである。
デスティネーション・オペランドは、MMXテクノロジ・レジスタまたはXMMレジスタである。
操作
PMAXSW instruction for 64-bit operands:
IF DEST[15-0] > SRC[15-0]) THEN
(DEST[15-0] ← DEST[15-0];
ELSE
(DEST[15-0] ← SRC[15-0];
FI
* repeat operation for 2nd and 3rd words in source and destination operands *
IF DEST[63-48] > SRC[63-48]) THEN
(DEST[63-48] ← DEST[63-48];
ELSE
(DEST[63-48] ← SRC[63-48];
FI
PMAXSW instruction for 128-bit operands:
IF DEST[15-0] > SRC[15-0]) THEN
(DEST[15-0] ← DEST[15-0];
ELSE
(DEST[15-0] ← SRC[15-0];
FI
* repeat operation for 2nd through 7th words in source and destination operands *
IF DEST[127-112] > SRC[127-112]) THEN
(DEST[127-112] ← DEST[127-112];
ELSE
(DEST[127-112] ← SRC[127-112];
FI
同等のインテルC/C++ コンパイラ組み込み関数
PMAXSW __m64 _mm_max_pi16(__m64 a, __m64 b)
PMAXSW __m128i _mm_max_epi16 ( __m128i a, __m128i b)
オペコード命令説明
0F EE /r PMAXSW mm1, mm2/m64 mm2/m64 とmm1 の符号付きワード整数を比較して
最大値を返す。
66 0F EE /r PMAXSW xmm1, xmm2/m128 xmm2/m128 とxmm1 の符号付きワード整数を比較
して最大値を返す。
3-549
命令セット・リファレンス
PMAXSW?Maximum of Packed Signed Word Integers ( 続き)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
3-550
命令セット・リファレンス
PMAXSW?Maximum of Packed Signed Word Integers ( 続き)
数値例外
なし。
3-551
命令セット・リファレンス
PMAXUB?Maximum of Packed Unsigned Byte Integers
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の
パックド符号なしバイト整数のSIMD 比較を実行し、それぞれのバイト整数のペアの最大値をデス
ティネーション・オペランドに返す。ソース・オペランドは、MMXテクノロジ・レジスタまたは64
ビットのメモリ・ロケーションか、XMMレジスタまたは128 ビットのメモリ・ロケーションである。
デスティネーション・オペランドは、MMXテクノロジ・レジスタまたはXMMレジスタである。
操作
PMAXUB instruction for 64-bit operands:
IF DEST[7-0] > SRC[17-0]) THEN
(DEST[7-0] ← DEST[7-0];
ELSE
(DEST[7-0] ← SRC[7-0];
FI
* repeat operation for 2nd through 7th bytes in source and destination operands *
IF DEST[63-56] > SRC[63-56]) THEN
(DEST[63-56] ← DEST[63-56];
ELSE
(DEST[63-56] ← SRC[63-56];
FI
PMAXUB instruction for 128-bit operands:
IF DEST[7-0] > SRC[17-0]) THEN
(DEST[7-0] ← DEST[7-0];
ELSE
(DEST[7-0] ← SRC[7-0];
FI
* repeat operation for 2nd through 15th bytes in source and destination operands *
IF DEST[127-120] > SRC[127-120]) THEN
(DEST[127-120] ← DEST[127-120];
ELSE
(DEST[127-120] ← SRC[127-120];
FI
同等のインテルC/C++ コンパイラ組み込み関数
PMAXUB __m64 _mm_max_pu8(__m64 a, __m64 b)
PMAXUB __m128i _mm_max_epu8 ( __m128i a, __m128i b)
オペコード命令説明
0F DE /r PMAXUB mm1, mm2/m64 mm2/m64 とmm1 の符号なしバイト整数を比較して
最大値を返す。
66 0F DE /r PMAXUB xmm1, xmm2/m128 xmm2/m128 とxmm1 の符号なしバイト整数を比較
して最大値を返す。
3-552
命令セット・リファレンス
PMAXUB?Maximum of Packed Unsigned Byte Integers ( 続き)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
3-553
命令セット・リファレンス
PMAXUB?Maximum of Packed Unsigned Byte Integers ( 続き)
数値例外
なし。
3-554
命令セット・リファレンス
PMINSW?Minimum of Packed Signed Word Integers
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の
パックド符号付きワード整数のSIMD 比較を実行し、それぞれのワード整数のペアの最小値をデス
ティネーション・オペランドに返す。ソース・オペランドは、MMXテクノロジ・レジスタまたは64
ビットのメモリ・ロケーションか、XMMレジスタまたは128 ビットのメモリ・ロケーションである。
デスティネーション・オペランドは、MMXテクノロジ・レジスタまたはXMMレジスタである。
操作
PMINSW instruction for 64-bit operands:
IF DEST[15-0] < SRC[15-0]) THEN
(DEST[15-0] ← DEST[15-0];
ELSE
(DEST[15-0] ← SRC[15-0];
FI
* repeat operation for 2nd and 3rd words in source and destination operands *
IF DEST[63-48] < SRC[63-48]) THEN
(DEST[63-48] ← DEST[63-48];
ELSE
(DEST[63-48] ← SRC[63-48];
FI
MINSW instruction for 128-bit operands:
IF DEST[15-0] < SRC[15-0]) THEN
(DEST[15-0] ← DEST[15-0];
ELSE
(DEST[15-0] ← SRC[15-0];
FI
* repeat operation for 2nd through 7th words in source and destination operands *
IF DEST[127-112] < SRC/m64[127-112]) THEN
(DEST[127-112] ← DEST[127-112];
ELSE
(DEST[127-112] ← SRC[127-112];
FI
同等のインテルC/C++ コンパイラ組み込み関数
PMINSW __m64 _mm_min_pi16 (__m64 a, __m64 b)
PMINSW __m128i _mm_min_epi16 ( __m128i a, __m128i b)
オペコード命令説明
0F EA /r PMINSW mm1, mm2/m64 mm2/m64 とmm1 の符号付きワード整数を比較して
最小値を返す。
66 0F EA /r PMINSW xmm1, xmm2/m128 xmm2/m128 とxmm1 の符号付きワード整数を比較
して最小値を返す。
3-555
命令セット・リファレンス
PMINSW?Minimum of Packed Signed Word Integers ( 続き)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
3-556
命令セット・リファレンス
PMINSW?Minimum of Packed Signed Word Integers ( 続き)
数値例外
なし。
3-557
命令セット・リファレンス
PMINUB?Minimum of Packed Unsigned Byte Integers
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の
パックド符号なしバイト整数のSIMD 比較を実行し、それぞれのバイト整数のペアの最小値をデス
ティネーション・オペランドに返す。ソース・オペランドは、MMXテクノロジ・レジスタまたは64
ビットのメモリ・ロケーションか、XMMレジスタまたは128 ビットのメモリ・ロケーションである。
デスティネーション・オペランドは、MMXテクノロジ・レジスタまたはXMMレジスタである。
操作
PMINUB instruction for 64-bit operands:
IF DEST[7-0] < SRC[17-0]) THEN
(DEST[7-0] ← DEST[7-0];
ELSE
(DEST[7-0] ← SRC[7-0];
FI
* repeat operation for 2nd through 7th bytes in source and destination operands *
IF DEST[63-56] < SRC[63-56]) THEN
(DEST[63-56] ← DEST[63-56];
ELSE
(DEST[63-56] ← SRC[63-56];
FI
PMINUB instruction for 128-bit operands:
IF DEST[7-0] < SRC[17-0]) THEN
(DEST[7-0] ← DEST[7-0];
ELSE
(DEST[7-0] ← SRC[7-0];
FI
* repeat operation for 2nd through 15th bytes in source and destination operands *
IF DEST[127-120] < SRC[127-120]) THEN
(DEST[127-120] ← DEST[127-120];
ELSE
(DEST[127-120] ← SRC[127-120];
FI
同等のインテルC/C++ コンパイラ組み込み関数
PMINUB __m64 _m_min_pu8 (__m64 a, __m64 b)
PMINUB ___m128i _mm_min_epu8 ( __m128i a, __m128i b)
オペコード命令説明
0F DA /r PMINUB mm1, mm2/m64 mm2/m64 とmm1 の符号なしバイト整数を比較して
最小値を返す。
66 0F DA /r PMINUB xmm1, xmm2/m128 xmm2/m128 とxmm1 の符号なしバイト整数を比較
して最小値を返す。
3-558
命令セット・リファレンス
PMINUB?Minimum of Packed Unsigned Byte Integers ( 続き)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
3-559
命令セット・リファレンス
PMINUB?Minimum of Packed Unsigned Byte Integers ( 続き)
数値例外
なし。
3-560
命令セット・リファレンス
PMOVMSKB?Move Byte Mask
説明
ソース・オペランド（第2 オペランド）の各バイトの最上位ビットからマスクを作成し、結果をデス
ティネーション・オペランド（第1 オペランド）の最下位バイトまたは下位ワードに格納する。ソー
ス・オペランドは、MMXテクノロジ・レジスタまたはXMMレジスタである。デスティネーション・
オペランドは汎用レジスタである。64 ビットのオペランドを操作する場合、バイト・マスクは8 ビッ
トである。128 ビットのオペランドを操作する場合、バイト・マスクは16 ビットである。
操作
PMOVMSKB instruction with 64-bit source operand:
r32[0] ← SRC[7];
r32[1] ← SRC[15];
* repeat operation for bytes 2 through 6;
r32[7] ← SRC[63];
r32[31-8] ← 000000H;
PMOVMSKB instruction with 128-bit source operand:
r32[0] ← SRC[7];
r32[1] ← SRC[15];
* repeat operation for bytes 2 through 14;
r32[15] ← SRC[127];
r32[31-16] ← 0000H;
同等のインテルC/C++ コンパイラ組み込み関数
PMOVMSKB int_mm_movemask_pi8(__m64 a)
PMOVMSKB int _mm_movemask_epi8 ( __m128i a)
影響を受けるフラグ
なし。
保護モード例外
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
オペコード命令説明
0F D7 /r PMOVMSKB r32, mm mm のバイト・マスクをr32 に移動する。
66 0F D7 /r PMOVMSKB r32, xmm xmm のバイト・マスクをr32 に移動する。
3-561
命令セット・リファレンス
PMOVMSKB?Move Byte Mask ( 続き)
実アドレス・モード例外
保護モードと同じ例外。
仮想8086 モード例外
保護モードと同じ例外。
数値例外
なし。
3-562
命令セット・リファレンス
PMULHUW?Multiply Packed Unsigned Integers and Store High Result
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の
パックド符号なしワード整数のSIMD 符号なし乗算を実行し、それぞれの32 ビットの中間結果の上
位16 ビットをデスティネーション・オペランドに格納する（図3-7. は、64 ビット・オペランドを使
用する場合の操作を示している）。ソース・オペランドは、MMX テクノロジ・レジスタまたは64
ビットのメモリ・ロケーションか、XMMレジスタまたは128 ビットのメモリ・ロケーションである。
デスティネーション・オペランドは、MMXテクノロジ・レジスタまたはXMMレジスタである。
図3-7. 64 ビット・オペランドを使用したPMULHUW 命令およびPMULHW 命令の動作
操作
PMULHUW instruction with 64-bit operands:
TEMP0[31-0] ← DEST[15-0] * SRC[15-0]; * Unsigned multiplication *
TEMP1[31-0] ← DEST[31-16] ? SRC[31-16];
TEMP2[31-0] ← DEST[47-32] ? SRC[47-32];
TEMP3[31-0] ← DEST[63-48] ? SRC[63-48];
DEST[15-0] ← TEMP0[31-16];
DEST[31-16] ← TEMP1[31-16];
DEST[47-32] ← TEMP2[31-16];
DEST[63-48] ← TEMP3[31-16];
PMULHUW instruction with 128-bit operands:
TEMP0[31-0] ← DEST[15-0] ? SRC[15-0]; * Unsigned multiplication *
TEMP1[31-0] ← DEST[31-16] ? SRC[31-16];
オペコード命令説明
0F E4 /r PMULHUW mm1, mm2/m64 mm1 レジスタとmm2/m64 のパックド符号なし
ワード整数を乗算し、結果の上位16 ビットを
mm1 に格納する。
66 0F E4 /r PMULHUW xmm1, xmm2/m128 xmm1 とxmm2/m128 のパックド符号なしワード
整数を乗算し、結果の上位16 ビットをxmm1 に格
納する。
X3 X2 X1 X0
Z3 = X3 ? Y3 Z2 = X2 ? Y2 Z1 = X1 ? Y1 Z0 = X0 ? Y0
SRC
DEST
DEST
Y3 Y2 Y1 Y0
TEMP
Z3[31-16] Z2[31-16] Z1[31-16] Z0[31-16]
3-563
命令セット・リファレンス
PMULHUW?Multiply Packed Unsigned Integers and Store High Result
( 続き)
TEMP2[31-0] ← DEST[47-32] ? SRC[47-32];
TEMP3[31-0] ← DEST[63-48] ? SRC[63-48];
TEMP4[31-0] ← DEST[79-64] ? SRC[79-64];
TEMP5[31-0] ← DEST[95-80] ? SRC[95-80];
TEMP6[31-0] ← DEST[111-96] ? SRC[111-96];
TEMP7[31-0] ← DEST[127-112] ? SRC[127-112];
DEST[15-0] ← TEMP0[31-16];
DEST[31-16] ← TEMP1[31-16];
DEST[47-32] ← TEMP2[31-16];
DEST[63-48] ← TEMP3[31-16];
DEST[79-64] ← TEMP4[31-16];
DEST[95-80] ← TEMP5[31-16];
DEST[111-96] ← TEMP6[31-16];
DEST[127-112] ← TEMP7[31-16];
同等のインテルC/C++ コンパイラ組み込み関数
PMULHUW __m64 _mm_mulhi_pu16(__m64 a, __m64 b)
PMULHUW __m128i _mm_mulhi_epu16 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
3-564
命令セット・リファレンス
PMULHUW?Multiply Packed Unsigned Integers and Store High Result
( 続き)
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-565
命令セット・リファレンス
PMULHW?Multiply Packed Signed Integers and Store High Result
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の
パックド符号付きワード整数のSIMD 符号付き乗算を実行し、それぞれの32 ビットの中間結果の上
位16 ビットをデスティネーション・オペランドに格納する（図3-7. は、64 ビット・オペランドを使
用する場合の操作を示している）。ソース・オペランドは、MMX テクノロジ・レジスタまたは64
ビットのメモリ・ロケーションか、XMMレジスタまたは128 ビットのメモリ・ロケーションである。
デスティネーション・オペランドは、MMXテクノロジ・レジスタまたはXMMレジスタである。
操作
PMULHW instruction with 64-bit operands:
TEMP0[31-0] ← DEST[15-0] ? SRC[15-0]; * Signed multiplication *
TEMP1[31-0] ← DEST[31-16] ? SRC[31-16];
TEMP2[31-0] ← DEST[47-32] ? SRC[47-32];
TEMP3[31-0] ← DEST[63-48] ? SRC[63-48];
DEST[15-0] ← TEMP0[31-16];
DEST[31-16] ← TEMP1[31-16];
DEST[47-32] ← TEMP2[31-16];
DEST[63-48] ← TEMP3[31-16];
PMULHW instruction with 128-bit operands:
TEMP0[31-0] ← DEST[15-0] ? SRC[15-0]; * Signed multiplication *
TEMP1[31-0] ← DEST[31-16] ? SRC[31-16];
TEMP2[31-0] ← DEST[47-32] ? SRC[47-32];
TEMP3[31-0] ← DEST[63-48] ? SRC[63-48];
TEMP4[31-0] ← DEST[79-64] ? SRC[79-64];
TEMP5[31-0] ← DEST[95-80] ? SRC[95-80];
TEMP6[31-0] ← DEST[111-96] ? SRC[111-96];
TEMP7[31-0] ← DEST[127-112] ? SRC[127-112];
DEST[15-0] ← TEMP0[31-16];
DEST[31-16] ← TEMP1[31-16];
DEST[47-32] ← TEMP2[31-16];
DEST[63-48] ← TEMP3[31-16];
DEST[79-64] ← TEMP4[31-16];
DEST[95-80] ← TEMP5[31-16];
DEST[111-96] ← TEMP6[31-16];
DEST[127-112] ← TEMP7[31-16];
オペコード命令説明
0F E5 /r PMULHW mm, mm/m64 mm1 レジスタとmm2/m64 のパックド符号付きワード整
数を乗算し、結果の上位16 ビットをmm1 に格納する。
66 0F E5 /r PMULHW xmm1, xmm2/m128 xmm1 とxmm2/m128 のパックド符号付きワード整数を
乗算し、結果の上位16 ビットをxmm1 に格納する。
3-566
命令セット・リファレンス
PMULHW?Multiply Packed Signed Integers and Store High Result
( 続き)
同等のインテルC/C++ コンパイラ組み込み関数
PMULHW __m64 _mm_mulhi_pi16 (__m64 m1, __m64 m2)
PMULHW __m128i _mm_mulhi_epi16 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
3-567
命令セット・リファレンス
PMULHW?Multiply Packed Signed Integers and Store High Result
( 続き)
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-568
命令セット・リファレンス
PMULLW?Multiply Packed Signed Integers and Store Low Result
説明
デスティネーション・オペランド（第1 オペランド）とソース・オペランド（第2 オペランド）の
パックド符号付きワード整数のSIMD 符号付き乗算を実行し、それぞれの32 ビットの中間結果の下
位16 ビットをデスティネーション・オペランドに格納する（図3-7. は、64 ビット・オペランドを使
用する場合の操作を示している）。ソース・オペランドは、MMX テクノロジ・レジスタまたは64
ビットのメモリ・ロケーションか、XMMレジスタまたは128 ビットのメモリ・ロケーションである。
デスティネーション・オペランドは、MMXテクノロジ・レジスタまたはXMMレジスタである。
操作
PMULLW instruction with 64-bit operands:
TEMP0[31-0] ← DEST[15-0] ? SRC[15-0]; * Signed multiplication *
TEMP1[31-0] ← DEST[31-16] ? SRC[31-16];
TEMP2[31-0] ← DEST[47-32] ? SRC[47-32];
TEMP3[31-0] ← DEST[63-48] ? SRC[63-48];
DEST[15-0] ← TEMP0[15-0];
DEST[31-16] ← TEMP1[15-0];
DEST[47-32] ← TEMP2[15-0];
DEST[63-48] ← TEMP3[15-0];
PMULLW instruction with 64-bit operands:
TEMP0[31-0] ← DEST[15-0] ? SRC[15-0]; * Signed multiplication *
TEMP1[31-0] ← DEST[31-16] ? SRC[31-16];
TEMP2[31-0] ← DEST[47-32] ? SRC[47-32];
TEMP3[31-0] ← DEST[63-48] ? SRC[63-48];
オペコード命令説明
0F D5 /r PMULLW mm, mm/m64 mm1 レジスタとmm2/m64 のパックド符号付きワード整
数を乗算し、結果の下位16 ビットをmm1 に格納する。
66 0F D5 /r PMULLW xmm1, xmm2/m128 xmm1 とxmm2/m128 のパックド符号付きワード整数を
乗算し、結果の下位16 ビットをxmm1 に格納する。
図3-8. 64 ビット・オペランドを使用したPMULLW 命令の動作
X3 X2 X1 X0
Z3 = X3 ? Y3 Z2 = X2 ? Y2 Z1 = X1 ? Y1 Z0 = X0 ? Y0
SRC
DEST
DEST
Y3 Y2 Y1 Y0
TEMP
Z3[15-0] Z2[15-0] Z1[15-0] Z0[15-0]
3-569
命令セット・リファレンス
PMULLW?Multiply Packed Signed Integers and Store Low Result
( 続き)
TEMP4[31-0] ← DEST[79-64] ? SRC[79-64];
TEMP5[31-0] ← DEST[95-80] ? SRC[95-80];
TEMP6[31-0] ← DEST[111-96] ? SRC[111-96];
TEMP7[31-0] ← DEST[127-112] ? SRC[127-112];
DEST[15-0] ← TEMP0[15-0];
DEST[31-16] ← TEMP1[15-0];
DEST[47-32] ← TEMP2[15-0];
DEST[63-48] ← TEMP3[15-0];
DEST[79-64] ← TEMP4[15-0];
DEST[95-80] ← TEMP5[15-0];
DEST[111-96] ← TEMP6[15-0];
DEST[127-112] ← TEMP7[15-0];
同等のインテルC/C++ コンパイラ組み込み関数
PMULLW __m64 _mm_mullo_pi16(__m64 m1, __m64 m2)
PMULLW __m128i _mm_mullo_epi16 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
3-570
命令セット・リファレンス
PMULLW?Multiply Packed Signed Integers and Store Low Result
( 続き)
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-571
命令セット・リファレンス
PMULUDQ?Multiply Packed Unsigned Doubleword Integers
説明
第1 オペランド（デスティネーション・オペランド）に第2 オペランド（ソース・オペランド）を掛
けて、結果をデスティネーション・オペランドに格納する。ソース・オペランドは、MMXテクノロ
ジ・レジスタまたは64 ビットのメモリ・ロケーションの下位ダブルワードに格納される1 つの符号
なしダブルワード整数か、XMMレジスタまたは128ビットのメモリ・ロケーションの第1（最下位）
ダブルワードと第3 ダブルワードに格納される2 つのパックド符号なしダブルワード整数である。デ
スティネーション・オペランドは、MMXテクノロジ・レジスタの下位ダブルワードに格納される1
つの符号なしダブルワード整数か、XMMレジスタの第1 ダブルワードと第3 ダブルワードに格納さ
れる2 つのパックド・ダブルワード整数である。得られる結果は、デスティネーションであるMMX
テクノロジ・レジスタにストアされた符号なしクワッドワード整数か、XMMレジスタにストアされ
た2 つのパックド符号なしクワッドワード整数である。結果のクワッドワードが大きすぎて64 ビッ
トで表現できない場合は（オーバーフロー）、結果はラップアラウンドされ、下位64 ビットがデス
ティネーション要素に書き込まれる（すなわち、キャリーは無視される）。
64 ビット・メモリ・オペランドの場合は64 ビットがメモリからフェッチされるが、下位のダブル
ワードしか計算に使用されない。128 ビット・メモリ・オペランドの場合は128 ビットがメモリから
フェッチされるが、第1 および第3 のダブルワードしか計算に使用されない。
操作
PMULUDQ instruction with 64-Bit operands:
DEST[63-0] ← DEST[31-0] ? SRC[31-0];
PMULUDQ instruction with 128-Bit operands:
DEST[63-0] ← DEST[31-0] ? SRC[31-0];
DEST[127-64] ← DEST[95-64] ? SRC[95-64];
同等のインテルC/C++ コンパイラ組み込み関数
PMULUDQ __m64 _mm_mul_su32 (__m64 a, __m64 b)
PMULUDQ __m128i _mm_mul_epu32 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
オペコード命令説明
0F F4 /r PMULUDQ mm1, mm2/m64 mm1 の符号なしダブルワード整数にmm2/m64 の符
号なしダブルワード整数を掛けて、結果のクワッド
ワードをmm1 に格納する。
66 OF F4 /r PMULUDQ xmm1, xmm2/m128 xmm1 のパックド符号なしダブルワード整数に
xmm2/m128 のパックド符号なしダブルワード整数を
掛けて、結果のクワッドワードをxmm1 に格納する。
3-572
命令セット・リファレンス
PMULUDQ?Multiply Packed Unsigned Doubleword Integers ( 続き)
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスが、CS、DS、ES、FS、またはGS
セグメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックが有効になっており、現
行特権レベルが3 のときにアライメントの合っていないメモリ参照を
行った場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックが有効になっており、ア
ライメントの合っていないメモリ参照を行った場合。
3-573
命令セット・リファレンス
POP?Pop a Value from the Stack
説明
値をスタックのトップからデスティネーション・オペランドで指定されたロケーションにロードし、
スタック・ポインタをインクリメントする。デスティネーション・オペランドには、汎用レジスタ、
メモリ・ロケーション、またはセグメント・レジスタを使用できる。
スタック・セグメントのアドレス・サイズ属性によって、スタック・ポインタのサイズ(16 ビットま
たは32 ビット−ソース・アドレスのサイズ) が決まり、現在のコード・セグメントのオペランド・サ
イズ属性によって、スタック・ポインタをインクリメントする量(2 バイトまたは4 バイト) が決まる。
例えば、これらのアドレス・サイズ属性およびオペランド・サイズ属性が32 である場合は、32 ビッ
トのESPレジスタ( スタック・ポインタ) が4 インクリメントされ、それらの属性が16である場合は、
16ビットのSP レジスタが2 インクリメントされる。( スタック・セグメントのセグメント・ディスク
リプタのB フラグによって、スタックのアドレス・サイズ属性が決まり、現在のコード・セグメン
トのセグメント・ディスクリプタのD フラグ( プリフィックスをともなう) によって、オペランド・
サイズ属性およびデスティネーション・オペランドのアドレス・サイズ属性が決まる。)
デスティネーション・オペランドがセグメント・レジスタDS、ES、FS、GS、またはSS の1 つであ
る場合は、レジスタにロードされる値は、有効なセグメント・セレクタでなければならない。保護
モードでは、セグメント・セレクタをセグメント・レジスタにポップすると、そのセグメント・セ
レクタに関連するディスクリプタ情報がセグメント・レジスタの隠蔽( シャドー) 部分に自動的に
ロードされ、セレクタおよびディスクリプタの情報が有効にされる( 下記の「操作」の項を参照)。
一般保護フォルトを発生させずにヌル値(0000 〜0003) をDS、ES、FS、またはGSレジスタにポップ
することができる。ただし、対応するセグメント・レジスタにヌル値がロードされているセグメン
トをその後で参照しようとすると、一般保護例外(#GP) が発生する。この状況では、メモリ参照は行
われず、セグメント・レジスタのセーブされた値はヌルである。
オペコード命令説明
8F /0 POP m16 スタックのトップをm16 にポップし、スタック・ポインタをイン
クリメントする。
8F /0 POP m32 スタックのトップをm32 にポップし、スタック・ポインタをイン
クリメントする。
58+ rw POP r16 スタックのトップをr16 にポップし、スタック・ポインタをインク
リメントする。
58+ rd POP r32 スタックのトップをr32 にポップし、スタック・ポインタをインク
リメントする。
1F POP DS スタックのトップをDS にポップし、スタック・ポインタをインク
リメントする。
07 POP ES スタックのトップをES にポップし、スタック・ポインタをインク
リメントする。
17 POP SS スタックのトップをSS にポップし、スタック・ポインタをインク
リメントする。
0F A1 POP FS スタックのトップをFS にポップし、スタック・ポインタをインク
リメントする。
0F A9 POP GS スタックのトップをGS にポップし、スタック・ポインタをインク
リメントする。
3-574
命令セット・リファレンス
POP?Pop a Value from the Stack ( 続き)
POP 命令では、値をCS レジスタにポップすることはできない。スタックからCS レジスタにロード
するには、RET命令を使用する。
メモリ内のデスティネーション・オペランドのアドレスを指定するベース・レジスタとしてESP レ
ジスタを使用すると、POP 命令は、ESP レジスタをインクリメントした後にオペランドの実効アド
レスを計算する。16 ビット・スタックでPOP命令を実行した結果、ESP レジスタが0h にラップされ
た場合は、結果のメモリ書き込みの位置はプロセッサのファミリによって異なる。
POP ESP 命令は、スタックの古いトップにあるデータをデスティネーションに書き込む前に、スタッ
ク・ポインタ(ESP) をインクリメントする。
POP SS 命令は、次の命令の実行後まで、NMI割り込みを含めたすべての割り込みを禁止する。この
処置によって、POP SS 命令およびMOV ESP,EBP命令を逐次に実行しても、割り込みによってスタッ
クが無効になる危険はない1。ただし、SS レジスタおよびESP レジスタをロードする方法としては、
LSS 命令の使用が望ましい。
操作
IF StackAddrSize ← 32
THEN
IF OperandSize ← 32
THEN
DEST ← SS:ESP; (* copy a doubleword *)
ESP ← ESP + 4;
ELSE (* OperandSize ← 16*)
DEST ← SS:ESP; (* copy a word *)
ESP ← ESP + 2;
FI;
ELSE (* StackAddrSize ← 16* )
IF OperandSize ← 16
THEN
DEST ← SS:SP; (* copy a word *)
SP ← SP + 2;
ELSE (* OperandSize ← 32 *)
DEST ← SS:SP; (* copy a doubleword *)
SP ← SP + 4;
FI;
FI;
1. 以降の命令を過ぎて割り込みを個別にディレイさせる命令シーケンスでは、シーケンスの最初の命令は、割り
込みをディレイさせることが保証されるが、後続の割り込みディレイ命令は、割り込みをディレイさせない場
合があることに注意されたい。そのため、次の命令シーケンス
STI
POP SS
POP ESP
では、STI も1 命令の間割り込みをディレイさせるので、POP ESP が実行される前に、割り込みが認識され
ることがある。
3-575
命令セット・リファレンス
POP?Pop a Value from the Stack ( 続き)
保護モードの間にセグメント・レジスタをロードすると、以下のリストで説明しているように特殊
なチェックと処置が行われる。これらのチェックは、セグメント・セレクタとそれが指しているセ
グメント・ディスクリプタに対して行われる。
IF SS is loaded;
THEN
IF segment selector is null
THEN #GP(0);
FI;
IF segment selector index is outside descriptor table limits
OR segment selector's RPL ≠ CPL
OR segment is not a writable data segment
OR DPL ≠ CPL
THEN #GP(selector);
FI;
IF segment not marked present
THEN #SS(selector);
ELSE
SS ← segment selector;
SS ← segment descriptor;
FI;
FI;
IF DS, ES, FS, or GS is loaded with non-null selector;
THEN
IF segment selector index is outside descriptor table limits
OR segment is not a data or readable code segment
OR ((segment is a data or nonconforming code segment)
AND (both RPL and CPL > DPL))
THEN #GP(selector);
IF segment not marked present
THEN #NP(selector);
ELSE
SegmentRegister ← segment selector;
SegmentRegister ← segment descriptor;
FI;
FI;
IF DS, ES, FS, or GS is loaded with a null selector;
THEN
SegmentRegister ← segment selector;
SegmentRegister ← segment descriptor;
FI;
影響を受けるフラグ
なし。
3-576
命令セット・リファレンス
POP?Pop a Value from the Stack ( 続き)
保護モード例外
#GP(0) ヌル・セグメント・セレクタでSS レジスタをロードしようとした場合。
デスティネーション・オペランドが書き込み不可能なセグメントにある
場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#GP( セレクタ) セグメント・セレクタ・インデックスがディスクリプタ・テーブルの範
囲外の場合。
SS レジスタがロードされ、セグメント・セレクタのRPL およびセグメ
ント・ディスクリプタのDPL がCPL に等しくない場合。
SS レジスタがロードされ、指示先のセグメントが書き込み不可能なデー
タ・セグメントである場合。
DS、ES、FS、またはGS レジスタがロードされ、指示先のセグメントが
データ・セグメントまたは読み取り可能なコード・セグメントでない場
合。
DS、ES、FS、またはGS レジスタがロードされ、指示先のセグメントが
データ・セグメントまたは非コンフォーミング・コード・セグメントで
あるが、RPL およびCPL の両方ともDPL より大きい場合。
#SS(0) スタックの現在のトップがスタック・セグメント内にない場合。
メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#SS( セレクタ) SS レジスタがロードされ、指示先のセグメントが存在しないとマーク
されている場合。
#NP DS、ES、FS、またはGS レジスタがロードされ、指示先のセグメント
が存在しないとマークされている場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
3-577
命令セット・リファレンス
POP?Pop a Value from the Stack ( 続き)
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-578
命令セット・リファレンス
POPA/POPAD?Pop All General-Purpose Registers
説明
ダブルワード(POPAD) またはワード(POPA) をスタックから汎用レジスタにポップする。レジスタが
ロードされる順番は、( オペランド・サイズ属性が32 である場合は)EDI、ESI、EBP、EBX、EDX、
ECX、EAXであり、( オペランド・サイズ属性が16 である場合は)DI、SI、BP、BX、DX、CX、AX
である。これらの命令は、PUSHA/PUSHAD命令の逆の操作を実行する。 ESPレジスタまたはSP レジ
スタのスタック上の値は無視される。その代わりに、ESP レジスタまたはSP レジスタは、各レジス
タがロードされた後にインクリメントされる。
POPA( すべてをポップ) ニーモニックおよびPOPAD( すべてのダブルをポップ) ニーモニックは、同
じオペコードを参照する。POPA 命令は、オペランド・サイズ属性が16 であるときに使用するため
のものであり、POPAD命令は、オペランド・サイズ属性が32 であるときに使用するためのものであ
る。一部のアセンブラは、( 必要な場合にはオペランド・サイズ・オーバライド・プリフィックス
[66H] を使用して)POPAが使用されるときはオペランド・サイズを16 に、POPADが使用されるとき
は32 に強制する。他のアセンブラは、これらのニーモニックをシノニム(POPA/POPAD) として取り
扱い、オペランド・サイズ属性の現在の設定を使用して、使用されているニーモニックに関係なく、
スタックからポップする値のサイズを決定することができる。( 現在のコード・セグメントのセグメ
ント・ディスクリプタのDフラグによって、オペランド・サイズ属性が決まる。)
操作
IF OperandSize ← 32 (* instruction ← POPAD *)
THEN
EDI ← Pop();
ESI ← Pop();
EBP ← Pop();
increment ESP by 4 (* skip next 4 bytes of stack *)
EBX ← Pop();
EDX ← Pop();
ECX ← Pop();
EAX ← Pop();
ELSE (* OperandSize ← 16, instruction ← POPA *)
DI ← Pop();
SI ← Pop();
BP ← Pop();
increment ESP by 2 (* skip next 2 bytes of stack *)
BX ← Pop();
DX ← Pop();
CX ← Pop();
AX ← Pop();
FI;
オペコード命令説明
61 POPA DI、SI、BP、BX、DX、CX、およびAX をポップする。
61 POPAD EDI、ESI、EBP、EBX、EDX、ECX、およびEAX をポップする。
3-579
命令セット・リファレンス
POPA/POPAD?Pop All General-Purpose Registers ( 続き)
影響を受けるフラグ
なし。
保護モード例外
#SS(0) 開始スタック・アドレスまたは終了スタック・アドレスがスタック・セ
グメント内にない場合
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#SS 開始スタック・アドレスまたは終了スタック・アドレスがスタック・セ
グメント内にない場合。
仮想8086 モード例外
#SS(0) 開始スタック・アドレスまたは終了スタック・アドレスがスタック・セ
グメント内にない場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-580
命令セット・リファレンス
POPF/POPFD?Pop Stack into EFLAGS Register
説明
( 現在のオペランド・サイズ属性が32 である場合は) ダブルワード(POPFD) をスタックのトップから
ポップして、値をEFLAGS レジスタにストアする。( オペランド・サイズ属性が16 である場合は)
ワードをスタックのトップからポップして、値をEFLAGSレジスタの下位16ビット(すなわち、FLAGS
レジスタ) にストアする。これらの命令は、PUSHF/PUSHFD命令の逆の操作を実行する。
POPF( フラグをポップ) ニーモニックおよびPOPFD( フラグ・ダブルをポップ) ニーモニックは、同
じオペコードを参照する。POPF 命令は、オペランド・サイズ属性が16 であるときに使用するための
ものであり、POPFD命令は、オペランド・サイズ属性が32 であるときに使用するためのものである。
一部のアセンブラは、POPF が使用されるときはオペランド・サイズを16 に、POPFD が使用される
ときは32 に強制する。他のアセンブラは、これらのニーモニックをシノニム(POPF/POPFD) として
取り扱い、オペランド・サイズ属性の現在の設定を使用して、使用されているニーモニックに関係
なく、スタックからポップする値のサイズを決定することができる。
EFLAGSレジスタへのPOPF/POPFD命令の影響は、プロセッサの動作モードに応じて少し変わる。プ
ロセッサが特権レベル0 の保護モード( または特権レベル0 に同等である実アドレス・モード) で動
作しているときは、VIP、VIF、およびVMフラグを除くEFLAGS レジスタのすべての非予約フラグ
は修正される可能性がある。VIPおよびVIF フラグはクリアされ、VMフラグは影響を受けない。
特権レベルが0 より大きいけれどもIOPL以下である保護モードで動作しているときは、IOPL フィー
ルドとVIP、VIF、およびVMフラグを除くすべてのフラグは修正される可能性がある。この場合も、
IOPL のフラグは影響を受けず、VIP およびVIF フラグはクリアされ、VMフラグは影響を受けない。
割り込みフラグ(IF) は、IOPL と少なくとも同じ特権レベルで動作しているときだけに変更される。
POPF/POPFD 命令が不十分な特権で実行されていても、例外は発生しないが、特権ビットは変わら
ない。
仮想8086 モードで動作しているときは、I/O 特権レベル(IOPL) は、POPF/POPFD 命令を使用するに
は3 に等しくなければならず、VM、RF、IOPL、VIP、およびVIFフラグは影響を受けない。IOPLが
3 より小さい場合、POPF/POPFD命令は一般保護例外(#GP) を発生させる。
EFLAGS レジスタの詳細については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッ
パーズ・マニュアル、上巻』第3 章の「EFLAGSレジスタ」を参照のこと。
オペコード命令説明
9D POPF スタックのトップをEFLAGS の下位16 ビットにポップする。
9D POPFD スタックのトップをEFLAGS にポップする。
3-581
命令セット・リファレンス
POPF/POPFD?Pop Stack into EFLAGS Register ( 続き)
操作
IF VM=0 (* Not in Virtual-8086 Mode *)
THEN IF CPL=0
THEN
IF OperandSize ← 32;
THEN
EFLAGS ← Pop();
(* All non-reserved flags except VIP, VIF, and VM can be modified; *)
(* VIP and VIF are cleared; VM is unaffected*)
ELSE (* OperandSize ← 16 *)
EFLAGS[15:0] ← Pop(); (* All non-reserved flags can be modified; *)
FI;
ELSE (* CPL > 0 *)
IF OperandSize ← 32;
THEN
EFLAGS ← Pop()
(* All non-reserved bits except IOPL, VIP, and VIF can be modified; *)
(* IOPL is unaffected; VIP and VIF are cleared; VM is unaffected *)
ELSE (* OperandSize ← 16 *)
EFLAGS[15:0] ← Pop();
(* All non-reserved bits except IOPL can be modified *)
(* IOPL is unaffected *)
FI;
FI;
ELSE (* In Virtual-8086 Mode *)
IF IOPL=3
THEN IF OperandSize=32
THEN
EFLAGS ← Pop()
(* All non-reserved bits except VM, RF, IOPL, VIP, and VIF *)
(* can be modified; VM, RF, IOPL, VIP, and VIF are unaffected *)
ELSE
EFLAGS[15:0] ← Pop()
(* All non-reserved bits except IOPL can be modified *)
(* IOPL is unaffected *)
FI;
ELSE (* IOPL < 3 *)
#GP(0); (* trap to virtual-8086 monitor *)
FI;
FI;
FI;
3-582
命令セット・リファレンス
POPF/POPFD?Pop Stack into EFLAGS Register ( 続き)
影響を受けるフラグ
予約ビットとVMビットを除くすべてのフラグ。
保護モード例外
#SS(0) スタックのトップがスタック・セグメント内にない場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#SS スタックのトップがスタック・セグメント内にない場合。
仮想8086 モード例外
#GP(0) I/O 特権レベルが3 より小さい場合。
オペランド・サイズ・オーバライド・プリフィックスの付いた
POPF/POPFD 命令を実行しようとした場合。
#SS(0) スタックのトップがスタック・セグメント内にない場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-583
命令セット・リファレンス
POR?Bitwise Logical OR
説明
クワッドワードのソース・オペランド( 第2 オペランド) とデスティネーション・オペランド( 第1 オ
ペランド) との間のビット単位のOR( 論理和) 演算を実行し、結果をデスティネーション・オペラン
ドにストアする。ソース・オペランドには、MMXテクノロジ・レジスタまたは64 ビットのメモリ・
ロケーション、XMM レジスタまたは128 ビットのメモリ・ロケーションを使用できる。デスティ
ネーション・オペランドは、MMXテクノロジ・レジスタまたはXMMレジスタでなければならない。
結果の各ビットは、第1 オペランドと第2 オペランドの対応するビットのうちいずれか一方または両
方が1 の場合は1 に設定され、それ以外の場合は0 に設定される。
操作
DEST ← DEST OR SRC;
同等のインテルC/C++ コンパイラ組み込み関数
POR __m64 _mm_or_si64(__m64 m1, __m64 m2)
POR __m128i _mm_or_si128(__m128i m1, __m128i m2)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
オペコード命令説明
0F EB /r POR mm, mm/m64 mm/m64 とmm のビット単位のOR（論理和）演算を実行す
る。
66 0F EB /r POR xmm1, xmm2/m128 xmm2/m128 とxmm1 のビット単位のOR（論理和）演算を
実行する。
3-584
命令セット・リファレンス
POR?Bitwise Logical OR ( 続き)
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-585
命令セット・リファレンス
PREFETCHh?Prefetch Data Into Caches
説明
ソース・オペランドで指定されたバイトを含むメモリから、ローカリティのヒントで指定された
キャッシュ階層内の位置にデータのラインをフェッチする。
? T0 テンポラル・データ - すべてのキャッシュ・レベルにデータをプリフェッチする。
? T1 第1 キャッシュ・レベル以上についてテンポラル・データ - 第0 キャッシュ・レベル以外の
すべてのキャッシュ・レベルにデータをプリフェッチする。
? T2 第2 キャッシュ・レベル以上についてテンポラル・データ - 第0 および第1 キャッシュ・レ
ベル以外のすべてのキャッシュ・レベルにデータをプリフェッチする。
? NTA すべてのキャッシュ・レベルについて非テンポラル・データ - 非テンポラルなキャッシュ
構造にデータをプリフェッチする（このヒントを使用して、キャッシュの汚染を最小限に抑え
ることができる）。
ソース・オペランドは、1 バイトのメモリ・ロケーションである（ローカリティのヒントは、ModR/M
バイトのビット3 〜5 を使用して、マシン・レベルの命令にエンコーディングされる。上記の値以外
のModR/M値を指定すると、予測不可能な動作が発生する）。
選択されたラインが、指定されたレベルよりプロセッサに近いキャッシュ階層レベルに既に存在す
る場合は、データの転送は行われない。キャッシュ不可メモリまたはWCメモリに対するプリフェッ
チ命令は無視される。
PREFETCHh 命令は単なるヒントであり、プログラムの動作には影響を与えない。この命令は、実行
された場合、これから使用されることが予想されるデータを、プロセッサの近くに移動する。
プリフェッチのローカリティ・ヒントの影響はプロセッサによって異なり、オーバーロードされた
り、無視されたりする可能性がある。プリフェッチされるデータのサイズもプロセッサによって異
なるが、最小でも32 バイトのデータがプリフェッチされる。
プロセッサは、見込み的な読み込みが許されるメモリ・タイプ（すなわち、WB、WC、およびWT
メモリ・タイプ）が割り当てられたシステム・メモリ領域から、いつでもデータを見込み的にフェッ
チしてキャッシュに入れることができる。PREFETCHh 命令は、この見込み的な動作に対するヒント
と見なされる。この見込み的なフェッチ動作は、命令の実行には拘束されず、任意の時点で発生す
る。したがって、PREFETCHh 命令は、フェンス命令（MFENCE、SFENCE、LFENCE）やロックさ
れたメモリ参照に対して順序付けされない。また、PREFETCHh 命令は、CLFLUSH 命令、他の
PREFETCHh 命令、あるいは他の汎用命令に対しても順序付けされない。ただし、PREFETCHh 命令
は、CPUID、WRMSR、OUT、MOV CRなどのシリアル化命令に対しては順序付けされる。
オペコード命令説明
0F 18 /1 PREFETCHT0 m8 T0 ヒントを使用して、m8 のデータをプロセッサの近くに
移動する。
0F 18 /2 PREFETCHT1 m8 T1 ヒントを使用して、m8 のデータをプロセッサの近くに
移動する。
0F 18 /3 PREFETCHT2 m8 T2 ヒントを使用して、m8 のデータをプロセッサの近くに
移動する。
0F 18 /0 PREFETCHNTA m8 NTA ヒントを使用して、m8 のデータをプロセッサの近く
に移動する。
3-586
命令セット・リファレンス
PREFETCHh?Prefetch Data Into Caches ( 続き)
操作
FETCH (m8);
同等のインテルC/C++ コンパイラ組み込み関数
void _mm_prefetch(char *p, int i)
引数"*p" は、プリフェッチされるバイト（および対応するキャッシュ・ライン）のアドレスを示す。
値"i" は、実行されるプリフェッチ操作のタイプを指定する定数（_MM_HINT_T0、_MM_HINT_T1、
_MM_HINT_T2、または_MM_HINT_NTA）を示す。
数値例外
なし。
保護モード例外
なし。
実アドレス・モード例外
なし。
仮想8086 モード例外
なし。
3-587
命令セット・リファレンス
PSADBW?Compute Sum of Absolute Differences
説明
ソース・オペランド（第1 オペランド）の8 つの符号なしバイト整数とデスティネーション・オペラ
ンド（第2 オペランド）の8 つの符号なしバイト整数の差の絶対値を計算する。次に、得られた8 つ
の差を合計して1 つの符号なしワード整数を求め、結果をデスティネーション・オペランドに格納す
る。ソース・オペランドは、MMX テクノロジ・レジスタまたは64 ビットのメモリ・ロケーション
か、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・オペラ
ンドは、MMXテクノロジ・レジスタまたはXMMレジスタである。図3-9. は、64 ビット・オペラン
ドを使用する場合のPSADBW命令の操作を示している。
64 ビット・オペランドを操作する場合は、結果のワード整数はデスティネーション・オペランドの
下位ワードに格納され、デスティネーション・オペランドのその他のバイトはすべて0 にクリアされ
る。
128 ビット・オペランドを操作する場合は、2 つの結果が計算され、パックされる。この場合は、ソー
ス・オペランドとデスティネーション・オペランドの下位の8 バイトを操作して1 ワードの結果を求
め、デスティネーション・オペランドの最下位ワードに格納する。また、上位の8 バイトを操作して
1 ワードの結果を求め、デスティネーション・オペランドのビット64 〜79 に格納する。デスティネー
ション・オペランドのその他のバイトはすべて0 にクリアされる。
図3-9. 64 ビット・オペランドを使用したPSADBW 命令の操作
オペコード命令説明
0F F6 /r PSADBW mm1, mm2/m64 mm2/m64 とmm1 の符号なしパックド・バイト整数
の差の絶対値を計算し、得られた差を合計して1 符
号なしワードの結果を返す。
66 0F F6 /r PSADBW xmm1, xmm2/m128 xmm2/m128 とxmm1 のパックド符号なしバイト整
数の差の絶対値を計算し、下位の8 つの差と上位の
8 つの差を別々に合計して2 つのワード整数の結果
を返す。
SRC X3 X2 X1 X0
DEST
TEMP
X7 X6 X5 X4
Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
ABS(X7-Y7) ABS(X6-Y6) ABS(X5-Y5) ABS(X4-Y4) ABS(X3-Y3) ABS(X2-Y2) ABS(X1-Y1) ABS(X0-Y0)
DEST 00H 00H 00H 00H 00H 00H SUM(TEMP7...TEMP0)
3-588
命令セット・リファレンス
PSADBW?Compute Sum of Absolute Differences ( 続き)
操作
PSADBW instructions when using 64-bit operands:
TEMP0 ← ABS(DEST[7-0] ? SRC[7-0]);
* repeat operation for bytes 2 through 6 *;
TEMP7 ← ABS(DEST[63-56] ? SRC[63-56]);
DEST[15:0] ← SUM(TEMP0...TEMP7);
DEST[63:16] ← 000000000000H;
PSADBW instructions when using 128-bit operands:
TEMP0 ← ABS(DEST[7-0] ? SRC[7-0]);
* repeat operation for bytes 2 through 14 *;
TEMP15 ← ABS(DEST[127-120] ? SRC[127-120]);
DEST[15-0] ← SUM(TEMP0...TEMP7);
DEST[63-6] ← 000000000000H;
DEST[79-64] ← SUM(TEMP8...TEMP15);
DEST[127-80] ← 000000000000H;
同等のインテルC/C++ コンパイラ組み込み関数
PSADBW __m64_mm_sad_pu8(__m64 a,__m64 b)
PSADBW __m128i _mm_sad_epu8(__m128i a, __m128i b)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
3-589
命令セット・リファレンス
PSADBW?Compute Sum of Absolute Differences ( 続き)
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-590
命令セット・リファレンス
PSHUFD?Shuffle Packed Doublewords
説明
ソース・オペランド（第2 オペランド）からダブルワードをコピーして、オーダー・オペランド（第
3 オペランド）で選択されたデスティネーション・オペランド（第1 オペランド）内の位置に挿入す
る。図3-10. は、PSHUFD 命令の操作と、オーダー・オペランドのエンコーディングを示している。
オーダー・オペランドのそれぞれの2 ビット・フィールドは、デスティネーション・オペランドの1
つのダブルワード位置の内容を指定する。例えば、オーダー・オペランドのビット0 とビット1 は、
デスティネーション・オペランドのダブルワード0 の内容を選択する。オーダー・オペランドのビッ
ト0 とビット1 のエンコーディング（図3-10. の各フィールドのエンコーディングを参照）によって、
ソース・オペランドのどのダブルワードがデスティネーション・オペランドのダブルワード0 にコ
ピーされるかが決まる。
ソース・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティ
ネーション・オペランドはXMMレジスタである。オーダー・オペランドは8 ビットの即値である。
この命令は、ソース・オペランドのダブルワードを、デスティネーション・オペランドの2 つ以上の
ダブルワード位置にコピーすることができる。
操作
DEST[31-0] ← (SRC >> (ORDER[1-0] ? 32) )[31-0]
DEST[63-32] ← (SRC >> (ORDER[3-2] ? 32) )[31-0]
DEST[95-64] ← (SRC >> (ORDER[5-4] ? 32) )[31-0]
DEST[127-96] ← (SRC >> (ORDER[7-6] ? 32) )[31-0]
オペコード命令説明
66 0F 70 /r ib PSHUFD xmm1,
xmm2/m128, imm8
imm8 のエンコーディングに基づいて、xmm2/m128 のダブ
ルワードをシャッフルし、結果をxmm1 に格納する。
図3-10. PSHUFD 命令の操作
SRC X3 X2 X1 X0
DEST Y3 Y2 Y1 Y0
ORDER
00B - X0
01B - X1
10B - X2
11B - X3
オーダー・
7 6 5 4 3 2 1 0
オペランドの
各フィールドの
エンコーディング
3-591
命令セット・リファレンス
PSHUFD?Shuffle Packed Doublewords ( 続き)
同等のインテルC/C++ コンパイラ組み込み関数
PSHUFD __m128i _mm_shuffle_epi32(__m128i a, int n)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスが、CS、DS、ES、FS、またはGS
セグメントの範囲外の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
数値例外
なし。
3-592
命令セット・リファレンス
PSHUFHW?Shuffle Packed High Words
説明
ソース・オペランド（第2 オペランド）の上位クワッドワードからワードをコピーして、オーダー・
オペランド（第3 オペランド）で選択された、デスティネーション・オペランド（第1 オペランド）
の上位クワッドワード内のワード位置に挿入する。この操作は、図3-10. に示したPSHUFD命令の操
作とよく似ている。PSHUFHW命令では、オーダー・オペランドのそれぞれの2 ビット・フィールド
は、デスティネーション・オペランドの上位クワッドワード内の1 つのワード位置の内容を指定す
る。オーダー・オペランドの各フィールドの2 進エンコーディングによって、ソース・オペランドの
上位クワッドワードからデスティネーション・オペランドにコピーされるワード（0、1、2、または
3、4）が選択される。
ソース・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティ
ネーション・オペランドはXMMレジスタである。オーダー・オペランドは8 ビットの即値である。
この命令は、ソース・オペランドのワードを、デスティネーション・オペランドの2 つ以上のワード
位置にコピーすることができる。
操作
DEST[79-64] ← (SRC >> (ORDER[1-0] ? 16) )[79-64]
DEST[95-80] ← (SRC >> (ORDER[3-2] ? 16) )[79-64]
DEST[111-96] ← (SRC >> (ORDER[5-4] ? 16) )[79-64]
DEST[127-112] ← (SRC >> (ORDER[7-6] ? 16) )[79-64]
同等のインテルC/C++ コンパイラ組み込み関数
PSHUFHW __m128i _mm_shufflehi_epi16(__m128i a, int n)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスが、CS、DS、ES、FS、またはGS
セグメントの範囲外の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
F3 0F 70 /r ib PSHUFHW xmm1,
xmm2/m128, imm8
imm8 のエンコーディングに基づいて、xmm2/m128 の上位
ワードをシャッフルし、結果をxmm1 に格納する。
3-593
命令セット・リファレンス
PSHUFHW?Shuffle Packed High Words ( 続き)
#NM CR0 のTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
数値例外
なし。
3-594
命令セット・リファレンス
PSHUFLW?Shuffle Packed Low Words
説明
ソース・オペランド（第2 オペランド）の下位クワッドワードからワードをコピーして、オーダー・
オペランド（第3 オペランド）で選択された、デスティネーション・オペランド（第1 オペランド）
の下位クワッドワード内のワード位置に挿入する。この操作は、図3-10. に示したPSHUFD命令の操
作とよく似ている。PSHUFLW命令では、オーダー・オペランドのそれぞれの2 ビット・フィールド
は、デスティネーション・オペランドの下位クワッドワード内の1 つのワード位置の内容を指定す
る。オーダー・オペランドの各フィールドの2 進エンコーディングによって、ソース・オペランドの
下位クワッドワードからデスティネーション・オペランドにコピーされるワード（0、1、2、または
3）が選択される。
ソース・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティ
ネーション・オペランドはXMMレジスタである。オーダー・オペランドは8 ビットの即値である。
この命令は、ソース・オペランドのワードを、デスティネーション・オペランドの2 つ以上のワード
位置にコピーすることができる。
操作
DEST[15-0] ← (SRC >> (ORDER[1-0] ? 16) )[15-0]
DEST[31-16] ← (SRC >> (ORDER[3-2] ? 16) )[15-0]
DEST[47-32] ← (SRC >> (ORDER[5-4] ? 16) )[15-0]
DEST[63-48] ← (SRC >> (ORDER[7-6] ? 16) )[15-0]
同等のインテルC/C++ コンパイラ組み込み関数
PSHUFLW __m128i _mm_shufflelo_epi16(__m128i a, int n)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスが、CS、DS、ES、FS、またはGS
セグメントの範囲外の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
F2 0F 70 /r ib PSHUFLW xmm1,
xmm2/m128, imm8
imm8 のエンコーディングに基づいて、xmm2/m128 の下位
ワードをシャッフルし、結果をxmm1 に格納する。
3-595
命令セット・リファレンス
PSHUFLW?Shuffle Packed Low Words ( 続き)
#NM CR0 のTS がセットされた場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
数値例外
なし。
3-596
命令セット・リファレンス
PSHUFW?Shuffle Packed Words
説明
ソース・オペランド（第2 オペランド）からワードをコピーして、オーダー・オペランド（第3 オペ
ランド）で選択されたデスティネーション・オペランド（第1 オペランド）内のワード位置に挿入す
る。この操作は、図3-10. に示したPSHUFD 命令の操作とよく似ている。PSHUFW 命令では、オー
ダー・オペランドのそれぞれの2 ビット・フィールドは、デスティネーション・オペランドの1 つの
ワード位置の内容を指定する。オーダー・オペランドの各フィールドのエンコーディングによって、
ソース・オペランドからデスティネーション・オペランドにコピーされるワードが選択される。
ソース・オペランドは、MMX テクノロジ・レジスタまたは64 ビットのメモリ・ロケーションであ
る。デスティネーション・オペランドはMMXテクノロジ・レジスタである。オーダー・オペランド
は8 ビットの即値である。
この命令は、ソース・オペランドのワードを、デスティネーション・オペランドの2 つ以上のワード
位置にコピーすることができる。
操作
DEST[15-0] ← (SRC >> (ORDER[1-0] ? 16) )[15-0]
DEST[31-16] ← (SRC >> (ORDER[3-2] ? 16) )[15-0]
DEST[47-32] ← (SRC >> (ORDER[5-4] ? 16) )[15-0]
DEST[63-48] ← (SRC >> (ORDER[7-6] ? 16) )[15-0]
同等のインテルC/C++ コンパイラ組み込み関数
PSHUFW __m64 _mm_shuffle_pi16(__m64 a, int n)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
オペコード命令説明
0F 70 /r ib PSHUFW mm1,
mm2/m64, imm8
imm8 のエンコーディングに基づいてmm2/m64 のワード
をシャッフルし、mm1 の結果にストアする。
3-597
命令セット・リファレンス
PSHUFW?Shuffle Packed Words ( 続き)
実アドレス・モード例外
#GP(0) オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
数値例外
なし。
3-598
命令セット・リファレンス
PSLLDQ?Shift Double Quadword Left Logical
説明
カウント・オペランド（第2 オペランド）で指定されたバイト数だけ、デスティネーション・オペラ
ンド（第1 オペランド）を左にシフトする。空いた下位バイトはクリアされる（すべて0 にセットさ
れる）。カウント・オペランドで指定された値が15 より大きい場合は、デスティネーション・オペラ
ンドはすべて0 に設定される。デスティネーション・オペランドはXMM レジスタである。カウン
ト・オペランドは8 ビットの即値である。
操作
TEMP ← COUNT;
if (TEMP > 15) TEMP ← 16;
DEST ← DEST << (TEMP ? 8);
同等のインテルC/C++ コンパイラ組み込み関数
PSLLDQ __m128i _mm_slli_si128 ( __m128i a, int imm)
影響を受けるフラグ
なし。
保護モード例外
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
実アドレス・モード例外
保護モードと同じ例外。
仮想8086 モード例外
保護モードと同じ例外。
数値例外
なし。
オペコード命令説明
66 0F 73 /7 ib PSLLDQ xmm1, imm8 imm8 で指定されたバイト数だけxmm1 を左にシフトし、
下位はゼロで埋める。
3-599
命令セット・リファレンス
PSLLW/PSLLD/PSLLQ?Shift Packed Data Left Logical
説明
デスティネーション・オペランド( 第1 オペランド) にある個別のデータ要素( ワード、ダブルワー
ド、クワッドワード) のビットを、カウント・オペランド( 第2 オペランド) に指定されたビット数だ
け左にシフトする。データ要素のビットが左にシフトされると、空の下位ビットはクリアされる( ゼ
ロに設定される)。カウント・オペランドによって指定される値が( ワードでは)15、( ダブルワード
では)31、または( クワッドワードでは)63 より大きいと、デスティネーション・オペランドはすべて
ゼロに設定される（図3-11. は、64ビット・オペランド内でワードをシフトする操作の例を示してい
る）。デスティネーション・オペランドは、MMX テクノロジ・レジスタまたはXMM レジスタでな
ければならない。カウント・オペランドには、MMX テクノロジ・レジスタまたは64 ビットのメモ
リ・ロケーション、XMMレジスタまたは128 ビットのメモリ・ロケーション、または8 ビットの即
値を使用できる。
オペコード命令説明
0F F1 /r PSLLW mm, mm/m64 mm のワードをmm/m64 だけ左にシフトし、下位はゼ
ロで埋める。
66 0F F1 /r PSLLW xmm1, xmm2/m128 xmm1 のワードをxmm2/m128 だけ左にシフトし、下位
はゼロで埋める。
0F 71 /6 ib PSLLW mm, imm8 mm のワードをimm8 だけ左にシフトし、下位はゼロで
埋める。
66 0F 71 /6 ib PSLLW xmm1, imm8 xmm1 のワードをimm8 だけ左にシフトし、下位はゼロ
で埋める。
0F F2 /r PSLLD mm, mm/m64 mm のダブルワードをmm/m64 だけ左にシフトし、下
位はゼロで埋める。
66 0F F2 /r PSLLD xmm1, xmm2/m128 xmm1 のダブルワードをxmm2/m128 だけ左にシフト
し、下位はゼロで埋める。
0F 72 /6 ib PSLLD mm, imm8 mm のダブルワードをimm8 だけ左にシフトし、下位は
ゼロで埋める。
66 0F 72 /6 ib PSLLD xmm1, imm8 xmm1 のダブルワードをimm8 だけ左にシフトし、下位
はゼロで埋める。
0F F3 /r PSLLQ mm, mm/m64 mm のクワッドワードをmm/m64 だけ左にシフトし、
下位はゼロで埋める。
66 0F F3 /r PSLLQ xmm1, xmm2/m128 xmm1 のクワッドワードをxmm2/m128 だけ左にシフト
し、下位はゼロで埋める。
0F 73 /6 ib PSLLQ mm, imm8 mm のクワッドワードをimm8 だけ左にシフトし、下位
はゼロで埋める。
66 0F 73 /6 ib PSLLQ xmm1, imm8 xmm1 のクワッドワードをimm8 だけ左にシフトし、下
位はゼロで埋める。
3-600
命令セット・リファレンス
PSLLW/PSLLD/PSLLQ?Shift Packed Data Left Logical ( 続き)
PSLLW命令は、デスティネーション・オペランドのワードのそれぞれを、カウント・オペランドに
指定されたビット数だけ左にシフトする。PSLLD 命令は、デスティネーション・オペランドのダブ
ルワードのそれぞれをシフトし、PSLLQ 命令は、デスティネーション・オペランドのクワッドワー
ドをシフトする。個別データ要素が左にシフトされると、空の下位ビット位置はゼロで埋められる。
操作
PSLLW instruction with 64-bit operand:
IF (COUNT > 15)
THEN
DEST[64..0] ← 0000000000000000H
ELSE
DEST[15..0] ← ZeroExtend(DEST[15..0] << COUNT);
* repeat shift operation for 2nd and 3rd words *;
DEST[63..48] ← ZeroExtend(DEST[63..48] << COUNT);
FI;
PSLLD instruction with 64-bit operand:
IF (COUNT > 31)
THEN
DEST[64..0] ← 0000000000000000H
ELSE
DEST[31..0] ← ZeroExtend(DEST[31..0] << COUNT);
DEST[63..32] ← ZeroExtend(DEST[63..32] << COUNT);
FI;
PSLLQ instruction with 64-bit operand:
IF (COUNT > 63)
THEN
DEST[64..0] ← 0000000000000000H
ELSE
DEST ← ZeroExtend(DEST << COUNT);
FI;
図3-11. 64 ビット・オペランドを使用したPSLLW 命令、PSLLD 命令、PSLLQ 命令の動作
シフト前の
シフト後の
ゼロ拡張を使用して
X0
X0 << COUNT
X3 X2 X1
X3 << COUNT X2 << COUNT X1 << COUNT
DEST
左にシフトする
DEST
3-601
命令セット・リファレンス
PSLLW/PSLLD/PSLLQ?Shift Packed Data Left Logical ( 続き)
PSLLW instruction with 128-bit operand:
IF (COUNT > 15)
THEN
DEST[128..0] ← 00000000000000000000000000000000H
ELSE
DEST[15-0] ← ZeroExtend(DEST[15-0] << COUNT);
* repeat shift operation for 2nd through 7th words *;
DEST[127-112] ← ZeroExtend(DEST[127-112] << COUNT);
FI;
PSLLD instruction with 128-bit operand:
IF (COUNT > 31)
THEN
DEST[128..0] ← 00000000000000000000000000000000H
ELSE
DEST[31-0] ← ZeroExtend(DEST[31-0] << COUNT);
* repeat shift operation for 2nd and 3rd doublewords *;
DEST[127-96] ← ZeroExtend(DEST[127-96] << COUNT);
FI;
PSLLQ instruction with 128-bit operand:
IF (COUNT > 15)
THEN
DEST[128..0] ← 00000000000000000000000000000000H
ELSE
DEST[63-0] ← ZeroExtend(DEST[63-0] << COUNT);
DEST[127-64] ← ZeroExtend(DEST[127-64] << COUNT);
FI;
同等のインテルC/C++ コンパイラ組み込み関数
PSLLW __m64 _mm_slli_pi16 (__m64 m, int count)
PSLLW __m64 _mm_sll_pi16(__m64 m, __m64 count)
PSLLW __m128i _mm_slli_pi16(__m64 m, int count)
PSLLW __m128i _mm_slli_pi16(__m128i m, __m128i count)
PSLLD __m64 _mm_slli_pi32(__m64 m, int count)
PSLLD __m64 _mm_sll_pi32(__m64 m, __m64 count)
PSLLD __m128i _mm_slli_epi32(__m128i m, int count)
PSLLD __m128i _mm_sll_epi32(__m128i m, __m128i count)
PSLLQ __m64 _mm_slli_si64(__m64 m, int count)
PSLLQ __m64 _mm_sll_si64(__m64 m, __m64 count)
PSLLQ __m128i _mm_slli_si64(__m128i m, int count)
PSLLQ __m128i _mm_sll_si64(__m128i m, __m128i count)
影響を受けるフラグ
なし。
3-602
命令セット・リファレンス
PSLLW/PSLLD/PSLLQ?Shift Packed Data Left Logical ( 続き)
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-603
命令セット・リファレンス
PSRAW/PSRAD?Shift Packed Data Right Arithmetic
説明
デスティネーション・オペランド( 第1 オペランド) にある個別のデータ要素( ワードまたはダブル
ワード) のビットを、カウント・オペランド( 第2 オペランド) に指定されたビット量だけ右にシフト
する。データ要素のビットが右にシフトされると、各要素の空の上位ビットは、データ要素の符号
ビットの初期値で埋められる。カウント・オペランドによって指定される値が、( ワードでは)15 ま
たは( ダブルワードでは)31 より大きいと、デスティネーションの各データ要素は、その要素の符号
ビットの初期値で埋められる（図3-12. は、64 ビット・オペランド内でワードをシフトする操作の例
を示している）。
デスティネーション・オペランドは、MMXテクノロジ・レジスタまたはXMMレジスタでなければ
ならない。カウント・オペランドには、MMX テクノロジ・レジスタまたは64 ビットのメモリ・ロ
ケーション、XMMレジスタまたは128 ビットのメモリ・ロケーション、または8 ビットの即値を使
用できる。
オペコード命令説明
0F E1 /r PSRAW mm, mm/m64 mm のワードをmm/m64 だけ右にシフトし、上位は符
号ビットで埋める。
66 0F E1 /r PSRAW xmm1, xmm2/m128 xmm1 のワードをxmm2/m128 だけ右にシフトし、上位
は符号ビットで埋める。
0F 71 /4 ib PSRAW mm, imm8 mm のワードをimm8 だけ右にシフトし、上位は符号
ビットで埋める。
66 0F 71 /4 ib PSRAW xmm1, imm8 xmm1 のワードをimm8 だけ右にシフトし、上位は符号
ビットで埋める。
0F E2 /r PSRAD mm, mm/m64 mm のダブルワードをmm/m64 だけ右にシフトし、上
位は符号ビットで埋める。
66 0F E2 /r PSRAD xmm1, xmm2/m128 xmm1 のダブルワードをxmm2/m128 だけ右にシフト
し、上位は符号ビットで埋める。
0F 72 /4 ib PSRAD mm, imm8 mm のダブルワードをimm8 だけ右にシフトし、上位は
符号ビットで埋める。
66 0F 72 /4 ib PSRAD xmm1, imm8 xmm1 のダブルワードをimm8 だけ右にシフトし、上位
は符号ビットで埋める。
図3-12. 64 ビット・オペランドを使用したPSRAW 命令とPSRAD 命令の動作
X0
X0 >> COUNT
X3 X2 X1
X3 >> COUNT X2 >> COUNT X1 >> COUNT
シフト前の
シフト後の
ゼロ拡張を使用して
DEST
右にシフトする
DEST
3-604
命令セット・リファレンス
PSRAW/PSRAD?Shift Packed Data Right Arithmetic ( 続き)
PSRAW命令は、デスティネーション・オペランドのワードのそれぞれを、カウント・オペランドに
指定されたビット数だけ右にシフトする。PSRAD命令は、デスティネーション・オペランドのダブ
ルワードのそれぞれをシフトする。
操作
PSRAW instruction with 64-bit operand:
IF (COUNT > 15)
THEN COUNT ← 16;
FI;
DEST[15..0] ← SignExtend(DEST[15..0] >> COUNT);
* repeat shift operation for 2nd and 3rd words *;
DEST[63..48] ← SignExtend(DEST[63..48] >> COUNT);
PSRAD instruction with 64-bit operand:
IF (COUNT > 31)
THEN COUNT ← 32;
FI;
ELSE
DEST[31..0] ← SignExtend(DEST[31..0] >> COUNT);
DEST[63..32] ← SignExtend(DEST[63..32] >> COUNT);
PSRAW instruction with 128-bit operand:
IF (COUNT > 15)
THEN COUNT ← 16;
FI;
ELSE
DEST[15-0] ← SignExtend(DEST[15-0] >> COUNT);
* repeat shift operation for 2nd through 7th words *;
DEST[127-112] ← SignExtend(DEST[127-112] >> COUNT);
PSRAD instruction with 128-bit operand:
IF (COUNT > 31)
THEN COUNT ← 32;
FI;
ELSE
DEST[31-0] ← SignExtend(DEST[31-0] >> COUNT);
* repeat shift operation for 2nd and 3rd doublewords *;
DEST[127-96] ← SignExtend(DEST[127-96] >>COUNT);
3-605
命令セット・リファレンス
PSRAW/PSRAD?Shift Packed Data Right Arithmetic ( 続き)
同等のインテルC/C++ コンパイラ組み込み関数
PSRAW __m64 _mm_srai_pi16 (__m64 m, int count)
PSRAW __m64 _mm_sraw_pi16 (__m64 m, __m64 count)
PSRAD __m64 _mm_srai_pi32 (__m64 m, int count)
PSRAD __m64 _mm_sra_pi32 (__m64 m, __m64 count)
PSRAW __m128i _mm_srai_epi16(__m128i m, int count)
PSRAW __m128i _mm_sra_epi16(__m128i m, __m128i count))
PSRAD __m128i _mm_srai_epi32 (__m128i m, int count)
PSRAD __m128i _mm_sra_epi32 (__m128i m, __m128i count)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
3-606
命令セット・リファレンス
PSRAW/PSRAD?Shift Packed Data Right Arithmetic ( 続き)
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-607
命令セット・リファレンス
PSRLDQ?Shift Double Quadword Right Logical
説明
カウント・オペランド（第2 オペランド）で指定されたバイト数だけ、デスティネーション・オペラ
ンド（第1 オペランド）を右にシフトする。空いた上位バイトはクリアされる（すべて0 にセットさ
れる）。カウント・オペランドで指定された値が15 より大きい場合は、デスティネーション・オペラ
ンドはすべて0 に設定される。デスティネーション・オペランドはXMM レジスタである。カウン
ト・オペランドは8 ビットの即値である。
操作
TEMP ← COUNT;
if (TEMP > 15) TEMP ← 16;
DEST ← DEST >> (temp ? 8);
同等のインテルC/C++ コンパイラ組み込み関数
PSRLDQ __m128i _mm_srli_si128 ( __m128i a, int imm)
影響を受けるフラグ
なし。
保護モード例外
#UD CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
実アドレス・モード例外
保護モードと同じ例外。
仮想8086 モード例外
保護モードと同じ例外。
数値例外
なし。
オペコード命令説明
66 0F 73 /3 ib PSRLDQ xmm1, imm8 xmm1 をimm8 だけ右にシフトし、上位はゼロで埋める。
3-608
命令セット・リファレンス
PSRLW/PSRLD/PSRLQ?Shift Packed Data Right Logical
説明
デスティネーション・オペランド( 第1 オペランド) にある個別のデータ要素( ワード、ダブルワー
ド、またはクワッドワード) のビットを、カウント・オペランド( 第2 オペランド) に指定されたビッ
ト量だけ右にシフトする。データ要素のビットが右にシフトされると、空の上位ビットはクリアさ
れる( ゼロに設定される)。カウント・オペランドによって指定された値が( ワードでは)15、( ダブル
ワードでは)31、または( クワッドワードでは)63 より大きいと、デスティネーション・オペランドは
すべてゼロに設定される（図3-13. は、64 ビット・オペランド内でワードをシフトする操作の例を示
している）。デスティネーション・オペランドは、MMX テクノロジ・レジスタまたはXMM レジス
タでなければならない。カウント・オペランドには、MMX テクノロジ・レジスタまたは64 ビット
のメモリ・ロケーション、XMMレジスタまたは128 ビット・メモリ・ロケーション、または8 ビッ
トの即値を使用できる。
オペコード命令説明
0F D1 /r PSRLW mm, mm/m64 mm のワードをmm/m64 に指定されたビットだけ右に
シフトし、上位はゼロで埋める。
66 0F D1 /r PSRLW xmm1, xmm2/m128 xmm1 のワードをxmm2/m128 に指定されたビットだけ
右にシフトし、上位はゼロで埋める。
0F 71 /2 ib PSRLW mm, imm8 mm のワードをimm8 だけ右にシフトし、上位はゼロで
埋める。
66 0F 71 /2 ib PSRLW xmm1, imm8 xmm1 のワードをimm8 だけ右にシフトし、上位はゼロ
で埋める。
0F D2 /r PSRLD mm, mm/m64 mm のダブルワードをmm/m64 に指定されたビットだ
け右にシフトし、上位はゼロで埋める。
66 0F D2 /r PSRLD xmm1, xmm2/m128 xmm1 のダブルワードをxmm2/m128 に指定されたビッ
トだけ右にシフトし、上位はゼロで埋める。
0F 72 /2 ib PSRLD mm, imm8 mm のダブルワードをimm8 だけ右にシフトし、上位は
ゼロで埋める。
66 0F 72 /2 ib PSRLD xmm1, imm8 xmm1 のダブルワードをimm8 だけ右にシフトし、上位
はゼロで埋める。
0F D3 /r PSRLQ mm, mm/m64 mm をmm/m64 に指定されたビットだけ右にシフトし、
上位はゼロで埋める。
66 0F D3 /r PSRLQ xmm1, xmm2/m128 xmm1 のクワッドワードをxmm/m128 に指定された
ビットだけ右にシフトし、上位はゼロで埋める。
0F 73 /2 ib PSRLQ mm, imm8 mm をimm8 だけ右にシフトし、上位はゼロで埋める。
66 0F 73 /2 ib PSRLQ xmm1, imm8 xmm1 をimm8 だけ右にシフトし、上位はゼロで埋め
る。
3-609
命令セット・リファレンス
PSRLW/PSRLD/PSRLQ?Shift Packed Data Right Logical ( 続き)
PSRLW命令は、デスティネーション・オペランドのワードのそれぞれを、カウント・オペランドに
指定されたビット数だけ右にシフトする。PSRLD 命令は、デスティネーション・オペランドのダブ
ルワードのそれぞれをシフトし、PSRLQ命令は、デスティネーション・オペランドの64ビットのク
ワッドワードをシフトする。
操作
PSRLW instruction with 64-bit operand:
IF (COUNT > 15)
THEN
DEST[64..0] ← 0000000000000000H
ELSE
DEST[15..0] ← ZeroExtend(DEST[15..0] >> COUNT);
* repeat shift operation for 2nd and 3rd words *;
DEST[63..48] ← ZeroExtend(DEST[63..48] >> COUNT);
FI;
PSRLD instruction with 64-bit operand:
IF (COUNT > 31)
THEN
DEST[64..0] ← 0000000000000000H
ELSE
DEST[31..0] ← ZeroExtend(DEST[31..0] >> COUNT);
DEST[63..32] ← ZeroExtend(DEST[63..32] >> COUNT);
FI;
PSRLQ instruction with 64-bit operand:
IF (COUNT > 63)
THEN
DEST[64..0] ← 0000000000000000H
ELSE
DEST ← ZeroExtend(DEST >> COUNT);
FI;
図3-13. 64 ビット・オペランドを使用したPSRLW 命令、PSRLD 命令、PSRLQ 命令の動作
X0
X0 >> COUNT
X3 X2 X1
X3 >> COUNT X2 >> COUNT X1 >> COUNT
シフト前の
シフト後の
ゼロ拡張を使用して
DEST
右にシフトする
DEST
3-610
命令セット・リファレンス
PSRLW/PSRLD/PSRLQ?Shift Packed Data Right Logical ( 続き)
PSRLW instruction with 128-bit operand:
IF (COUNT > 15)
THEN
DEST[128..0] ← 00000000000000000000000000000000H
ELSE
DEST[15-0] ← ZeroExtend(DEST[15-0] >> COUNT);
* repeat shift operation for 2nd through 7th words *;
DEST[127-112] ← ZeroExtend(DEST[127-112] >> COUNT);
FI;
PSRLD instruction with 128-bit operand:
IF (COUNT > 31)
THEN
DEST[128..0] ← 00000000000000000000000000000000H
ELSE
DEST[31-0] ← ZeroExtend(DEST[31-0] >> COUNT);
* repeat shift operation for 2nd and 3rd doublewords *;
DEST[127-96] ← ZeroExtend(DEST[127-96] >> COUNT);
FI;
PSRLQ instruction with 128-bit operand:
IF (COUNT > 15)
THEN
DEST[128..0] ← 00000000000000000000000000000000H
ELSE
DEST[63-0] ← ZeroExtend(DEST[63-0] >> COUNT);
DEST[127-64] ← ZeroExtend(DEST[127-64] >> COUNT);
FI;
同等のインテルC/C++ コンパイラ組み込み関数
PSRLW __m64 _mm_srli_pi16(__m64 m, int count)
PSRLW __m64 _mm_srl_pi16 (__m64 m, __m64 count)
PSRLW __m128i _mm_srli_epi16 (__m128i m, int count)
PSRLW __m128i _mm_srl_epi16 (__m128i m, __m128i count)
PSRLD __m64 _mm_srli_pi32 (__m64 m, int count)
PSRLD __m64 _mm_srl_pi32 (__m64 m, __m64 count)
PSRLD __m128i _mm_srli_epi32 (__m128i m, int count)
PSRLD __m128i _mm_srl_epi32 (__m128i m, __m128i count)
PSRLQ __m64 _mm_srli_si64 (__m64 m, int count)
PSRLQ __m64 _mm_srl_si64 (__m64 m, __m64 count)
PSRLQ __m128i _mm_srli_epi64 (__m128i m, int count)
PSRLQ __m128i _mm_srl_epi64 (__m128i m, __m128i count)
3-611
命令セット・リファレンス
PSRLW/PSRLD/PSRLQ?Shift Packed Data Right Logical ( 続き)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
3-612
命令セット・リファレンス
PSRLW/PSRLD/PSRLQ?Shift Packed Data Right Logical ( 続き)
数値例外
なし。
3-613
命令セット・リファレンス
PSUBB/PSUBW/PSUBD?Subtract Packed Integers
説明
デスティネーション・オペランド（第1 オペランド）のパックド整数からソース・オペランド（第2
オペランド）のパックド整数をSIMD減算し、結果のパックド整数をデスティネーション・オペラン
ドに格納する。SIMD演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』の図9-4. を参照のこと。以降の段落で説明するように、オーバーフローは
ラップアラウンドを使用して処理される。
上記の命令は、64 ビット・オペランドまたは128 ビット・オペランドのいずれかを操作する。64 ビッ
ト・オペランドを操作する場合、デスティネーション・オペランドにはMMXテクノロジ・レジスタ
を使用しなければならないが、ソース・オペランドにはMMX テクノロジ・レジスタまたは64 ビッ
ト・メモリ・ロケーションのどちらを使用しても構わない。128 ビット・オペランドを操作する場合
は、デスティネーション・オペランドにはXXMレジスタを使用しなければならないが、ソース・オ
ペランドにはXMMレジスタまたは128 ビット・メモリ・ロケーションのどちらを使用しても構わな
い。
PSUBB命令は、パックド・バイト整数を引く。個別の結果がバイトで表現するには大きすぎるまた
は小さすぎるときは、結果はラップアラウンドされ、下位8 ビットがデスティネーション要素に書き
込まれる。
PSUBW命令は、パックド・ワード整数を引く。個別の結果がワードで表現するには大きすぎるまた
は小さすぎるときは、結果はラップアラウンドされ、下位16 ビットがデスティネーション要素に書
き込まれる。
PSUBD命令は、パックド・ダブルワード整数を引く。個別の結果がダブルワードで表現するには大
きすぎるまたは小さすぎるときは、結果はラップアラウンドされ、下位32 ビットがデスティネーショ
ン要素に書き込まれる。
PSUBB、PSUBW、およびPSUBD 命令は、符号なしまたは符号付き(2 の補数表記) のパックド整数
を操作できることに注意すること。ただし、これらの命令は、オーバーフローやキャリーを示す
EFLAGS レジスタ内のビットをセットしない。このため、検出されないオーバーフロー状態が発生
しないように、操作される値の範囲をソフトウェアによって制御しなければならない。
オペコード命令説明
0F F8 /r PSUBB mm, mm/m64 mm のパックド・バイト整数からmm/m64 のパック
ド・バイト整数を引く。
66 0F F8 /r PSUBB xmm1, xmm2/m128 xmm1 のパックド・バイト整数からxmm2/m128 の
パックド・バイト整数を引く。
0F F9 /r PSUBW mm, mm/m64 mm のパックド・ワード整数からmm/m64 のパック
ド・ワード整数を引く。
66 0F F9 /r PSUBW xmm1, xmm2/m128 xmm1 のパックド・ワード整数からxmm2/m128 の
パックド・ワード整数を引く。
0F FA /r PSUBD mm, mm/m64 mm のパックド・ダブルワード整数からmm/m64 の
パックド・ダブルワード整数を引く。
66 0F FA /r PSUBD xmm1, xmm2/m128 xmm1 のパックド・ダブルワード整数からxmm2/m128
のパックド・ダブルワード整数を引く。
3-614
命令セット・リファレンス
PSUBB/PSUBW/PSUBD?Subtract Packed Integers ( 続き)
操作
PSUBB instruction with 64-bit operands:
DEST[7..0] ← DEST[7..0] ? SRC[7..0];
* repeat subtract operation for 2nd through 7th byte *;
DEST[63..56] ← DEST[63..56] ? SRC[63..56];
PSUBB instruction with 128-bit operands:
DEST[7-0] ← DEST[7-0] ? SRC[7-0];
* repeat subtract operation for 2nd through 14th byte *;
DEST[127-120] ← DEST[111-120] ? SRC[127-120];
PSUBW instruction with 64-bit operands:
DEST[15..0] ← DEST[15..0] ? SRC[15..0];
* repeat subtract operation for 2nd and 3rd word *;
DEST[63..48] ← DEST[63..48] ? SRC[63..48];
PSUBW instruction with 128-bit operands:
DEST[15-0] ← DEST[15-0] ? SRC[15-0];
* repeat subtract operation for 2nd through 7th word *;
DEST[127-112] ← DEST[127-112] ? SRC[127-112];
PSUBD instruction with 64-bit operands:
DEST[31..0] ← DEST[31..0] ? SRC[31..0];
DEST[63..32] ← DEST[63..32] ? SRC[63..32];
PSUBD instruction with 128-bit operands:
DEST[31-0] ← DEST[31-0] ? SRC[31-0];
* repeat subtract operation for 2nd and 3rd doubleword *;
DEST[127-96] ← DEST[127-96] ? SRC[127-96];
同等のインテルC/C++ コンパイラ組み込み関数
PSUBB __m64 _mm_sub_pi8(__m64 m1, __m64 m2)
PSUBW __m64 _mm_sub_pi16(__m64 m1, __m64 m2)
PSUBD __m64 _mm_sub_pi32(__m64 m1, __m64 m2)
PSUBB __m128i _mm_sub_epi8 ( __m128i a, __m128i b)
PSUBW __m128i _mm_sub_epi16 ( __m128i a, __m128i b)
PSUBD __m128i _mm_sub_epi32 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
3-615
命令セット・リファレンス
PSUBB/PSUBW/PSUBD?Subtract Packed Integers ( 続き)
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-616
命令セット・リファレンス
PSUBQ?Subtract Packed Quadword Integers
説明
第1 オペランド（デスティネーション・オペランド）から第2 オペランド（ソース・オペランド）を
引き、結果をデスティネーション・オペランドに格納する。ソース・オペランドは、MMXテクノロ
ジ・レジスタまたは64 ビットのメモリ・ロケーションに格納される1 つのクワッドワード整数か、
XMMレジスタまたは128 ビットのメモリ・ロケーションに格納される2 つのパックド・クワッドワー
ド整数である。デスティネーション・オペランドは、MMXテクノロジ・レジスタに格納される1 つ
のクワッドワード整数か、XMMレジスタに格納される2 つのパックド・クワッドワード整数である。
パックド・クワッドワードのオペランドを使用する場合は、SIMD減算が実行される。結果のクワッ
ドワードが大きすぎて64ビットで表現できない場合は（オーバーフロー）、結果はラップアラウンド
され、下位64 ビットがデスティネーション要素に書き込まれる（すなわち、キャリーは無視される）。
PSUBQ命令は、符号なし整数と符号付き整数（2 の補数記法）のどちらを操作することもできる。た
だし、この命令は、オーバーフローやキャリーを示すEFLAGSレジスタ内のビットをセットしない。
このため、検出されないオーバーフロー状態が発生しないように、操作される値の範囲をソフトウェ
アによって制御しなければならない。
操作
PSUBQ instruction with 64-Bit operands:
DEST[63-0] ← DEST[63-0] ? SRC[63-0];
PSUBQ instruction with 128-Bit operands:
DEST[63-0] ← DEST[63-0] ? SRC[63-0];
DEST[127-64] ← DEST[127-64] ? SRC[127-64];
同等のインテルC/C++ コンパイラ組み込み関数
PSUBQ __m64 _mm_sub_si64(__m64 m1, __m64 m2)
PSUBQ __m128i _mm_sub_epi64(__m128i m1, __m128i m2)
影響を受けるフラグ
なし。
オペコード命令説明
0F FB /r PSUBQ mm1, mm2/m64 mm2/m64 からmm1 のクワッドワード整数を引く。
66 0F FB /r PSUBQ xmm1, xmm2/m128 xmm2/m128 からxmm1 のパックド・クワッドワード整
数を引く。
3-617
命令セット・リファレンス
PSUBQ?Subtract Packed Quadword Integers ( 続き)
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスが、CS、DS、ES、FS、またはGS
セグメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックが有効になっており、現
行特権レベルが3 のときにアライメントの合っていないメモリ参照を
行った場合。
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックが有効になっており、ア
ライメントの合っていないメモリ参照を行った場合。
数値例外
なし。
3-618
命令セット・リファレンス
PSUBSB/PSUBSW?Subtract Packed Signed Integers with Signed
Saturation
説明
デスティネーション・オペランド（第1 オペランド）のパックド符号付き整数からソース・オペラン
ド（第2 オペランド）のパックド符号付き整数をSIMD減算し、結果のパックド整数をデスティネー
ション・オペランドに格納する。オーバーフローは、以下に説明する方法で飽和処理される。SIMD
演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上
巻』の図9-4. を参照のこと。以降の段落で説明するように、オーバーフローは符号付き飽和処理を
使用して処理される。
上記の命令は、64 ビット・オペランドまたは128 ビット・オペランドのいずれかを操作する。64 ビッ
ト・オペランドを操作する場合、デスティネーション・オペランドにはMMXテクノロジ・レジスタ
を使用しなければならないが、ソース・オペランドにはMMX テクノロジ・レジスタまたは64 ビッ
ト・メモリ・ロケーションのどちらを使用しても構わない。128 ビット・オペランドを操作する場合
は、デスティネーション・オペランドにはXXMレジスタを使用しなければならないが、ソース・オ
ペランドにはXMMレジスタまたは128 ビット・メモリ・ロケーションのどちらを使用しても構わな
い。
PSUBSB 命令は、符号付きパックド・バイト整数を引く。個別のバイト結果が符号付きバイト整数
の範囲を超える場合( すなわち、7FHより大きいかまたは80Hより小さい場合) は、それぞれ7FHま
たは80Hの飽和された値がデスティネーション・オペランドに書き込まれる。
PSUBSW 命令は、符号付きパックド・ワード整数を引く。個別のワード結果が符号付きワード整数
の範囲を超える場合( すなわち、7FFFH より大きいかまたは8000H より小さい場合) は、それぞれ
7FFFHまたは8000Hの飽和された値がデスティネーション・オペランドに書き込まれる。
操作
PSUBSB instruction with 64-bit operands:
DEST[7..0] ← SaturateToSignedByte(DEST[7..0] ? SRC (7..0]) ;
* repeat subtract operation for 2nd through 7th bytes *;
DEST[63..56] ← SaturateToSignedByte(DEST[63..56] ? SRC[63..56] );
オペコード命令説明
0F E8 /r PSUBSB mm, mm/m64 mm の符号付きパックド・バイトからmm/m64 の符号
付きパックド・バイトを引き、結果を飽和させる。
66 0F E8 /r PSUBSB xmm1, xmm2/m128 xmm1 の符号つきパックド・バイトからxmm2/m128 の
符号付きパックド・バイトを引き、結果を飽和させる。
0F E9 /r PSUBSW mm, mm/m64 mm の符号付きパックド・ワードからmm/m64 の符号
付きパックド・ワードを引き、結果を飽和させる。
66 0F E9 /r PSUBSW xmm1, xmm2/m128 xmm1 の符号つきパックド・ワードからxmm2/m128 の
符号付きパックド・ワードを引き、結果を飽和させる。
3-619
命令セット・リファレンス
PSUBSB/PSUBSW?Subtract Packed Signed Integers with Signed
Saturation ( 続き)
PSUBSB instruction with 128-bit operands:
DEST[7-0] ← SaturateToSignedByte (DEST[7-0] ? SRC[7-0]);
* repeat subtract operation for 2nd through 14th bytes *;
DEST[127-120] ← SaturateToSignedByte (DEST[111-120] ? SRC[127-120]);
PSUBSW instruction with 64-bit operands
DEST[15..0] ← SaturateToSignedWord(DEST[15..0] ? SRC[15..0] );
* repeat subtract operation for 2nd and 7th words *;
DEST[63..48] ← SaturateToSignedWord(DEST[63..48] ? SRC[63..48] );
PSUBSW instruction with 128-bit operands
DEST[15-0] ← SaturateToSignedWord (DEST[15-0] ? SRC[15-0]);
* repeat subtract operation for 2nd through 7th words *;
DEST[127-112] ← SaturateToSignedWord (DEST[127-112] ? SRC[127-112]);
同等のインテルC/C++ コンパイラ組み込み関数
PSUBSB __m64 _mm_subs_pi8(__m64 m1, __m64 m2)
PSUBSB __m128i _mm_subs_epi8(__m128i m1, __m128i m2)
PSUBSW __m64 _mm_subs_pi16(__m64 m1, __m64 m2)
PSUBSW __m128i _mm_subs_epi16(__m128i m1, __m128i m2)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
3-620
命令セット・リファレンス
PSUBSB/PSUBSW?Subtract Packed Signed Integers with Signed
Saturation ( 続き)
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-621
命令セット・リファレンス
PSUBUSB/PSUBUSW?Subtract Packed Unsigned Integers with
Unsigned Saturation
説明
デスティネーション・オペランド（第1 オペランド）のパックド符号なし整数からソース・オペラン
ド（第2 オペランド）のパックド符号なし整数をSIMD減算し、結果のパックド整数をデスティネー
ション・オペランドに格納する。SIMD演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェ
ア・デベロッパーズ・マニュアル、上巻』の図9-4. を参照のこと。以降の段落で説明するように、
オーバーフローは符号なし飽和処理を使用して処理される。
上記の命令は、64 ビット・オペランドまたは128 ビット・オペランドのいずれかを操作する。64 ビッ
ト・オペランドを操作する場合、デスティネーション・オペランドにはMMXテクノロジ・レジスタ
を使用しなければならないが、ソース・オペランドにはMMX テクノロジ・レジスタまたは64 ビッ
ト・メモリ・ロケーションのどちらを使用しても構わない。128 ビット・オペランドを操作する場合
は、デスティネーション・オペランドにはXXMレジスタを使用しなければならないが、ソース・オ
ペランドにはXMMレジスタまたは128 ビット・メモリ・ロケーションのどちらを使用しても構わな
い。
PSUBUSB命令は、符号なしパックド・バイト整数を引く。個別のバイト結果がゼロより小さい場合
は、00Hの飽和された符号なし値がデスティネーション・オペランドに書き込まれる。
PSUBUSW 命令は、符号なしパックド・ワード整数を引く。個別のワード結果がゼロより小さい場
合は、0000Hの飽和された符号なし値がデスティネーション・オペランドに書き込まれる。
操作
PSUBUSB instruction with 64-bit operands:
DEST[7..0] ← SaturateToUnsignedByte(DEST[7..0] ? SRC (7..0] );
* repeat add operation for 2nd through 7th bytes *:
DEST[63..56] ← SaturateToUnsignedByte(DEST[63..56] ? SRC[63..56]
PSUBUSB instruction with 128-bit operands:
DEST[7-0] ← SaturateToUnsignedByte (DEST[7-0] ? SRC[7-0]);
* repeat add operation for 2nd through 14th bytes *:
DEST[127-120] ← SaturateToUnSignedByte (DEST[127-120] ? SRC[127-120]);
オペコード命令説明
0F D8 /r PSUBUSB mm, mm/m64 mm の符号なしパックド・バイトからmm/m64 の符号
なしパックド・バイトを引き、結果を飽和させる。
66 0F D8 /r PSUBUSB xmm1, xmm2/m128 xmm1 の符号なしパックド・バイトからxmm2/m128 の
符号なしパックド・バイトを引き、結果を飽和させる。
0F D9 /r PSUBUSW mm, mm/m64 mm の符号なしパックド・ワードからmm/m64 の符号
なしパックド・ワードを引き、結果を飽和させる。
66 0F D9 /r PSUBUSW xmm1, xmm2/m128 xmm1 の符号なしパックド・ワードからxmm2/m128 の
符号なしパックド・ワードを引き、結果を飽和させる。
3-622
命令セット・リファレンス
PSUBUSB/PSUBUSW?Subtract Packed Unsigned Integers with
Unsigned Saturation ( 続き)
PSUBUSW instruction with 64-bit operands:
DEST[15..0] ← SaturateToUnsignedWord(DEST[15..0] ? SRC[15..0] );
* repeat add operation for 2nd and 3rd words *:
DEST[63..48] ← SaturateToUnsignedWord(DEST[63..48] ? SRC[63..48] );
PSUBUSW instruction with 128-bit operands:
DEST[15-0] ← SaturateToUnsignedWord (DEST[15-0] ? SRC[15-0]);
* repeat add operation for 2nd through 7th words *:
DEST[127-112] ← SaturateToUnSignedWord (DEST[127-112] ? SRC[127-112]);
同等のインテルC/C++ コンパイラ組み込み関数
PSUBUSB __m64 _mm_sub_pu8(__m64 m1, __m64 m2)
PSUBUSB __m128i _mm_sub_epu8(__m128i m1, __m128i m2)
PSUBUSW __m64 _mm_sub_pu16(__m64 m1, __m64 m2)
PSUBUSW __m128i _mm_sub_epu16(__m128i m1, __m128i m2)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
3-623
命令セット・リファレンス
PSUBUSB/PSUBUSW?Subtract Packed Unsigned Integers with
Unsigned Saturation ( 続き)
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-624
命令セット・リファレンス
PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ?
Unpack High Data
説明
デスティネーション・オペランド( 第1 オペランド) とソース・オペランド( 第2 オペランド) の上位
データ要素( バイト、ワード、ダブルワードまたはクワッドワード) をデスティネーション・オペラ
ンドにアンパックしてインタリーブする( 図3-14. はビット・オペランドのバイトでアンパックされ
た動作を示す)。下位データ要素は無視される。
ソース・オペランドは、MMXテクノロジ・レジスタまたは64 ビットのメモリ・ロケーション、XMM
レジスタまたは128 ビットのメモリ・ロケーションが使用できる。デスティネーション・オペランド
には、MMXテクノロジ・レジスタまたはXMMレジスタを使用できる。ソース・データが64 ビット
のメモリ・オペランドからであるときは、64 ビット・オペランドすべてがメモリからアクセスされ
るが、命令は上位32 ビットだけを使用する。ソース・データが128 ビット・メモリ・オペランドか
らのものである場合、プロセッサによっては、適切な64 ビットだけがフェッチされる。この場合も、
16 バイト境界へのアライメントと通常のセグメント・チェックが適用される。
オペコード命令説明
0F 68 /r PUNPCKHBW mm,
mm/m64
mm およびmm/m64 からmm に上位バイトをアンパックし
てインタリーブする。
66 0F 68 /r PUNPCKHBW xmm1,
xmm2/m128
xmm1 およびxmm2/m128 からxmm1 に上位バイトをアン
パックしてインタリーブする。
0F 69 /r PUNPCKHWD mm,
mm/m64
mm およびmm/m64 からmm に上位ワードをアンパックし
てインタリーブする。
66 0F 69 /r PUNPCKHWD xmm1,
xmm2/m128
xmm1 およびxmm2/m128 からxmm1 に上位ワードをアン
パックしてインタリーブする。
0F 6A /r PUNPCKHDQ mm,
mm/m64
mm およびmm/m64 からmm に上位ダブルワードをアン
パックしてインタリーブする。
66 0F 6A /r PUNPCKHDQ xmm1,
xmm2/m128
xmm1 およびxmm2/m128 からxmm1 に上位ダブルワード
をアンパックしてインタリーブする。
66 0F 6D /r PUNPCKHQDQ xmm1,
xmm2/m128
xmm1 およびxmm2/m128 からxmm1 に上位クワッドワー
ドをアンパックしてインタリーブする。
図3-14. 64 ビット・オペランドを使用したPUNPCKHBW 命令の動作
Y7 X7 Y6 X6 Y5 X5 Y4 X4
SRC Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 X7 X6 X5 X4 X3 X2 X1 X0 DEST
DEST
3-625
命令セット・リファレンス
PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ?
Unpack High Data ( 続き)
PUNPCKHBW命令は、ソース・オペランドとデスティネーション・オペランドの上位バイトをイン
タリーブする。PUNPCKHWD命令は、ソース・オペランドとデスティネーション・オペランドの上
位ワードをインタリーブする。PUNPCKHDQ 命令は、ソース・オペランドとデスティネーション・
オペランドの上位ダブルワードをインタリーブし、PUNPCKHQDQ 命令は、ソース・オペランドと
デスティネーション・オペランドの上位クワッドワードをインタリーブする。
上記の命令では、ソース・オペランドにすべてゼロを入れることにより、バイトからワード、ワー
ドからダブルワード、ダブルワードからクワッドワード、クワッドワードからダブル・クワッドワー
ドへと、それぞれ変換することができる。ソース・オペランドがすべてゼロである場合、( デスティ
ネーション・オペランドにストアされる) 結果は、デスティネーション・オペランドの元の値の上位
データ要素がゼロ拡張されたものになる。例えば、PUNPCKHBW命令では、上位バイトがゼロ拡張
され( すなわち、符号なしワード整数にアンパックされる)、PUNPCKHWD命令では、上位ワードが
ゼロ拡張される( 符号なしダブルワード整数にアンパックされる)。
操作
PUNPCKHBW instruction with 64-bit operands:
DEST[7..0] ← DEST[39..32];
DEST[15..8] ← SRC[39..32];
DEST[23..16] ← DEST[47..40];
DEST[31..24] ← SRC[47..40];
DEST[39..32] ← DEST[55..48];
DEST[47..40] ← SRC[55..48];
DEST[55..48] ← DEST[63..56];
DEST[63..56] ← SRC[63..56];
PUNPCKHW instruction with 64-bit operands:
DEST[15..0] ← DEST[47..32];
DEST[31..16] ← SRC[47..32];
DEST[47..32] ← DEST[63..48];
DEST[63..48] ← SRC[63..48];
PUNPCKHDQ instruction with 64-bit operands:
DEST[31..0] ← DEST[63..32]
DEST[63..32] ← SRC[63..32];
PUNPCKHBW instruction with 128-bit operands:
DEST[7-0] ← DEST[71-64];
DEST[15-8] ← SRC[71-64];
DEST[23-16] ← DEST[79-72];
DEST[31-24] ← SRC[79-72];
DEST[39-32] ← DEST[87-80];
DEST[47-40] ← SRC[87-80];
DEST[55-48] ← DEST[95-88];
DEST[63-56] ← SRC[95-88];
3-626
命令セット・リファレンス
PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ?
Unpack High Data ( 続き)
DEST[71-64] ← DEST[103-96];
DEST[79-72] ← SRC[103-96];
DEST[87-80] ← DEST[111-104];
DEST[95-88] ← SRC[111-104];
DEST[103-96] ← DEST[119-112];
DEST[111-104] ← SRC[119-112];
DEST[119-112] ← DEST[127-120];
DEST[127-120] ← SRC[127-120];
PUNPCKHWD instruction with 128-bit operands:
DEST[15-0] ← DEST[79-64];
DEST[31-16] ← SRC[79-64];
DEST[47-32] ← DEST[95-80];
DEST[63-48] ← SRC[95-80];
DEST[79-64] ← DEST[111-96];
DEST[95-80] ← SRC[111-96];
DEST[111-96] ← DEST[127-112];
DEST[127-112] ← SRC[127-112];
PUNPCKHDQ instruction with 128-bit operands:
DEST[31-0] ← DEST[95-64];
DEST[63-32] ← SRC[95-64];
DEST[95-64] ← DEST[127-96];
DEST[127-96] ← SRC[127-96];
PUNPCKHQDQ instruction:
DEST[63-0] ← DEST[127-64];
DEST[127-64] ← SRC[127-64];
同等のインテルC/C++ コンパイラ組み込み関数
PUNPCKHBW __m64 _mm_unpackhi_pi8(__m64 m1, __m64 m2)
PUNPCKHBW __m128i _mm_unpackhi_epi8(__m128i m1, __m128i m2)
PUNPCKHWD __m64 _mm_unpackhi_pi16(__m64 m1,__m64 m2)
PUNPCKHWD __m128i _mm_unpackhi_epi16(__m128i m1,__m128i m2)
PUNPCKHDQ __m64 _mm_unpackhi_pi32(__m64 m1, __m64 m2)
PUNPCKHDQ __m128i _mm_unpackhi_epi32(__m128i m1, __m128i m2)
PUNPCKHQDQ __m128i _mm_unpackhi_epi64 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
3-627
命令セット・リファレンス
PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ?
Unpack High Data ( 続き)
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
数値例外
なし。
3-628
命令セット・リファレンス
PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ?Unpack
Low Data
説明
デスティネーション・オペランド( 第1 オペランド) とソース・オペランド( 第2 オペランド) の下位
データ要素( バイト、ワード、ダブルワード、およびクワッドワード) をデスティネーション・オペ
ランドにアンパックしてインタリーブする( 図3-15. は64ビット・オペランドのバイトでアンパック
された動作を示す)。上位データ要素は無視される。
ソース・オペランドには、MMX テクノロジ・レジスタまたは64 ビットのメモリ・ロケーション、
XMMレジスタまたは128 ビットのメモリ・ロケーションを使用できる。デスティネーション・オペ
ランドは、MMX テクノロジ・レジスタまたはXMM レジスタを使用できる。ソース・データが64
ビットのメモリ・オペランドからであるときは、64 ビット・オペランドのすべてがメモリからアク
セスされるが、命令は上位32 ビットだけを使用する。ソース・データが128 ビット・メモリ・オペ
ランドからのものである場合、プロセッサによっては、適切な64 ビットだけがフェッチされる。こ
の場合も、16バイト境界へのアライメントと通常のセグメント・チェックが適用される。
オペコード命令説明
0F 60 /r PUNPCKLBW mm,
mm/m32
mm およびmm/m64 からmm に下位バイトをアンパックし
てインタリーブする。
66 0F 60 /r PUNPCKLBW xmm1,
xmm2/m128
xmm1 およびxmm2/m128 からxmm1 に下位バイトをアン
パックしてインタリーブする。
0F 61 /r PUNPCKLWD mm,
mm/m32
mm およびmm/m64 からmm に下位ワードをアンパックし
てインタリーブする。
66 0F 61 /r PUNPCKLWD xmm1,
xmm2/m128
xmm1 およびxmm2/m128 からxmm1 に下位ワードをアン
パックしてインタリーブする。
0F 62 /r PUNPCKLDQ mm,
mm/m32
mm およびmm/m64 からmm に下位ダブルワードをアン
パックしてインタリーブする。
66 0F 62 /r PUNPCKLDQ xmm1,
xmm2/m128
xmm1 およびxmm2/m128 からxmm1 に下位ダブルワード
をアンパックしてインタリーブする。
66 0F 6C /r PUNPCKLQDQ xmm1,
xmm2/m128
xmm1 およびxmm2/m128 からxmm1 レジスタに下位ク
ワッドワードをアンパックしてインタリーブする。
図3-15. 64 ビット・オペランドを使用したPUNPCKLBW 命令の動作
Y3 X3 Y2 X2 Y1 X1 Y0 X0
SRC Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 X7 X6 X5 X4 X3 X2 X1 X0 DEST
DEST
3-629
命令セット・リファレンス
PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ?Unpack
Low Data ( 続き)
PUNPCKLBW命令は、ソース・オペランドとデスティネーション・オペランドの下位バイトをイン
タリーブする。PUNPCKLWD 命令は、ソース・オペランドとデスティネーション・オペランドの下
位ワードをインタリーブする。PUNPCKLDQ 命令は、ソース・オペランドとデスティネーション・
オペランドの下位ダブルワードをインタリーブする。
上記の命令では、ソース・オペランドにすべてゼロを入れることにより、バイトからワード、ワー
ドからダブルワード、ダブルワードからクワッドワード、クワッドワードからダブル・クワッドワー
ドへと、それぞれ変換することができる。ソース・オペランドがすべてゼロである場合、( デスティ
ネーション・オペランドにストアされる) 結果は、デスティネーション・オペランドの元の値の上位
データ要素がゼロ拡張されたものになる。例えば、PUNPCKLBW 命令では、上位バイトがゼロ拡張
され( すなわち、符号なしワード整数にアンパックされる)、PUNPCKLWD命令では、上位ワードが
ゼロ拡張される( 符号なしダブルワード整数にアンパックされる)。
操作
PUNPCKLBW instruction with 64-bit operands:
DEST[63..56] ← SRC[31..24];
DEST[55..48] ← DEST[31..24];
DEST[47..40] ← SRC[23..16];
DEST[39..32] ← DEST[23..16];
DEST[31..24] ← SRC[15..8];
DEST[23..16] ← DEST[15..8];
DEST[15..8] ← SRC[7..0];
DEST[7..0] ← DEST[7..0];
PUNPCKLWD instruction with 64-bit operands:
DEST[63..48] ← SRC[31..16];
DEST[47..32] ← DEST[31..16];
DEST[31..16] ← SRC[15..0];
DEST[15..0] ← DEST[15..0];
PUNPCKLDQ instruction with 64-bit operands:
DEST[63..32] ← SRC[31..0];
DEST[31..0] ← DEST[31..0];
PUNPCKLBW instruction with 128-bit operands:
DEST[7-0] ← DEST[7-0];
DEST[15-8] ← SRC[7-0];
DEST[23-16] ← DEST[15-8];
DEST[31-24] ← SRC[15-8];
DEST[39-32] ← DEST[23-16];
DEST[47-40] ← SRC[23-16];
DEST[55-48] ← DEST[31-24];
DEST[63-56] ← SRC[31-24];
DEST[71-64] ← DEST[39-32];
3-630
命令セット・リファレンス
PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ?Unpack
Low Data ( 続き)
DEST[79-72] ← SRC[39-32];
DEST[87-80] ← DEST[47-40];
DEST[95-88] ← SRC[47-40];
DEST[103-96] ← DEST[55-48];
DEST[111-104] ← SRC[55-48];
DEST[119-112] ← DEST[63-56];
DEST[127-120] ← SRC[63-56];
PUNPCKLWD instruction with 128-bit operands:
DEST[15-0] ← DEST[15-0];
DEST[31-16] ← SRC[15-0];
DEST[47-32] ← DEST[31-16];
DEST[63-48] ← SRC[31-16];
DEST[79-64] ← DEST[47-32];
DEST[95-80] ← SRC[47-32];
DEST[111-96] ← DEST[63-48];
DEST[127-112] ← SRC[63-48];
PUNPCKLDQ instruction with 128-bit operands:
DEST[31-0] ← DEST[31-0];
DEST[63-32] ← SRC[31-0];
DEST[95-64] ← DEST[63-32];
DEST[127-96] ← SRC[63-32];
PUNPCKLQDQ
DEST[63-0] ← DEST[63-0];
DEST[127-64] ← SRC[63-0];
同等のインテルC/C++ コンパイラ組み込み関数
PUNPCKLBW __m64 _mm_unpacklo_pi8 (__m64 m1, __m64 m2)
PUNPCKLBW __m128i _mm_unpacklo_epi8 (__m128i m1, __m128i m2)
PUNPCKLWD __m64 _mm_unpacklo_pi16 (__m64 m1, __m64 m2)
PUNPCKLWD __m128i _mm_unpacklo_epi16 (__m128i m1, __m128i m2)
PUNPCKLDQ __m64 _mm_unpacklo_pi32 (__m64 m1, __m64 m2)
PUNPCKLDQ __m128i _mm_unpacklo_epi32 (__m128i m1, __m128i m2)
PUNPCKLQDQ __m128i _mm_unpacklo_epi64 (__m128i m1, __m128i m2)
影響を受けるフラグ
なし。
3-631
命令セット・リファレンス
PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ?Unpack
Low Data ( 続き)
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0 のEM がセットされた場合。
#NM CR0 のTS がセットされた場合。
#MF 未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
数値例外
なし。
3-632
命令セット・リファレンス
PUSH?Push Word or Doubleword onto the Stack
説明
スタック・ポインタをデクリメントし、次にソース・オペランドをスタックのトップにストアす
る。スタック・セグメントのアドレス・サイズ属性によって、スタック・ポインタのサイズ(16
ビットまたは32 ビット) が決まり、現在のコード・セグメントのオペランド・サイズ属性によっ
て、スタック・ポインタをデクリメントする量(2 バイトまたは4 バイト) が決まる。例えば、これ
らのアドレス・サイズ属性およびオペランド・サイズ属性が32 である場合は、32 ビットのESP レ
ジスタ( スタック・ポインタ) が4 デクリメントされ、それらの属性が16 である場合は、16 ビット
のSP レジスタが2 デクリメントされる。( スタック・セグメントのセグメント・ディスクリプタの
Bフラグによって、スタックのアドレス・サイズ属性が決まり、現在のコード・セグメントのセグ
メント・ディスクリプタのD フラグ( プリフィックスを伴う) によって、オペランド・サイズ属性
およびソース・オペランドのアドレス・サイズ属性が決まる。) スタックのアドレス・サイズ属性
が32 であるときに16 ビット・オペランドをプッシュすると、スタック・ポインタでアライメント
不正が発生することがある( すなわち、スタック・ポインタはダブルワード境界にアライメントが
合っていない)。
PUSH ESP 命令は、命令が実行される前にESP レジスタの値が存在していたようにその値をプッシュ
する。そのため、ESP レジスタがオペランド・アドレスの計算にベース・レジスタとして使用され
るメモリ・オペランドを、PUSH命令が使用すると、ESP レジスタがデクリメントされる前に、オペ
ランドの実効アドレスが計算される。
実アドレス・モードでは、PUSH命令が実行されるときに、ESP レジスタまたはSP レジスタが1 であ
る場合、プロセッサはスタック・スペースの不足によってシャット・ダウンする。この状態を示す
例外は生成されない。
オペコード命令説明
FF /6 PUSH r/m16 r/m16 をプッシュする。
FF /6 PUSH r/m32 r/m32 をプッシュする。
50+rw PUSH r16 r16 をプッシュする。
50+rd PUSH r32 r32 をプッシュする。
6A PUSH imm8 imm8 をプッシュする。
68 PUSH imm16 imm16 をプッシュする。
68 PUSH imm32 imm32 をプッシュする。
0E PUSH CS CS をプッシュする。
16 PUSH SS SS をプッシュする。
1E PUSH DS DS をプッシュする。
06 PUSH ES ES をプッシュする。
0F A0 PUSH FS FS をプッシュする。
0F A8 PUSH GS GS をプッシュする。
3-633
命令セット・リファレンス
PUSH?Push Word or Doubleword onto the Stack ( 続き)
IA-32 アーキテクチャにおける互換性
Intel 286 プロセッサ以降のIA-32 プロセッサでは、PUSH ESP 命令は、命令が実行される前にESP レ
ジスタの値が存在していたようにその値をプッシュする。( このことは、実アドレス・モードまたは
仮想8086 モードでも同じである。) Intel 8086 プロセッサでは、PUSH SP 命令は、(2 デクリメントさ
れた後の値である)SP レジスタの新しい値をプッシュする。
操作
IF StackAddrSize ← 32
THEN
IF OperandSize ← 32
THEN
ESP ← ESP ? 4;
SS:ESP ← SRC; (* push doubleword *)
ELSE (* OperandSize ← 16*)
ESP ← ESP ? 2;
SS:ESP ← SRC; (* push word *)
FI;
ELSE (* StackAddrSize ← 16*)
IF OperandSize ← 16
THEN
SP ← SP ? 2;
SS:SP ← SRC; (* push word *)
ELSE (* OperandSize ← 32*)
SP ← SP ? 4;
SS:SP ← SRC; (* push doubleword *)
FI;
FI;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
3-634
命令セット・リファレンス
PUSH?Push Word or Doubleword onto the Stack ( 続き)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
SP レジスタまたはESP レジスタの新しい値がスタック・セグメントの
範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-635
命令セット・リファレンス
PUSHA/PUSHAD?Push All General-Purpose Registers
説明
汎用レジスタの内容をスタックにプッシュする。レジスタがスタックにストアされる順番は、
( 現在のオペランド・サイズ属性が32 である場合は)EAX、ECX、EDX、EBX、ESP( 元の値)、EBP、
ESI、EDI であり、( オペランド・サイズ属性が16 である場合は)AX、CX、DX、BX、SP( 元の値)、
BP、SI、DI である。これらの命令は、POPA/POPAD 命令の逆の操作を実行する。ESP レジスタまた
はSP レジスタとしてプッシュされる値は、最初のレジスタをプッシュする前のその値である( 下記
の「操作」の項を参照)。
PUSHA( すべてをプッシュ) ニーモニックおよびPUSHAD( すべてのダブルをプッシュ) ニーモニック
は、同じオペコードを参照する。PUSHA命令は、オペランド・サイズ属性が16であるときに使用す
るためのものであり、PUSHAD命令は、オペランド・サイズ属性が32であるときに使用するための
ものである。一部のアセンブラは、PUSHAが使用されるときはオペランド・サイズを16 に、PUSHAD
が使用されるときは32 に強制する。他のアセンブラは、これらのニーモニックをシノニム
(PUSHA/PUSHAD) として取り扱い、オペランド・サイズ属性の現在の設定を使用して、使用される
ニーモニックに関係なく、スタックにプッシュする値のサイズを決定することができる。
実アドレス・モードでは、PUSHA/PUSHAD 命令が実行されるときに、ESP レジスタまたはSP レジ
スタが1、3、または5 である場合、プロセッサはスタック・スペースの不足によってシャット・ダ
ウンする。この状態を示す例外は生成されない。
操作
IF OperandSize ← 32 (* PUSHAD instruction *)
THEN
Temp ← (ESP);
Push(EAX);
Push(ECX);
Push(EDX);
Push(EBX);
Push(Temp);
Push(EBP);
Push(ESI);
Push(EDI);
ELSE (* OperandSize ← 16, PUSHA instruction *)
Temp ← (SP);
Push(AX);
Push(CX);
Push(DX);
Push(BX);
オペコード命令説明
60 PUSHA AX、CX、DX、BX、元のSP、BP、SI、およびDI をプッ
シュする。
60 PUSHAD EAX、ECX、EDX、EBX、元のESP、EBP、ESI、および
EDI をプッシュする。
3-636
命令セット・リファレンス
PUSHA/PUSHAD?Push All General-Purpose Register ( 続き)
Push(Temp);
Push(BP);
Push(SI);
Push(DI);
FI;
影響を受けるフラグ
なし。
保護モード例外
#SS(0) 開始スタック・アドレスまたは終了スタック・アドレスがスタック・セ
グメント内にない場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP ESP レジスタまたはSP レジスタの内容が7、9、11、13、または15 であ
る場合。
仮想8086 モード例外
#GP(0) ESP レジスタまたはSP レジスタの内容が7、9、11、13、または15 であ
る場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-637
命令セット・リファレンス
PUSHF/PUSHFD?Push EFLAGS Register onto the Stack
説明
( 現在のオペランド・サイズ属性が32 である場合は) スタック・ポインタを4 デクリメントし、EFLAGS
レジスタの内容全体をスタックにプッシュする。( オペランド・サイズ属性が16 である場合は) ス
タック・ポインタを2 デクリメントし、EFLAGS レジスタの下位16 ビット( すなわち、FLAGS レジ
スタ) をスタックにプッシュする。( これらの命令は、POPF/POPFD 命令の逆の操作を実行する。)
EFLAGSレジスタ全体をスタックにコピーするときは、VMおよびRFフラグ( ビット16および17) は
コピーされない。その代わりに、これらのフラグの値は、スタックにストアされるEFLAGS イメー
ジでクリアされる。EFLAGS レジスタの詳細については、『IA-32 インテルR アーキテクチャ・ソフト
ウェア・デベロッパーズ・マニュアル、上巻』第3 章の「EFLAGSレジスタ」の項を参照のこと。
PUSHF( フラグをプッシュ) ニーモニックおよびPUSHFD( ダブルのフラグをプッシュ) ニーモニック
は、同じオペコードを参照する。PUSHF 命令は、オペランド・サイズ属性が16であるときに使用す
るためのものであり、PUSHFD命令は、オペランド・サイズ属性が32 であるときに使用するための
ものである。一部のアセンブラは、PUSHF が使用されるときはオペランド・サイズを16 に、PUSHFD
が使用されるときは32 に強制する。他のアセンブラは、これらのニーモニックをシノニム
(PUSHF/PUSHFD) として取り扱い、オペランド・サイズ属性の現在の設定を使用して、使用されて
いるニーモニックに関係なく、スタックにプッシュする値のサイズを決定することができる。
仮想8086 モードでI/O特権レベル(IOPL) が3 より小さい場合、PUSHF/PUSHFD命令は一般保護例外
(#GP) を発生させる。
実アドレス・モードでは、PUSHF/PUSHFD命令が実行されるときに、ESP レジスタまたはSP レジス
タが1、3、または5 である場合、プロセッサはスタック・スペースの不足によってシャット・ダウ
ンする。この状態を示す例外は生成されない。
操作
IF (PE=0) OR (PE=1 AND ((VM=0) OR (VM=1 AND IOPL=3)))
(* Real-Address Mode, Protected mode, or Virtual-8086 mode with IOPL equal to 3 *)
THEN
IF OperandSize ← 32
THEN
push(EFLAGS AND 00FCFFFFH);
(* VM and RF EFLAG bits are cleared in image stored on the stack*)
ELSE
push(EFLAGS); (* Lower 16 bits only *)
FI;
ELSE (* In Virtual-8086 Mode with IOPL less than 0 *)
#GP(0); (* Trap to virtual-8086 monitor *)
FI;
オペコード命令説明
9C PUSHF EFLAGS の下位16 ビットをプッシュする。
9C PUSHFD EFLAGS をプッシュする。
3-638
命令セット・リファレンス
PUSHF/PUSHFD?Push EFLAGS Register onto the Stack ( 続き)
影響を受けるフラグ
なし。
保護モード例外
#SS(0) ESP レジスタの新しい値がスタック・セグメントの境界外にある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
なし。
仮想8086 モード例外
#GP(0) I/O 特権レベルが3 より小さい場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-639
命令セット・リファレンス
PXOR?Logical Exclusive OR
説明
ソース・オペランド( 第2 オペランド) とデスティネーション・オペランド( 第1 オペランド) との間
のビット単位のXOR( 排他的論理和) 演算を実行し、結果をデスティネーション・オペランドにスト
アする。ソース・オペランドには、MMX テクノロジ・レジスタまたは64 ビットのメモリ・ロケー
ション、XMMレジスタまたは128 ビットのメモリ・ロケーションを使用できる。デスティネーショ
ン・オペランドは、MMXテクノロジ・レジスタまたはXMMレジスタを使用できる。各ビットの結
果は、2 つのオペランドの対応するビットが異なる場合は1 になり、同じ場合は0 になる。
操作
DEST ← DEST XOR SRC;
同等のインテルC/C++ コンパイラ組み込み関数
PXOR __m64 _mm_xor_si64 (__m64 m1, __m64 m2)
PXOR __m128i _mm_xor_si128 ( __m128i a, __m128i b)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
（128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）現行特権レベルが3 のときに、アライメント・チェッ
クがイネーブルにされていて、アライメントが合わないメモリ参照が行
われた場合。
オペコード命令説明
0F EF /r PXOR mm, mm/m64 mm/m64 とmm のビット単位のXOR（排他的論理
和）演算を実行する。
66 0F EF /r PXOR xmm1, xmm2/m128 xmm2/m128 とxmm1 のビット単位のXOR（排他的
論理和）演算を実行する。
3-640
命令セット・リファレンス
PXOR?Logical Exclusive OR ( 続き)
実アドレス・モード例外
#GP(0) （128 ビット操作のみ）セグメントに関係なく、メモリ・オペランドのア
ライメントが16 バイトに合っていない場合。
オペランドのいずれかの部分が実効アドレス空間0 〜 FFFFH の外にあ
る場合。
#UD CR0 のEM がセットされた場合。
（128 ビット操作のみ）CR4 のOSFXSR が0 の場合。
（128 ビット操作のみ）CPUID 機能フラグSSE2 が0 の場合。
#NM CR0 のTS がセットされた場合。
#MF （64 ビット操作のみ）未処理のx87 FPU 例外がある場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) （64 ビット操作のみ）アライメント・チェックがイネーブルにされてい
て、アライメントが合わないメモリ参照が行われた場合。
数値例外
なし。
3-641
命令セット・リファレンス
RCL/RCR/ROL/ROR?Rotate
オペコード命令説明
D0 /2 RCL r/m8,1 9 ビット(CF、r/m8) を左に1 回回転させる。
D2 /2 RCL r/m8,CL 9 ビット(CF、r/m8) を左にCL 回回転させる。
C0 /2 ib RCL r/m8,imm8 9 ビット(CF、r/m8) を左にimm8 回回転させる。
D1 /2 RCL r/m16,1 17 ビット(CF、r/m16) を左に1 回回転させる。
D3 /2 RCL r/m16,CL 17 ビット(CF、r/m16) を左にCL 回回転させる。
C1 /2 ib RCL r/m16,imm8 17 ビット(CF、r/m16) を左にimm8 回回転させる。
D1 /2 RCL r/m32,1 33 ビット(CF、r/m32) を左に1 回回転させる。
D3 /2 RCL r/m32,CL 33 ビット(CF、r/m32) を左にCL 回回転させる。
C1 /2 ib RCL r/m32,imm8 33 ビット(CF、r/m32) を左にimm8 回回転させる。
D0 /3 RCR r/m8,1 9 ビット(CF、r/m8) を右に1 回回転させる。
D2 /3 RCR r/m8,CL 9 ビット(CF、r/m8) を右にCL 回回転させる。
C0 /3 ib RCR r/m8,imm8 9 ビット(CF、r/m8) を右にimm8 回回転させる。
D1 /3 RCR r/m16,1 17 ビット(CF、r/m16) を右に1 回回転させる。
D3 /3 RCR r/m16,CL 17 ビット(CF、r/m16) を右にCL 回回転させる。
C1 /3 ib RCR r/m16,imm8 17 ビット(CF、r/m16) を右にimm8 回回転させる。
D1 /3 RCR r/m32,1 33 ビット(CF、r/m32) を右に1 回回転させる。
D3 /3 RCR r/m32,CL 33 ビット(CF、r/m32) を右にCL 回回転させる。
C1 /3 ib RCR r/m32,imm8 33 ビット(CF、r/m32) を右にimm8 回回転させる。
D0 /0 ROL r/m8,1 8 ビットr/m8 を左に1 回回転させる。
D2 /0 ROL r/m8,CL 8 ビットr/m8 を左にCL 回回転させる。
C0 /0 ib ROL r/m8,imm8 8 ビットr/m8 を左にimm8 回回転させる。
D1 /0 ROL r/m16,1 16 ビットr/m16 を左に1 回回転させる。
D3 /0 ROL r/m16,CL 16 ビットr/m16 を左にCL 回回転させる。
C1 /0 ib ROL r/m16,imm8 16 ビットr/m16 を左にimm8 回回転させる。
D1 /0 ROL r/m32,1 32 ビットr/m32 を左に1 回回転させる。
D3 /0 ROL r/m32,CL 32 ビットr/m32 を左にCL 回回転させる。
C1 /0 ib ROL r/m32,imm8 32 ビットr/m32 を左にimm8 回回転させる。
D0 /1 ROR r/m8,1 8 ビットr/m8 を右に1 回回転させる。
D2 /1 ROR r/m8,CL 8 ビットr/m8 を右にCL 回回転させる。
C0 /1 ib ROR r/m8,imm8 8 ビットr/m8 を右にimm8 回回転させる。
D1 /1 ROR r/m16,1 16 ビットr/m16 を右に1 回回転させる。
D3 /1 ROR r/m16,CL 16 ビットr/m16 を右にCL 回回転させる。
C1 /1 ib ROR r/m16,imm8 16 ビットr/m16 を右にimm8 回回転させる。
D1 /1 ROR r/m32,1 32 ビットr/m32 を右に1 回回転させる。
D3 /1 ROR r/m32,CL 32 ビットr/m32 を右にCL 回回転させる。
C1 /1 ib ROR r/m32,imm8 32 ビットr/m32 を右にimm8 回回転させる。
3-642
命令セット・リファレンス
RCL/RCR/ROL/ROR-?Rotate ( 続き)
説明
第1 オペランド( デスティネーション・オペランド) のビットを第2 オペランド( カウント・オペラン
ド) に指定されたビット位置の数だけシフトし( 回転させ)、結果をデスティネーション・オペランド
にストアする。デスティネーション・オペランドには、レジスタまたはメモリ・ロケーションを使
用できる。カウント・オペランドは、即値またはCL レジスタの値が可能で、符号なし整数である。
プロセッサは、最下位5 ビットを除くカウント・オペランドのすべてのビットをマスクして、カウン
トを0 から31 までの数に制限する。
左に回転(ROL) 命令およびキャリーを通じて左に回転(RCL) 命令は、すべてのビットを最上位ビット
位置の方向にシフトするが、最上位ビットだけは最下位ビット・ロケーションに回転される(『IA-32
インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図7-11. を参照)。
右に回転(ROR) 命令およびキャリーを通じて右に回転(RCR) 命令は、すべてのビットを最下位ビット
位置の方向にシフトするが、最下位ビットだけは最上位ビット・ロケーションに回転される(『IA-32
インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図7-11. を参照)。
RCL命令およびRCR命令は、回転の中にCFフラグを含める。RCL命令は、CF フラグを最下位ビッ
トにシフトさせ、最上位ビットをCF フラグにシフトさせる(『IA-32 インテルR アーキテクチャ・ソ
フトウェア・デベロッパーズ・マニュアル、上巻』の図7-11. を参照)。RCR命令は、CFフラグを最
上位ビットにシフトさせ、最下位ビットをCF フラグにシフトさせる(『IA-32 インテルR アーキテク
チャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図7-11. を参照)。ROL命令およびROR
命令では、CFフラグの元の値は結果には含められないが、CFフラグには1 端からもう1 端にシフト
されたビットのコピーが入る。
OF フラグは、1 ビットの回転だけに定義され、( どのフラグにも影響を与えないゼロ・ビットの回
転が何も行わないことを除いて) その他のすべての場合は未定義である。左回転では、OFフラグは、
( 回転後の)CF ビットと結果の最上位ビットとの排他的論理和に設定される。右回転では、OF フラ
グは、結果の最上位2 ビットの排他的論理和に設定される。
IA-32 アーキテクチャにおける互換性
8086 は、回転カウントをマスクしない。ただし、(Intel 286 プロセッサから始まる) 他のすべての
IA-32 プロセッサは、回転カウントを5 ビットにマスクするので、最大カウントは31 になる。この
マスク設定は( 仮想8086 モードを含めた) すべての動作モードで行われて、命令の最大実行時間を
減少させる。
操作
(* RCL and RCR instructions *)
SIZE ← OperandSize
CASE (determine count) OF
SIZE ← 8: tempCOUNT ← (COUNT AND 1FH) MOD 9;
SIZE ← 16: tempCOUNT ← (COUNT AND 1FH) MOD 17;
SIZE ← 32: tempCOUNT ← COUNT AND 1FH;
ESAC;
(* RCL instruction operation *)
3-643
命令セット・リファレンス
RCL/RCR/ROL/ROR-?Rotate ( 続き)
WHILE (tempCOUNT ≠ 0)
DO
tempCF ← MSB(DEST);
DEST ← (DEST ? 2) + CF;
CF ← tempCF;
tempCOUNT ← tempCOUNT ? 1;
OD;
ELIHW;
IF COUNT ← 1
THEN OF ← MSB(DEST) XOR CF;
ELSE OF is undefined;
FI;
(* RCR instruction operation *)
IF COUNT ← 1
THEN OF ← MSB(DEST) XOR CF;
ELSE OF is undefined;
FI;
WHILE (tempCOUNT ≠ 0)
DO
tempCF ← LSB(SRC);
DEST ← (DEST / 2) + (CF * 2SIZE);
CF ← tempCF;
tempCOUNT ← tempCOUNT ? 1;
OD;
(* ROL and ROR instructions *)
SIZE ← OperandSize
CASE (determine count) OF
SIZE ← 8: tempCOUNT ← COUNT MOD 8;
SIZE ← 16: tempCOUNT ← COUNT MOD 16;
SIZE ← 32: tempCOUNT ← COUNT MOD 32;
ESAC;
(* ROL instruction operation *)
WHILE (tempCOUNT ≠ 0)
DO
tempCF ← MSB(DEST);
DEST ← (DEST ? 2) + tempCF;
tempCOUNT ← tempCOUNT ? 1;
OD;
ELIHW;
CF ← LSB(DEST);
IF COUNT ← 1
THEN OF ← MSB(DEST) XOR CF;
ELSE OF is undefined;
FI;
(* ROR instruction operation *)
3-644
命令セット・リファレンス
RCL/RCR/ROL/ROR-?Rotate ( 続き)
WHILE (tempCOUNT ≠ 0)
DO
tempCF ← LSB(SRC);
DEST ← (DEST / 2) + (tempCF ? 2SIZE);
tempCOUNT ← tempCOUNT ? 1;
OD;
ELIHW;
CF ← MSB(DEST);
IF COUNT ← 1
THEN OF ← MSB(DEST) XOR MSB ? 1(DEST);
ELSE OF is undefined;
FI;
影響を受けるフラグ
CF フラグは、そこにシフトされたビットの値を持つ。OFフラグは、単一ビット回転( 上記の「説明」
の項を参照) の場合だけに影響を受け、複数ビット回転の場合には未定義である。SF、ZF、AF、お
よびPFフラグは影響を受けない。
保護モード例外
#GP(0) ソース・オペランドが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-645
命令セット・リファレンス
RCPPS?Compute Reciprocals of Packed Single-Precision Floating-
Point Values
説明
ソース・オペランド（第2 オペランド）の4 つのパックド単精度浮動小数点値の逆数の近似値をSIMD
計算し、結果のパックド単精度浮動小数点値をデスティネーション・オペランドに格納する。この
近似値の最大相対誤差は(? 1.5 * 2-12) である。ソース・オペランドは、XMMレジスタまたは128 ビッ
トのメモリ・ロケーションである。デスティネーション・オペランドはXMMレジスタである。単精
度浮動小数点値のSIMD 演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッ
パーズ・マニュアル、上巻』の図10-5. を参照のこと。
RCPSS 命令は、MXCSR レジスタの丸め制御ビットの影響を受けない。ソースの値が0.0 の場合は、
ソースの値と同じ符号の∞が返される。ソースの値がデノーマルの場合は、（同じ符号の）0.0 とし
て処理される。アンダーフローの結果は、常に、オペランドと同じ符号の0.0 にフラッシュされる。
ソースの値がSNaNまたはQNaNの場合は、QNaNに変換されたSNaNか、ソースのQNaNが返される。
操作
DEST[31-0] ← APPROXIMATE(1.0/(SRC[31-0]));
DEST[63-32] ← APPROXIMATE(1.0/(SRC[63-32]));
DEST[95-64] ← APPROXIMATE(1.0/(SRC[95-64]));
DEST[127-96] ← APPROXIMATE(1.0/(SRC[127-96]));
同等のインテルC/C++ コンパイラ組み込み関数
RCCPS __m128 _mm_rcp_ps(__m128 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
0F 53 /r RCPPS xmm1, xmm2/m128 xmm2/m128 のパックド単精度浮動小数点値の逆数の
近似値を計算し、その結果をxmm1 にストアする。
3-646
命令セット・リファレンス
RCPPS?Compute Reciprocals of Packed Single-Precision Floating-
Point Values ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-647
命令セット・リファレンス
RCPSS?Compute Reciprocal of Scalar Single-Precision Floating-Point
Values
説明
ソース・オペランド（第2 オペランド）の最下位の単精度浮動小数点値の逆数の近似値を計算し、
結果の単精度浮動小数点値をデスティネーション・オペランドに格納する。この近似値の最大相対
誤差は(? 1.5 * 2-12) である。ソース・オペランドは、XMMレジスタまたは32 ビットのメモリ・ロ
ケーションである。デスティネーション・オペランドはXMMレジスタである。デスティネーショ
ン・オペランドの上位3 つのダブルワードは変更されない。単精度浮動小数点値のスカラ演算の図
は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図
10-6. を参照のこと。
RCPSS 命令は、MXCSR レジスタの丸め制御ビットの影響を受けない。ソースの値が0.0 の場合は、
ソースの値と同じ符号の∞が返される。ソースの値がデノーマルの場合は、（同じ符号の）0.0 とし
て処理される。アンダーフローの結果は、常に、オペランドと同じ符号の0.0 にフラッシュされる。
ソースの値がSNaNまたはQNaNの場合は、QNaNに変換されたSNaNか、ソースのQNaNが返される。
操作
DEST[31-0] ← APPROX (1.0/(SRC[31-0]));
* DEST[127-32] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
RCPSS __m128 _mm_rcp_ss(__m128 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
F3 0F 53 /r RCPSS xmm1, xmm2/m32 xmm2/m128 のスカラ単精度浮動小数点値の逆数の近
似値を計算し、その結果をxmm1 にストアする。
3-648
命令セット・リファレンス
RCPSS?Compute Reciprocal of Scalar Single-Precision Floating-Point
Values ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
現行特権レベルが3 のときに、アライメントの合っていないメモリ参照
を行った場合。
3-649
命令セット・リファレンス
RDMSR?Read from Model Specific Register
説明
ECXレジスタに指定された64ビットのモデル固有レジスタ(MSR)の内容をレジスタEDX:EAXにロー
ドする。ECXレジスタにロードされる入力値は、読み取られるMSRのアドレスである。EDXレジス
タにはMSRの上位32 ビットがロードされ、EAXレジスタには下位32 ビットがロードされる。読み
取られるMSRに64 より少ないビットしかインプリメントされていない場合は、インプリメントされ
ていないビット・ロケーションでEDX:EAXに返される値は未定義である。
この命令は、特権レベル0 または実アドレス・モードで実行しなければならない。そうしないと、一
般保護例外#GP(0) が生成される。予約されているかまたはインプリメントされていないMSRアドレ
スをECXに指定しても、一般保護例外が生成される。
MSR は、テスト機能、実行トレース、性能モニタリング、およびマシン・チェック・エラーの機能
を制御する。『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、下
巻』付録B「モデル固有レジスタ(MSR)」では、この命令で読み取ることができるすべてのMSR と
それらのアドレスを一覧している。各プロセッサ・ファミリは、独自に一連のMSRを持っているこ
とに注意すること。
この命令を使用する前に、MSRがサポートされている(EDX[5]=1) かどうかを判断するため、CPUID
命令を使用する必要がある。
IA-32 アーキテクチャにおける互換性
MSRおよびRDMSR命令でそれらを読み取る機能は、Pentium プロセッサでIA-32 アーキテクチャに
導入された。Pentium プロセッサより以前のIA-32 プロセッサでこの命令を実行すると、無効オペコー
ド例外#UDが生成される。
操作
EDX:EAX ← MSR[ECX];
影響を受けるフラグ
なし。
保護モード例外
#GP(0) 現行特権レベルが0 でない場合。
ECX の値が予約されているかまたはインプリメントされていないMSR
アドレスを指定している場合。
実アドレス・モード例外
#GP CXの値が予約されているまたはインプリメントされていないMSRアド
レスを指定している場合。
オペコード命令説明
0F 32 RDMSR ECX によって指定されるMSR をEDX:EAX にロードする。
3-650
命令セット・リファレンス
RDMSR?Read from Model Specific Register ( 続き)
仮想8086 モード例外
#GP(0) RDMSR 命令は仮想8086 モードでは認識されない。
3-651
命令セット・リファレンス
RDPMC?Read Performance-Monitoring Counters
説明
この命令は、ECXレジスタに指定された40 ビットの性能モニタリング・カウンタの内容をレジスタ
EDX:EAXにロードする。EDXレジスタには、カウンタの上位8 ビットがロードされ、EAXレジスタ
には、下位32 ビットがロードされる。読み込まれるカウンタは、ECXレジスタに格納される符号な
し整数で指定される。P6 プロセッサには、2 個の性能モニタリング・カウンタ(0 および1) があり、
ECXレジスタにそれぞれ0000Hまたは0001Hを入れて指定する。Pentium 4 プロセッサには18 個のカ
ウンタ(0 〜17) があり、それぞれ0000Hから0011Hで指定する。
Pentium 4 プロセッサではパフォーマンス・カウンタの「高速」(32 ビット) 読み込みと「低速」(40
ビット) 読み込みをサポートしているが、これは、ECX レジスタのビット31 で選択される。ビット
31 がセットされている場合、RDPMC 命令は、選択されたパフォーマンス・カウンタの下位32 ビッ
トのみを読み込む。ビット31がクリアされている場合は、カウンタの40 ビットがすべて読み込まれ
る。読み込まれた32 ビット・カウンタはEAX レジスタに返され、EDX レジスタは0 にセットされ
る。Pentium 4 プロセッサでは、全40ビットの読み込みよりも32 ビットの読み込みの方が高速に実行
される。
RDPMC命令を使用すると、特権レベル1、2、または3 で実行しているアプリケーション・コードは、
CR4 レジスタのPCE フラグがセットされている場合に性能モニタリング・カウンタを読み取ること
ができる。この命令は、オペレーティング・システム・プロシージャの呼び出しのオーバヘッドを
被ることなく、アプリケーション・コードが性能モニタリングを行えるように提供されている。
性能モニタリング・カウンタは、デコードされた命令数、受け取った割り込み数、キャッシュ・
ロードの回数などのイベントをカウントするようにプログラムできるイベント・カウンタである。
『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、下巻』付録A
「性能モニタリング・イベント」では、初期のIA-32 プロセッサのPentium 4 プロセッサでカウント
できるイベントを一覧している。
RDPMC命令は、命令をシリアル化しない。すなわち、先行する命令によって発生したすべてのイベ
ントが完了していること、または後続の命令によって発生するイベントが開始していないことを保
証していない。正確なイベント・カウントが必要な場合は、ソフトウェアは、RDPMC命令の前、後、
またはその両方で(CPUID 命令などの) シリアル化命令を挿入しなければならない。
Pentium 4 プロセッサでは、バックツーバック高速読み込みの実行が単調になるという保証はない。
バックツーバック読み込みの単調性を保証するためには、シリアル化命令を2 つのRDPMC命令間に
配置する必要がある。
RDPMC命令は、16 ビット・アドレス指定モードまたは仮想8086 モードで実行することができるが、
ECXレジスタの内容すべてを使用してカウンタを選択し、イベント・カウントはすべてのEAXレジ
スタおよびEDXレジスタにストアされる。
RDPMC 命令は、Pentium Pro プロセッサおよびMMX テクノロジを実装したPentium プロセッサで
IA-32 アーキテクチャに導入された。初期のPentium プロセッサにも性能モニタリング・カウンタが
あるが、RDMSR命令で読み取らなければならない。
オペコード命令説明
0F 33 RDPMC ECX によって指定される性能モニタリング・カウンタを
EDX:EAX に読み込む。
3-652
命令セット・リファレンス
RDPMC?Read Performance-Monitoring Counters ( 続き)
操作
(* P6 and Pentium with MMX processors *)
IF (ECX = 0 OR 1) AND ((CR4.PCE = 1) OR ((CR4.PCE = 0) AND (CPL= 0)))
THEN
EAX ← PMC(ECX)[31:0];
EDX ← PMC(ECX)[39:32];
ELSE (* ECX is not 0 or 1 and/or CR4.PCE is 0 and CPL is 1, 2, or 3 *)
#GP(0); FI;
(* Pentium 4 processors *)
IF (ECX = 0...17) AND ((CR4.PCE = 1) OR ((CR4.PCE = 0) AND (CPL=0 )))
THEN IF ECX[31] = 0
THEN EAX ← PMC(ECX)[31:0]; (* 40-bit read *);
EDX ← PMC(ECX)[39:32];
ELSE IF ECX[31] = 1
THEN EAX ← PMC(ECX)[31:0]; (* 32-bit read *);
EDX ← 0;
FI;
FI;
ELSE (* ECX ≠ 0...17 and/or CR4.PCE is 0 and CPL is 1, 2, or 3 *)
#GP(0); FI;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) 現行特権レベルが0 でなく、CR4 レジスタのPCE フラグがクリアされ
ている場合。
ECX レジスタの値が0 または1 でない場合。
実アドレス・モード例外
#GP CR4 レジスタのPCE フラグがクリアされている場合。
ECX レジスタの値が0 または1 でない場合。
仮想8086 モード例外
#GP(0) CR4 レジスタのPCE フラグがクリアされている場合。
ECX レジスタの値が0 または1 でない場合。
3-653
命令セット・リファレンス
RDTSC?Read Time-Stamp Counter
説明
プロセッサのタイムスタンプ・カウンタの現在の値をEDX:EAXレジスタにロードする。タイムスタ
ンプ・カウンタは、64 ビットのMSR に包含されている。MSR の上位32 ビットがEDX レジスタに
ロードされ、下位32 ビットがEAXレジスタにロードされる。プロセッサは、クロック・サイクルご
とにタイムスタンプ・カウンタMSRをインクリメントし、プロセッサがリセットされるとカウンタ
を0 にリセットする。
CR4 レジスタのタイムスタンプ・ディスエーブル(TSD) フラグは、RDTSC 命令の使用を制限する。
TSDフラグがクリアされていると、RDTSC命令はどの特権レベルでも実行することができる。この
フラグがセットされていると、命令は特権レベル0 だけで実行することができる。特権レベル0 で実
行しているときは、RDMSR命令を使用してタイムスタンプ・カウンタを読み取ることもできる。
RDTSC命令は、シリアル化命令ではない。そのため、カウンタを読み取る前に、前のすべての命令
が実行されるまで待つことをしない。同様に、読み取り操作が行われる前に、後続の命令が実行を
開始している場合もある。
この命令は、PentiumプロセッサでIA-32 アーキテクチャに導入された。
操作
IF (CR4.TSD ← 0) OR ((CR4.TSD ← 1) AND (CPL=0))
THEN
EDX:EAX ← TimeStampCounter;
ELSE (* CR4 is 1 and CPL is 1, 2, or 3 *)
#GP(0)
FI;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) CR4 レジスタのTSD フラグがセットされていて、CPL が0 より大きい
場合。
実アドレス・モード例外
#GP CR4 レジスタのTSD フラグがセットされた場合。
仮想8086 モード例外
#GP(0) CR4 レジスタのTSD フラグがセットされた場合。
オペコード命令説明
0F 31 RDTSC タイムスタンプ・カウンタをEDX:EAX に読み込む。
3-654
命令セット・リファレンス
REP/REPE/REPZ/REPNE /REPNZ?Repeat String Operation Prefix
説明
カウンタ・レジスタ((E)CX) に指定された回数か、またはZF フラグの指定された条件が満たされな
くなるまで、ストリング命令を繰り返す。REP( リピート)、REPE( 等しい間はリピート)、REPNE( 等
しくない間はリピート)、REPZ( ゼロの間はリピート)、およびREPNZ( ゼロでない間はリピート) の
各ニーモニックは、ストリング命令の1 つに付加できるプリフィックスである。REPプリフィックス
は、INS、OUTS、MOVS、LODS、およびSTOS命令に付加することができ、REPE、REPNE、REPZ、
およびREPNZ プリフィックスは、CMPS およびSCAS 命令に付加することができる。(REPZ プリ
フィックスおよびREPNZプリフィックスは、それぞれREPEプリフィックスおよびREPNEプリフィッ
クスのシノニム形式である。) 非ストリング命令とともに使用すると、REPプリフィックスの行動は
未定義である。
オペコード命令説明
F3 6C REP INS r/m8, DX (E)CX のバイトをポートDX からES:[(E)DI] に入力する。
F3 6D REP INS r/m16,DX (E)CX のワードをポートDX からES:[(E)DI] に入力する。
F3 6D REP INS r/m32,DX (E)CX のダブルワードをポートDX からES:[(E)DI] に入力する。
F3 A4 REP MOVS m8,m8 (E)CX のバイトをDS:[(E)SI] からES:[(E)DI] に転送する。
F3 A5 REP MOVS m16,m16 (E)CX のワードをDS:[(E)SI] からES:[(E)DI] に転送する。
F3 A5 REP MOVS m32,m32 (E)CX のダブルワードをDS:[(E)SI] からES:[(E)DI] に転送す
る。
F3 6E REP OUTS DX,r/m8 (E)CX のバイトをDS:[(E)SI] からポートDX に出力する。
F3 6F REP OUTS DX,r/m16 (E)CX のワードをDS:[(E)SI] からポートDX に出力する。
F3 6F REP OUTS DX,r/m32 (E)CX のダブルワードをDS:[(E)SI] からポートDX に出力する。
F3 AC REP LODS AL (E)CX のバイトをDS:[(E)SI] からAL にロードする。
F3 AD REP LODS AX (E)CX のワードをDS:[(E)SI] からAX にロードする。
F3 AD REP LODS EAX (E)CX のダブルワードをDS:[(E)SI] からEAX にロードする。
F3 AA REP STOS m8 ES:[(E)DI] にある(E)CX のバイトをAL で埋める。
F3 AB REP STOS m16 ES:[(E)DI] にある(E)CX のワードをAX で埋める。
F3 AB REP STOS m32 ES:[(E)DI] にある(E)CX のダブルワードをEAX で埋める。
F3 A6 REPE CMPS m8,m8 ES:[(E)DI] とDS:[(E)SI] にある一致していないバイトを探す。
F3 A7 REPE CMPS m16,m16 ES:[(E)DI] とDS:[(E)SI] にある一致していないワードを探す。
F3 A7 REPE CMPS m32,m32 ES:[(E)DI] とDS:[(E)SI] にある一致していないダブルワードを
探す。
F3 AE REPE SCAS m8 ES:[(E)DI] で始まるAL でないバイトを探す。
F3 AF REPE SCAS m16 ES:[(E)DI] で始まるAX でないワードを探す。
F3 AF REPE SCAS m32 ES:[(E)DI] で始まるEAX でないダブルワードを探す。
F2 A6 REPNE CMPS m8,m8 ES:[(E)DI] とDS:[(E)SI] にある一致しているバイトを探す。
F2 A7 REPNE CMPS m16,m16 ES:[(E)DI] とDS:[(E)SI] にある一致しているワードを探す。
F2 A7 REPNE CMPS m32,m32 ES:[(E)DI] とDS:[(E)SI] にある一致しているダブルワードを探
す。
F2 AE REPNE SCAS m8 ES:[(E)DI] で始まるAL を探す。
F2 AF REPNE SCAS m16 ES:[(E)DI] で始まるAX を探す。
F2 AF REPNE SCAS m32 ES:[(E)DI] で始まるEAX を探す。
3-655
命令セット・リファレンス
REP/REPE/REPZ/REPNE /REPNZ?Repeat String Operation Prefix
( 続き)
REPプリフィックスは、一度には1 つのストリング命令だけに適用される。命令ブロックを繰り返す
には、LOOP命令またはその他のループ構造体を使用する。
これらすべてのリピート・プリフィックスは、(E)CXレジスタのカウントが0 にデクリメントされる
まで、関連する命令を繰り返させる( 下記の表を参照)( 現在のアドレス・サイズ属性が32 である場
合)。ECXレジスタがカウンタとして使用され、アドレス・サイズ属性が16 である場合は、CXレジ
スタが使用される。 REPE、REPNE、REPZ、およびREPNZプリフィックスも、各リピート後にZFフ
ラグの状態をチェックし、ZF フラグが指定された状態になければリピート・ループを終了する。両
方の終了条件がテストされるときは、リピート終了の原因は、JECXZ 命令での(E)CX レジスタのテ
スト、またはJZ、JNZ、およびJNE命令でのZF フラグのテストによって判断することができる。
REPE/REPZおよびREPNE/REPNZ プリフィックスを使用すると、CMPS命令およびSCAS命令の両方
が、それらが行う比較の結果に従ってZF フラグに影響を与えるので、ZF フラグを初期化する必要は
ない。
リピート・ストリング操作は、例外または割り込みによって中断されることがある。こうなっても、
レジスタの状態は、例外ハンドラまたは割り込みハンドラからのリターン時にストリング操作を再
開できるように保たれる。ソース・レジスタおよびデスティネーション・レジスタは操作する次の
ストリング要素を指し、EIPレジスタはストリング命令を指し、ECXレジスタは命令の最後の正常な
リピートの後に保持していた値をもつ。これによって、システムの割り込み応答時間に影響を与え
ずに、長いストリング操作を進めることができる。
PEPEまたはREPNEのプリフィックスの付いたCMPS命令またはSCAS命令の実行中にフォルトが発
生すると、EFLAGS の値は命令の実行前の状態にリストアされる。SCAS 命令およびCMPS 命令は
EFLAGS を入力として使用しないので、プロセッサはページ・フォルト・ハンドラの後に命令を再
開することができる。
REP INS命令およびREP OUTS 命令は、注意して使用しなければならない。これらの命令が実行する
レートを処理できないI/O ポートもある。
REP STOS命令は、大きいメモリ・ブロックを初期化する最も速い方法である。
リピート・プリフィックス終了条件1 終了条件2
REP ECX=0 なし
REPE/REPZ ECX=0 ZF=0
REPNE/REPNZ ECX=0 ZF=1
3-656
命令セット・リファレンス
REP/REPE/REPZ/REPNE /REPNZ?Repeat String Operation Prefix
( 続き)
操作
IF AddressSize ← 16
THEN
use CX for CountReg;
ELSE (* AddressSize ← 32 *)
use ECX for CountReg;
FI;
WHILE CountReg ≠ 0
DO
service pending interrupts (if any);
execute associated string instruction;
CountReg ← CountReg ? 1;
IF CountReg ← 0
THEN exit WHILE loop
FI;
IF (repeat prefix is REPZ or REPE) AND (ZF=0)
OR (repeat prefix is REPNZ or REPNE) AND (ZF=1)
THEN exit WHILE loop
FI;
OD;
影響を受けるフラグ
なし。ただし、CMPS命令およびSCAS命令は、EFLAGS レジスタのステータス・フラグを設定する。
例外 ( すべての操作モード)
なし。ただし、リピート・プリフィックスが関係している命令によって例外が生成されることがある。
3-657
命令セット・リファレンス
RET?Return from Procedure
説明
プログラム制御をスタックのトップにあるリターン・アドレスに移す。通常、アドレスはCALL 命
令によってスタックに置かれ、リターンはCALL命令の後に続く命令に対して行われる。
オプションのソース・オペランドは、リターン・アドレスがポップされた後にリリースされるスタッ
ク・バイト数を指定し、デフォルトではなしである。このオペランドは、コール先プロシージャに
渡されてもう必要ないパラメータをスタックからリリースするために使用することができる。これ
は、新しいプロシージャへの切り替えに使用されるCALL 命令が新しいプロシージャのアクセスに
ゼロでないワード・カウントのコール・ゲートを使用するときに使用しなければならない。ここで、
RET 命令のソース・オペランドは、コール・ゲートのワード・カウント・フィールドに指定されて
いるのと同じバイト数を指定しなければならない。
RET命令を使用して、以下の異なる3 つのタイプのリターンを実行することができる。
? near リターン - 現在のコード・セグメント( 現在のCS レジスタの指示先のセグメント) 内にあ
るコール元プロシージャへのリターン。セグメント内リターンともいう。
? far リターン - 現在のコード・セグメントとは異なるセグメント内にあるコール元プロシージャ
へのリターン。セグメント間リターンともいう。
? 特権レベル間far リターン - 現在実行中のプログラムまたはプロシージャの特権レベルとは異な
る特権レベルへのfar リターン。
特権レベル間リターン・タイプは、保護モードでしか実行することができない。near、far、および特
権レベル間の各リターンの詳細については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デ
ベロッパーズ・マニュアル、上巻』第6 章の「CALL とRETによるプロシージャのコール」の節を参
照のこと。
near リターンを実行すると、プロセッサは、リターン命令ポインタ( オフセット) をスタックのトッ
プからEIP レジスタにポップし、新しい命令ポインタでのプログラム実行を開始する。CS レジスタ
は変更されない。
far リターンを実行すると、プロセッサは、リターン命令ポインタをスタックのトップからEIP レジ
スタにポップし、次にセグメント・セレクタをスタックのトップからCS レジスタにポップする。プ
ロセッサは、その後、新しい命令ポインタにある新しいコード・セグメントでのプログラム実行を
開始する。
オペコード命令説明
C3 RET コール元プロシージャにnear リターンする。
CB RET コール元プロシージャにfar リターンする。
C2 iw RET imm16 コール元プロシージャにnear リターンし、imm16 バイト
をスタックからポップする。
CA iw RET imm16 コール元プロシージャにfar リターンし、imm16 バイトを
スタックからポップする。
3-658
命令セット・リファレンス
RET?Return from Procedure ( 続き)
特権レベル間far リターンのメカニズムは、セグメント間リターンと同様であるが、プロセッサが戻
されるコード・セグメントとスタック・セグメントの特権レベルとアクセス権を調べて、制御の転
送を行うことができるかどうかを判断する点が異なる。DS、ES、FS、およびGS セグメント・レジ
スタは、新しい特権レベルではアクセスすることができないセグメントをそれらが参照している場
合は、特権レベル間リターン中にRET命令によってクリアされる。特権レベル間リターンではスタッ
ク・スイッチも行われるので、ESP レジスタおよびSSレジスタがスタックからロードされる。
特権レベル間コール中にパラメータがコール先プロシージャに渡される場合は、RET 命令でオプ
ションのソース・オペランドを使用して、リターン時にパラメータをリリースしなければならない。
この場合は、パラメータは、コール先プロシージャのスタックとコール元プロシージャのスタック
( すなわち、戻されるスタック) から両方ともリリースされる。
操作
(* Near return *)
IF instruction ← near return
THEN;
IF OperandSize ← 32
THEN
IF top 12 bytes of stack not within stack limits THEN #SS(0); FI;
EIP ← Pop();
ELSE (* OperandSize ← 16 *)
IF top 6 bytes of stack not within stack limits
THEN #SS(0)
FI;
tempEIP ← Pop();
tempEIP ← tempEIP AND 0000FFFFH;
IF tempEIP not within code segment limits THEN #GP(0); FI;
EIP ← tempEIP;
FI;
IF instruction has immediate operand
THEN IF StackAddressSize=32
THEN
ESP ← ESP + SRC; (* release parameters from stack *)
ELSE (* StackAddressSize=16 *)
SP ← SP + SRC; (* release parameters from stack *)
FI;
FI;
(* Real-address mode or virtual-8086 mode *)
IF ((PE ← 0) OR (PE ← 1 AND VM ← 1)) AND instruction ← far return
THEN;
IF OperandSize ← 32
THEN
IF top 12 bytes of stack not within stack limits THEN #SS(0); FI;
EIP ← Pop();
3-659
命令セット・リファレンス
RET?Return from Procedure ( 続き)
CS ← Pop(); (* 32-bit pop, high-order 16 bits discarded *)
ELSE (* OperandSize ← 16 *)
IF top 6 bytes of stack not within stack limits THEN #SS(0); FI;
tempEIP ← Pop();
tempEIP ← tempEIP AND 0000FFFFH;
IF tempEIP not within code segment limits THEN #GP(0); FI;
EIP ← tempEIP;
CS ← Pop(); (* 16-bit pop *)
FI;
IF instruction has immediate operand
THEN
SP ← SP + (SRC AND FFFFH); (* release parameters from stack *)
FI;
FI;
(* Protected mode, not virtual-8086 mode *)
IF (PE ← 1 AND VM ← 0) AND instruction ← far RET
THEN
IF OperandSize ← 32
THEN
IF second doubleword on stack is not within stack limits THEN #SS(0); FI;
ELSE (* OperandSize ← 16 *)
IF second word on stack is not within stack limits THEN #SS(0); FI;
FI;
IF return code segment selector is null THEN GP(0); FI;
IF return code segment selector addrsses descriptor beyond diescriptor table limit
THEN GP(selector; FI;
Obtain descriptor to which return code segment selector points from descriptor table
IF return code segment descriptor is not a code segment THEN #GP(selector); FI;
if return code segment selector RPL < CPL THEN #GP(selector); FI;
IF return code segment descriptor is conforming
AND return code segment DPL > return code segment selector RPL
THEN #GP(selector); FI;
IF return code segment descriptor is not present THEN #NP(selector); FI:
IF return code segment selector RPL > CPL
THEN GOTO RETURN-OUTER-PRIVILEGE-LEVEL;
ELSE GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL
FI;
END;FI;
RETURN-SAME-PRIVILEGE-LEVEL:
IF the return instruction pointer is not within ther return code segment limit
THEN #GP(0);
FI;
IF OperandSize=32
THEN
EIP ← Pop();
3-660
命令セット・リファレンス
RET?Return from Procedure ( 続き)
CS ← Pop(); (* 32-bit pop, high-order 16 bits discarded *)
ESP ← ESP + SRC; (* release parameters from stack *)
ELSE (* OperandSize=16 *)
EIP ← Pop();
EIP ← EIP AND 0000FFFFH;
CS ← Pop(); (* 16-bit pop *)
ESP ← ESP + SRC; (* release parameters from stack *)
FI;
RETURN-OUTER-PRIVILEGE-LEVEL:
IF top (16 + SRC) bytes of stack are not within stack limits (OperandSize=32)
OR top (8 + SRC) bytes of stack are not within stack limits (OperandSize=16)
THEN #SS(0); FI;
FI;
Read return segment selector;
IF stack segment selector is null THEN #GP(0); FI;
IF return stack segment selector index is not within its descriptor table limits
THEN #GP(selector); FI;
Read segment descriptor pointed to by return segment selector;
IF stack segment selector RPL ≠ RPL of the return code segment selector
OR stack segment is not a writable data segment
OR stack segment descriptor DPL ≠ RPL of the return code segment selector
THEN #GP(selector); FI;
IF stack segment not present THEN #SS(StackSegmentSelector); FI;
IF the return instruction pointer is not within the return code segment limit THEN #GP(0); FI:
CPL ← ReturnCodeSegmentSelector(RPL);
IF OperandSize=32
THEN
EIP ← Pop();
CS ← Pop(); (* 32-bit pop, high-order 16 bits discarded *)
(* segment descriptor information also loaded *)
CS(RPL) ← CPL;
ESP ← ESP + SRC; (* release parameters from called procedure’s stack *)
tempESP ← Pop();
tempSS ← Pop(); (* 32-bit pop, high-order 16 bits discarded *)
(* segment descriptor information also loaded *)
ESP ← tempESP;
SS ← tempSS;
ELSE (* OperandSize=16 *)
EIP ← Pop();
EIP ← EIP AND 0000FFFFH;
CS ← Pop(); (* 16-bit pop; segment descriptor information also loaded *)
CS(RPL) ← CPL;
ESP ← ESP + SRC; (* release parameters from called procedure’s stack *)
tempESP ← Pop();
3-661
命令セット・リファレンス
RET?Return from Procedure ( 続き)
tempSS ← Pop(); (* 16-bit pop; segment descriptor information also loaded *)
(* segment descriptor information also loaded *)
ESP ← tempESP;
SS ← tempSS;
FI;
FOR each of segment register (ES, FS, GS, and DS)
DO;
IF segment register points to data or non-conforming code segment
AND CPL > segment descriptor DPL; (* DPL in hidden part of segment register *)
THEN (* segment register invalid *)
SegmentSelector ← 0; (* null segment selector *)
FI;
OD;
For each of ES, FS, GS, and DS
DO
IF segment selector index is not within descriptor table limits
OR segment descriptor indicates the segment is not a data or
readable code segment
OR if the segment is a data or non-conforming code segment and the segment
descriptor’s DPL < CPL or RPL of code segment’s segment selector
THEN
segment selector register ← null selector;
OD;
ESP ← ESP + SRC; (* release parameters from calling procedure’s stack *)
影響を受けるフラグ
なし。
保護モード例外
#GP(0) リターン・コードまたはスタック・セグメント・セレクタがヌルの場合。
リターン命令ポインタがリターン・コード・セグメントの範囲内にない
場合。
#GP( セレクタ) リターン・コード・セグメント・セレクタのRPL がCPL より小さい場合。
リターン・コードまたはスタック・セグメント・セレクタ・インデック
スがそのディスクリプタ・テーブルの範囲内にない場合。
リターン・コード・セグメント・ディスクリプタがコード・セグメント
を指定していない場合。
リターン・コード・セグメントが非コンフォーミングであり、セグメン
ト・セレクタのDPL がコード・セグメントのセグメント・セレクタの
RPL に等しくない場合。
リターン・コード・セグメントがコンフォーミングであり、セグメン
ト・セレクタのDPL がコード・セグメントのセグメント・セレクタの
RPL より大きい場合。
3-662
命令セット・リファレンス
RET?Return from Procedure ( 続き)
スタック・セグメントが書き込み可能なデータ・セグメントでない場合。
スタック・セグメント・セレクタRPL がリターン・コード・セグメン
ト・セレクタのRPL に等しくない場合。
スタック・セグメント・ディスクリプタDPL がリターン・コード・セ
グメント・セレクタのRPL に等しくない場合。
#SS(0) スタックのトップ・バイトがスタックの範囲内にない場合。
リターン・スタック・セグメントが存在しない場合。
#NP( セレクタ) リターン・コード・セグメントが存在しない場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ・アクセスが行われた場合。
実アドレス・モード例外
#GP リターン命令ポインタがリターン・コード・セグメントの範囲内にない
場合。
#SS スタックのトップ・バイトがスタックの範囲内にない場合。
仮想8086 モード例外
#GP(0) リターン命令ポインタがリターン・コード・セグメントの範囲内にない
場合。
#SS(0) スタックのトップ・バイトがスタックの範囲内にない場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ・アクセスが行われた場合。
3-663
命令セット・リファレンス
ROL/ROR?Rotate
「RCL/RCR/ROL/ROR?Rotate」を参照のこと。
3-664
命令セット・リファレンス
RSM?Resume from System Management Mode
説明
プログラム制御をシステム管理モード(SMM) からプロセッサがSMM割り込みを受け取ったときに
割り込まれたアプリケーション・プログラムまたはオペレーティング・システム・プロシージャに
戻す。プロセッサの状態は、SMMに入ったときに作成されたダンプからリストアされる。プロセッ
サは、状態リストア中に無効な状態情報を検出すると、シャットダウン状態に入る。以下の無効な
情報がシャットダウンを発生させる可能性がある。
? CR4 の予約ビットのいずれかが1 にセットされている。
? (PG=1 とPE=0) や(NW=1とCD=0) などCR0 のビットの不当な組み合わせ。
? ( インテルPentium プロセッサおよびIntel486 プロセッサのみ) 状態ダンプ・ベース・フィー
ルドにストアされている値が32Kバイト・アライメント・アドレスでない。
モデル固有レジスタの内容は、SMMからのリターンによって影響を受けない。
SMMおよびRSM命令の動作の詳細については、『IA-32 インテルR アーキテクチャ・ソフトウェア・
デベロッパーズ・マニュアル、下巻』第12章「システム管理」を参照のこと。
操作
ReturnFromSSM;
ProcessorState ← Restore(SSMDump);
影響を受けるフラグ
すべて。
保護モード例外
#UD プロセッサがSMM にないときにこの命令を実行しようとした場合。
実アドレス・モード例外
#UD プロセッサがSMM にないときにこの命令を実行しようとした場合。
仮想8086 モード例外
#UD プロセッサがSMM にないときにこの命令を実行しようとした場合。
オペコード命令説明
0F AA RSM 割り込まれたプログラムの動作を再開する。
3-665
命令セット・リファレンス
RSQRTPS?Compute Reciprocals of Square Roots of Packed Single-
Precision Floating-Point Values
説明
ソース・オペランド（第2 オペランド）の4 つのパックド単精度浮動小数点値の平方根の逆数の近似
値をSIMD計算し、結果のパックド単精度浮動小数点値をデスティネーション・オペランドに格納す
る。この近似値の最大相対誤差は(? 1.5 * 2-12) である。ソース・オペランドは、XMMレジスタまた
は128 ビットのメモリ・ロケーションである。デスティネーション・オペランドはXMMレジスタで
ある。単精度浮動小数点値のSIMD演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・
デベロッパーズ・マニュアル、上巻』の図10-5. を参照のこと。
RSQRTPS 命令は、MXCSR レジスタの丸め制御ビットの影響を受けない。ソース値が0.0 の場合、
ソース値の符号の∞が返される。デノーマル・ソース値は、同じ符号の0.0 として処理される。ソー
ス値が-0.0 以外の負の値の場合、浮動小数点の未定義値が返される。アンダーフローの結果は、オ
ペランドの符号を使用して、常に0.0 にフラッシュされる。ソース値がSNaN またはQNaN の場合、
QNaNまたはソースQNaNに変換されるSNaNが返される。
操作
DEST[31-0] ← APPROXIMATE(1.0/SQRT(SRC[31-0]));
DEST[63-32] ← APPROXIMATE(1.0/SQRT(SRC[63-32]));
DEST[95-64] ← APPROXIMATE(1.0/SQRT(SRC[95-64]));
DEST[127-96] ← APPROXIMATE(1.0/SQRT(SRC[127-96]));
同等のインテルC/C++ コンパイラ組み込み関数
RSQRTPS __m128 _mm_rsqrt_ps(__m128 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
オペコード命令説明
0F 52 /r RSQRTPS xmm1,
xmm2/m128
xmm2/m128 のパックド単精度浮動小数点値の平方根の逆
数の近似値を計算し、その結果をxmm1 にストアする。
3-666
命令セット・リファレンス
RSQRTPS?Compute Reciprocals of Square Roots of Packed Single-
Precision Floating-Point Values ( 続き)
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-667
命令セット・リファレンス
RSQRTSS?Compute Reciprocal of Square Root of Scalar Single-
Precision Floating-Point Value
説明
ソース・オペランド（第2 オペランド）の最下位の単精度浮動小数点値の平方根の逆数の近似値を
計算し、結果の単精度浮動小数点値をデスティネーション・オペランドに格納する。この近似値の
最大相対誤差は(? 1.5 * 2-12) である。ソース・オペランドは、XMMレジスタまたは32 ビットのメ
モリ・ロケーションである。デスティネーション・オペランドはXMMレジスタである。デスティ
ネーション・オペランドの上位3 つのダブルワードは変更されない。単精度浮動小数点値のスカラ
演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上
巻』の図10-6. を参照のこと。
RSQRTPS 命令は、MXCSR レジスタの丸め制御ビットの影響を受けない。ソース値が0.0 の場合、
ソース値の符号の∞が返される。デノーマル・ソース値は、同じ符号の0.0 として処理される。ソー
ス値が-0.0 以外の負の値の場合、浮動小数点の未定義値が返される。アンダーフローの結果は、オ
ペランドの符号を使用して、常に0.0 にフラッシュされる。ソース値がSNaN またはQNaN の場合、
QNaNまたはソースQNaNに変換されるSNaNが返される。
操作
DEST[31-0] ← APPROXIMATE(1.0/SQRT(SRC[31-0]));
* DEST[127-32] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
RSQRTSS __m128 _mm_rsqrt_ss(__m128 a)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
F3 0F 52 /r RSQRTSS xmm1,
xmm2/m32
xmm2/m128 の下位の単精度浮動小数点値の平方根の逆数
の近似値を計算し、その結果をxmm1 にストアする。
3-668
命令セット・リファレンス
RSQRTSS?Compute Reciprocal of Square Root of Scalar Single-
Precision Floating-Point Value ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-669
命令セット・リファレンス
SAHF?Store AH into Flags
説明
EFLAGSレジスタのSF、ZF、AF、PF、およびCFフラグにAHレジスタの対応するビット( それぞれ
ビット7、6、4、2、および0) からの値をロードする。レジスタAH のビット1、3、および5 は無視
される。EFLAGSレジスタの対応する予約ビット(1、3、および5) は、以下の「操作」の項に示すよ
うに残る。
操作
EFLAGS(SF:ZF:0:AF:0:PF:1:CF) ← AH;
影響を受けるフラグ
SF、ZF、AF、PF、およびCF フラグにAH レジスタからの値がロードされる。EFLAGS レジスタの
ビット1、3、および5 は影響を受けず、それぞれ1、0、および0 の値が残る。
例外 ( すべての操作モード)
なし。
オペコード命令Clocks 説明
9E SAHF 2 9E SF、ZF、AF、PF、およびCF をAH から
EFLAGS レジスタにロードする。
3-670
命令セット・リファレンス
SAL/SAR/SHL/SHR?Shift
注:
* IDIV と同じ除算形式ではないことに注意されたい。負の無限大方向に丸められる。
オペコード命令説明
D0 /4 SAL r/m8,1 r/m8 に2 を1 回掛ける。
D2 /4 SAL r/m8,CL r/m8 に2 をCL 回掛ける。
C0 /4 ib SAL r/m8,imm8 r/m8 に2 をimm8 回掛ける。
D1 /4 SAL r/m16,1 r/m16 に2 を1 回掛ける。
D3 /4 SAL r/m16,CL r/m16 に2 をCL 回掛ける。
C1 /4 ib SAL r/m16,imm8 r/m16 に2 をimm8 回掛ける。
D1 /4 SAL r/m32,1 r/m32 に2 を1 回掛ける。
D3 /4 SAL r/m32,CL r/m32 に2 をCL 回掛ける。
C1 /4 ib SAL r/m32,imm8 r/m32 に2 をimm8 回掛ける。
D0 /7 SAR r/m8,1 r/m8 を2 で1 回符号付き除算する。*
D2 /7 SAR r/m8,CL r/m8 を2 でCL 回符号付き除算する。*
C0 /7 ib SAR r/m8,imm8 r/m8 を2 でimm8 回符号付き除算する。*
D1 /7 SAR r/m16,1 r/m16 を2 で1 回符号付き除算する。*
D3 /7 SAR r/m16,CL r/m16 を2 でCL 回符号付き除算する。*
C1 /7 ib SAR r/m16,imm8 r/m16 を2 でimm8 回符号付き除算する。*
D1 /7 SAR r/m32,1 r/m32 を2 で1 回符号付き除算する。*
D3 /7 SAR r/m32,CL r/m32 を2 でCL 回符号付き除算する。*
C1 /7 ib SAR r/m32,imm8 r/m32 を2 でimm8 回符号付き除算する。*
D0 /4 SHL r/m8,1 r/m8 に2 を1 回掛ける。
D2 /4 SHL r/m8,CL r/m8 に2 をCL 回掛ける。
C0 /4 ib SHL r/m8,imm8 r/m8 に2 をimm8 回掛ける。
D1 /4 SHL r/m16,1 r/m16 に2 を1 回掛ける。
D3 /4 SHL r/m16,CL r/m16 に2 をCL 回掛ける。
C1 /4 ib SHL r/m16,imm8 r/m16 に2 をimm8 回掛ける。
D1 /4 SHL r/m32,1 r/m32 に2 を1 回掛ける。
D3 /4 SHL r/m32,CL r/m32 に2 をCL 回掛ける。
C1 /4 ib SHL r/m32,imm8 r/m32 に2 をimm8 回掛ける。
D0 /5 SHR r/m8,1 r/m8 を2 で1 回符号なし除算する。
D2 /5 SHR r/m8,CL r/m8 を2 でCL 回符号なし除算する。
C0 /5 ib SHR r/m8,imm8 r/m8 を2 でimm8 回符号なし除算する。
D1 /5 SHR r/m16,1 r/m16 を2 で1 回符号なし除算する。
D3 /5 SHR r/m16,CL r/m16 を2 でCL 回符号なし除算する。
C1 /5 ib SHR r/m16,imm8 r/m16 を2 でimm8 回符号なし除算する。
D1 /5 SHR r/m32,1 r/m32 を2 で1 回符号なし除算する。
D3 /5 SHR r/m32,CL r/m32 を2 でCL 回符号なし除算する。
C1 /5 ib SHR r/m32,imm8 r/m32 を2 でimm8 回符号なし除算する。
3-671
命令セット・リファレンス
SAL/SAR/SHL/SHR?Shift ( 続き)
説明
第1 オペランド( デスティネーション・オペランド) のビットを第2 オペランド( カウント・オペラン
ド) に指定されたビット数だけ左または右にシフトする。デスティネーション・オペランドの境界を
超えてシフトされるビットは、まずCF フラグにシフトされ、次に捨てられる。シフト操作の最後で
は、CF フラグには、デスティネーション・オペランドから最後にシフトされたビットが含まれる。
デスティネーション・オペランドには、レジスタまたはメモリ・ロケーションを使用できる。カウ
ント・オペランドには、即値またはレジスタCLを使用できる。カウントは、5 ビットにマスクされ、
0 から31 までのカウント範囲に制限される。1 のカウントに対しては、特別なオペコード・エンコー
ディングが備えられている。
左への算術シフト(SAL) 命令および左への論理シフト(SHL) 命令は、同じ操作を実行しする。すなわ
ち、デスティネーション・オペランドのビットを左( 上位ビット・ロケーションの方向) にシフトす
る。シフト・カウントごとに、デスティネーション・オペランドの最上位ビットがCF フラグにシフ
トされ、最下位ビットはクリアされる(『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッ
パーズ・マニュアル、上巻』の図7-7. を参照)。
右への算術シフト(SAR) 命令および右への論理シフト(SHR) 命令は、デスティネーション・オペラ
ンドのビットを右( 下位ビット・ロケーションの方向) にシフトする。シフト・カウントごとに、デ
スティネーション・オペランドの最下位ビットがCF フラグにシフトされ、最上位ビットは、命令
タイプに応じてセットまたはクリアされる。SHR命令は、最上位ビットをクリアする(『IA-32 イン
テルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図7-8. を参照のこ
と)。SAR命令は、デスティネーション・オペランドの元の値の符号( 最上位ビット) に相当するよ
うに最上位ビットをセットまたはクリアする。実際上、SAR命令は、空のビット位置のシフトされ
た値をシフトされていない値の符号で埋める(『IA-32 インテルR アーキテクチャ・ソフトウェア・
デベロッパーズ・マニュアル、上巻』の図7-9. を参照のこと)。
SAR 命令およびSHR 命令を使用して、それぞれデスティネーション・オペランドに2 の累乗による
符号付きまたは符号なしの除算を行うことができる。例えば、 SAR命令を使用して符号付き整数を1
ビット右にシフトすることは、値を2 で割ることになる。
SAR命令を使用して除算演算を実行しても、IDIV 命令と同じ結果は生成されない。IDIV命令の商は
ゼロ方向に丸められるのに対し、SAR命令の「商」は負の無限大方向に丸められる。この違いは、負
の数に対してだけ明白である。例えば、IDIV 命令を使用して-9 を4 で除算すると、結果は-2 であり、
剰余は-1 である。SAR 命令を使用して-9 を右に2 ビットだけシフトすると、結果は-3 であり、「剰
余」は+3 である。ただし、SAR命令は、剰余の最上位ビットだけを(CF フラグに) ストアする。
OF フラグは、1 ビット・シフトの場合だけに影響を受ける。左シフトでは、結果の最上位ビットが
CF フラグと同じである( すなわち、元のオペランドの最上位2 ビットが同じである) 場合は、OF フ
ラグは0 にクリアされ、そうでない場合は1 にセットされる。SAR 命令では、OF フラグはすべての
1 ビット・シフトでクリアされる。SHR 命令では、OF フラグは元のオペランドの最上位ビットに設
定される。
3-672
命令セット・リファレンス
SAL/SAR/SHL/SHR?Shift ( 続き)
IA-32 アーキテクチャにおける互換性
8086 は、シフト・カウントをマスクしない。しかし、(Intel 286 プロセッサで始まる) その他のすべて
のIA-32 プロセッサは、シフト・カウントを5 ビットにマスクするので、最大カウントは31 になる。
このマスク設定は、( 仮想8086 モードを含めた) すべての動作モードで行われ、命令の最大実行時間
を減少させる。
操作
tempCOUNT ← (COUNT AND 1FH);
tempDEST ← DEST;
WHILE (tempCOUNT ≠ 0)
DO
IF instruction is SAL or SHL
THEN
CF ← MSB(DEST);
ELSE (* instruction is SAR or SHR *)
CF ← LSB(DEST);
FI;
IF instruction is SAL or SHL
THEN
DEST ← DEST ? 2;
ELSE
IF instruction is SAR
THEN
DEST ← DEST / 2 (*Signed divide, rounding toward negative infinity*);
ELSE (* instruction is SHR *)
DEST ← DEST / 2 ; (* Unsigned divide *);
FI;
FI;
tempCOUNT ← tempCOUNT ? 1;
OD;
(* Determine overflow for the various instructions *)
IF COUNT ← 1
THEN
IF instruction is SAL or SHL
THEN
OF ← MSB(DEST) XOR CF;
ELSE
IF instruction is SAR
THEN
OF ← 0;
ELSE (* instruction is SHR *)
OF ← MSB(tempDEST);
FI;
FI;
3-673
命令セット・リファレンス
SAL/SAR/SHL/SHR?Shift ( 続き)
ELSE IF COUNT ← 0
THEN
All flags remain unchanged;
ELSE (* COUNT neither 1 or 0 *)
OF ← undefined;
FI;
FI;
影響を受けるフラグ
CFフラグは、デスティネーション・オペランドから最後にシフトされたビットの値をもつ。このフ
ラグは、カウントがデスティネーション・オペランドの( ビットでの) サイズ以上であるSHL命令と
SHR 命令では未定義である。OF フラグは、1 ビット・シフトの場合だけに影響を受け( 上記の「説
明」の項を参照)、その他の場合は未定義である。SF、ZF、およびPF フラグは、結果に従って設定
される。カウントが0 である場合は、フラグは影響を受けない。カウントがゼロでない場合は、AF
フラグは未定義である。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-674
命令セット・リファレンス
SBB?Integer Subtraction with Borrow
説明
ソース・オペランド( 第2 オペランド) とキャリー(CF) フラグを加算し、結果をデスティネーション・
オペランド( 第1 オペランド) から引く。減算の結果は、デスティネーション・オペランドにストア
される。デスティネーション・オペランドには、レジスタまたはメモリ・ロケーションを使用でき
る。ソース・オペランドには、即値、レジスタ、またはメモリ・ロケーションを使用できる。( ただ
し、1 つの命令で2 つのメモリ・オペランドを使用することはできない。) CFフラグの状態は、前の
減算からのボローを表す。
即値をオペランドとして使用すると、デスティネーション・オペランドのフォーマットの長さまで
符号拡張される。
SBB 命令は、符号付きオペランドと符号なしオペランドとを区別しない。その代わりに、プロセッ
サは、両方のデータ型の結果を評価し、OF フラグとCF フラグを設定して、それぞれ符号付きの結
果または符号なしの結果のボローを示す。SF フラグは、符号付き結果の符号を示す。
通常、SBB命令は、SUB命令の後にSBB命令が続く複数バイトまたは複数ワードの除算の一部とし
て実行される。
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
DEST ← DEST ? (SRC + CF);
影響を受けるフラグ
OF、SF、ZF、AF、PF、およびCFフラグが結果に従って設定される。
オペコード命令説明
1C ib SBB AL,imm8 AL から imm8 をボローありで引く。
1D iw SBB AX,imm16 AX から imm16 をボローありで引く。
1D id SBB EAX,imm32 EAX から imm32 をボローありで引く。
80 /3 ib SBB r/m8,imm8 r/m8 からimm8 をボローありで引く。
81 /3 iw SBB r/m16,imm16 r/m16 からimm16 をボローありで引く。
81 /3 id SBB r/m32,imm32 r/m32 からimm32 をボローありで引く。
83 /3 ib SBB r/m16,imm8 r/m16 から符号拡張されたimm8 をボローありで引く。
83 /3 ib SBB r/m32,imm8 r/m32 から符号拡張されたimm8 をボローありで引く。
18 /r SBB r/m8,r8 r/m8 からr8 をボローありで引く。
19 /r SBB r/m16,r16 r/m16 からr16 をボローありで引く。
19 /r SBB r/m32,r32 r/m32 からr32 をボローありで引く。
1A /r SBB r8,r/m8 r8 からr/m8 をボローありで引く。
1B /r SBB r16,r/m16 r16 からr/m16 をボローありで引く。
1B /r SBB r32,r/m32 r32 からr/m32 をボローありで引く。
3-675
命令セット・リファレンス
SBB?Integer Subtraction with Borrow ( 続き)
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-676
命令セット・リファレンス
SCAS/SCASB/SCASW/SCASD?Scan String
説明
メモリ・オペランドで指定されたバイト、ワード、またはダブルワードを、AL、AX、またはEAX
レジスタの値と比較し、結果に従ってEFLAGSレジスタのステータス・フラグを設定する。メモリ・
オペランド・アドレスは、( 命令のアドレス・サイズ属性、32 または16 に応じて) それぞれES:EDI
レジスタまたはES:DI レジスタから読み取られる。) ESセグメントは、セグメント・オーバライド・
プリフィックスでオーバライドすることはできない。
アセンブリ・コード・レベルでは、この命令の「明示オペランド」形式と「オペランドなし」形式
という2 つの形式が使用できる。(SCASニーモニックで指定される) 明示オペランド形式では、メモ
リ・オペランドを明示的に指定することができる。この場合、メモリ・オペランドは、オペランド
値のサイズとロケーションを示す記号でなければならない。レジスタ・オペランドは、この場合に
はメモリ・オペランドのサイズに一致するように自動的に選択される( バイト比較ではALレジスタ、
ワード比較ではAX レジスタ、ダブルワード比較ではEAX レジスタ)。この明示オペランド形式は、
ドキュメンテーションを可能にするために設けられたものであるが、この形式によって提供される
ドキュメンテーションは誤解を招く場合があるので注意されたい。すなわち、メモリ・オペランド
の記号は、オペランドの正しいタイプ( サイズ: バイト、ワード、またはダブルワード) を指定しな
ければならないが、正しいロケーションを指定する必要はない。ロケーションは、常にES:(E)DI レ
ジスタによって指定されるので、ストリング比較命令を実行する前に、これらのレジスタに正しく
ロードされていなければならない。
オペランドなし形式は、SCAS 命令のバイト、ワード、およびダブルワード各バージョンの「ショー
ト形式」を提供する。この場合も、ES:(E)DI がメモリ・オペランドであると想定され、AL、AX、ま
たはEAX レジスタがレジスタ・オペランドであると想定される。2 つのオペランドのサイズは、
SCASB( バイト比較)、SCASW( ワード比較)、またはSCASD( ダブルワード比較) の各ニーモニック
で選択される。
比較後、(E)DI レジスタはEFLAGS レジスタ内のDF フラグの設定に従って自動的にインクリメント
またはデクリメントされる。(DF フラグが0 である場合は、(E)DI レジスタはインクリメントされる。
DFフラグが1 である場合は、(E)DI レジスタはデクリメントされる。) (E)DI レジスタは、バイト操作
の場合は1、ワード操作の場合は2、ダブルワード操作の場合は4、それぞれインクリメントまたは
デクリメントされる。
オペコード命令説明
AE SCAS m8 AL をES:(E)DI のバイトと比較し、ステータス・フラグを設定する。
AF SCAS m16 AX をES:(E)DI のワードと比較し、ステータス・フラグを設定する。
AF SCAS m32 EAX をES:(E)DI のダブルワードと比較し、ステータス・フラグを設定
する。
AE SCASB AL をES:(E)DI のバイトと比較し、ステータス・フラグを設定する。
AF SCASW AX をES:(E)DI のワードと比較し、ステータス・フラグを設定する。
AF SCASD EAX をES:(E)DI のダブルワードと比較し、ステータス・フラグを設定
する。
3-677
命令セット・リファレンス
SCAS/SCASB/SCASW/SCASD?Scan String ( 続き)
SCAS、SCASB、SCASW、およびSCASD 命令は、前にREP プリフィックスを付けることにより、
ECX バイト、ワード、またはダブルワードのブロック比較を行うことができる。しかし通常は、こ
れらの命令は、次の比較が行われる前にステータス・フラグの設定に基づいてある処置を行うルー
プ構造体で使用されることの方が多い。REP プリフィックスの説明については、本章の
「REP/REPE/REPZ/REPNE /REPNZ?Repeat String Operation Prefix」を参照のこと。
操作
IF (byte cmparison)
THEN
temp ← AL ? SRC;
SetStatusFlags(temp);
THEN IF DF ← 0
THEN (E)DI ← (E)DI + 1;
ELSE (E)DI ← (E)DI ? 1;
FI;
ELSE IF (word comparison)
THEN
temp ← AX ? SRC;
SetStatusFlags(temp)
THEN IF DF ← 0
THEN (E)DI ← (E)DI + 2;
ELSE (E)DI ← (E)DI ? 2;
FI;
ELSE (* doubleword comparison *)
temp ← EAX ? SRC;
SetStatusFlags(temp)
THEN IF DF ← 0
THEN (E)DI ← (E)DI + 4;
ELSE (E)DI ← (E)DI ? 4;
FI;
FI;
FI;
影響を受けるフラグ
OF、SF、ZF、AF、PF、およびCF フラグが比較の一時的な結果に従って設定される。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがES セグメントの範囲外の場合。
ES レジスタの内容がヌル・セグメント・セレクタの場合。
ES レジスタに不当なメモリ・オペランド実効アドレスが与えられてい
る場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-678
命令セット・リファレンス
SCAS/SCASB/SCASW/SCASD?Scan String ( 続き)
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-679
命令セット・リファレンス
SETcc?Set Byte on Condition
説明
デスティネーション・オペランドをEFLAGS レジスタのステータス・フラグ(CF、SF、OF、ZF、お
よびPF) の設定に従って0 または1 に設定する。デスティネーション・オペランドは、バイト・レジ
スタまたはメモリ内のバイトを指す。条件コード・サフィックス(cc) は、テストされる条件を示し
ている。
オペコード命令説明
0F 97 SETA r/m8 より上(CF=0 およびZF=0) の場合バイトを設定する。
0F 93 SETAE r/m8 より上か等しい(CF=0) 場合バイトを設定する。
0F 92 SETB r/m8 より下(CF=1) の場合バイトを設定する。
0F 96 SETBE r/m8 より下か等しい(CF=1 またはZF=1) 場合バイトを設定する。
0F 92 SETC r/m8 キャリーがある(CF=1) 場合設定する。
0F 94 SETE r/m8 等しい(ZF=1) 場合バイトを設定する。
0F 9F SETG r/m8 より大きい(ZF=0 およびSF=OF) 場合バイトを設定する。
0F 9D SETGE r/m8 より大きいか等しい(SF=OF) 場合バイトを設定する。
0F 9C SETL r/m8 より小さい(SF<>OF) 場合バイトを設定する。
0F 9E SETLE r/m8 より小さいか等しい(ZF=1 またはSF<>OF) 場合バイトを設定す
る。
0F 96 SETNA r/m8 より上でない(CF=1 またはZF=1) 場合バイトを設定する。
0F 92 SETNAE r/m8 より上でなく等しくない(CF=1) 場合バイトを設定する。
0F 93 SETNB r/m8 より下でない(CF=0) 場合バイトを設定する。
0F 97 SETNBE r/m8 より下でなく等しくない(CF=0 およびZF=0) 場合バイトを設定
する。
0F 93 SETNC r/m8 キャリーがない(CF=0) 場合バイトを設定する。
0F 95 SETNE r/m8 等しくない(ZF=0) 場合バイトを設定する。
0F 9E SETNG r/m8 より大きくない(ZF=1 またはSF<>OF) 場合バイトを設定する。
0F 9C SETNGE r/m8 より大きくなく等しくない(SF<>OF) 場合設定する。
0F 9D SETNL r/m8 より小さくない(SF=OF) 場合バイトを設定する。
0F 9F SETNLE r/m8 より小さくなく等しくない(ZF=0 およびSF=OF) 場合バイトを
設定する。
0F 91 SETNO r/m8 オーバフローがない(OF=0) 場合バイトを設定する。
0F 9B SETNP r/m8 パリティがない(PF=0) 場合バイトを設定する。
0F 99 SETNS r/m8 符号がない(SF=0) 場合バイトを設定する。
0F 95 SETNZ r/m8 ゼロでない(ZF=0) 場合バイトを設定する。
0F 90 SETO r/m8 オーバフローがある(OF=1) 場合バイトを設定する。
0F 9A SETP r/m8 パリティがある(PF=1) 場合バイトを設定する。
0F 9A SETPE r/m8 パリティが偶数(PF=1) の場合バイトを設定する。
0F 9B SETPO r/m8 パリティが奇数(PF=0) の場合バイトを設定する。
0F 98 SETS r/m8 符号がある(SF=1) 場合バイトを設定する。
0F 94 SETZ r/m8 ゼロ(ZF=1) の場合バイトを設定する。
3-680
命令セット・リファレンス
SETcc?Set Byte on Condition ( 続き)
「より上」および「より下」という表現は、CF フラグに関連付けられ、2 つの符号なし整数値間の関
係をいっている。「より大きい」および「より小さい」という表現は、SF およびOFフラグに関連付
けられ、2 つの符号付き整数値間の関係をいっている。
SETcc 命令のオペコードの多くには、代替ニーモニックがある。例えば、SETG( より大きい場合バイ
トを設定) とSETNLE( より小さくなく等しくない場合設定) は、同じオペコードをもち、同じ条件、す
なわち、ZFが0に等しく、SF がOFに等しいことをテストする。これらの代替ニーモニックは、コー
ドをよりわかりやすくするために提供されている。『IA-32 インテルR アーキテクチャ・ソフトウェ
ア・デベロッパーズ・マニュアル、上巻』付録B「EFLAGS条件コード」では、さまざまなテスト条
件の代替ニーモニックを示している。
一部の言語では、すべてのビットをセットした整数として論理1 を表す。この表現は、SETcc 命令に
論理的に反対の条件を選択し、結果をデクリメントすると得ることができる。例えば、オーバフロー
があるかテストするには、SETNO命令を使用し、次に結果をデクリメントする。
操作
IF condition
THEN DEST ← 1
ELSE DEST ← 0;
FI;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
3-681
命令セット・リファレンス
SETcc?Set Byte on Condition ( 続き)
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-682
命令セット・リファレンス
SFENCE?Store Fence
説明
SFENCE 命令より前に発行されたすべてのストア・メモリ命令に対して、シリアル化操作を実行す
る。このシリアル化操作は、プログラムの順序でSFENCE 命令に先行するすべてのストア命令が、
SFENCE 命令に後続するストア命令より前にグローバルにアクセス可能になることを保証する。
SFENCE 命令は、ストア命令、他のSFENCE 命令、MFENCE 命令、および任意のシリアル化命令
（CPUID命令など）に対して順序付けされる。SFENCE 命令は、ロード命令やLFENCE命令に対して
は順序付けされない。
順序設定の緩いメモリ・タイプを使用して、アウト・オブ・オーダー発行、ライト・コンバイニン
グ、およびライト・コラプシングなどの手法により、プロセッサ・パフォーマンスの向上を達成す
る。データを参照する側のルーチンが、順序設定の緩いデータであることをどの程度認識するかは、
アプリケーションによって異なり、データを生成する側のルーチンにはわからない。SFENCE 命令
は、順序設定の緩い結果を生成するルーチンとそのデータを参照するルーチンの間のストアの順序
付けを保証するための効率的な方法である。
操作
Wait_On_Following_Stores_Until(preceding_stores_globally_visible);
同等のインテルC/C++ コンパイラ組み込み関数
void_mm_sfence(void)
保護モード例外
なし。
実アドレス・モード例外
なし。
仮想8086 モード例外
なし。
オペコード命令説明
0F AE /7 SFENCE ストア操作をシリアル化する。
3-683
命令セット・リファレンス
SGDT/SIDT?Store Global/Interrupt Descriptor Table Register
説明
グローバル・ディスクリプタ・テーブル・レジスタ(GDTR) または割り込みディスクリプタ・テーブ
ル・レジスタ(IDTR) をデスティネーション・オペランドにストアする。デスティネーション・オペ
ランドは、6 バイトのメモリ・ロケーションを指定する。オペランド・サイズ属性が32 ビットであ
る場合は、レジスタの16 ビットのリミット・フィールドがメモリ・ロケーションの下位2 バイトに
ストアされ、32 ビットのベース・アドレスが上位4 バイトにストアされる。オペランド・サイズ属
性が16 ビットである場合は、範囲が下位2 バイトにストアされ、24 ビットのベース・アドレスが3
〜5 バイト目にストアされ、6 バイト目は0 で埋められる。
SGDT 命令およびSIDT 命令は、オペレーティング・システム・ソフトウェアだけに有用であるが、
例外を生成せずにアプリケーション・プログラムで使用することができる。
GDTRおよびIDTRのローディングに関する詳細については、本章の「LGDT/LIDT?Load Global/Interrupt
Descriptor Table Register」を参照のこと。
IA-32 アーキテクチャにおける互換性
SGDT命令およびSIDT命令の16ビット形式は、上位8ビットが参照されない場合にIntel 286プロセッ
サと互換性がある。Intel 286プロセッサはこれらのビットを1で埋め、Pentium Pro プロセッサ、Pentium
プロセッサ、Intel486 プロセッサ、およびIntel386 プロセッサはこれらのビットを0 で埋める。
操作
IF instruction is IDTR
THEN
IF OperandSize ← 16
THEN
DEST[0:15] ← IDTR(Limit);
DEST[16:39] ← IDTR(Base); (* 24 bits of base address loaded; *)
DEST[40:47] ← 0;
ELSE (* 32-bit Operand Size *)
DEST[0:15] ← IDTR(Limit);
DEST[16:47] ← IDTR(Base); (* full 32-bit base address loaded *)
FI;
ELSE (* instruction is SGDT *)
IF OperandSize ← 16
THEN
DEST[0:15] ← GDTR(Limit);
DEST[16:39] ← GDTR(Base); (* 24 bits of base address loaded; *)
DEST[40:47] ← 0;
オペコード命令説明
0F 01 /0 SGDT m GDTR をm にストアする。
0F 01 /1 SIDT m IDTR をm にストアする。
3-684
命令セット・リファレンス
SGDT/SIDT?Store Global/Interrupt Descriptor Table Register ( 続き)
ELSE (* 32-bit Operand Size *)
DEST[0:15] ← GDTR(Limit);
DEST[16:47] ← GDTR(Base); (* full 32-bit base address loaded *)
FI; FI;
影響を受けるフラグ
なし。
保護モード例外
#UD デスティネーション・オペランドがレジスタである場合。
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、およびGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
#UD デスティネーション・オペランドがレジスタである場合。
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#UD デスティネーション・オペランドがレジスタである場合。
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-685
命令セット・リファレンス
SHL/SHR?Shift Instructions
「SAL/SAR/SHL/SHR?Shift」を参照のこと。
3-686
命令セット・リファレンス
SHLD?Double Precision Shift Left
説明
第1 オペランド( デスティネーション・オペランド) を第3 オペランド( カウント・オペランド) で指
定されたビット数だけ左にシフトする。第2 オペランド( ソース・オペランド) は、( デスティネー
ション・オペランドのビット0 で始まって) 右からシフト・インするビットを指定する。デスティ
ネーション・オペランドには、レジスタまたはメモリ・ロケーションを使用できる。ソース・オペ
ランドは、レジスタである。カウント・オペランドは符号なし整数で、即値バイトまたはCLレジス
タの内容である。カウントのビット0 〜4 だけが使用され、カウントが0 〜31 の値にマスクされる。
カウントがオペランド・サイズより大きい場合は、デスティネーション・オペランドの結果は未定
義である。
カウントが1 以上である場合は、CF フラグにはデスティネーション・オペランドから最後にシフト
されたビットが入る。1 ビット・シフトでは、OF フラグは、符号変更が発生するとセットされ、そ
うでなければクリアされる。カウント・オペランドが0 である場合は、フラグは影響を受けない。
SHLD命令は、64ビット以上の多重精度シフトに有用である。
操作
COUNT ← COUNT MOD 32;
SIZE ← OperandSize
IF COUNT = 0
THEN
no operation
ELSE
IF COUNT > SIZE
THEN (* Bad parameters *)
DEST is undefined;
CF, OF, SF, ZF, AF, PF are undefined;
ELSE (* Perform the shift *)
CF ← BIT[DEST, SIZE ? COUNT];
(* Last bit shifted out on exit *)
FOR i ← SIZE ? 1 DOWNTO COUNT
DO
Bit(DEST, i) ← Bit(DEST, i ? COUNT);
OD;
オペコード命令説明
0F A4 SHLD r/m16,r16,imm8 r/m16 を左にimm8 位置シフトし、r16 からのビットを右か
らシフト・インする。
0F A5 SHLD r/m16,r16,CL r/m16 を左にCL 位置シフトし、r16 からのビットを右から
シフト・インする。
0F A4 SHLD r/m32,r32,imm8 r/m32 を左にimm8 位置シフトし、r32 からのビットを右か
らシフト・インする。
0F A5 SHLD r/m32,r32,CL r/m32 を左にCL 位置シフトし、r32 からのビットを右から
シフト・インする。
3-687
命令セット・リファレンス
SHLD?Double Precision Shift Left ( 続き)
FOR i ← COUNT ? 1 DOWNTO 0
DO
BIT[DEST, i] ← BIT[SRC, i ? COUNT + SIZE];
OD;
FI;
FI;
影響を受けるフラグ
カウントが1 以上である場合は、CF フラグにはデスティネーション・オペランドから最後にシフト
されたビットが入り、SF、ZF、およびPFフラグは結果の値に従って設定される。1 ビット・シフト
では、OF フラグは、符号変更が発生するとセットされ、そうでなければクリアされる。1 ビットよ
り大きいシフトでは、OFフラグは未定義である。シフトが行われると、AFフラグは未定義である。
カウント・オペランドが0 である場合は、フラグは影響を受けない。カウントがオペランド・サイズ
より大きい場合は、フラグは未定義である。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-688
命令セット・リファレンス
SHRD?Double Precision Shift Right
説明
第1 オペランド( デスティネーション・オペランド) を第3 オペランド( カウント・オペランド) で指
定されたビット数だけ右にシフトする。第2 オペランド( ソース・オペランド) は、( デスティネー
ション・オペランドの最上位ビットで始まって) 左からシフト・インするビットを指定する。デス
ティネーション・オペランドには、レジスタまたはメモリ・ロケーションを使用できる。ソース・
オペランドは、レジスタである。カウント・オペランドは符号なし整数で、即値バイトまたはCLレ
ジスタの内容である。カウントのビット0 〜4 だけが使用され、カウントが0 〜31の値にマスクされ
る。カウントがオペランド・サイズより大きい場合は、デスティネーション・オペランドの結果は
未定義である。
カウントが1 以上である場合は、CF フラグにはデスティネーション・オペランドから最後にシフト
されたビットが入る。1 ビット・シフトでは、OF フラグは、符号変更が発生するとセットされ、そ
うでなければクリアされる。カウント・オペランドが0 である場合は、フラグは影響を受けない。
SHRD命令は、64ビット以上の多重精度シフトに有用である。
操作
COUNT ← COUNT MOD 32;
SIZE ← OperandSize
IF COUNT = 0
THEN
no operation
ELSE
IF COUNT > SIZE
THEN (* Bad parameters *)
DEST is undefined;
CF, OF, SF, ZF, AF, PF are undefined;
ELSE (* Perform the shift *)
CF ← BIT[DEST, COUNT ? 1]; (* last bit shifted out on exit *)
FOR i ← 0 TO SIZE ? 1 ? COUNT
DO
BIT[DEST, i] ← BIT[DEST, i + COUNT];
OD;
オペコード命令説明
0F AC SHRD r/m16,r16,imm8 r/m16 を右にimm8 位置シフトし、r16 からのビットを左か
らシフト・インする。
0F AD SHRD r/m16,r16,CL r/m16 を右にCL 位置シフトし、r16 からのビットを左から
シフト・インする。
0F AC SHRD r/m32,r32,imm8 r/m32 を右にimm8 位置シフトし、r32 からのビットを左か
らシフト・インする。
0F AD SHRD r/m32,r32,CL r/m32 を右にCL 位置シフトし、r32 からのビットを左から
シフト・インする。
3-689
命令セット・リファレンス
SHRD?Double Precision Shift Right ( 続き)
FOR i ← SIZE ? COUNT TO SIZE ? 1
DO
BIT[DEST,i] ← BIT[SRC, i + COUNT ? SIZE];
OD;
FI;
FI;
影響を受けるフラグ
カウントが1 以上である場合は、CF フラグにはデスティネーション・オペランドから最後にシフト
されたビットが入り、SF、ZF、およびPFフラグは結果の値に従って設定される。1 ビット・シフト
では、OF フラグは、符号変更が発生するとセットされ、そうでなければクリアされる。1 ビットよ
り大きいシフトでは、OFフラグは未定義である。シフトが行われると、AFフラグは未定義である。
カウント・オペランドが0 である場合は、フラグは影響を受けない。カウントがオペランド・サイズ
より大きい場合は、フラグは未定義である。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-690
命令セット・リファレンス
SHUFPD?Shuffle Packed Double-Precision Floating-Point Values
説明
デスティネーション・オペランド（第1 オペランド）内の2 つのパックド倍精度浮動小数点値のうち
1 つを、デスティネーション・オペランドの下位クワッドワードに移動し、ソース・オペランド内の
2 つのパックド倍精度浮動小数点値のうち1 つを、デスティネーション・オペランドの上位クワッド
ワードに移動する（図3-16. を参照）。セレクト・オペランド（第3 オペランド）によって、どちらの
値がデスティネーション・オペランドに転送されるかが決まる。
ソース・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティ
ネーション・オペランドはXMMレジスタである。セレクト・オペランドは8 ビットの即値である。
セレクト・オペランドのビット0 は、デスティネーション・オペランドから結果に転送される値を選
択する（値が0 の場合は下位クワッドワードが転送され、1 の場合は上位クワッドワードが転送され
る）。ビット1 は、ソース・オペランドから結果に転送される値を選択する。シャッフル・オペラン
ドのビット3 〜7 は予約されている。
操作
IF SELECT[0] == 0
THEN DEST[63-0] ← DEST[63-0];
ELSE DEST[63-0] ← DEST[127-64]; FI;
IF SELECT[1] == 0
THEN DEST[127-64] ← SRC[63-0];
ELSE DEST[127-64] ← SRC[127-64]; FI;
オペコード命令説明
66 0F C6 /r ib SHUFPD xmm1,
xmm2/m128, imm8
imm8 によって選択された、xmm1 およびxmm1/m128 内
のパックド倍精度浮動小数点値をシャッフルして、xmm1
に格納する。
図3-16. SHUFPD のシャッフル操作
X1 X0
Y1 Y0
Y1 またはY0 X1 またはX0
SRC
DEST
DEST
3-691
命令セット・リファレンス
SHUFPD?Shuffle Packed Double-Precision Floating-Point Values
( 続き)
同等のインテルC/C++ コンパイラ組み込み関数
SHUFPD __m128d _mm_shuffle_pd(__m128d a, __m128d b, unsigned int imm8)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
3-692
命令セット・リファレンス
SHUFPD?Shuffle Packed Double-Precision Floating-Point Values
( 続き)
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-693
命令セット・リファレンス
SHUFPS?Shuffle Packed Single-Precision Floating-Point Values
説明
デスティネーション・オペランド（第1 オペランド）の4 つのパックド単精度浮動小数点値のうち2
つを、デスティネーション・オペランドの下位クワッドワードに移動し、ソース・オペランド（第2
オペランド）の4 つの単精度浮動小数点値のうち2 つを、デスティネーション・オペランドの上位ク
ワッドワードに移動する（図3-17. を参照）。セレクト・オペランド（第3 オペランド）によって、ど
の値がデスティネーション・オペランドに転送されるかが決まる。
ソース・オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティ
ネーション・オペランドはXMM レジスタである。セレクト・オペランドは8 ビットの即値である。
即値のビット0 とビット1 は、デスティネーション・オペランドから結果の最下位のダブルワードに
転送される値を選択する。ビット2 とビット3 は、デスティネーション・オペランドから結果の第2
ダブルワードに転送される値を選択する。ビット4 とビット5 は、ソース・オペランドから結果の第
3 ダブルワードに転送される値を選択する。ビット6 とビット7 は、ソース・オペランドから結果の
最上位のダブルワードに転送される値を選択する。
操作
CASE (SELECT[1-0]) OF
0: DEST[31-0] ← DEST[31-0];
1: DEST[31-0] ← DEST[63-32];
2: DEST[31-0] ← DEST[95-64];
3: DEST[31-0] ← DEST[127-96];
ESAC;
オペコード命令説明
0F C6 /r ib SHUFPS xmm1,
xmm2/m128, imm8
imm8 によって選択された、xmm1 およびxmm1/m128 内
のパックド単精度浮動小数点値をシャッフルして、xmm1
に格納する。
図3-17. SHUFPS 命令の動作
X3 X2 X1 X0
Y3 Y2 Y1 Y0
Y3 ... Y0 Y3 ... Y0 X3 ... X0 X3 ... X0
3-694
命令セット・リファレンス
SHUFPS?Shuffle Packed Single-Precision Floating-Point Values
( 続き)
CASE (SELECT[3-2]) OF
0: DEST[63-32] ← DEST[31-0];
1: DEST[63-32] ← DEST[63-32];
2: DEST[63-32] ← DEST[95-64];
3: DEST[63-32] ← DEST[127-96];
ESAC;
CASE (SELECT[5-4]) OF
0: DEST[95-64] ← SRC[31-0];
1: DEST[95-64] ← SRC[63-32];
2: DEST[95-64] ← SRC[95-64];
3: DEST[95-64] ← SRC[127-96];
ESAC;
CASE (SELECT[7-6]) OF
0: DEST[127-96] ← SRC[31-0];
1: DEST[127-96] ← SRC[63-32];
2: DEST[127-96] ← SRC[95-64];
3: DEST[127-96] ← SRC[127-96];
ESAC;
同等のインテルC/C++ コンパイラ組み込み関数
SHUFPS __m128 _mm_shuffle_ps(__m128 a, __m128 b, unsigned int imm8)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS ビットがセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
3-695
命令セット・リファレンス
SHUFPS?Shuffle Packed Single-Precision Floating-Point Values
( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-696
命令セット・リファレンス
SIDT?Store Interrupt Descriptor Table Register
「SGDT/SIDT?Store Global/Interrupt Descriptor Table Register」を参照のこと。
3-697
命令セット・リファレンス
SLDT?Store Local Descriptor Table Register
説明
セグメント・セレクタをローカル・ディスクリプタ・テーブル・レジスタ(LDTR) からデスティネー
ション・オペランドにストアする。デスティネーション・オペランドには、汎用レジスタまたはメ
モリ・ロケーションを使用できる。この命令でストアされるセグメント・セレクタは、現在のLDT
の(GDTにある) セグメント・ディスクリプタを指す。この命令は、保護モードでしか実行すること
ができない。
デスティネーション・オペランドが32ビット・レジスタであるときは、16 ビットのセグメント・セ
レクタがレジスタの下位16 ビットにコピーされる。レジスタの上位16 ビットは、Pentium Pro プロ
セッサでは0 にクリアされ、Pentiumプロセッサ、Intel486 プロセッサ、およびIntel386 プロセッサで
は未定義である。デスティネーション・オペランドがメモリ・ロケーションであるときは、セグメ
ント・セレクタは、オペランド・サイズに関係なく、16ビット幅でメモリに書き込まれる。
SLDT 命令は、オペレーティング・システム・ソフトウェアだけに有用であるが、アプリケーショ
ン・プログラムで使用することもできる。
操作
DEST ← LDTR(SegmentSelector);
影響を受けるフラグ
なし。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、およびGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
オペコード命令説明
0F 00 /0 SLDT r/m16 セグメント・セレクタをLDTR からr/m16 にストアする。
0F 00 /0 SLDT r/m32 セグメント・セレクタをLDTR からr/m32 の下位16 ビッ
トにストアする。
3-698
命令セット・リファレンス
SLDT?Store Local Descriptor Table Register ( 続き)
実アドレス・モード例外
#UD SLDT 命令は実アドレス・モードでは認識されない。
仮想8086 モード例外
#UD SLDT 命令は仮想8086 モードでは認識されない。
3-699
命令セット・リファレンス
SMSW?Store Machine Status Word
説明
マシン・ステータス・ワード( 制御レジスタCR0 のビット0 〜15) をデスティネーション・オペラン
ドにストアする。デスティネーション・オペランドには、16 ビットの汎用レジスタまたはメモリ・
ロケーションを使用できる。
デスティネーション・オペランドが32 ビット・レジスタであるときは、CR0 レジスタの下位16 ビッ
トがレジスタの下位16 ビットにコピーされ、レジスタの上位16 ビットは未定義である。デスティ
ネーション・オペランドがメモリ・ロケーションであるときは、オペランド・サイズに関係なく、
CR0 レジスタの下位16 ビットが16ビット幅でメモリに書き込まれる。
SMSW 命令は、オペレーティング・システム・ソフトウェアだけに有用であるが、特権命令ではな
く、アプリケーション・プログラムで使用することもできる。
この命令は、Intel 286 プロセッサとの互換性を保つために設けられたものである。Pentium Pro プロ
セッサ、Pentium プロセッサ、Intel486 プロセッサ、およびIntel386 プロセッサで実行するように意図
されたプログラムおよびプロシージャでは、MOV( 制御レジスタ) 命令を使用してマシン・ステータ
ス・ワードをロードする必要がある。
操作
DEST ← CR0[15:0]; (* Machine status word *);
影響を受けるフラグ
なし。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、およびGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
オペコード命令説明
0F 01 /4 SMSW r/m16 マシン・ステータス・ワードをr/m16 にストアする。
0F 01 /4 SMSW r32/m16 マシン・ステータス・ワードをr32 の下位16 ビットまたは
m16 にストアし、r32 の上位16 ビットは未定義である。
3-700
命令セット・リファレンス
SMSW?Store Machine Status Word ( 続き)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-701
命令セット・リファレンス
SQRTPD?Compute Square Roots of Packed Double-Precision
Floating-Point Values
説明
ソース・オペランド（第2 オペランド）の2 つのパックド倍精度浮動小数点値の平方根をSIMD 計
算し、結果のパックド倍精度浮動小数点値をデスティネーション・オペランドに格納する。ソース・
オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーショ
ン・オペランドはXMMレジスタである。倍精度浮動小数点値のSIMD 演算の図は、『IA-32 インテ
ルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図11-3. を参照のこと。
操作
DEST[63-0] ← SQRT(SRC[63-0]);
DEST[127-64] ← SQRT(SRC[127-64]);
同等のインテルC/C++ コンパイラ組み込み関数
SQRTPD __m128d _mm_sqrt_pd (m128d a)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
66 0F 51 /r SQRTPD xmm1, xmm2/m128 xmm2/m128 のパックド倍精度浮動小数点値の平方根
を計算し、結果をxmm1 に格納する。
3-702
命令セット・リファレンス
SQRTPD?Compute Square Roots of Packed Double-Precision
Floating-Point Values ( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-703
命令セット・リファレンス
SQRTPS?Compute Square Roots of Packed Single-Precision
Floating-Point Values
説明
ソース・オペランド（第2 オペランド）の4 つのパックド単精度浮動小数点値の平方根をSIMD 計
算し、結果のパックド単精度浮動小数点値をデスティネーション・オペランドに格納する。ソース・
オペランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーショ
ン・オペランドはXMMレジスタである。単精度浮動小数点値のSIMD 演算の図は、『IA-32 インテ
ルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図10-5. を参照のこと。
操作
DEST[31-0] ← SQRT(SRC[31-0]);
DEST[63-32] ← SQRT(SRC[63-32]);
DEST[95-64] ← SQRT(SRC[95-64]);
DEST[127-96] ← SQRT(SRC[127-96]);
同等のインテルC/C++ コンパイラ組み込み関数
SQRTPS __m128 _mm_sqrt_ps(__m128 a)
SIMD 浮動小数点例外
無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
0F 51 /r SQRTPS xmm1, xmm2/m128 xmm2/m128 のパックド単精度浮動小数点値の平方根
を計算し、結果をxmm1 に格納する。
3-704
命令セット・リファレンス
SQRTPS?Compute Square Roots of Packed Single-Precision
Floating-Point Values ( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-705
命令セット・リファレンス
SQRTSD?Compute Square Root of Scalar Double-Precision Floating-
Point Value
説明
ソース・オペランド（第2 オペランド）の下位の倍精度浮動小数点値の平方根を計算し、結果の倍精
度浮動小数点値をデスティネーション・オペランドに格納する。ソース・オペランドは、XMMレジ
スタまたは64 ビットのメモリ・ロケーションである。デスティネーション・オペランドはXMM レ
ジスタである。デスティネーション・オペランドの上位クワッドワードは変更されない。倍精度浮
動小数点値のスカラ演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパー
ズ・マニュアル、上巻』の図11-4. を参照のこと。
操作
DEST[63-0] ← SQRT(SRC[63-0]);
* DEST[127-64] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
SQRTSD __m128d _mm_sqrt_sd (m128d a)
SIMD 浮動小数点例外
無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
F2 0F 51 /r SQRTSD xmm1, xmm2/m64 xmm2/m64 の下位の倍精度浮動小数点値の平方根を計
算し、結果をxmm1 に格納する。
3-706
命令セット・リファレンス
SQRTSD?Compute Square Root of Scalar Double-Precision Floating-
Point Value ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-707
命令セット・リファレンス
SQRTSS?Compute Square Root of Scalar Single-Precision Floating-
Point Value
説明
ソース・オペランド（第2 オペランド）の最下位の単精度浮動小数点値の平方根を計算し、結果の単
精度浮動小数点値をデスティネーション・オペランドに格納する。ソース・オペランドは、XMMレ
ジスタまたは32 ビットのメモリ・ロケーションである。デスティネーション・オペランドはXMM
レジスタである。デスティネーション・オペランドの上位3 つのダブルワードは変更されない。単精
度浮動小数点値のスカラ演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッ
パーズ・マニュアル、上巻』の図10-6. を参照のこと。
操作
DEST[31-0] ← SQRT (SRC[31-0]);
* DEST[127-64] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
SQRTSS __m128 _mm_sqrt_ss(__m128 a)
SIMD 浮動小数点例外
無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
F3 0F 51 /r SQRTSS xmm1, xmm2/m32 xmm2/m32 の最下位の単精度浮動小数点値の平方根を
計算し、結果をxmm1 に格納する。
3-708
命令セット・リファレンス
SQRTSS?Compute Square Root of Scalar Single-Precision Floating-
Point Value ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-709
命令セット・リファレンス
STC?Set Carry Flag
説明
EFLAGSレジスタのCFフラグをセットする。
操作
CF ← 1;
影響を受けるフラグ
CFフラグがセットされる。OF、ZF、SF、AF、およびPF フラグは影響を受けない。
例外 ( すべての操作モード)
なし。
オペコード命令説明
F9 STC CF フラグをセットする。
3-710
命令セット・リファレンス
STD?Set Direction Flag
説明
EFLAGSレジスタのDFフラグをセットする。DFフラグが1 にセットされると、ストリング操作はイ
ンデックス・レジスタ(ESI またはEDI、またはその両方) をデクリメントする。
操作
DF ← 1;
影響を受けるフラグ
DFフラグがセットされる。CF、OF、ZF、SF、AF、およびPF フラグは影響を受けない。
例外 ( すべての操作モード)
なし。
オペコード命令説明
FD STD DF フラグをセットする。
3-711
命令セット・リファレンス
STI?Set Interrupt Flag
説明
EFLAGS レジスタの割り込みフラグ(IF) をセットする。IF フラグがセットされた後、プロセッサは、
次の命令を実行した後に外部マスク可能割り込みへの応答を開始する。この命令のディレイした効
果は、プロシージャ( またはサブルーチン) から戻る直前に割り込みをイネーブルにできるように提
供されている。例えば、STI 命令の後にRET 命令が続いている場合に、RET 命令は、外部割り込み
が認識される前に実行を認められる1。この動作によって、外部割り込みをプロシージャの始まりで
ディスエーブルにし、プロシージャの終わりで再びイネーブルにすることができる。STI 命令の後に
(IF フラグをクリアする)CLI 命令が続いていると、STI 命令の効果はネゲートされる。
IF フラグとSTI 命令およびCLI 命令は、例外およびNMI 割り込みの生成には影響を与えない。
以下のデシジョン・テーブルは、プロセッサの動作モードおよび現在実行中のプログラムまたはプ
ロシージャのCPLとIOPL( テーブルの上部分) によって、STI 命令の処置( テーブルの下部分) が決ま
ることを示している。
注:
X 関係なし。
N 左端の欄の処置が行われない。
Y 左端の欄の処置が行われる。
オペコード命令説明
FB STI 割り込みフラグをセットする。次の命令の最後で、外部マ
スク可能割り込みがイネーブルになる。
1. 以降の命令を過ぎて割り込みを個別にディレイさせる命令シーケンスでは、シーケンスの最初の命令は、割り
込みをディレイさせることが保証されるが、以降の割り込みディレイ命令は、割り込みをディレイさせない場
合があることに注意されたい。そのため、以下の命令シーケンスでは、
STI
MOV SS, AX
MOV ESP, EBP
MOV DD, AX が通常は割り込みを1 命令の間ディレイさせる場合でも、MOV ESP,EBP が実行される前に、割
り込みが認識されることがある。
PE = 0 1 1 1
VM = X 0 0 1
CPL X ? IOPL > IOPL =3
IOPL X X X =3
IF ← 1 Y Y N Y
#GP(0) N N Y N
3-712
命令セット・リファレンス
STI?Set Interrupt Flag ( 続き)
操作
IF PE=0 (* Executing in real-address mode *)
THEN
IF ← 1; (* Set Interrupt Flag *)
ELSE (* Executing in protected mode or virtual-8086 mode *)
IF VM=0 (* Executing in protected mode*)
THEN
IF IOPL ← 3
THEN
IF ← 1;
ELSE
IF CPL ? IOPL
THEN
IF ← 1;
ELSE
#GP(0);
FI;
FI;
ELSE (* Executing in Virtual-8086 mode *)
#GP(0); (* Trap to virtual-8086 monitor *)
FI;
FI;
影響を受けるフラグ
IF フラグが1 にセットされる。
保護モード例外
#GP(0) CPL が現在のプログラムまたはプロシージャのIOPL より大きい( 低い
特権をもつ) 場合。
実アドレス・モード例外
なし。
仮想8086 モード例外
#GP(0) CPL が現在のプログラムまたはプロシージャのIOPL より大きい( 低い
特権をもつ) 場合。
3-713
命令セット・リファレンス
STMXCSR?Store MXCSR Register State
説明
MXCSR 制御/ ステータス・レジスタの内容をデスティネーション・オペランドにストアする。デス
ティネーション・オペランドは、32 ビット・メモリ・ロケーションである。MXCSRレジスタの予約
ビットは、ゼロとしてストアされる。
操作
m32 ← MXCSR;
同等のインテルC/C++ コンパイラ組み込み関数
_mm_getcsr(void)
例外
なし。
数値例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、GS セグメント内のメモリ・オペランドの実効アドレ
スが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#UD CR0.EM が1 の場合。
#NM CR0 のTS ビットがセットされている場合。
#AC アライメントの合っていないメモリ参照が行われた場合。#AC 例外をイ
ネーブルにするには、3 つの条件を真にする必要がある(CR0.AM をセッ
トし、EFLAGS.AC をセットし、現行CPL を3 にする)。
#UD CR4.OSFXSR( ビット9) が0 の場合。
#UD CPUID.XMM(EDX ビット25) が0 の場合。
オペコード命令説明
0F AE /3 STMXCSR m32 MXCSR レジスタの内容をm32 にストアする。
3-714
命令セット・リファレンス
STMXCSR?Store MXCSR Register State ( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#UD CR0.EM が1 の場合。
#NM CR0のTS ビットがセットされている場合。
#UD CR4.OSFXSR( ビット9) が0 の場合。
#UD CPUID.XMM(EDX ビット25) が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC アライメントの合っていないメモリ参照を行った場合。
3-715
命令セット・リファレンス
STOS/STOSB/STOSW/STOSD?Store String
説明
バイト、ワード、またはダブルワードをそれぞれAL、AX、またはEAX レジスタからデスティネー
ション・オペランドにストアする。デスティネーション・オペランドはメモリ・ロケーションであ
り、そのアドレスは、( 命令のアドレス・サイズ属性、32 または16 に応じて) それぞれES:EDI レジ
スタまたはES:DI レジスタから読み取られる。ES セグメントは、セグメント・オーバライド・プリ
フィックスでオーバライドすることはできない。
アセンブリ・コード・レベルでは、この命令の「明示オペランド」形式と「オペランドなし」形式
という2 つの形式が使用できる。(STOSニーモニックで指定される) 明示オペランド形式では、デス
ティネーション・オペランドを明示的に指定することができる。この場合、デスティネーション・
オペランドは、デスティネーション値のサイズとロケーションを示す記号でなければならない。ソー
ス・オペランドは、この場合にはデスティネーション・オペランドのサイズに一致するように自動
的に選択される( バイト・オペランドではAL レジスタ、ワード・オペランドではAX レジスタ、ダ
ブルワード・オペランドではEAXレジスタ)。この明示オペランド形式は、ドキュメンテーションを
可能にするために設けられたものであるが、この形式によって提供されるドキュメンテーションは
誤解を招く場合があるので注意されたい。すなわち、デスティネーション・オペランドの記号は、オ
ペランドの正しいタイプ( サイズ: バイト、ワード、またはダブルワード) を指定しなければならな
いが、正しいロケーションを指定する必要はない。ロケーションは、常にES:(E)DI レジスタによっ
て指定されるので、ストリング・ストア命令を実行する前に、これらのレジスタに正しくロードさ
れていなければならない。
オペランドなし形式は、STOS 命令のバイト、ワード、およびダブルワード各バージョンの「ショー
ト形式」を提供する。この場合も、ES:(E)DI がデスティネーション・オペランドであると想定され、
AL、AX、またはEAX レジスタがソース・オペランドであると想定される。デスティネーション・
オペランドとソース・オペランドのサイズは、STOSB( レジスタAL からのバイト読み取り)、
STOSW(AXからのワード読み取り)、またはSTOSD(EAXからのダブルワード読み取り) の各ニーモ
ニックで指定される。
バイト、ワード、またはダブルワードがAL、AX、またはEAX レジスタからメモリ・ロケーション
に転送された後、(E)DI レジスタはEFLAGS レジスタのDF フラグの設定に従って自動的にインクリ
メントまたはデクリメントされる。(DF フラグが0 である場合は、(E)DI レジスタはインクリメント
される。DFフラグが1 である場合は、(E)DI レジスタはデクリメントされる。) (E)DI レジスタは、バ
イト操作の場合は1、ワード操作の場合は2、ダブルワード操作の場合は4、それぞれインクリメン
トまたはデクリメントされる。
オペコード命令説明
AA STOS m8 AL をアドレスES:(E)DI にストアする。
AB STOS m16 AX をアドレスES:(E)DI にストアする。
AB STOS m32 EAX をアドレスES:(E)DI にストアする。
AA STOSB AL をアドレスES:(E)DI にストアする。
AB STOSW AX をアドレスES:(E)DI にストアする。
AB STOSD EAX をアドレスES:(E)DI にストアする。
3-716
命令セット・リファレンス
STOS/STOSB/STOSW/STOSD?Store String ( 続き)
STOS、STOSB、STOSW、およびSTOSD命令は、前にREP プリフィックスを付けることにより、ECX
バイト、ワード、またはダブルワードのブロック・ロードを行うことができる。しかし通常は、デー
タをストアするにはその前にAL、AX、またはEAXレジスタに転送する必要があるので、これらの
命令はループ構造体で使用されることの方が多い。REP プリフィックスの説明については、本章の
「REP/REPE/REPZ/REPNE /REPNZ?Repeat String Operation Prefix」を参照のこと。
操作
IF (byte store)
THEN
DEST ← AL;
THEN IF DF ← 0
THEN (E)DI ← (E)DI + 1;
ELSE (E)DI ← (E)DI ? 1;
FI;
ELSE IF (word store)
THEN
DEST ← AX;
THEN IF DF ← 0
THEN (E)DI ← (E)DI + 2;
ELSE (E)DI ← (E)DI ? 2;
FI;
ELSE (* doubleword store *)
DEST ← EAX;
THEN IF DF ← 0
THEN (E)DI ← (E)DI + 4;
ELSE (E)DI ← (E)DI ? 4;
FI;
FI;
FI;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがES セグメントの範囲外の場合。
ES レジスタの内容がヌル・セグメント・セレクタの場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
3-717
命令セット・リファレンス
STOS/STOSB/STOSW/STOSD?Store String ( 続き)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがES セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがES セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-718
命令セット・リファレンス
STR?Store Task Register
説明
セグメント・セレクタをタスク・レジスタ(TR) からデスティネーション・オペランドにストアする。
デスティネーション・オペランドには、汎用レジスタまたはメモリ・ロケーションを使用できる。こ
の命令でストアされるセグメント・セレクタは、現在実行中のタスクのタスク・ステート・セグメ
ント(TSS) を指す。
デスティネーション・オペランドが32 ビット・レジスタであるときは、16ビットのセグメント・セ
レクタがレジスタの下位16 ビットにコピーされ、レジスタの上位16 ビットは0 にクリアされる。デ
スティネーション・オペランドがメモリ・ロケーションであるときは、セグメント・セレクタは、オ
ペランド・サイズに関係なく、16 ビット幅でメモリに書き込まれる。
STR命令は、オペレーティング・システム・ソフトウェアだけに有用である。この命令は、保護モー
ドでしか実行することができない。
操作
DEST ← TR(SegmentSelector);
影響を受けるフラグ
なし。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにあるメモリ・オペ
ランドである場合、または実効アドレスがCS、DS、ES、FS、またはGS
セグメントの範囲外の場合。
DS、ES、FS、およびGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#UD STR 命令は実アドレス・モードでは認識されない。
仮想8086 モード例外
#UD STR 命令は仮想8086 モードでは認識されない。
オペコード命令説明
0F 00 /1 STR r/m16 セグメント・セレクタをTR からr/m16 にストアする。
3-719
命令セット・リファレンス
SUB?Subtract
説明
第1 オペランド( デスティネーション・オペランド) から第2 オペランド( ソース・オペランド) を引
き、結果をデスティネーション・オペランドにストアする。デスティネーション・オペランドには、
レジスタまたはメモリ・ロケーションを使用できる。ソース・オペランドには、即値、レジスタ、ま
たはメモリ・ロケーションを使用できる。( ただし、1 つの命令で2 つのメモリ・オペランドを使用
することはできない。) 即値をオペランドとして使用すると、デスティネーション・オペランドの
フォーマットの長さまで符号拡張される。
SUB 命令は、整数の減算を実行する。SUB 命令は、符号付き整数オペランドおよび符号なし整数オ
ペランドの両方の結果を評価し、OF フラグとCF フラグを設定して、それぞれ符号付きの結果また
は符号なしの結果のボローを示す。SFフラグは、符号付き結果の符号を示す。
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
DEST ← DEST ? SRC;
影響を受けるフラグ
OF、SF、ZF、AF、PF、およびCF フラグが結果に従って設定される。
オペコード命令説明
2C ib SUB AL,imm8 AL からimm8 を引く。
2D iw SUB AX,imm16 AX からimm16 を引く。
2D id SUB EAX,imm32 EAX からimm32 を引く。
80 /5 ib SUB r/m8,imm8 r/m8 からimm8 を引く。
81 /5 iw SUB r/m16,imm16 r/m16 からimm16 を引く。
81 /5 id SUB r/m32,imm32 r/m32 からimm32 を引く。
83 /5 ib SUB r/m16,imm8 r/m16 から符号拡張されたimm8 を引く。
83 /5 ib SUB r/m32,imm8 r/m32 から符号拡張されたimm8 を引く。
28 /r SUB r/m8,r8 r/m8 からr8 を引く。
29 /r SUB r/m16,r16 r/m16 からr16 を引く。
29 /r SUB r/m32,r32 r/m32 からr32 を引く。
2A /r SUB r8,r/m8 r8 からr/m8 を引く。
2B /r SUB r16,r/m16 r16 からr/m16 を引く。
2B /r SUB r32,r/m32 r32 からr/m32 を引く。
3-720
命令セット・リファレンス
SUB?Subtract ( 続き)
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-721
命令セット・リファレンス
SUBPD?Subtract Packed Double-Precision Floating-Point Values
説明
デスティネーション・オペランド（第1 オペランド）の2 つのパックド倍精度浮動小数点値からソー
ス・オペランド（第2 オペランド）の2 つのパックド倍精度浮動小数点値をSIMD 減算し、結果の
パックド倍精度浮動小数点値をデスティネーション・オペランドに格納する。ソース・オペランド
は、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・オペラ
ンドはXMMレジスタである。倍精度浮動小数点値のSIMD演算の図は、『IA-32 インテルR アーキテ
クチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図11-3. を参照のこと。
操作
DEST[63-0] ← DEST[63-0] ? SRC[63-0];
DEST[127-64] ← DEST[127-64] ? SRC[127-64];
同等のインテルC/C++ コンパイラ組み込み関数
SUBPD __m128d _mm_sub_pd (m128d a, m128d b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
66 0F 5C /r SUBPD xmm1, xmm2/m128 xmm1 からxmm2/m128 のパックド倍精度浮動小数点値
を引く。
3-722
命令セット・リファレンス
SUBPD?Subtract Packed Double-Precision Floating-Point Values
( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-723
命令セット・リファレンス
SUBPS?Subtract Packed Single-Precision Floating-Point Values
説明
デスティネーション・オペランド（第1 オペランド）の4 つのパックド単精度浮動小数点値からソー
ス・オペランド（第2 オペランド）の4 つのパックド単精度浮動小数点値をSIMD 減算し、結果の
パックド単精度浮動小数点値をデスティネーション・オペランドに格納する。ソース・オペランド
は、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・オペラ
ンドはXMMレジスタである。単精度浮動小数点値のSIMD演算の図は、『IA-32 インテルR アーキテ
クチャ・ソフトウェア・デベロッパーズ・マニュアル、上巻』の図10-5. を参照のこと。
操作
DEST[31-0] ← DEST[31-0] ? SRC[31-0];
DEST[63-32] ← DEST[63-32] ? SRC[63-32];
DEST[95-64] ← DEST[95-64] ? SRC[95-64];
DEST[127-96] ← DEST[127-96] ? SRC[127-96];
同等のインテルC/C++ コンパイラ組み込み関数
SUBPS __m128 _mm_sub_ps(__m128 a, __m128 b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
オペコード命令説明
0F 5C /r SUBPS xmm1 xmm2/m128 xmm1 のパックド単精度浮動小数点値からxmm2/mem
のパックド単精度浮動小数点値を引く。
3-724
命令セット・リファレンス
SUBPS?Subtract Packed Single-Precision Floating-Point Values
( 続き)
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-725
命令セット・リファレンス
SUBSD?Subtract Scalar Double-Precision Floating-Point Values
説明
デスティネーション・オペランド（第1 オペランド）の下位の倍精度浮動小数点値からソース・オペ
ランド（第2 オペランド）の下位の倍精度浮動小数点値を引き、結果の倍精度浮動小数点値をデス
ティネーション・オペランドに格納する。ソース・オペランドは、XMM レジスタまたは64 ビット
のメモリ・ロケーションである。デスティネーション・オペランドはXMM レジスタである。デス
ティネーション・オペランドの上位クワッドワードは変更されない。倍精度浮動小数点値のスカラ
演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上
巻』の図11-4. を参照のこと。
操作
DEST[63-0] ← DEST[63-0] ? SRC[63-0];
* DEST[127-64] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
SUBSD __m128d _mm_sub_sd (m128d a, m128d b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
F2 0F 5C /r SUBSD xmm1, xmm2/m64 xmm1 からxmm2/mem64 の下位の倍精度浮動小数点値
を引く。
3-726
命令セット・リファレンス
SUBSD?Subtract Scalar Double-Precision Floating-Point Values
( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4
のOSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-727
命令セット・リファレンス
SUBSS?Subtract Scalar Single-Precision Floating-Point Values
説明
デスティネーション・オペランド（第1 オペランド）の最下位の単精度浮動小数点値からソース・オ
ペランド（第2 オペランド）の最下位の単精度浮動小数点値を引き、結果の単精度浮動小数点値をデ
スティネーション・オペランドに格納する。ソース・オペランドは、XMM レジスタまたは32 ビッ
トのメモリ・ロケーションである。デスティネーション・オペランドはXMMレジスタである。デス
ティネーション・オペランドの上位3 つのダブルワードは変更されない。単精度浮動小数点値のスカ
ラ演算の図は、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、上
巻』の図10-6. を参照のこと。
操作
DEST[31-0] ← DEST[31-0] - SRC[31-0];
* DEST[127-96] remains unchanged *;
同等のインテルC/C++ コンパイラ組み込み関数
SUBSS __m128 _mm_sub_ss(__m128 a, __m128 b)
SIMD 浮動小数点例外
オーバーフロー、アンダーフロー、無効、精度、デノーマル。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
オペコード命令説明
F3 0F 5C /r SUBSS xmm1, xmm2/m32 xmm1 の最下位の単精度浮動小数点値からxmm2/m32
の最下位の単精度浮動小数点値を引く。
3-728
命令セット・リファレンス
SUBSS?Subtract Scalar Single-Precision Floating-Point Values
( 続き)
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-729
命令セット・リファレンス
SYSENTER?Fast System Call
説明
特権レベル0 のシステム・プロシージャまたはルーチンへの高速コールを実行する。この命令は、
SYSEXIT 命令に対するコンパニオン命令である。SYSENTER 命令は、特権レベル3 で実行中のユー
ザ・コードからオペレーティング・システムまたは特権レベル0 で実行中の実行プロシージャへのシ
ステム・コールについて、そのパフォーマンスが最高になるように最適化される。
SYSENTER命令を実行する前に、ソフトウェア上で以下のMSRに値を書き込むことにより、特権レ
ベル0 のコード・セグメントとコード・エントリ・ポイント、および特権レベル0 のスタック・セグ
メントとスタック・ポインタを指定する必要がある。
? SYSENTER_CS_MSR - 特権レベル0 のコード・セグメントの32 ビット・セグメント・セレクタ
が入る。( この値は、特権レベル0 のスタック・セグメントのセグメント・セレクタを計算する
のにも使用される)
? SYSENTER_EIP_MSR - 選択された操作プロシージャまたはルーチンの先頭の命令に対する、特
権レベル0 のコード・セグメントの32ビット・オフセットが入る。
? SYSENTER_ESP_MSR - 特権レベル0 のスタックの32 ビット・スタック・ポインタが入る。
これらのMSR は、RDMSR 命令およびWRMSR 命令を使用して読み取りおよび書き込みを行なうこ
とができる。レジスタ・アドレスを表3-14. に示す。これらのアドレスは、今後のIA-32 プロセッサ
においても固定されたままとなるよう定義されている。
SYSENTER命令を実行するとき、プロセッサは以下のことを行なう。
1. セグメント・セレクタをSYSENTER_CS_MSR からCS レジスタにロードする。
2. 命令ポインタをSYSENTER_EIP_MSR からEIP レジスタにロードする。
3. SYSENTER_CS_MSR の値に8 を加算し、その合計をSS レジスタにロードする。
4. スタック・ポインタをSYSENTER_ESP_MSR からESP レジスタにロードする。
5. 特権レベル0 に切り替える。
6. ( フラグが設定されている場合には)EFLAGS レジスタのVM フラグをクリアする。
7. 選択したシステム・プロシージャの実行を開始する。
プロセッサは、コール元のプロシージャのリターンIP や他の状態情報をセーブしない。
オペコード命令説明
0F 34 SYSENTER 特権レベル0 のシステム・プロシージャへの高速コール
表3-14. SYSENTER 命令およびSYSEXIT 命令によって使用されるMSR
MSR アドレス
SYSENTER_CS_MSR 174H
SYSENTER_ESP_MSR 175H
SYSENTER_EIP_MSR 176H
3-730
命令セット・リファレンス
SYSENTER?Fast System Call ( 続き)
SYSENTER命令は常に、DPLが0 の保護モード・コード・セグメントにプログラムの制御を移す。こ
の命令を使用するには、オペレーティング・システムが以下の条件を満たしていなければならない。
? 選択されたシステム・コード・セグメントのセグメント記述子により、実行許可、読み取り許
可、アクセス許可、非コンフォーミング許可を持つ最大4Gバイトのフラットな32 ビット・コー
ド・セグメントが選択されていること。
? 選択されたシステム・スタック・セグメントのセグメント記述子により、読み取り許可、書き
込み許可、アクセス許可、拡張許可を持つ最大4Gバイトのフラットな32 ビット・スタック・セ
グメントが選択されていること。
SYSENTER命令は、実アドレス・モードを除くすべての操作モードから起動できる。
SYSENTER 命令とSYSEXIT 命令はコンパニオン命令であるが、コール/ リターンのペアを形成する
ものではない。SYSENTER 命令を実行するときに、プロセッサはユーザ・コードの状態情報をセー
ブしない。また、SYSENTER命令もSYSEXIT命令も、スタックへのパラメータ渡しをサポートしない。
SYSENTER命令とSYSEXIT 命令をコンパニオン命令として使用し、特権レベル3 のコードと特権レ
ベル0 のオペレーティング・システム・プロシージャ間のトランジション( 移行) を行なうには、以
下の規則に従う必要がある。
? 特権レベル0 のコードとスタック・セグメントのセグメント記述子、および特権レベル3 のコー
ドとスタック・セグメントのセグメント記述子は、グローバル記述子テーブル内で連続してい
なければならない。この規則により、プロセッサは、SYSENTER_CS_MSR MSR に入力された
値からセグメント・セレクタを計算することができる。
? ユーザ・コードが実行する高速システム・コールの「スタブ」ルーチン( 通常は、共用ライブラ
リまたはDLL 内にある) では、コール元プロシージャへのリターンが要求される場合、必要な
リターンIP とプロセッサ状態情報をセーブしておく必要がある。同様に、SYSENTER 命令で
コールされるオペレーティング・システムまたは実行プロシージャでは、ユーザ・コードにリ
ターンするときにアクセス権が必要であるとともに、このセーブされているリターンIP と状態
に関する情報を使用する必要がある。
SYSENTER命令とSYSEXIT 命令は、Pentium II プロセッサでIA-32 アーキテクチャに導入された。こ
れらの命令をプロセッサで使用できるかどうかは、CPUID 命令によってEDX レジスタに返される
SYSENTER/SYSEXIT Present(SEP) 機能フラグの状態によって示される。オペレーティング・システ
ムでSEPフラグを調べる場合は、プロセッサのファミリとモデルも調べて、SYSENTER/SYSEXIT命
令を実際にサポートしているかどうかを確認しなければならない。例えば、次のコードを使用でき
る。
IF (CPUID SEP bit is set)
THEN IF (Family == 6) AND (Model < 3) AND (Stepping < 3)
THEN
SYSENTER/SYSEXIT_Not_Supported
FI;
ELSE SYSENTER/SYSEXIT_Supported
FI;
Pentium Pro プロセッサ( モデル1) 上でCPUID命令を実行すると、SEP フラグがセットされて返され
るが、SYSENTER/SYSEXIT命令はサポートされない。
3-731
命令セット・リファレンス
SYSENTER?Fast System Call ( 続き)
操作
IF CR0.PE = 0 THEN #GP(0); FI;
IF SYSENTER_CS_MSR = 0 THEN #GP(0); FI;
EFLAGS.VM ← 0 (* Insures protected mode execution *)
EFLAGS.IF ← 0 (* Mask interrupts *)
EFLAGS.RF ← 0
CS.SEL ← SYSENTER_CS_MSR (* Operating system provides CS *)
(* Set rest of CS to a fixed value *)
CS.SEL.CPL ← 0
CS.BASE ← 0 (* Flat segment *)
CS.LIMIT ← FFFFH (* 4 GByte limit *)
CS.ARbyte.G ← 1 (* 4 KByte granularity *)
CS.ARbyte.S ← 1
CS.ARbyte.TYPE ← 1011B (* Execute + Read, Accessed *)
CS.ARbyte.D ← 1 (* 32-bit code segment*)
CS.ARbyte.DPL ← 0
CS.ARbyte.RPL ← 0
CS.ARbyte.P ← 1
SS.SEL ← CS.SEL + 8
(* Set rest of SS to a fixed value *)
SS.BASE ← 0 (* Flat segment *)
SS.LIMIT ← FFFFH (* 4 GByte limit *)
SS.ARbyte.G ← 1 (* 4 KByte granularity *)
SS.ARbyte.S ←
SS.ARbyte.TYPE ← 0011B (* Read/Write, Accessed *)
SS.ARbyte.D ← 1 (* 32-bit stack segment*)
SS.ARbyte.DPL ← 0
SS.ARbyte.RPL ← 0
SS.ARbyte.P ← 1
ESP ← SYSENTER_ESP_MSR
EIP ← SYSENTER_EIP_MSR
影響を受けるフラグ
VM、IF、RF（上記の操作を参照）
保護モード例外
#GP(0) SYSENTER_CS_MSR の値がゼロの場合。
3-732
命令セット・リファレンス
SYSENTER?Fast System Call ( 続き)
実アドレス・モード例外
#GP(0) 保護モードがイネーブルになっていない場合。
仮想8086 モード例外
#GP(0) SYSENTER_CS_MSR の値がゼロの場合。
3-733
命令セット・リファレンス
SYSEXIT?Fast Return from Fast System Call
説明
特権レベル3 のユーザ・コードへの高速リターンを実行する。この命令は、SYSENTER 命令に対す
るコンパニオン命令である。SYSEXIT 命令は、保護レベル0 で実行中のシステム・プロシージャか
ら保護レベル3 で実行中のユーザ・プロシージャへのリターンについて、そのパフォーマンスが最高
になるように最適化される。この命令は、特権レベル0 で実行中のコードから実行しなければならな
い。
SYSEXIT命令を実行する前に、ソフトウェア上で以下のMSRおよび汎用レジスタに値を書き込むこ
とにより、特権レベル3 のコード・セグメントとコード・エントリ・ポイント、および特権レベル3
のスタック・セグメントとスタック・ポインタを指定する必要がある。
? SYSENTER_CS_MSR - プロセッサが現在実行中の特権レベル0 のコード・セグメントの32 ビッ
ト・セグメント・セレクタが入る。( この値は、特権レベル3 のコードおよびスタック・セグメ
ントのセグメント・セレクタを計算するのに使用される)
? EDX - ユーザ・コードで最初に実行される命令に対する、特権レベル3 のコード・セグメントの
32 ビット・オフセットが入る。
? ECX - 特権レベル3 のスタックの32 ビット・スタック・ポインタが入る。
SYSENTER_CS_MSR MSRは、RDMSR命令およびWRMSR命令を使用して読み取りおよび書き込み
を行なうことができる。レジスタ・アドレスを表3-14. に示す。このアドレスは、今後のIA-32 プロ
セッサにおいても固定されたままとなるよう定義されている。
SYSEXIT命令を実行するとき、プロセッサは以下のことを行なう。
1. SYSENTER_CS_MSR の値に16 を加算し、その合計をCS セレクタ・レジスタにロードする。
2. 命令ポインタをEDX レジスタからEIP レジスタにロードする。
3. SYSENTER_CS_MSR の値に24 を加算し、その合計をSS セレクタ・レジスタにロードする。
4. スタック・ポインタをECX レジスタからESP レジスタにロードする。
5. 特権レベル3 に切り替える。
6. EIP アドレスでユーザ・コードの実行を開始する。
コールおよびリターンのコンパニオン命令としてSYSENTER命令とSYSEXIT命令を使用する方法に
ついては、「SYSENTER?Fast System Call」を参照のこと。
SYSEXIT 命令は常に、DPL が3 の保護モード・コード・セグメントにプログラムの制御を移す。こ
の命令を使用するには、オペレーティング・システムが以下の条件を満たしていなければならない。
? 選択されたユーザ・コード・セグメントのセグメント記述子により、実行許可、読み取り許可、
アクセス許可、非コンフォーミング許可を持つ最大4Gバイトのフラットな32 ビット・コード・
セグメントが選択されていること。
オペコード命令説明
0F 35 SYSEXIT 特権レベル3 のユーザ・コードに高速リターンする。
3-734
命令セット・リファレンス
SYSEXIT?Fast Return from Fast System Call ( 続き)
? 選択されたユーザ・スタック・セグメントのセグメント記述子により、拡張許可、読み取り許
可、書き込み許可、アクセス許可を持つ最大4Gバイトのフラットな32 ビット・スタック・セグ
メントが選択されていること。
SYSENTERは、実アドレス・モードを除くすべての操作モードから起動できる。
SYSENTER命令とSYSEXIT 命令は、Pentium II プロセッサでIA-32 アーキテクチャに導入された。こ
れらの命令をプロセッサで使用できるかどうかは、CPUID 命令によってEDX レジスタに返される
SYSENTER/SYSEXIT Present(SEP) 機能フラグの状態によって示される。オペレーティング・システ
ムでSEPフラグを調べる場合は、プロセッサのファミリとモデルも調べて、SYSENTER/SYSEXIT命
令を実際にサポートしているかどうかを確認しなければならない。例えば、次のコードを使用でき
る。
IF (CPUID SEP bit is set)
THEN IF (Family == 6) AND (Model < 3) AND (Stepping < 3)
THEN
SYSENTER/SYSEXIT_Not_Supported
FI;
ELSE SYSENTER/SYSEXIT_Supported
FI;
Pentium Pro プロセッサ( モデル1) 上でCPUID命令を実行すると、SEP フラグがセットされて返され
るが、SYSENTER/SYSEXIT命令はサポートされない。
操作
IF SYSENTER_CS_MSR = 0 THEN #GP(0); FI;
IF CR0.PE = 0 THEN #GP(0); FI;
IF CPL ≠ 0 THEN #GP(0)
CS.SEL ← (SYSENTER_CS_MSR + 16) (* Segment selector for return CS *)
(* Set rest of CS to a fixed value *)
CS.BASE ← 0 (* Flat segment *)
CS.LIMIT ← FFFFH (* 4 GByte limit *)
CS.ARbyte.G ← 1 (* 4 KByte granularity *)
CS.ARbyte.S ← 1
CS.ARbyte.TYPE ← 1011B (* Execute, Read, Non-Conforming Code *)
CS.ARbyte.D ← 1 (* 32-bit code segment*)
CS.ARbyte.DPL ← 3
CS.ARbyte.RPL ← 3
CS.ARbyte.P ← 1
SS.SEL ← (SYSENTER_CS_MSR + 24) (* Segment selector for return SS *)
(* Set rest of SS to a fixed value *)
SS.BASE ← 0 (* Flat segment *)
SS.LIMIT ← FFFFH (* 4 GByte limit *)
SS.ARbyte.G ← 1 (* 4 KByte granularity *)
SS.ARbyte.S ←
3-735
命令セット・リファレンス
SYSEXIT?Fast Return from Fast System Call ( 続き)
SS.ARbyte.TYPE ← 0011B (* Expand Up, Read/Write, Data *)
SS.ARbyte.D ← 1 (* 32-bit stack segment*)
SS.ARbyte.DPL ← 3
SS.ARbyte.RPL ← 3
SS.ARbyte.P ← 1
ESP ← ECX
EIP ← EDX
影響を受けるフラグ
なし。
保護モード例外
#GP(0) SYSENTER_CS_MSR の値がゼロの場合。
実アドレス・モード例外
#GP(0) 保護モードがイネーブルになっていない場合。
仮想8086 モード例外
#GP(0) SYSENTER_CS_MSR の値がゼロの場合。
3-736
命令セット・リファレンス
TEST?Logical Compare
説明
第1オペランド(ソース1オペランド)と第2オペランド( ソース2 オペランド) との間のビット単位の
AND( 論理積) 演算を実行し、結果に従ってSF、ZF、およびPF ステータス・フラグを設定する。結
果は、その後捨てられる。
操作
TEMP ← SRC1 AND SRC2;
SF ← MSB(TEMP);
IF TEMP ← 0
THEN ZF ← 1;
ELSE ZF ← 0;
FI:
PF ← BitwiseXNOR(TEMP[0:7]);
CF ← 0;
OF ← 0;
(*AF is Undefined*)
影響を受けるフラグ
OF およびCF フラグが0 にクリアされる。SF、ZF、およびPF フラグが結果に従って設定される( 上
記の「操作」の項を参照)。AFフラグの状態は未定義。
オペコード命令説明
A8 ib TEST AL,imm8 imm8 とAL とのADN をとり、結果に従ってSF、ZF、PF を設定す
る。
A9 iw TEST AX,imm16 imm16 とAX とのADN をとり、結果に従ってSF、ZF、PF を設定
する。
A9 id TEST EAX,imm32 imm32 とEAX とのADN をとり、結果に従ってSF、ZF、PF を設
定する。
F6 /0 ib TEST r/m8,imm8 imm8 とr/m8 とのADN をとり、結果に従ってSF、ZF、PF を設定
する。
F7 /0 iw TEST r/m16,imm16 imm16 とr/m16 とのADN をとり、結果に従ってSF、ZF、PF を設
定する。
F7 /0 id TEST r/m32,imm32 imm32 とr/m32 とのADN をとり、結果に従ってSF、ZF、PF を設
定する。
84 /r TEST r/m8,r8 r8 とr/m8 とのADN をとり、結果に従ってSF、ZF、PF を設定す
る。
85 /r TEST r/m16,r16 r16 とr/m16 とのADN をとり、結果に従ってSF、ZF、PF を設定
する。
85 /r TEST r/m32,r32 r32 とr/m32 とのADN をとり、結果に従ってSF、ZF、PF を設定
する。
3-737
命令セット・リファレンス
TEST?Logical Compare ( 続き)
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-738
命令セット・リファレンス
UCOMISD?Unordered Compare Scalar Double-Precision Floating-
Point Values and Set EFLAGS
説明
ソース・オペランド1（第1 オペランド）とソース・オペランド2（第2 オペランド）の下位クワッ
ドワード内の倍精度浮動小数点値のアンオーダー比較を実行し、その結果（アンオーダー、より大
きい、より小さい、または等しい）に従って、EFLAGSレジスタのZF、PF、およびCF フラグをセッ
トする。EFLAGS レジスタのOF、SF、およびAFフラグは0 にクリアされる。いずれかのソース・オ
ペランドがNaN（QNaNまたはSNaN）の場合は、アンオーダーの結果が返される。
ソース・オペランド1 はXMMレジスタである。ソース・オペランド2 は、XMMレジスタまたは64
ビットのメモリ・ロケーションである。
UCOMISD命令とCOMISD命令の相違点は、UCOMISD命令は、ソース・オペランドがSNaN の場合
にのみSIMD浮動小数点無効操作例外（#I）を報告することである。COMISD命令は、ソース・オペ
ランドがQNaNまたはSNaNの場合に、無効操作例外を報告する。
マスクされていないSIMD浮動小数点例外が発生した場合は、EFLAGSレジスタは更新されない。
操作
RESULT ← UnorderedCompare(SRC1[63-0] <> SRC2[63-0]) {
* Set EFLAGS *CASE (RESULT) OF
UNORDERED: ZF,PF,CF ← 111;
GREATER_THAN: ZF,PF,CF ← 000;
LESS_THAN: ZF,PF,CF ← 001;
EQUAL: ZF,PF,CF ← 100;
ESAC;
OF,AF,SF ← 0;
同等のインテルC/C++ コンパイラ組み込み関数
int_mm_ucomieq_sd(__m128d a, __m128d b)
int_mm_ucomilt_sd(__m128d a, __m128d b)
int_mm_ucomile_sd(__m128d a, __m128d b)
int_mm_ucomigt_sd(__m128d a, __m128d b)
int_mm_ucomige_sd(__m128d a, __m128d b)
int_mm_ucomineq_sd(__m128d a, __m128d b)
SIMD 浮動小数点例外
無効（SNaN オペランドの場合）、デノーマル。
オペコード命令説明
66 0F 2E /r UCOMISD xmm1, xmm2/m64 xmm1 とxmm2/m64 の下位の倍精度浮動小数点値を
（アンオーダー）比較し、その結果に従ってEFLAGS
フラグをセットする。
3-739
命令セット・リファレンス
UCOMISD?Unordered Compare Scalar Double-Precision Floating-
Point Values and Set EFLAGS ( 続き)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-740
命令セット・リファレンス
UCOMISS?Unordered Compare Scalar Single-Precision Floating-
Point Values and Set EFLAGS
説明
ソース・オペランド1（第1 オペランド）とソース・オペランド2（第2 オペランド）の最下位ダブ
ルワード内の単精度浮動小数点値のアンオーダー比較を実行し、その結果（アンオーダー、より大
きい、より小さい、または等しい）に従って、EFLAGSレジスタのZF、PF、およびCF フラグをセッ
トする。EFLAGS レジスタのOF、SF、およびAFフラグは0 にクリアされる。いずれかのソース・オ
ペランドがNaN(QNaNまたはSNaN) の場合は、アンオーダーの結果が返される。
ソース・オペランド1 はXMMレジスタである。ソース・オペランド2 は、XMMレジスタまたは32
ビットのメモリ・ロケーションである。
UCOMISS 命令とCOMISS 命令の相違点は、UCOMISS 命令は、ソース・オペランドがSNaN の場合
にのみSIMD浮動小数点無効操作例外（#I）を報告することである。COMISS命令は、ソース・オペ
ランドがQNaNまたはSNaNの場合に、無効操作例外を報告する。
マスクされていないSIMD浮動小数点例外が発生した場合は、EFLAGSレジスタは更新されない。
操作
RESULT ← UnorderedCompare(SRC1[63-0] <> SRC2[63-0]) {
* Set EFLAGS *CASE (RESULT) OF
UNORDERED: ZF,PF,CF ← 111;
GREATER_THAN: ZF,PF,CF ← 000;
LESS_THAN: ZF,PF,CF ← 001;
EQUAL: ZF,PF,CF ← 100;
ESAC;
OF,AF,SF ← 0;
同等のインテルC/C++ コンパイラ組み込み関数
int_mm_ucomieq_ss(__m128 a, __m128 b)
int_mm_ucomilt_ss(__m128 a, __m128 b)
int_mm_ucomile_ss(__m128 a, __m128 b)
int_mm_ucomigt_ss(__m128 a, __m128 b)
int_mm_ucomige_ss(__m128 a, __m128 b)
int_mm_ucomineq_ss(__m128 a, __m128 b)
SIMD 浮動小数点例外
無効(SNaNオペランドの場合)、デノーマル。
オペコード命令説明
0F 2E /r UCOMISS xmm1, xmm2/m32 xmm1 レジスタの最下位の単精度浮動小数点値と
xmm2/mem の最下位の単精度浮動小数点値を比較し、
結果に従ってステータス・フラグを設定する。
3-741
命令セット・リファレンス
UCOMISS?Unordered Compare Scalar Single-Precision Floating-
Point Values and Set EFLAGS ( 続き)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
#AC(0) アライメント・チェックがイネーブルにされていて、現行特権レベルが
3 のときにアライメントが合わないメモリ参照を行った場合。
実アドレス・モード例外
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照を行った場合。
3-742
命令セット・リファレンス
UD2?Undefined Instruction
説明
無効オペコードを生成する。この命令は、無効オペコードを明示的に生成してソフトウェアをテス
トするために提供されている。この命令のオペコードは、この目的のために予約されている。
無効オペコード例外を発生させる以外は、この命令はNOP命令と同じである。
操作
#UD (* Generates invalid opcode exception *);
影響を受けるフラグ
なし。
例外 ( すべての操作モード)
#UD 命令は、すべての動作モードで無効オペコード例外を発生させることが
保証されている。
オペコード命令説明
0F 0B UD2 無効オペコード例外を発生させる。
3-743
命令セット・リファレンス
UNPCKHPD?Unpack and Interleave High Packed Double-Precision
Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の上
位の倍精度浮動小数点値をアンパックしてインタリーブする。図3-18. を参照のこと。ソース・オペ
ランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・
オペランドはXMMレジスタである。
メモリ・オペランドからアンパックする場合、プロセッサによっては、適切な64ビットだけをフェッ
チすることがある。この場合も、16 バイト・アライメントの条件と通常のセグメント・チェックが
適用される。
操作
DEST[63-0] ← DEST[127-64];
DEST[127-64] ← SRC[127-64];
同等のインテルC/C++ コンパイラ組み込み関数
UNPCKHPD __m128d _mm_unpackhi_pd(__m128d a, __m128d b)
SIMD 浮動小数点例外
なし。
オペコード命令説明
66 0F 15 /r UNPCKHPD xmm1,
xmm2/m128
xmm1 とxmm2/m128 の上位クワッドワードの倍精度浮動
小数点値をアンパックしてインタリーブする。
図3-18. UNPCKHPD 命令の上位アンパックとインタリーブ操作
X1 X0
Y1 Y0
Y1 X1
DEST
SRC
DEST
3-744
命令セット・リファレンス
UNPCKHPD?Unpack and Interleave High Packed Double-Precision
Floating-Point Values ( 続き)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-745
命令セット・リファレンス
UNPCKHPS?Unpack and Interleave High Packed Single-Precision
Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の上
位の単精度浮動小数点値をアンパックしてインタリーブする。図3-19. を参照のこと。ソース・オペ
ランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・
オペランドはXMMレジスタである。
プロセッサによっては、メモリ・オペランドからのアンパックの際に、適切な64ビットだけをフェッ
チすることがある。しかしこの場合も、16 バイト・アライメントのチェックと通常のセグメント・
チェックが行われる。
操作
DEST[31-0] ← DEST[95-64];
DEST[63-32] ← SRC[95-64];
DEST[95-64] ← DEST[127-96];
DEST[127-96] ← SRC[127-96];
同等のインテルC/C++ コンパイラ組み込み関数
UNPCKHPS __m128 _mm_unpackhi_ps(__m128 a, __m128 b)
オペコード命令説明
0F 15 /r UNPCKHPS xmm1,
xmm2/m128
xmm1 の上位クワッドワードの単精度浮動小数点値と
xmm2/mem の上位半分の単精度浮動小数点値をxmm1 レ
ジスタにアンパックしてインタリーブする。
図3-19. UNPCKHPS 命令の上位アンパックとインタリーブ操作
X3 X2 X1 X0
Y3 Y2 Y1 Y0
Y3 X3 Y2 X2
DEST
SRC
DEST
3-746
命令セット・リファレンス
UNPCKHPS?Unpack and Interleave High Packed Single-Precision
Floating-Point Values ( 続き)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-747
命令セット・リファレンス
UNPCKLPD?Unpack and Interleave Low Packed Double-Precision
Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の下
位の倍精度浮動小数点値をアンパックしてインタリーブする。図3-20. を参照のこと。ソース・オペ
ランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・
オペランドはXMMレジスタである。
メモリ・オペランドからアンパックする場合、プロセッサによっては、適切な64ビットだけをフェッ
チすることがある。この場合も、16 バイト・アライメントの条件と通常のセグメント・チェックが
適用される。
操作
DEST[63-0] ← DEST[63-0];
DEST[127-64] ← SRC[63-0];
同等のインテルC/C++ コンパイラ組み込み関数
UNPCKHPD __m128d _mm_unpacklo_pd(__m128d a, __m128d b)
SIMD 浮動小数点例外
なし。
オペコード命令説明
66 0F 14 /r UNPCKLPD xmm1,
xmm2/m128
xmm1 とxmm2/m128 の下位クワッドワードの倍精度浮動
小数点値をアンパックしてインタリーブする。
図3-20. UNPCKLPD 命令の下位アンパックとインタリーブ操作
X1 X0
Y1 Y0
Y0 X0
DEST
SRC
DEST
3-748
命令セット・リファレンス
UNPCKLPD?Unpack and Interleave Low Packed Double-Precision
Floating-Point Values ( 続き)
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-749
命令セット・リファレンス
UNPCKLPS?Unpack and Interleave Low Packed Single-Precision
Floating-Point Values
説明
ソース・オペランド（第2 オペランド）とデスティネーション・オペランド（第1 オペランド）の下
位の単精度浮動小数点値をアンパックしてインタリーブする。図3-21. を参照のこと。ソース・オペ
ランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・
オペランドはXMMレジスタである。
プロセッサによっては、メモリ・オペランドからのアンパックの際に、適切な64ビットだけをフェッ
チすることがある。しかしこの場合も、16 バイト・アライメントのチェックと通常のセグメント・
チェックが行われる。
操作
DEST[31-0] ← DEST[31-0];
DEST[63-32] ← SRC[31-0];
DEST[95-64] ← DEST[63-32];
DEST[127-96] ← SRC[63-32];
同等のインテルC/C++ コンパイラ組み込み関数
UNPCKLPS __m128 _mm_unpacklo_ps(__m128 a, __m128 b)
オペコード命令説明
0F 14 /r UNPCKLPS xmm1,
xmm2/m128
xmm1 の下位クワッドワードの単精度浮動小数点値と
xmm2/mem の下位半分の単精度浮動小数点値をxmm1 レ
ジスタにアンパックしてインタリーブする。
図3-21. UNPCKLPS 命令の下位アンパックとインタリーブ操作
X3 X2 X1 X0
Y3 Y2 Y1 Y0
Y3 X3 Y2 X2
DEST
SRC
DEST
3-750
命令セット・リファレンス
UNPCKLPS?Unpack and Interleave Low Packed Single-Precision
Floating-Point Values ( 続き)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-751
命令セット・リファレンス
VERR, VERW?Verify a Segment for Reading or Writing
説明
ソース・オペランドで指定されたコード・セグメントまたはデータ・セグメントが現行特権レベル
(CPL) から読み取り可能(VERR) または書き込み可能(VERW) であるかを検証する。ソース・オペラ
ンドは、検証するセグメントのセグメント・セレクタをもつ16 ビットのレジスタまたはメモリ・ロ
ケーションである。セグメントがアクセス可能で読み取り可能(VERR) または書き込み可能(VERW)
である場合は、ZF フラグがセットされる。そうでない場合は、ZFフラグがクリアされる。コード・
セグメントが書き込み可能であると検証されることはない。このチェックは、システム・セグメン
トに行うことはできない。
ZFフラグをセットするには、以下の条件が満たされていなければならない。
? セグメント・セレクタがヌルでない。
? セレクタは、ディスクリプタ・テーブル(GDT またはLDT) の範囲内のディスクリプタを指定し
ていなければならない。
? セレクタは、( システム・セグメントまたはゲートのディスクリプタではなく) コード・セグメ
ントまたはデータ・セグメントのディスクリプタを指定していなければならない。
? VERR命令では、セグメントは読み取り可能でなければならない。
? VERW命令では、セグメントは書き込み可能なデータ・セグメントでなければならない。
? セグメントがコンフォーミング・コード・セグメントでない場合は、セグメントのDPLは、CPL
およびセグメント・セレクタのRPLの両方以上( 以下の特権をもつ) でなければならない。
この検証動作は、セグメント・セレクタがDS、ES、FS、またはGSレジスタにロードされ、指定さ
れたアクセス( 読み取りまたは書き込み) が行われる場合と同じ動作である。セグメント・セレクタ
の値は保護例外を発生させることはなく、ソフトウェアは起こり得るセグメント・アクセス問題を
前もって処理することができる。
操作
IF SRC[Offset) > (GDTR(Limit) OR (LDTR(Limit))
THEN
ZF ← 0
Read segment descriptor;
IF SegmentDescriptor(DescriptorType) ← 0 (* system segment *)
OR (SegmentDescriptor(Type) ≠ conforming code segment)
AND (CPL > DPL) OR (RPL > DPL)
THEN
ZF ← 0
オペコード命令説明
0F 00 /4 VERR r/m16 r/m16 で指定されたセグメントを読み取りできる場合ZF=1
を設定する。
0F 00 /5 VERW r/m16 r/m16 で指定されたセグメントに書き込みできる場合ZF=1
を設定する。
3-752
命令セット・リファレンス
VERR, VERW?Verify a Segment for Reading or Writing ( 続き)
ELSE
IF ((Instruction ← VERR) AND (segment ← readable))
OR ((Instruction ← VERW) AND (segment ← writable))
THEN
ZF ← 1;
FI;
FI;
影響を受けるフラグ
ZF フラグは、セグメントがアクセス可能で読み取り可能(VERR) または書き込み可能(VERW) である
場合は1 にセットされ、そうでない場合は0 にクリアされる。
保護モード例外
これらの命令に対して生成される唯一の例外は、ソース・オペランドの不当なアドレス指定に関係
する例外である。
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、およびGS レジスタを使用してメモリがアクセスされ、レ
ジスタの内容がヌル・セグメント・セレクタであった場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#UD VERR 命令およびVERW 命令は、実アドレス・モードでは認識されない。
仮想8086 モード例外
#UD VERR 命令およびVERW 命令は、仮想8086 モードでは認識されない。
3-753
命令セット・リファレンス
WAIT/FWAIT?Wait
説明
プロセッサは、未処理のマスクされていない浮動小数点例外があるかチェックし、あれば処理して
から先に進む。(FWAIT は、WAIT の代替ニーモニックである。)
この命令は、コードの重要な部分で例外を同期させるために有用である。浮動小数点命令の後に
WAIT 命令を入れると、この命令が発生させる可能性があるマスクされていない浮動小数点例外があ
れば、プロセッサはそれらを処理してから命令の結果を修正できることが保証される。WAIT/FWAIT
命令の使用に関する詳細については、『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッ
パーズ・マニュアル、上巻』第8 章の「x87 FPU例外の同期 」の節を参照のこと。
操作
CheckForPendingUnmaskedFloatingPointExceptions;
FPU 影響を受けるフラグ
C0、C1、C2、およびC3フラグは未定義。
浮動小数点例外
なし。
保護モード例外
#NM CR0 のMP およびTS がセットされた場合。
実アドレス・モード例外
#NM CR0 のMP およびTS がセットされた場合。
仮想8086 モード例外
#NM CR0 のMP およびTS がセットされた場合。
オペコード命令説明
9B WAIT 未処理のマスクされていない浮動小数点例外をチェックする。
9B FWAIT 未処理のマスクされていない浮動小数点例外をチェックする。
3-754
命令セット・リファレンス
WBINVD?Write Back and Invalidate Cache
説明
プロセッサの内部キャッシュで修正されているすべてのキャッシュ・ラインをメイン・メモリにラ
イトバックし、内部キャッシュを無効化( フラッシュ) する。命令は、その後、外部キャッシュにも、
修正されているデータをライトバックするよう指示する特殊機能バス・サイクルと、外部キャッシュ
を無効化するよう指示するもう1 つのバス・サイクルを発行する。
この命令を実行した後、プロセッサは、外部キャッシュのライトバック操作とフラッシュ操作の完
了を待たずに、命令の実行を継続する。キャッシュ・ライトバック信号およびキャッシュ・フラッ
シュ信号に応答することは、ハードウェアによって行う。
WBINVD 命令は特権命令である。プロセッサが保護モードで動作している場合は、この命令を実行
するには、プログラムまたはプロシージャのCPL が0 でなければならない。この命令はシリアル化
命令でもある。詳細は『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュ
アル、下巻』第7 章の「命令のシリアル化」の節を参照。
メイン・メモリとのキャッシュ・コヒーレンシが重要でない場合は、ソフトウェアはINVD命令を使
用することができる。
IA-32 アーキテクチャにおける互換性
WBINVD 命令はプロセッサに依存し、その機能は将来のIA-32 プロセッサでは異なってサポートさ
れる可能性もある。この命令は、Intel486 プロセッサより以前のIA-32 プロセッサではサポートされ
ていない。
操作
WriteBack(InternalCaches);
Flush(InternalCaches);
SignalWriteBack(ExternalCaches);
SignalFlush(ExternalCaches);
Continue (* Continue execution);
影響を受けるフラグ
なし。
保護モード例外
#GP(0) 現行特権レベルが0 でない場合。
実アドレス・モード例外
なし。
オペコード命令説明
0F 09 WBINVD ライトバックして内部キャッシュをフラッシュする。外部
キャッシュのライトバックとフラッシュを開始させる。
3-755
命令セット・リファレンス
WBINVD?Write Back and Invalidate Cache ( 続き)
仮想8086 モード例外
#GP(0) WBINVD 命令は仮想8086 モードで実行することはできない。
3-756
命令セット・リファレンス
WRMSR?Write to Model Specific Register
説明
レジスタEDX:EAXの内容をECXレジスタで指定された64 ビットのモデル固有レジスタ(MSR) に書
き込む。ECXレジスタにロードされる入力値は、書き込み先のMSRのアドレスである。選択された
MSRの上位32ビットにEDXレジスタの内容がコピーされ、MSRの下位32 ビットにEAXレジスタの
内容がコピーされる。MSR の未定義ビットまたは予約ビットは、以前に読み取られている値に設定
される。
この命令は、特権レベル0 または実アドレス・モードで実行しなければならない。そうしないと、一
般保護例外#GP(0) が生成される。予約されているかまたはインプリメントされていないMSRアドレ
スをECXに指定しても、一般保護例外が生成される。
WRMSR命令を使用してMTRRに書き込むと、グローバル・エントリを含めてTLBが無効化される。
詳細は『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、下巻』第
3 章の「トランスレーション・ルックアサイド・バッファ(TLB)」の節を参照のこと。(MTRR は、
Pentium Pro プロセッサのプロセッサ固有機能である。)
MSR は、テスト機能、実行トレース、性能モニタリング、およびマシン・チェック・エラーの機能
を制御する。『IA-32 インテルR アーキテクチャ・ソフトウェア・デベロッパーズ・マニュアル、下
巻』付録B「モデル固有レジスタ(MSR)」では、この命令で読み込むことができるすべてのMSR と
それらのアドレスを一覧している。各プロセッサ・ファミリは、独自に一連のMSRを持っているこ
とに注意すること。
WRMSR 命令はシリアル化命令である。詳細は『IA-32 インテルR アーキテクチャ・ソフトウェア・
デベロッパーズ・マニュアル、下巻』第7 章の「命令のシリアル化」の節を参照のこと。
この命令を使用する前に、CPUID命令を使用してMSRがサポートされている(EDX[5]=1) かどうかを
確認する必要がある。
IA-32 アーキテクチャにおける互換性
MSR 命令およびWRMSR 命令でそれらを読み取る機能は、Pentium プロセッサでIA-32 アーキテク
チャに導入された。Pentiumプロセッサより以前のIA-32 プロセッサでこの命令を実行すると、無効
オペコード例外#UDが生成される。
操作
MSR[ECX] ← EDX:EAX;
影響を受けるフラグ
なし。
オペコード命令説明
0F 30 WRMSR EDX:EAX の値をECX で指定されるMSR に書き込む。
3-757
命令セット・リファレンス
WRMSR?Write to Model Specific Register ( 続き)
保護モード例外
#GP(0) 現行特権レベルが0 でない場合。
ECX の値が予約されているかまたはインプリメントされていないMSR
アドレスを指定している場合。
実アドレス・モード例外
#GP ECX の値が予約されているかまたはインプリメントされていないMSR
アドレスを指定している場合。
仮想8086 モード例外
#GP(0) WRMSR 命令は仮想8086 モードでは認識されない。
3-758
命令セット・リファレンス
XADD?Exchange and Add
説明
第1 オペランド( デスティネーション・オペランド) を第2 オペランド( ソース・オペランド) と交換
し、次に2 つの値の合計をデスティネーション・オペランドにロードする。デスティネーション・オ
ペランドには、レジスタまたはメモリ・ロケーションを使用できる。ソース・オペランドは、レジ
スタである。
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
IA-32 アーキテクチャにおける互換性
Intel486 プロセッサより以前のIA-32 プロセッサは、この命令を認識しない。この命令を使用する場
合は、以前のプロセッサ上で実行する同等のコード・シーケンスを備えなければならない。
操作
TEMP ← SRC + DEST
SRC ← DEST
DEST ← TEMP
影響を受けるフラグ
CF、PF、AF、SF、ZF、およびOFフラグが、デスティネーション・オペランドにストアされる加算
の結果に従って設定される。
保護モード例外
#GP(0) デスティネーションが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
オペコード命令説明
0F C0/r XADD r/m8,r8 r8 をr/m8 と交換し、合計をr/m8 にロードする。
0F C1/r XADD r/m16,r16 r16 をr/m16 と交換し、合計をr/m16 にロードする。
0F C1/r XADD r/m32,r32 r32 をr/m32 と交換し、合計をr/m32 にロードする。
3-759
命令セット・リファレンス
XADD?Exchange and Add ( 続き)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-760
命令セット・リファレンス
XCHG?Exchange Register/Memory with Register
説明
デスティネーション・オペランド( 第1 オペランド) の内容をソース・オペランド( 第2 オペランド)
の内容と交換する。オペランドには、2 個の汎用レジスタまたは1 つのレジスタと1 つのメモリ・ロ
ケーションを使用できる。メモリ・オペランドが参照されていると、LOCKプリフィックスの有無、
あるいはIOPL の値に関係なく、プロセッサのロッキング・プロトコルが交換操作が持続している間
自動的にインプリメントされる。( ロッキング・プロトコルに関する詳細については、本章のLOCK
プリフィックスの説明を参照のこと。)
この命令は、プロセスを同期するためのセマフォまたは同様のデータ構造体のインプリメンテー
ションに有用である。( バス・ロッキングの詳細については、『IA-32 インテルR アーキテクチャ・ソ
フトウェア・デベロッパーズ・マニュアル、下巻』第7 章の「バスのロック」の項を参照のこと。)
XCHG命令は、16ビット・オペランドではBSWAP命令の代わりに使用することもできる。
操作
TEMP ← DEST
DEST ← SRC
SRC ← TEMP
影響を受けるフラグ
なし。
保護モード例外
#GP(0) いずれかのオペランドが書き込み不可能なセグメントにある場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
オペコード命令説明
90+rw XCHG AX,r16 r16 をAX と交換する。
90+rw XCHG r16,AX AX をr16 と交換する。
90+rd XCHG EAX,r32 r32 をEAX と交換する。
90+rd XCHG r32,EAX EAX をr32 と交換する。
86 /r XCHG r/m8,r8 r8( バイト・レジスタ) をr/m8 からのバイトと交換する。
86 /r XCHG r8,r/m8 r/m8 からのバイトをr8( バイト・レジスタ) と交換する。
87 /r XCHG r/m16,r16 r16 をr/m16 からのワードと交換する。
87 /r XCHG r16,r/m16 r/m16 からのワードをr16 と交換する。
87 /r XCHG r/m32,r32 r32 をr/m32 からのダブルワードと交換する。
87 /r XCHG r32,r/m32 r/m32 からのダブルワードをr32 と交換する。
3-761
命令セット・リファレンス
XCHG?Exchange Register/Memory with Register ( 続き)
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-762
命令セット・リファレンス
XLAT/XLATB?Table Look-up Translation
説明
ALレジスタの内容をテーブル・インデックスとして使用して、メモリ内のテーブルのバイト・エン
トリの位置を探し、テーブル・エントリの内容をAL レジスタにコピーし直す。AL レジスタのイン
デックスは、符号なし整数として取り扱われる。XLAT 命令およびXLATB 命令は、メモリ内のテー
ブルのベース・アドレスを( 命令のアドレス・サイズ属性、32 または16 に応じて) それぞれDS:EBX
レジスタまたはDS:BX レジスタから得る。（DS セグメントは、セグメント・オーバライド・プリ
フィックスを使用してオーバライドすることができる。)
アセンブリ・コード・レベルでは、この命令の「明示オペランド」形式と「オペランドなし」形式
という2 つの形式が使用できる。(XLATニーモニックで指定される) 明示オペランド形式では、テー
ブルのベース・アドレスを記号で明示的に指定することができる。この明示オペランド形式は、ド
キュメンテーションを可能にするために設けられたものであるが、この形式によって提供されるド
キュメンテーションは誤解を招く場合があるので注意されたい。すなわち、記号は、正しいベース・
アドレスを指定する必要はない。ベース・アドレスは、常にDS:(E)BXレジスタによって指定される
ので、XLAT 命令を実行する前に、これらのレジスタに正しくロードされていなければならない。
オペランドなし形式(XLATB) は、XLAT命令の「ショート形式」を提供する。この場合も、プロセッ
サはDS:(E)BXレジスタがテーブルのベース・アドレスをもっていると想定する。
操作
IF AddressSize ← 16
THEN
AL ← (DS:BX + ZeroExtend(AL))
ELSE (* AddressSize ← 32 *)
AL ← (DS:EBX + ZeroExtend(AL));
FI;
影響を受けるフラグ
なし。
保護モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
オペコード命令説明
D7 XLAT m8 AL をメモリ・バイトDS:[(E)BX+ 符号なしAL] に設定する。
D7 XLATB AL をメモリ・バイトDS:[(E)BX+ 符号なしAL] に設定する。
3-763
命令セット・リファレンス
XLAT/XLATB?Table Look-up Translation ( 続き)
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-764
命令セット・リファレンス
XOR?Logical Exclusive OR
説明
デスティネーション・オペランド( 第1 オペランド) とソース・オペランド( 第2 オペランド) との間
のビット単位のXOR( 排他的論理和) 演算を実行し、結果をデスティネーション・オペランド・ロ
ケーションにストアする。ソース・オペランドには、即値、レジスタ、またはメモリ・ロケーショ
ンを使用できる。デスティネーション・オペランドには、レジスタまたはメモリ・ロケーションを
使用できる。( ただし、1 つの命令で2 つのメモリ・オペランドを使用することはできない。) 各ビッ
トの結果は、オペランドの対応するビットが異なる場合は1 になり、対応するビットが同じ場合は0
になる。
この命令をLOCKプリフィックスと共に使用すると、アトミックに命令を実行させることができる。
操作
DEST ← DEST XOR SRC;
影響を受けるフラグ
OF およびCF フラグがクリアされる。SF、ZF、およびPF フラグが結果に従って設定される。AF フ
ラグの状態は未定義。
保護モード例外
#GP(0) デスティネーション・オペランドの指示先が書き込み不可能なセグメン
トの場合。
メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
DS、ES、FS、またはGS レジスタの内容がヌル・セグメント・セレクタ
の場合。
オペコード命令説明
34 ib XOR AL,imm8 AL とimm8 とのXOR をとる。
35 iw XOR AX,imm16 AX とimm16 とのXOR をとる。
35 id XOR EAX,imm32 EAX とimm32 とのXOR をとる。
80 /6 ib XOR r/m8,imm8 r/m8 とimm8 とのXOR をとる。
81 /6 iw XOR r/m16,imm16 r/m16 とimm16 とのXOR をとる。
81 /6 id XOR r/m32,imm32 r/m32 とimm32 とのXOR をとる。
83 /6 ib XOR r/m16,imm8 r/m16 とimm8( 符号拡張) とのXOR をとる。
83 /6 ib XOR r/m32,imm8 r/m32 とimm8( 符号拡張) とのXOR をとる。
30 /r XOR r/m8,r8 r/m8 とr8 とのXOR をとる。
31 /r XOR r/m16,r16 r/m16 とr16 とのXOR をとる。
31 /r XOR r/m32,r32 r/m32 とr32 とのXOR をとる。
32 /r XOR r8,r/m8 r8 とr/m8 とのXOR をとる。
33 /r XOR r16,r/m16 r16 とr/m16 とのXOR をとる。
33 /r XOR r32,r/m32 r32 とr/m32 とのXOR をとる。
3-765
命令セット・リファレンス
XOR?Logical Exclusive OR ( 続き)
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) 現行特権レベルが3 のときに、アライメント・チェックがイネーブルに
されていて、アライメントが合わないメモリ参照が行われた場合。
実アドレス・モード例外
#GP メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
仮想8086 モード例外
#GP(0) メモリ・オペランドの実効アドレスがCS、DS、ES、FS、またはGS セ
グメントの範囲外の場合。
#SS(0) メモリ・オペランドの実効アドレスがSS セグメントの範囲外の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#AC(0) アライメント・チェックがイネーブルにされていて、アライメントが合
わないメモリ参照が行われた場合。
3-766
命令セット・リファレンス
XORPD?Bitwise Logical XOR for Double-Precision Floating-Point
Values
説明
ソース・オペランド（第2 オペランド）の2 つのパックド倍精度浮動小数点値とデスティネーショ
ン・オペランド（第1 オペランド）の2 つのパックド倍精度浮動小数点値の間でビット単位のXOR
（排他的論理和）演算を実行し、結果をデスティネーション・オペランドに格納する。ソース・オペ
ランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・
オペランドはXMMレジスタである。
操作
DEST[127-0] ← DEST[127-0] BitwiseXOR SRC[127-0];
同等のインテルC/C++ コンパイラ組み込み関数
XORPD __m128d _mm_xor_pd(__m128d a, __m128d b)
SIMD 浮動小数点例外
なし。
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
オペコード命令説明
66 0F 57 /r XORPD xmm1, xmm2/m128 xmm2/m128 とxmm1 のビット単位のXOR（排他的論
理和）演算を実行する。
3-767
命令セット・リファレンス
XORPD?Bitwise Logical XOR for Double-Precision Floating-Point
Values ( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE2 が0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-768
命令セット・リファレンス
XORPS?Bitwise Logical XOR for Single-Precision Floating-Point
Values
説明
ソース・オペランド（第2 オペランド）の4 つのパックド単精度浮動小数点値とデスティネーショ
ン・オペランド（第1 オペランド）の4 つのパックド単精度浮動小数点値の間でビット単位のXOR
（排他的論理和）演算を実行し、結果をデスティネーション・オペランドに格納する。ソース・オペ
ランドは、XMMレジスタまたは128 ビットのメモリ・ロケーションである。デスティネーション・
オペランドはXMMレジスタである。
操作
DEST[127-0] ← DEST[127-0] BitwiseXOR SRC[127-0];
同等のインテルC/C++ コンパイラ組み込み関数
XORPS __m128 _mm_xor_ps(__m128 a, __m128 b)
SIMD 浮動小数点例外
なし
保護モード例外
#GP(0) CS、DS、ES、FS、またはGS セグメント内のメモリ・オペランドの実
効アドレスが無効の場合。
セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
#SS(0) SS セグメント内のアドレスが無効の場合。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
オペコード命令説明
0F 57 /r XORPS xmm1, xmm2/m128 xmm2/m128 とxmm1 のビット単位のXOR（排他的論
理和）演算を実行する。
3-769
命令セット・リファレンス
XORPS?Bitwise Logical XOR for Single-Precision Floating-Point
Values ( 続き)
実アドレス・モード例外
#GP(0) セグメントに関係なく、メモリ・オペランドのアライメントが16 バイ
トに合っていない場合。
割り込み13 オペランドの一部が0 〜 FFFFH の実効アドレス空間の範囲外の場合。
#NM CR0 のTS がセットされた場合。
#XM マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が1 の場合。
#UD マスクされていないSIMD 浮動小数点例外が発生し、CR4 の
OSXMMEXCPT が0 の場合。
CR0 のEM がセットされた場合。
CR4 のOSFXSR が0 の場合。
CPUID 機能フラグSSE が 0 の場合。
仮想8086 モード例外
実アドレス・モードと同じ例外。
#PF( フォルト・コード) ページ・フォルトが発生した場合。
3-770
命令セット・リファレンス
A
オペコード・マップ

A-1
付録A
オペコード・マップ
本付録にあるオペコード・テーブルは、IA-32 アーキテクチャのオブジェクト・コードを解釈する際
に便利である。命令は3 つのエンコーディング・グループに分かれている。そのグループとは、1 バ
イト・オペコードのエンコーディング、2 バイト・オペコードのエンコーディング、およびエスケー
プ( 浮動小数点) エンコーディングである。1 バイトと2 バイトのオペコードのエンコーディングは、
整数、システム、MMX テクノロジ、SSE、およびSSE2 のエンコーディングに使用される。これら
の命令のオペコード・マップを表A-2. 〜A-6. に示す。A.2.1. 項「1 バイト・オペコード命令」〜A.2.4.
項「1 バイトと2 バイトのオペコードのオペコード拡張」項では、1 バイトと2 バイトのオペコード・
マップを解釈するための命令を示している。エスケープ・エンコーディングは、浮動小数点命令を
コード化するために使用される。表A-7. 〜 A-22. に、これらの命令のオペコード・マップを示す。
A.2.5. 項「エスケープ・オペコード命令」では、エスケープ・オペコード・マップを解釈するための
命令を示している。
本付録にあるオペコードの表は、IA-32 プロセッサのオブジェクト・コードを解釈する際に便利であ
る。オペコードの上位4 ビットを、オペコードの表の行に対するインデックスとして使用する。オペ
コードの下位4 ビットを、表の列に対するインデックスとして使用する。オペコードが0FH である
場合は、2 バイトのオペコードの表を参照し、オペコードの第2 バイトをその表の行と列に対するイ
ンデックスとして使用する。
浮動小数点命令用のエスケープ(ESC) オペコードの表では、各ページの一番上にオペコードの上位8
ビットを示す。オペコードに付随するModR/Mバイトが00H〜BFHの範囲内である場合は、各ペー
ジの3番目の表の一番上の行に示すModR/Mバイトのビット3〜5とREGビットによってオペコード
が決まる。ModR/Mバイトが00H 〜BFH の範囲外である場合のオペコード・マップは、各ページの
最後の2 つの表に示す。
ModR/Mバイト、レジスタ値、およびさまざまなアドレス指定形式の詳細については、第2 章「命令
フォーマット」を参照のこと。
A.1. 略語の説明
オペランドは、形式Zz の2 文字のコードによって識別される。最初の文字は、大文字の英字であり、
アドレス指定方式を指定する。2 番目の文字は、小文字の英字であり、オペランドのタイプを指定す
る。
A.1.1. アドレス指定方式のコード
以下の略号は、アドレス指定方式に使用される。
A 直接アドレス。命令は、ModR/M バイトをもたない。オペランドのアドレスは、命令内に
コード化されている。ベース・レジスタ、インデックス・レジスタ、またはスケーリング・
ファクタを適用することはできない。例えば、far JMP(EA)。
C ModR/M バイトのreg フィールドで制御レジスタを選択する( 例、MOV (0F20, 0F22)）。
A-2
オペコード・マップ
D ModR/Mバイトのregフィールドでデバッグ・レジスタを選択する。例えば、MOV (0F21,0F23)。
E ModR/M バイトがオペコードの後に続き、オペランドを指定する。オペランドは、汎用レ
ジスタまたはメモリ・アドレスである。オペランドがメモリ・アドレスである場合は、ア
ドレスは、セグメント・レジスタと、ベース・レジスタ、インデックス・レジスタ、スケー
リング・ファクタ、ディスプレースメントの任意の組み合わせから計算される。
F EFLAGS レジスタ。
G ModR/M バイトのreg フィールドで汎用レジスタを選択する( 例、AX(000))。
I 即値データ。オペランド値は命令の後続バイト内にコード化される。
J 命令は、命令ポインタ・レジスタに付加する相対オフセットをもつ( 例、JMP(0E9)、LOOP)。
M ModR/M バイトは、メモリだけを参照することができる( 例、BOUND、LES、LDS、LSS、
LFS、LGS、CMPXCHG8B)。
O 命令は、ModR/M バイトをもたない。オペランドのオフセットが命令内に( アドレス・サ
イズ属性に応じて) ワードまたはダブルワードとして入れられる。ベース・レジスタ、イ
ンデックス・レジスタ、またはスケーリング・ファクタを適用することはできない( 例、
MOV (A0-A3))。
P ModR/M バイトのreg フィールドでパックド・クワッドワードMMX テクノロジ・レジス
タを選択する。
Q ModR/M バイトがオペコードの後に続き、オペランドを指定する。オペランドは、MMX テ
クノロジ・レジスタまたはメモリ・アドレスである。オペランドがメモリ・アドレスであ
る場合は、アドレスは、セグメント・レジスタと、ベース・レジスタ、インデックス・レ
ジスタ、スケーリング・ファクタ、ディスプレースメントの任意の組み合わせから計算さ
れる。
R ModR/M バイトのmod フィールドは、汎用レジスタだけを参照することがある( 例、MOV
(0F20-0F24, 0F26))。
S ModR/M バイトのreg フィールドでセグメント・レジスタを選択する( 例、MOV (8C, 8E))。
T ModR/M バイトのreg フィールドでテスト・レジスタを選択する( 例、MOV (0F24, 0F26))。
V ModR/M バイトのreg フィールドで128 ビットXMM レジスタを選択する。
W ModR/M バイトがオペコードの後に続き、オペランドを指定する。オペランドは128 ビッ
トXMM レジスタまたはメモリ・アドレスである。オペランドがメモリ・アドレスの場合、
アドレスは、セグメント・レジスタと、ベース・レジスタ、インデックス・レジスタ、ス
ケーリング・レジスタ、およびディスプレースメントの任意の組み合わせから計算される。
X DS:SI レジスタ・ペアによってアドレス指定されるメモリ( 例、MOVS、CMPS、OUTS、ま
たはLODS)。
Y ES:DI レジスタ・ペアによってアドレス指定されるメモリ( 例、MOVS、CMPS、INS、STOS、
またはSCAS)。
A-3
オペコード・マップ
A.1.2. オペランド・タイプのコード
以下の略号は、オペランド・タイプに使用される。
a メモリ内の2 つの1 ワード・オペランドまたはメモリ内の2 つのダブルワード・オペラン
ド。オペランド・サイズ属性に依存する(BOUND 命令だけに使用される)。
b バイト。オペランド・サイズ属性に関係ない。
c バイトまたはワード。オペランド・サイズ属性に依存する。
d ダブルワード。オペランド・サイズ属性に関係ない。
dq ダブル・クワッドワード。オペランド・サイズ属性に関係ない。
p 32 ビットまたは48 ビットのポインタ。オペランド・サイズ属性に依存する。
pi クワッドワードのMMX テクノロジ・レジスタ( 例えば、mm0)。
ps 128 ビットのパックド単精度浮動小数点データ。
q クワッドワード。オペランド・サイズ属性に関係ない。
s 6バイトの疑似ディスクリプタ。
ss 128 ビットのパックド単精度浮動小数点データのスカラ要素。
si ダブルワードの整数レジスタ( 例えば、eax)。
v ワードまたはダブルワード。オペランド・サイズ属性に依存する。
w ワード。オペランド・サイズ属性に関係ない。
A.1.3. レジスタ・コード
オペランドがオペコード内にコード化された特定のレジスタであるときは、レジスタはその名前( 例
えば、AX、CL、ESI) によって識別される。レジスタの名前は、そのレジスタの幅が32 ビット、16
ビット、または8 ビットのいずれであるかを示す。レジスタの幅がオペランド・サイズ属性に依存す
る場合は、形式eXX のレジスタ識別子が使用される。例えば、eAXは、オペランド・サイズ属性が
16であるときはAXレジスタが使用され、オペランド・サイズ属性が32 であるときはEAXレジスタ
が使用されることを示す。
A.2. オペコードの見つけ方の例
ここでは、オペコード・マップの使い方の例をいくつか示す。ModR/M バイト、レジスタ値、およ
び各種のアドレス指定形式についての詳細は、第3 章「命令セット・リファレンス」の最初の項を参
照されたい。
A-4
オペコード・マップ
A.2.1. 1 バイト・オペコード命令
表A-2. とA-3. に、1 バイト・オペコードのオペコード・マップを示す。1 バイト・オペコード・マッ
プでは、命令およびそのオペランドは、16 進のオペコードから決定することができる。例えば、
オペコード: 030500000000H
ADD 命令のオペコード030500000000H は、1 バイト・オペコード・マップから次のように解釈する
ことができる。すなわち、オペコードの1 桁目(0) はオペコード・マップ・テーブルの行を示し、2 桁
目(3) は列を示す。第1 オペランド( タイプGv) は、オペランド・サイズ属性に応じてワードまたはダ
ブルワードである汎用レジスタを示している。第2 オペランド( タイプEv) は、オペランドがワード
またはダブルワードの汎用レジスタあるいはメモリ・アドレスのいずれであるかを指定するModR/M
バイトが後に続くことを示している。この命令のModR/Mバイトは05Hであり、これは、32 ビット
のディスプレースメント(00000000H) が後に続くことを示している。ModR/M バイトのreg/ オペコー
ド部分( ビット3 〜 5) は、EAX レジスタを示す000 である。したがって、このオペコードの命令は、
ADD EAX,mem_op であり、mem_op のオフセットは00000000Hであると決定することができる。
1 バイトと2 バイトのオペコードは、「グループ」番号を指す場合もある。これらのグループ番号は、
命令がModR/M バイトのreg/ オペコード・ビットをオペコード拡張として使用することを示してい
る(A.2.4. 項「1 バイトと2 バイトのオペコードのオペコード拡張」を参照)。
A.2.2. 2 バイト・オペコード命令
0FHで始まる命令は、表A-4. とA-5. に示している2 バイトのオペコード・マップにある。ここでは、
オペコードの第2 バイトは、表の特定の行と列の参照に使用する。例えば、オペコード
0FA4050000000003Hは、2 バイトのオペコード・マップの行A、列4 にある。このオペコードは、オ
ペランドEv、Gv、およびIbのSHLD命令を指している。これらのオペランドは、次のように解釈される。
Ev ワードまたはダブルワードのオペランドを指定するModR/M バイトがオペコードの後に続
く。
Cv ModR/M バイトのreg フィールドが汎用レジスタを選択する。
Ib 即値データが命令の後続バイト内にコード化されている。
第3 バイトは、ModR/M バイト(05H) である。mod およびオペコード/reg フィールドは、32 ビットの
ディスプレースメントが後に続くことおよびEAXレジスタがソースであることを示している。
オペコードの次の部分は、デスティネーション・メモリ・オペランドの32 ビット・ディスプレース
メント(00000000H) である。最後の部分は、シフトのカウントを表す即値バイト(03H) である。
このような分析により、このオペコードが次の命令を表すことが示される。
SHLD DS:00000000H, EAX, 3
LSB アドレスMSB アドレス
03 05 00 00 00 00
A-5
オペコード・マップ
SHLDオペコードの次の部分は、デスティネーション・メモリ・オペランドの32 ビット・ディスプ
レースメント(00000000H) であり、この後に、シフトのカウントを表す即値バイト(03H) が続く。こ
のブレークダウンによって、オペコード0FA4050000000003H が命令SHLD DS: 00000000H, EAX, 3
を表すことが示されている。
SHLD DS:00000000H, EAX, 3.
以下の表では、MMX テクノロジ、SSE、およびSSE2 によって追加されたニーモニックを小文字で
強調する。
A.2.3. オペコード・マップの注意事項
表A-1. は、特定のエンコーディングについての注意事項を示している。以下のオペコード・マップ
( 表A-2. 〜A-6.) では、これらの注意を上付き文字で示す。
1 バイト・オペコード・マップ( 表A-2. 〜A-3.) については、グレー表示で命令グループを示す。
表A-1. 命令セット・エンコーディング表についての注意事項
記号注意
1A ModR/M バイトのビット5、4、3 をオペコード拡張として使用(A.2.4. 節「1 バイトと2 バイト
のオペコードのオペコード拡張」を参照のこと)。
1B 故意に無効オペコード例外(#UD) を発生させる場合は、0F0B オペコード(UD2 命令) または
0FB9H オペコードを使用する。
1C Pentium III プロセッサに追加された命令の中には、同じ2 バイト・オペコードを使用するもの
がある。命令にバリエーションがある場合、またはオペコードが別々の命令を表す場合は、そ
の命令を区別するためにModR/M バイトが使用される。命令を完全にデコードするために必要
なModR/M バイトの値については、表A-6. を参照のこと( このような命令としては、
PREFETCH およびそのバリエーションだけではなく、SFENCE、STMXCSR、LDMXCSR、
FXRSTOR、FXSAVE がある)。
A-6
オペコード・マップ
表A-2. 1 バイトのオペコード・マップ( 左側)
0 1 2 3 4 5 6 7
0 ADD PUSH
ES
POP
ES
Eb, Gb Ev, Gv Gb, Eb Gv, Ev AL, Ib eAX, Iv
1 ADC PUSH
SS
POP
SS
Eb, Gb Ev, Gv Gb, Eb Gv, Ev AL, Ib eAX, Iv
2 AND SEG=ES DAA
Eb, Gb Ev, Gv Gb, Eb Gv, Ev AL, Ib eAX, Iv
3 XOR SEG=SS AAA
Eb, Gb Ev, Gv Gb, Eb Gb, Ev AL, Ib eAX, Iv
4 INC general register
eAX eCX eDX eBX eSP eBP eSI eDI
5 PUSH general register
eAX eCX eDX eBX eSP eBP eSI eDI
6 PUSHA/
PUSHAD
POPA/
POPAD
BOUND
Gv, Ma
ARPL
Ew, Gw
SEG=FS SEG=GS Opd
Size
Addr
Size
7 Jcc, Jb - Short-displacement jump on condition
O NO B/NAE/C NB/AE/NC Z/E NZ/NE BE/NA NBE/A
8 Immediate Grp 11A TEST XCHG
Eb, Ib Ev, Iv Ev, Ib Ev, Ib Eb, Gb Ev, Gv Eb, Gb Ev, Gv
9 NOP XCHG word or double-word register with eAX
eCX eDX eBX eSP eBP eSI eDI
A MOV MOVS/
MOVSB
Xb, Yb
MOVS/
MOVSW/
MOVSD
Xv, Yv
CMPS/
CMPSB
Xb, Yb
CMPS/
CMPSW/
CMPSD
Xv, Yv
AL, Ob eAX, Ov Ob, AL Ov, eAX
B MOV immediate byte into byte register
AL CL DL BL AH CH DH BH
C Shift Grp 21A RETN
Iw
RETN LES
Gv, Mp
LDS
Gv, Mp
Grp 111A - MOV
Eb, Ib Ev, Ib Eb, Ib Ev, Iv
D Shift Grp 21A AAM
Ib
AAD
Ib
XLAT/
XLATB
Eb, 1 Ev, 1 Eb, CL Ev, CL
E LOOPNE/
LOOPNZ
Jb
LOOPE/
LOOPZ
Jb
LOOP
Jb
JCXZ/
JECXZ
Jb
IN OUT
AL, Ib eAX, Ib Ib, AL Ib, eAX
F LOCK REPNE REP/
REPE
HLT CMC Unary Grp 31A
Eb Ev
A-7
オペコード・マップ
表A-3. 1 バイトのオペコード・マップ( 右側)
注:
オペコード・マップ表A-2. およびA-3. にあるすべての空白は、予約されており、使用してはならない。
これらの未定義オペコードの動作に依存してはならない。
8 9 A B C D E F
OR PUSH
CS
2-byte
escape
0
Eb, Gb Ev, Gv Gb, Eb Gv, Ev AL, Ib eAX, Iv
SBB PUSH
DS
POP
DS
1
Eb, Gb Ev, Gv Gb, Eb Gv, Ev AL, Ib eAX, Iv
SUB SEG=CS DAS 2
Eb, Gb Ev, Gv Gb, Eb Gv, Ev AL, Ib eAX, Iv
CMP SEG=DS AAS 3
Eb, Gb Ev, Gv Gb, Eb Gv, Ev AL, Ib eAX, Iv
DEC general register 4
eAX eCX eDX eBX eSP eBP eSI eDI
POP into general register 5
eAX eCX eDX eBX eSP eBP eSI eDI
PUSH
Iv
IMUL
Gv, Ev, Iv
PUSH
Ib
IMUL
Gv, Ev, Ib
INS/
INSB
Yb, DX
INS/
INSW/
INSD
Yv, DX
OUTS/
OUTSB
DX, Xb
OUTS/
OUTSW/
OUTSD
DX, Xv
6
Jcc, Jb- Short displacement jump on condition 7
S NS P/PE NP/PO L/NGE NL/GE LE/NG NLE/G
MOV MOV
Ew, Sw
LEA
Gv, M
MOV
Sw, Ew
POP
Ev
8
Eb, Gb Ev, Gv Gb, Eb Gv, Ev
CBW/
CWDE
CWD/
CDQ
CALLF
Ap
FWAIT/
WAIT
PUSHF/
PUSHFD
Fv
POPF/
POPFD
Fv
SAHF LAHF 9
TEST STOS/
STOSB
Yb, AL
STOS/
STOSW/
STOSD
Yv, eAX
LODS/
LODSB
AL, Xb
LODS/
LODSW/
LODSD
eAX, Xv
SCAS/
SCASB
AL, Yb
SCAS/
SCASW/
SCASD
eAX, Xv
A
AL, Ib eAX, Iv
MOV immediate word or double into word or double register B
eAX eCX eDX eBX eSP eBP eSI eDI
ENTER
Iw, Ib
LEAVE RETF
Iw
RETF INT
3
INT
Ib
INTO IRET C
ESC (Escape to coprocessor instruction set) D
CALL
Jv
JMP IN OUT E
near
JV
far
AP
short
Jb
AL, DX eAX, DX DX, AL DX, eAX
CLC STC CLI STI CLD STD INC/DEC
Grp 41A
INC/DEC
Grp 51A
F
A-8
オペコード・マップ
表A-4. 2 バイトのオペコード・マップ( 左側)( 第1 バイトは0FH)
注:
オペコード・マップ表A-4. およびA-5. にあるすべての空白は、予約されており、使用してはならない。
これらの未定義オペコードの動作に依存してはならない。
0 1 2 3 4 5 6 7
0 Grp 61A Grp 71A LAR
Gv, Ew
LSL
Gv, Ew
CLTS
1 movups
Vps, Wps
movss (F3)
Vss, Wss
movups
Wps, Vps
movss (F3)
Wss, Vss
movlps
Wq, Vq
movhlps
Vq, Vq
movlps
Vq, Wq
unpcklps
Vps, Wq
unpckhps
Vps, Wq
movhps
Vq, Wq
movlhps
Vq, Vq
movhps
Wq, Vq
2 MOV
Rd, Cd
MOV
Rd, Dd
MOV
Cd, Rd
MOV
Dd, Rd
3 WRMSR RDTSC RDMSR RDPMC SYSENTER SYSEXIT
4 CMOVcc, (Gv, Ev) - Conditional Move
O NO B/C/NAE AE/NB/NC E/Z NE/NZ BE/NA A/NBE
5 movmskps
Ed, Vps
sqrtps
Vps, Wps
sqrtss (F3)
Vss, Wss
rsqrtps
Vps, Wps
rsqrtss (F3)
Vss, Wss
rcpps
Vps, Wps
rcpss (F3)
Vss, Wss
andps
Vps, Wps
andnps
Vps, Wps
orps
Vps, Wps
xorps
Vps, Wps
6 punpcklbw
Pq, Qd
punpcklwd
Pq, Qd
punpckldq
Pq, Qd
packsswb
Pq, Qq
pcmpgtb
Pq, Qq
pcmpgtw
Pq, Qq
pcmpgtd
Pq, Qq
packuswb
Pq, Qq
7 pshufw
Pq, Qq, Ib
(Grp 121A) (Grp 131A) (Grp 141A) pcmpeqb
Pq, Qq
pcmpeqw
Pq, Qq
pcmpeqd
Pq, Qq
emms
8 Jcc, Jv - Long-displacement jump on condition
O NO B/C/NAE AE/NB/NC E/Z NE/NZ BE/NA A/NBE
9 SETcc, Eb - Byte Set on condition
O NO B/C/NAE AE/NB/NC E/Z NE/NZ BE/NA A/NBE
A PUSH
FS
POP
FS
CPUID BT
Ev, Gv
SHLD
Ev, Gv, Ib
SHLD
Ev, Gv, CL
B CMPXCHG LSS
Mp
BTR
Ev, Gv
LFS
Mp
LGS
Mp
MOVZX
Eb, Gb Ev, Gv Gv, Eb Gv, Ew
C XADD
Eb, Gb
XADD
Ev, Gv
cmpps
Vps, Wps, Ib
cmpss (F3)
Vss, Wss, Ib
pinsrw
Pq, Ed, Ib
pextrw
Gd, Pq, Ib
shufps
Vps, Wps, Ib
Grp 91A
D psrlw
Pq, Qq
psrld
Pq, Qq
psrlq
Pq, Qq
pmullw
Pq, Qq
pmovmskb
Gd, Pq
E pavgb
Pq, Qq
psraw
Pq, Qq
psrad
Pq, Qq
pavgw
Pq, Qq
pmulhuw
Pq, Qq
pmulhw
Pq, Qq
movntq
Wq, Vq
F psllw
Pq, Qq
pslld
Pq, Qq
psllq
Pq, Qq
pmaddwd
Pq, Qq
psadbw
Pq, Qq
maskmovq
Ppi, Qpi
A-9
オペコード・マップ
表A-5. 2 バイトのオペコード・マップ( 右側)( 第1 バイトは0FH)
8 9 A B C D E F
INVD WBINVD 2-byte Illegal
Opcodes
UD21B
0
Prefetch1C
(Grp 161A)
1
movaps
Vps, Wps
movaps
Wps, Vps
cvtpi2ps
Vps, Qq
cvtsi2ss (F3)
Vss, Ed
movntps
Wps, Vps
cvttps2pi
Qq, Wps
cvttss2si (F3)
Gd, Wss
cvtps2pi
Qq, Wps
cvtss2si (F3)
Gd, Wss
ucomiss
Vss, Wss
comiss
Vps, Wps
2
3
CMOVcc(Gv, Ev) - Conditional Move 4
S NS P/PE NP/PO L/NGE NL/GE LE/NG NLE/G
addps
Vps, Wps
addss (F3)
Vss, Wss
mulps
Vps, Wps
mulss (F3)
Vss, Wss
subps
Vps, Wps
subss (F3)
Vss, Wss
minps
Vps, Wps
minss (F3)
Vss, Wss
divps
Vps, Wps
divss (F3)
Vss, Wss
maxps
Vps, Wps
maxss (F3)
Vss, Wss
5
punpckhbw
Pq, Qd
punpckhwd
Pq, Qd
punpckhdq
Pq, Qd
packssdw
Pq, Qd
movd
Pd, Ed
movq
Pq, Qq
6
MMX UD movd
Ed, Pd
movq
Qq, Pq
7
Jcc, Jv - Long-displacement jump on condition 8
S NS P/PE NP/PO L/NGE NL/GE LE/NG NLE/G
SETcc, Eb - Byte Set on condition 9
S NS P/PE NP/PO L/NGE NL/GE LE/NG NLE/G
PUSH
GS
POP
GS
RSM BTS
Ev, Gv
SHRD
Ev, Gv, Ib
SHRD
Ev, Gv, CL
(Grp 151A)1C IMUL
Gv, Ev
A
Grp 101A
Invalid
Opcode1B
Grp 81A
Ev, Ib
BTC
Ev, Gv
BSF
Gv, Ev
BSR
Gv, Ev
MOVSX B
Gv, Eb Gv, Ew
BSWAP C
EAX ECX EDX EBX ESP EBP ESI EDI
psubusb
Pq, Qq
psubusw
Pq, Qq
pminub
Pq, Qq
pand
Pq, Qq
paddusb
Pq, Qq
paddusw
Pq, Qq
pmaxub
Pq, Qq
pandn
Pq, Qq
D
psubsb
Pq, Qq
psubsw
Pq, Qq
pminsw
Pq, Qq
por
Pq, Qq
paddsb
Pq, Qq
paddsw
Pq, Qq
pmaxsw
Pq, Qq
pxor
Pq, Qq
E
psubb
Pq, Qq
psubw
Pq, Qq
psubd
Pq, Qq
paddb
Pq, Qq
paddw
Pq, Qq
paddd
Pq, Qq
F
A-10
オペコード・マップ
A.2.4. 1 バイトと2 バイトのオペコードのオペコード拡張
1 バイトと2 バイトのオペコードの一部は、ModR/Mバイトのビット5、4、3( 図A-1. のnnn フィール
ド) をオペコードの拡張として使用する。オペコード拡張をもつオペコードは、表A-6. でグループ
番号( グループ1、グループ2 など) で示している。(1 からAまでの範囲の) グループ番号は、オペコー
ド拡張フィールドのエンコーディングがある表A-6. へのエントリ・ポイントを提供する。例えば、
80Hの1 バイト・オペコードをもつADD命令はグループ1 命令である。その後、表A-6. によってこ
の命令のModR/Mバイトでコード化されなければならないオペコード拡張が000Bであることが示さ
れる。
mod nnn R/M
図A-1. ModR/M バイトのnnn フィールド( ビット5、4、3)
A-11
オペコード・マップ
注:
オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-6. グループ番号による1 バイトと2 バイトのオペコードのオペコード拡張
ModR/M バイトのビット5、4、3 のエンコーディング
オペコードグループMod 7,6 000 001 010 011 100 101 110 111
80-83 1 mem11 ADD OR ADC SBB AND SUB XOR CMP
C0, C1 reg, imm
D0, D1 reg, 1
D2, D3 reg, CL
2 mem11 ROL ROR RCL RCR SHL/SAL SHR SAR
F6, F7 3 mem11 TEST
Ib/Iv
NOT NEG MUL
AL/eAX
IMUL
AL/eAX
DIV
AL/eAX
IDIV
AL/eAX
FE 4 mem11 INC
Eb
DEC
Eb
FF 5 mem11 INC
Ev
DEC
Ev
CALLN
Ev
CALLF
Ep
JMPN
Ev
JMPF
Ep
PUSH
Ev
OF OO 6 mem11 SLDT
Ew
STR
Ew
LLDT
Ew
LTR
Ew
VERR
Ew
VERW
Ew
OF O1 7 mem11 SGDT
Ms
SIDT
Ms
LGDT
Ms
LIDT
Ms
SMSW
Ew
LMSW
Ew
INVLPG
Mb
OF BA 8 mem11 BT BTS BTR BTC
OF C7 9
mem CMPXCH
8B Mq
11
OF B9 10
mem
11
C6
11
mem MOV
Ev, Iv
C7 11 MOV
Ev, Iv
OF 71 12
mem
11 psrlw
Pq, Ib
psraw
Pq, Ib
psllw
Pq, Ib
OF 72 13
mem
11 psrld
Pq, Ib
psrad
Pq, Ib
pslld
Pq, Ib
OF 73 14
mem
11 psrlq
Pq, Ib
psllq
Pq, Ib
OF AE 15
mem fxsave fxrstor ldmxcsr stmxcsr
11 sfence
OF 18 16
mem prefetch
NTA
prefetch
T0
prefetch
T1
prefetch
T2
11
A-12
オペコード・マップ
A.2.5. エスケープ・オペコード命令
表A-7. 〜A-22. に、エスケープ命令オペコード( 浮動小数点命令オペコード) のオペコード・マップ
を示す。これらのオペコード・マップは、D8 〜DFのオペコードの第1 バイトによってグループ化さ
れる。これらのオペコードはそれぞれ、ModR/Mバイトをもつ。ModR/M バイトが00H 〜 BFH の範
囲内にある場合は、ModR/Mバイトのビット5、4、3 がオペコード拡張として使用され、1 バイトと
2 バイトのオペコードに使用された技法と同様である(A.2.4. 項「1 バイトと2 バイトのオペコードの
オペコード拡張」を参照)。ModR/Mバイトが00H〜BFHの範囲外にある場合は、ModR/Mバイト全
体がオペコード拡張として使用される。
A.2.5.1. ModR/M バイトが00H 〜 BFH の範囲内にある場合のオペコード
オペコードDD0504000000H は、次のように解釈することができる。すなわち、このオペコードで
コード化される命令は、A.2.5.8. 項「第1 バイトとしてDDをもつエスケープ・オペコード」にある。
ModR/M バイト(05H) は、00H〜BFHの範囲内にあるので、このバイトのビット3 〜5 は、オペコー
ドがFLD倍精度実数命令用であることを示している( 表A-9. を参照)。ロードされる倍精度実数値は、
00000004H にであり、これは、このオペコードの後に続き、このオペコードに属している32 ビット
のディスプレースメントである。
A.2.5.2. ModR/M バイトが00H 〜 BFH の範囲外にある場合のオペコード
オペコードD8C1Hは、00H〜BFHの範囲外にあるModR/Mバイトをもつオペコードの例を示してい
る。ここでコード化される命令は、A.2.4. 項「1 バイトと2 バイトのオペコードのオペコード拡張」に
ある。表A-8. で、ModR/M バイトC1H は行C 列1 を示し、これはST(0)、ST(1) をオペランドとして
使用するFADD命令である。
A-13
オペコード・マップ
A.2.5.3. 第1 バイトとしてD8 をもつエスケープ・オペコード
表A-7. とA-8. は、D8Hで始まるエスケープ命令オペコードのオペコード・マップである。表A-7. に、
付随するModR/M バイトが00H〜BFHの範囲内にある場合のオペコード・マップを示す。ここでは、
ビット5、4、3( 図A-1. のnnn フィールド) の値が命令を選択する。
表A-8. に、付随するModR/Mバイトが00H〜BFHの範囲外にある場合のオペコード・マップを示す。
この場合は、ModR/Mバイトの1 桁目が表の行を選択し、2 桁目が列を選択する。
表A-7. ModR/M バイトが00H 〜 BFH 内にあるときのD8 オペコード・マップ1
ModR/M バイトのnnn フィールド( 図A-1. を参照)
000 001 010 011 100 101 110 111
FADD
単精度実数
FMUL
単精度実数
FCOM
単精度実数
FCOMP
単精度実数
FSUB
単精度実数
FSUBR
単精度実数
FDIV
単精度実数
FDIVR
単精度実数
表A-8. ModR/M バイトが00H 〜 BFH 外にあるときのD8 オペコード・マップ1
0 1 2 3 4 5 6 7
C FADD
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
D FCOM
ST(0),ST(0) ST(0),ST(1) ST(0),T(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
E FSUB
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
F FDIV
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
8 9 A B C D E F
C FMUL
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
D FCOMP
ST(0),ST(0) ST(0),ST(1) ST(0),T(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
E FSUBR
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
F FDIVR
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
A-14
オペコード・マップ
A.2.5.4. 第1 バイトとしてD9 をもつエスケープ・オペコード
表A-9. とA-10. は、D9H で始まるエスケープ命令オペコードのオペコード・マップである。表A-9.
に、付随するModR/Mバイトが00H〜BFHの範囲内にある場合のオペコード・マップを示す。ここ
では、ビット5、4、3( 図A-1. のnnn フィールド) の値が命令を選択する。
.
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-10. に、付随するModR/M バイトが00H 〜 BFH の範囲外にある場合のオペコード・マップを示
す。この場合は、ModR/Mバイトの1 桁目が表の行を選択し、2 桁目が列を選択する。
表A-10. ModR/M バイトが00H 〜 BFH 外にあるときのD9 オペコード・マップ1
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-9. ModR/M バイトが00H 〜 BFH 内にあるときのD9 オペコード・マップ1
ModR/M バイトのnnn フィールド( 図A-1. を参照)
000 001 010 011 100 101 110 111
FLD
単精度実数
FST
単精度実数
FSTP
単精度実数
FLDENV
14/28 バイト
FLDCW
2 バイト
FSTENV
14/28 バイト
FSTCW
2 バイト
0 1 2 3 4 5 6 7
C FLD
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
D FNOP
E FCHS FABS FTST FXAM
F F2XM1 FYL2X FPTAN FPATAN FXTRACT FPREM1 FDECSTP FINCSTP
8 9 A B C D E F
C FXCH
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
D
E FLD1 FLDL2T FLDL2E FLDPI FLDLG2 FLDLN2 FLDZ
F FPREM FYL2XP1 FSQRT FSINCOS FRNDINT FSCALE FSIN FCOS
A-15
オペコード・マップ
A.2.5.5. 第1 バイトとしてDA をもつエスケープ・オペコード
表A-11. とA-12. は、DAHで始まるエスケープ命令オペコードのオペコード・マップである。表A-11.
に、付随するModR/Mバイトが00H〜BFHの範囲内にある場合のオペコード・マップを示す。ここ
では、ビット5、4、3( 図A-1. のnnn フィールド) の値が命令を選択する。
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-12. に、付随するModR/Mバイトが00H 〜 BFH の範囲外にある場合のオペコード・マップを示
す。この場合は、ModR/Mバイトの1 桁目が表の行を選択し、2 桁目が列を選択する。
表A-12. ModR/M バイトが00H 〜 BFH 外にあるときのDA オペコード・マップ1
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-11. ModR/M バイトが00H 〜 BFH 内にあるときのDA オペコード・マップ1
ModR/M バイトのnnn フィールド( 図A-1. を参照)
000 001 010 011 100 101 110 111
FIADD
dword 整数
FIMUL
dword 整数
FICOM
dword 整数
FICOMP
dword 整数
FISUB
dword 整数
FISUBR
dword 整数
FIDIV
dword 整数
FIDIVR
dword 整数
0 1 2 3 4 5 7
C FCMOVB
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
D FCMOVBE
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
E
F
8 9 A B C D E F
C FCMOVE
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
D FCMOVU
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
E FUCOMPP
F
A-16
オペコード・マップ
A.2.5.6. 第1 バイトとしてDB をもつエスケープ・オペコード
表A-13. とA-14. は、DBHで始まるエスケープ命令オペコードのオペコード・マップである。表A-13.
に、付随するModR/Mバイトが00H〜BFHの範囲内にある場合のオペコード・マップを示す。ここ
では、ビット5、4、3( 図A-1. のnnn フィールド) の値が命令を選択する。
表A-13. ModR/M バイトが00H 〜 BFH 内にあるときのDB オペコード・マップ1
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-14. に、付随するModR/M バイトが00H 〜 BFH の範囲外にある場合のオペコード・マップを示
す。この場合は、ModR/Mバイトの1 桁目が表の行を選択し、2 桁目が列を選択する。
表A-14. ModR/M バイトが00H 〜 BFH 外にあるときのDB オペコード・マップ1
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
nnn Field of ModR/M Byte (refer to 図A-1.)
000 001 010 011 100 101 110 111
FILD
dword 整数
FIST
dword 整数
FISTP
dword 整数
FLD
拡張実数
FSTP
拡張実数
0 1 2 3 4 5 7
C FCMOVNB
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
D FCMOVNBE
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
E FCLEX FINIT
F FCOMI
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
8 9 A B C D E F
C FCMOVNE
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
D FCMOVNU
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
E FUCOMI
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
F
A-17
オペコード・マップ
A.2.5.7. 第1 バイトとしてDC をもつエスケープ・オペコード
表A-15. とA-16. は、DCHで始まるエスケープ命令オペコードのオペコード・マップである。表A-15.
に、付随するModR/Mバイトが00H〜BFHの範囲内にある場合のオペコード・マップを示す。ここ
では、ビット5、4、3( 図A-1. のnnn フィールド) の値が命令を選択する。
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-16. に、付随するModR/Mバイトが00H 〜 BFH の範囲外にある場合のオペコード・マップを示
す。この場合は、ModR/Mバイトの1 桁目が表の行を選択し、2 桁目が列を選択する。
表A-16. ModR/M バイトが00H 〜 BFH 外にあるときのDC オペコード・マップ1
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-15. ModR/M バイトが00H 〜 BFH 内にあるときのDC オペコード・マップ1
ModR/M バイトのnnn フィールド( 図A-1. を参照)
000 001 010 011 100 101 110 111
FADD
倍精度実数
FMUL
倍精度実数
FCOM
倍精度実数
FCOMP
倍精度実数
FSUB
倍精度実数
FSUBR
倍精度実数
FDIV
倍精度実数
FDIVR
倍精度実数
0 1 2 3 4 5 7
C FADD
ST(0),ST(0) ST(1),ST(0) ST(2),ST(0) ST(3),ST(0) ST(4),ST(0) ST(5),ST(0) ST(6),ST(0) ST(7),ST(0)
D
E FSUBR
ST(0),ST(0) ST(1),ST(0) ST(2),ST(0) ST(3),ST(0) ST(4),ST(0) ST(5),ST(0) ST(6),ST(0) ST(7),ST(0)
F FDIVR
ST(0),ST(0) ST(1),ST(0) ST(2),ST(0) ST(3),ST(0) ST(4),ST(0) ST(5),ST(0) ST(6),ST(0) ST(7),ST(0)
8 9 A B C D E F
C FMUL
ST(0),ST(0) ST(1),ST(0) ST(2),ST(0) ST(3),ST(0) ST(4),ST(0) ST(5),ST(0) ST(6),ST(0) ST(7),ST(0)
D
E FSUB
ST(0),ST(0) ST(1),ST(0) ST(2),ST(0) ST(3),ST(0) ST(4),ST(0) ST(5),ST(0) ST(6),ST(0) ST(7),ST(0)
F FDIV
ST(0),ST(0) ST(1),ST(0) ST(2),ST(0) ST(3),ST(0) ST(4),ST(0) ST(5),ST(0) ST(6),ST(0) ST(7),ST(0)
A-18
オペコード・マップ
A.2.5.8. 第1 バイトとしてDD をもつエスケープ・オペコード
表A-17. とA-18. は、DDHで始まるエスケープ命令オペコードのオペコード・マップである。表A-17.
に、付随するModR/Mバイトが00H〜BFHの範囲内にある場合のオペコード・マップを示す。ここ
では、ビット5、4、3( 図A-1. のnnn フィールド) の値が命令を選択する。
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-18. に、付随するModR/M バイトが00H 〜 BFH の範囲外にある場合のオペコード・マップを示
す。この場合は、ModR/Mバイトの1 桁目が表の行を選択し、2 桁目が列を選択する。
表A-18. ModR/M バイトが00H 〜 BFH 外にあるときのDD オペコード・マップ1
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-17. ModR/M バイトが00H 〜 BFH 内にあるときのDD オペコード・マップ1
ModR/M バイトのnnn フィールド( 図A-1. を参照)
000 001 010 011 100 101 110 111
FLD
倍精度実数
FST
倍精度実数
FSTP
倍精度実数
FRSTOR
98/108 バイト
FSAVE
98/108 バイト
FSTSW
2 バイト
0 1 2 3 4 5 7
C FFREE
ST(0) ST(1) ST(2) ST(3) ST(4) ST(5) ST(6) ST(7)
D FST
ST(0) ST(1) ST(2) ST(3) ST(4) ST(5) ST(6) ST(7)
E FUCOM
ST(0),ST(0) ST(1),ST(0) ST(2),ST(0) ST(3),ST(0) ST(4),ST(0) ST(5),ST(0) ST(6),ST(0) ST(7),ST(0)
F
8 9 A B C D E F
C
D FSTP
ST(0) ST(1) ST(2) ST(3) ST(4) ST(5) ST(6) ST(7)
E FUCOMP
ST(0) ST(1) ST(2) ST(3) ST(4) ST(5) ST(6) ST(7)
F
A-19
オペコード・マップ
A.2.5.9. 第1 バイトとしてDE をもつエスケープ・オペコード
表A-19. とA-20. は、DEHで始まるエスケープ命令オペコードのオペコード・マップである。表A-19.
に、付随するModR/Mバイトが00H〜BFHの範囲内にある場合のオペコード・マップを示す。ここ
では、ビット5、4、3( 図A-1. のnnn フィールド) の値が命令を選択する。
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-20. に、付随するModR/Mバイトが00H 〜 BFH の範囲外にある場合のオペコード・マップを示
す。この場合は、ModR/Mバイトの1 桁目が表の行を選択し、2 桁目が列を選択する。
表A-20. ModR/M バイトが00H 〜 BFH 外にあるときのDE オペコード・マップ1
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-19. ModR/M バイトが00H 〜 BFH 内にあるときのDE オペコード・マップ1
ModR/M バイトのnnn フィールド( 図A-1. を参照)
000 001 010 011 100 101 110 111
FIADD
ワード整数
FIMUL
ワード整数
FICOM
ワード整数
FICOMP
ワード整数
FISUB
ワード整数
FISUBR
ワード整数
FIDIV
ワード整数
FIDIVR
ワード整数
0 1 2 3 4 5 7
C FADDP
ST(0),ST(0) ST(1),ST(0) ST(2),ST(0) ST(3),ST(0) ST(4),ST(0) ST(5),ST(0) ST(6),ST(0) ST(7),ST(0)
D
E FSUBRP
ST(0),ST(0) ST(1),ST(0) ST(2),ST(0) ST(3),ST(0) ST(4),ST(0) ST(5),ST(0) ST(6),ST(0) ST(7),ST(0)
F FDIVRP
ST(0),ST(0) ST(1),ST(0) ST(2),ST(0) ST(3),ST(0) ST(4),ST(0) ST(5),ST(0) ST(6),ST(0) ST(7),ST(0)
8 9 A B C D E F
C FMULP
ST(0),ST(0) ST(1),ST(0) ST(2),ST(0) ST(3),ST(0) ST(4),ST(0) ST(5),ST(0) ST(6),ST(0) ST(7),ST(0)
D FCOMPP
E FSUBP
ST(0),ST(0) ST(1),ST(0) ST(2),ST(0) ST(3),ST(0) ST(4),ST(0) ST(5),ST(0) ST(6),ST(0) ST(7),ST(0)
F FDIVP
ST(0),ST(0) ST(1),ST(0) ST(2),ST(0). ST(3),ST(0) ST(4),ST(0) ST(5),ST(0) ST(6),ST(0) ST(7),ST(0)
A-20
オペコード・マップ
A.2.5.10. 第1 バイトとしてDF をもつエスケープ・オペコード
表A-21. とA-22. は、DFHで始まるエスケープ命令オペコードのオペコード・マップである。表A-21.
に、付随するModR/Mバイトが00H〜BFHの範囲内にある場合のオペコード・マップを示す。ここ
では、ビット5、4、3( 図A-1. のnnn フィールド) の値が命令を選択する。
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-22. に、付随するModR/M バイトが00H 〜 BFH の範囲外にある場合のオペコード・マップを示
す。この場合は、ModR/Mバイトの1 桁目が表の行を選択し、2 桁目が列を選択する。
表A-22. ModR/M バイトが00H 〜 BFH 外にあるときのDF オペコード・マップ1
注:
1. オペコード・マップにあるすべての空白は、予約されており、使用してはならない。これらの未定義オ
ペコードの動作に依存してはならない。
表A-21. ModR/M バイトが00H 〜 BFH 内にあるときのDF オペコード・マップ1
ModR/M バイトのnnn フィールド( 図A-1. を参照)
000 001 010 011 100 101 110 111
FILD
ワード整数
FIST
ワード整数
FISTP
ワード整数
FBLD
パックド
BCD
FILD
qword 整数
FBSTP
パックド
BCD
FISTP
qword 整数
0 1 2 3 4 5 7
C
D
E FSTSW
AX
F FCOMIP
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
8 9 A B C D E F
C
D
E FUCOMIP
ST(0),ST(0) ST(0),ST(1) ST(0),ST(2) ST(0),ST(3) ST(0),ST(4) ST(0),ST(5) ST(0),ST(6) ST(0),ST(7)
F
B
命令フォーマット
および
エンコーディング

B-1
付録B
命令フォーマットおよびエンコーディング
本付録では、IA-32 アーキテクチャ命令の機械語命令のフォーマットとエンコーディングを説明す
る。最初のセクションでは、IA-32 アーキテクチャの機械語命令のフォーマットを詳しく説明する。
次のセクションでは、汎用、MMX、P6 ファミリ、SSE、SSE2、x87 FPUの各命令のフォーマットと
エンコーディングを説明する。
B.1. マシン命令フォーマット
すべてのインテル・アーキテクチャ命令は、図B-1. に示す汎用のマシン命令フォーマットのサブセッ
トを使用してコード化される。各命令は、オペコード、ModR/M バイトを構成するレジスタ指定子
とアドレス・モード指定子( 必要な場合)、および必要な場合には、スケール・インデックス・ベー
ス(SIB) バイト、ディスプレースメント、即値データ・フィールドからなる。
命令のプライマリ・オペコードは、命令の1 バイトまたは2 バイトにコード化される。一部の命令で
は、ModR/Mバイトのビット5、4、3 にコード化されるオペコード拡張フィールドも使用する。プラ
イマリ・オペコード内では、それより小さいエンコーディング・フィールドを定義することができ
る。これらのフィールドは、実行される操作のクラスによって変わる。フィールドでは、レジスタ・
エンコーディング、実行する条件付きテスト、または即値バイトの符号拡張などの情報を定義する。
レジスタやメモリのオペランドを参照するほとんどすべての命令は、オペコードの後にレジスタ・
バイトやアドレス・モード・バイトをもつ。このModR/Mバイトは、mod フィールド、reg フィール
ド、およびR/Mフィールドからなる。ModR/M バイトの一定のエンコーディングは、第2 アドレス・
モード・バイトであるSIBバイトを使用しなければならないことを指定する。
選択されているアドレス指定モードがディスプレースメントを指定している場合は、ディスプレー
スメント値がModR/M バイトまたはSIB バイトの直後に置かれる。ディスプレースメントが存在し
ている場合は、可能なサイズは、8、16、または32 ビットである。
命令が即値オペランドを指定している場合は、即値がディスプレースメントの後に続く。即値オペ
ランドは、指定する場合は、常に命令の最終フィールドである。
図B-1. 汎用マシン命令フォーマット
ModR/M バイト
7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7-6 5-3 2-0 7-6 5-3 2-0
T T T T T T T T T T T T T T T T Mod Reg* R/M スケール・インデッd32 | 16 | 8 | なしd32 | 16 | 8 | なし
オペコード 1 バイト
または2 バイト
(T はオペコード・
ビットを表す)
SIB バイトアドレス・ディス
プレースメント
即値データ
(4、2、1 バイト
レジスタ指定子または
アドレス・モード指定子、
* Reg フィールドは、オペコード拡張フィールド(TTT)
として使用されることもある。
クス・ベース
またはその両方
(4、2、1 バイト
またはなし)
またはなし)
B-2
命令フォーマットおよびエンコーディング
表B-1. に、一定の命令に、オペコード・バイト自体の中にも現れることもあるいくつかのより小さ
いフィールドまたはビットの一覧を示す。以降の表では、これらのフィールドとビットについて説
明し、許容可能な値の一覧を示す。(d ビットを除く) これらのフィールドのすべては、表B-10. に示
す汎用命令フォーマットで示している。
B.1.1. reg フィールド(reg)
ModR/M バイトのreg フィールドでは、汎用レジスタ・オペランドを指定する。指定されるレジス
タのグループは、エンコーディングにおけるwビットの存在と状態によって決定される( 表B-4. を
参照)。表B-2. に、wビットがエンコーディングで存在していないときのreg フィールドのエンコー
ディングを示し、表B-3. に、w ビットが存在しているときのreg フィールドのエンコーディングを
示す。
表B-1. 命令エンコーディング内の特殊フィールド
フィールド名説明ビット数
reg 汎用レジスタ指定子( 表B-2. またはB-3. を参照)。3
w データがバイトであるかまたはフルサイズであるかを指定する。ここで、フル
サイズとは16 ビットまたは32 ビットである( 表B-4. を参照)。
1
s 即値データ・フィールドの符号拡張を指定する( 表B-5. を参照)。1
sreg2 CS、SS、DS、ES のセグメント・レジスタ指定子( 表B-6. を参照)。2
sreg3 CS、SS、DS、ES、FS、GS のセグメント・レジスタ指定子( 表B-6. を参照)。3
eee 特殊目的( 制御またはデバッグ) レジスタを指定する( 表B-7. を参照)。3
tttn 条件付き命令の場合に、アサートされる条件またはネゲートされる条件を指定す
る( 表B-8. を参照)。
4
d データ操作の方向を指定する( 表B-9. を参照)。1
表B-2. w フィールドが命令に存在していないときのreg フィールドのエンコーディング
reg フィールド
16 ビット・データ操作中に
選択されるレジスタ
32 ビット・データ操作中に
選択されるレジスタ
000 AX EAX
001 CX ECX
010 DX EDX
011 BX EBX
100 SP ESP
101 BP EBP
110 SI ESI
111 DI EDI
B-3
命令フォーマットおよびエンコーディング
B.1.2. オペランド・サイズ・ビット(w) のエンコーディング
現在のオペランド・サイズ属性によって、プロセッサが16 ビットまたは32 ビットどちらの操作を実
行するかが決まる。現在のオペランド・サイズ属性の制約内で、オペランド・サイズ・ビット(w) を
使用して、8 ビット・オペランドまたはオペランド・サイズ属性で指定されたオペランド・サイズ全
体(16 ビットまたは32 ビット) への操作を指定することができる。表B-4. に、現在のオペランド・サ
イズ属性に依存したwビットのエンコーディングを示す。
B.1.3. 符号拡張(s) ビット
符号拡張(s) ビットは、8 ビットから16ビットまたは32ビットに拡張される即値データ・フィールド
をもつ命令に主に現れる。表B-5. に、s ビットのエンコーディングを示す。
表B-3. w フィールドが命令に存在しているときのreg フィールドのエンコーディング
16 ビット・データ操作中に
reg フィールドによって指定されるレジスタ
32 ビット・データ操作中に
reg フィールドによって指定されるレジスタ
w フィールドの機能w フィールドの機能
reg w = 0 のときw = 1 のときreg w = 0 のときw = 1 のとき
000 AL AX 000 AL EAX
001 CL CX 001 CL ECX
010 DL DX 010 DL EDX
011 BL BX 011 BL EBX
100 AH SP 100 AH ESP
101 CH BP 101 CH EBP
110 DH SI 110 DH ESI
111 BH DI 111 BH EDI
表B-4. オペランド・サイズ(w) ビットのエンコーディング
w ビット
オペランド・サイズ属性が16 ビット
であるときのオペランド・サイズ
オペランド・サイズ属性が32 ビット
であるときのオペランド・サイズ
0 8 ビット8 ビット
1 16 ビット32 ビット
表B-5. 符号拡張(s) ビットのエンコーディング
s 8ビット即値データへの影響
16 ビットまたは
32 ビット即値データへの影響
0 なしなし
1 16 ビットまたは32 ビットのデスティネーションに合う
ように符号拡張
なし
B-4
命令フォーマットおよびエンコーディング
B.1.4. セグメント・レジスタ・フィールド(sreg)
命令がセグメント・レジスタを操作するときは、ModR/Mバイトのreg フィールドをsreg フィールド
といい、セグメント・レジスタの指定に使用する。表B-6. に、sreg フィールドのエンコーディングを
示す。このフィールドは、2 ビット・フィールド(sreg2) のときと、3 ビット・フィールド(sreg3) のと
きがある。
* 予約エンコーディングを使用してはならない。
B.1.5. 特殊目的レジスタ(eee) フィールド
制御レジスタまたはデバッグ・レジスタが命令で参照されているときは、それらのレジスタは、
ModR/M バイトのビット5、4、3 にあるeee フィールド内にコード化される。表B-7. に、eee フィール
ドのエンコーディングを示す。
* 予約エンコーディングを使用してはならない。
表B-6. セグメント・レジスタ(sreg) フィールドのエンコーディング
2 ビットsreg
フィールド
選択されるセグメント・
レジスタ
3 ビットsreg
フィールド
選択されるセグメント・
レジスタ
00 ES 000 ES
01 CS 001 CS
10 SS 010 SS
11 DS 011 DS
100 FS
101 GS
110 予約済み*
111 予約済み*
表B-7. 特殊目的レジスタ(eee) フィールドのエンコーディング
eee 制御レジスタデバッグ・レジスタ
000 CR0 DR0
001 予約済み* DR1
010 CR2 DR2
011 CR3 DR3
100 CR4 予約済み*
101 予約済み* 予約済み*
110 予約済み* DR6
111 予約済み* DR7
B-5
命令フォーマットおよびエンコーディング
B.1.6. 条件テスト・フィールド(tttn)
( 条件付きジャンプや条件での設定などの) 条件付き命令では、条件テスト・フィールド(tttn) は、テ
ストされる条件に対してコード化される。フィールドのttt 部分では、テストする条件を指定し、n 部
分では、条件(n=0) またはその否定(n=1) のどちらを使用するかを指定する。1 バイト・プライマリ・
オペコードでは、tttn フィールドは、オペコード・バイトのビット3、2、1、0 になる。2 バイト・プ
ライマリ・オペコードでは、tttn フィールドは、第2 オペコード・バイトのビット3、2、1、0 になる。
表B-8. に、tttn フィールドのエンコーディングを示す。
B.1.7. 方向(d) ビット
多くの2 オペランド命令では、方向ビット(d) は、どちらのオペランドをソースと考え、どちらのオ
ペランドをデスティネーションと考えるかを指定する。表B-9. に、d ビットのエンコーディングを示
す。整数命令に使用するときは、d ビットは1 バイト・プライマリ・オペコードのビット1 になる。
このビットは、表B-10. には記号"d" として表されていない。その代わりに、1 または0 としてビット
の実際のエンコーディングが示されている。( 表B-16. にある) 浮動小数点命令に使用するときは、d
ビットはプライマリ・オペコードの第1 バイトのビット2 として示される。
.
表B-8. 条件付きテスト(tttn) フィールドのエンコーディング
t t t n ニーモニック条件
0000 O オーバフローがある
0001 NO オーバフローがない
0010 B, NAE より下、より上でなく等しくない
0011 NB, AE より下でない、より上か等しい
0100 E, Z 等しい、ゼロ
0101 NE, NZ 等しくない、ゼロでない
0110 BE, NA より下か等しい、より上でない
0111 NBE, A より下でなく等しくない、より上
1000 S 符号がある
1001 NS 符号がない
1010 P, PE パリティがある、パリティ偶数
1011 NP, PO パリティがない、パリティ奇数
1100 L, NGE より小さい、より大きくなく等しくない
1101 NL, GE より小さくない、より大きいか等しい
1110 LE, NG より小さいか等しい、より大きくない
1111 NLE, G より小さくなく等しくない、より大きい
B-6
命令フォーマットおよびエンコーディング
B.2. 汎用命令のフォーマットおよびエンコーディング
表B-10. に、汎用命令のマシン命令フォーマットおよびエンコーディングを示す。
表B-9. 操作方向(d) ビットのエンコーディング
d ソースデスティネーション
0 regフィールドModR/M バイトまたはSIB バイト
1 ModR/M バイトまたはSIB バイトreg フィールド
表B-10. 汎用命令のフォーマットおよびエンコーディング
命令およびフォーマットエンコーディング
AAA ? ASCII Adjust after Addition 0011 0111
AAD ? ASCII Adjust AX before Division 1101 0101 : 0000 1010
AAM ? ASCII Adjust AX after Multiply 1101 0100 : 0000 1010
AAS ? ASCII Adjust AL after Subtraction 0011 1111
ADC ? ADD with Carry
register1 to register2 0001 000w : 11 reg1 reg2
register2 to register1 0001 001w : 11 reg1 reg2
memory to register 0001 001w : mod reg r/m
register to memory 0001 000w : mod reg r/m
immediate to register 1000 00sw : 11 010 reg : immediate data
immediate to AL, AX, or EAX 0001 010w : immediate data
immediate to memory 1000 00sw : mod 010 r/m : immediate data
ADD ? Add
register1 to register2 0000 000w : 11 reg1 reg2
register2 to register1 0000 001w : 11 reg1 reg2
memory to register 0000 001w : mod reg r/m
register to memory 0000 000w : mod reg r/m
immediate to register 1000 00sw : 11 000 reg : immediate data
immediate to AL, AX, or EAX 0000 010w : immediate data
immediate to memory 1000 00sw : mod 000 r/m : immediate data
AND ? Logical AND
register1 to register2 0010 000w : 11 reg1 reg2
register2 to register1 0010 001w : 11 reg1 reg2
B-7
命令フォーマットおよびエンコーディング
memory to register 0010 001w : mod reg r/m
register to memory 0010 000w : mod reg r/m
immediate to register
immediate to AL, AX, or EAX 0010 010w : immediate data
immediate to memory 1000 00sw : mod 100 r/m : immediate data
ARPL ? Adjust RPL Field of Selector
from register 0110 0011 : 11 reg1 reg2
from memory 0110 0011 : mod reg r/m
BOUND ? Check Array Against Bounds 0110 0010 : mod reg r/m
BSF ? Bit Scan Forward
register1, register2 0000 1111 : 1011 1100 : 11 reg2 reg1
memory, register 0000 1111 : 1011 1100 : mod reg r/m
BSR ? Bit Scan Reverse
register1, register2 0000 1111 : 1011 1101 : 11 reg2 reg1
memory, register 0000 1111 : 1011 1101 : mod reg r/m
BSWAP ? Byte Swap 0000 1111 : 1100 1 reg
BT ? Bit Test
register, immediate 0000 1111 : 1011 1010 : 11 100 reg: imm8 data
memory, immediate 0000 1111 : 1011 1010 : mod 100 r/m : imm8 data
register1, register2 0000 1111 : 1010 0011 : 11 reg2 reg1
memory, reg 0000 1111 : 1010 0011 : mod reg r/m
BTC ? Bit Test and Complement
register, immediate 0000 1111 : 1011 1010 : 11 111 reg: imm8 data
memory, immediate 0000 1111 : 1011 1010 : mod 111 r/m : imm8 data
register1, register2 0000 1111 : 1011 1011 : 11 reg2 reg1
memory, reg 0000 1111 : 1011 1011 : mod reg r/m
BTR ? Bit Test and Reset
register, immediate 0000 1111 : 1011 1010 : 11 110 reg: imm8 data
memory, immediate 0000 1111 : 1011 1010 : mod 110 r/m : imm8 data
register1, register2 0000 1111 : 1011 0011 : 11 reg2 reg1
memory, reg 0000 1111 : 1011 0011 : mod reg r/m
BTS ? Bit Test and Set
register, immediate 0000 1111 : 1011 1010 : 11 101 reg: imm8 data
表B-10. 汎用命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-8
命令フォーマットおよびエンコーディング
memory, immediate 0000 1111 : 1011 1010 : mod 101 r/m : imm8 data
register1, register2 0000 1111 : 1010 1011 : 11 reg2 reg1
memory, reg 0000 1111 : 1010 1011 : mod reg r/m
CALL ? Call Procedure (in same segment)
direct 1110 1000 : full displacement
register indirect 1111 1111 : 11 010 reg
memory indirect 1111 1111 : mod 010 r/m
CALL ? Call Procedure (in other segment)
direct 1001 1010 : unsigned full offset, selector
indirect 1111 1111 : mod 011 r/m
CBW ? Convert Byte to Word 1001 1000
CDQ ? Convert Doubleword to Qword 1001 1001
CLC ? Clear Carry Flag 1111 1000
CLD ? Clear Direction Flag 1111 1100
CLI ? Clear Interrupt Flag 1111 1010
CLTS ? Clear Task-Switched Flag in CR0 0000 1111 : 0000 0110
CMC ? Complement Carry Flag 1111 0101
CMOVcc ? Conditional Move
register2 to register1 0000 1111: 0100 tttn : 11 reg1 reg2
memory to register 0000 1111: 0100 tttn : mod mem r/m
CMP ? Compare Two Operands
register1 with register2 0011 100w : 11 reg1 reg2
register2 with register1 0011 101w : 11 reg1 reg2
memory with register 0011 100w : mod reg r/m
register with memory 0011 101w : mod reg r/m
immediate with register 1000 00sw : 11 111 reg : immediate data
immediate with AL, AX, or EAX 0011 110w : immediate data
immediate with memory 1000 00sw : mod 111 r/m
CMPS/CMPSB/CMPSW/CMPSD ? Compare
String Operands
1010 011w
CMPXCHG ? Compare and Exchange
register1, register2 0000 1111 : 1011 000w : 11 reg2 reg1
memory, register 0000 1111 : 1011 000w : mod reg r/m
表B-10. 汎用命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-9
命令フォーマットおよびエンコーディング
CMPXCHG8B ? Compare and Exchange 8 Bytes
memory, register 0000 1111 : 1100 0111 : mod reg r/m
CPUID ? CPU Identification 0000 1111 : 1010 0010
CWD ? Convert Word to Doubleword 1001 1001
CWDE ? Convert Word to Doubleword 1001 1000
DAA ? Decimal Adjust AL after Addition 0010 0111
DAS ? Decimal Adjust AL after Subtraction 0010 1111
DEC ? Decrement by 1
register 1111 111w : 11 001 reg
register (alternate encoding) 0100 1 reg
memory 1111 111w : mod 001 r/m
DIV ? Unsigned Divide
AL, AX, or EAX by register 1111 011w : 11 110 reg
AL, AX, or EAX by memory 1111 011w : mod 110 r/m
ENTER ? Make Stack Frame for High Level
Procedure
1100 1000 : 16-bit displacement : 8-bit level (L)
HLT ? Halt 1111 0100
IDIV ? Signed Divide
AL, AX, or EAX by register 1111 011w : 11 111 reg
AL, AX, or EAX by memory 1111 011w : mod 111 r/m
IMUL ? Signed Multiply
AL, AX, or EAX with register 1111 011w : 11 101 reg
AL, AX, or EAX with memory 1111 011w : mod 101 reg
register1 with register2 0000 1111 : 1010 1111 : 11 : reg1 reg2
register with memory 0000 1111 : 1010 1111 : mod reg r/m
register1 with immediate to register2 0110 10s1 : 11 reg1 reg2 : immediate data
memory with immediate to register 0110 10s1 : mod reg r/m : immediate data
IN ? Input From Port
fixed port 1110 010w : port number
variable port 1110 110w
INC ? Increment by 1
reg 1111 111w : 11 000 reg
reg (alternate encoding) 0100 0 reg
表B-10. 汎用命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-10
命令フォーマットおよびエンコーディング
memory 1111 111w : mod 000 r/m
INS ? Input from DX Port 0110 110w
INT n ? Interrupt Type n 1100 1101 : type
INT ? Single-Step Interrupt 3 1100 1100
INTO ? Interrupt 4 on Overflow 1100 1110
INVD ? Invalidate Cache 0000 1111 : 0000 1000
INVLPG ? Invalidate TLB Entry 0000 1111 : 0000 0001 : mod 111 r/m
IRET/IRETD ? Interrupt Return 1100 1111
Jcc ? Jump if Condition is Met
8-bit displacement 0111 tttn : 8-bit displacement
full displacement 0000 1111 : 1000 tttn : full displacement
JCXZ/JECXZ ? Jump on CX/ECX Zero
Address-size prefix differentiates JCXZ
and JECXZ
1110 0011 : 8-bit displacement
JMP ? Unconditional Jump (to same segment)
short 1110 1011 : 8-bit displacement
direct 1110 1001 : full displacement
register indirect 1111 1111 : 11 100 reg
memory indirect 1111 1111 : mod 100 r/m
JMP ? Unconditional Jump (to other segment)
direct intersegment 1110 1010 : unsigned full offset, selector
indirect intersegment 1111 1111 : mod 101 r/m
LAHF ? Load Flags into AHRegister 1001 1111
LAR ? Load Access Rights Byte
from register 0000 1111 : 0000 0010 : 11 reg1 reg2
from memory 0000 1111 : 0000 0010 : mod reg r/m
LDS ? Load Pointer to DS 1100 0101 : mod reg r/m
LEA ? Load Effective Address 1000 1101 : mod reg r/m
LEAVE ? High Level Procedure Exit 1100 1001
LES ? Load Pointer to ES 1100 0100 : mod reg r/m
LFS ? Load Pointer to FS 0000 1111 : 1011 0100 : mod reg r/m
LGDT ? Load Global Descriptor Table Register 0000 1111 : 0000 0001 : mod 010 r/m
LGS ? Load Pointer to GS 0000 1111 : 1011 0101 : mod reg r/m
LIDT ? Load Interrupt Descriptor Table Register
表B-10. 汎用命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-11
命令フォーマットおよびエンコーディング
LLDT ? Load Local Descriptor Table Register
LDTR from register 0000 1111 : 0000 0000 : 11 010 reg
LDTR from memory 0000 1111 : 0000 0000 : mod 010 r/m
LMSW ? Load Machine Status Word
from register 0000 1111 : 0000 0001 : 11 110 reg
from memory 0000 1111 : 0000 0001 : mod 110 r/m
LOCK ? Assert LOCK# Signal Prefix 1111 0000
LODS/LODSB/LODSW/LODSD ? Load String
Operand
1010 110w
LOOP ? Loop Count 1110 0010 : 8-bit displacement
LOOPZ/LOOPE ? Loop Count while Zero/Equal 1110 0001 : 8-bit displacement
LOOPNZ/LOOPNE ? Loop Count while not
Zero/Equal
1110 0000 : 8-bit displacement
LSL ? Load Segment Limit
from register 0000 1111 : 0000 0011 : 11 reg1 reg2
from memory 0000 1111 : 0000 0011 : mod reg r/m
LSS ? Load Pointer to SS 0000 1111 : 1011 0010 : mod reg r/m
LTR ? Load Task Register
from register 0000 1111 : 0000 0000 : 11 011 reg
from memory 0000 1111 : 0000 0000 : mod 011 r/m
MOV ? Move Data
register1 to register2 1000 100w : 11 reg1 reg2
register2 to register1 1000 101w : 11 reg1 reg2
memory to reg 1000 101w : mod reg r/m
reg to memory 1000 100w : mod reg r/m
immediate to register 1100 011w : 11 000 reg : immediate data
immediate to register (alternate encoding) 1011 w reg : immediate data
immediate to memory 1100 011w : mod 000 r/m : immediate data
memory to AL, AX, or EAX 1010 000w : full displacement
AL, AX, or EAX to memory 1010 001w : full displacement
MOV ? Move to/from Control Registers
CR0 from register 0000 1111 : 0010 0010 : 11 000 reg
CR2 from register 0000 1111 : 0010 0010 : 11 010reg
CR3 from register 0000 1111 : 0010 0010 : 11 011 reg
表B-10. 汎用命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-12
命令フォーマットおよびエンコーディング
CR4 from register 0000 1111 : 0010 0010 : 11 100 reg
register from CR0-CR4 0000 1111 : 0010 0000 : 11 eee reg
MOV ? Move to/from Debug Registers
DR0-DR3 from register 0000 1111 : 0010 0011 : 11 eee reg
DR4-DR5 from register 0000 1111 : 0010 0011 : 11 eee reg
DR6-DR7 from register 0000 1111 : 0010 0011 : 11 eee reg
register from DR6-DR7 0000 1111 : 0010 0001 : 11 eee reg
register from DR4-DR5 0000 1111 : 0010 0001 : 11 eee reg
register from DR0-DR3 0000 1111 : 0010 0001 : 11 eee reg
MOV ? Move to/from Segment Registers
register to segment register 1000 1110 : 11 sreg3 reg
register to SS 1000 1110 : 11 sreg3 reg
memory to segment reg 1000 1110 : mod sreg3 r/m
memory to SS 1000 1110 : mod sreg3 r/m
segment register to register 1000 1100 : 11 sreg3 reg
segment register to memory 1000 1100 : mod sreg3 r/m
MOVS/MOVSB/MOVSW/MOVSD ? Move Data
from String to String
1010 010w
MOVSX ? Move with Sign-Extend
register2 to register1 0000 1111 : 1011 111w : 11 reg1 reg2
memory to reg 0000 1111 : 1011 111w : mod reg r/m
MOVZX ? Move with Zero-Extend
register2 to register1 0000 1111 : 1011 011w : 11 reg1 reg2
memory to register 0000 1111 : 1011 011w : mod reg r/m
MUL ? Unsigned Multiply
AL, AX, or EAX with register 1111 011w : 11 100 reg
AL, AX, or EAX with memory 1111 011w : mod 100 reg
NEG ? Two's Complement Negation
register 1111 011w : 11 011 reg
memory 1111 011w : mod 011 r/m
NOP ? No Operation 1001 0000
NOT ? One's Complement Negation
register 1111 011w : 11 010 reg
表B-10. 汎用命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-13
命令フォーマットおよびエンコーディング
memory 1111 011w : mod 010 r/m
OR ? Logical Inclusive OR
register1 to register2 0000 100w : 11 reg1 reg2
register2 to register1 0000 101w : 11 reg1 reg2
memory to register 0000 101w : mod reg r/m
register to memory 0000 100w : mod reg r/m
immediate to register 1000 00sw : 11 001 reg : immediate data
immediate to AL, AX, or EAX 0000 110w : immediate data
immediate to memory 1000 00sw : mod 001 r/m : immediate data
OUT ? Output to Port
fixed port 1110 011w : port number
variable port 1110 111w
OUTS ? Output to DX Port 0110 111w
POP ? Pop a Word from the Stack
register 1000 1111 : 11 000 reg
register (alternate encoding) 0101 1 reg
memory 1000 1111 : mod 000 r/m
POP ? Pop a Segment Register from the Stack
segment register CS, DS, ES 000 sreg2 111
segment register SS 000 sreg2 111
segment register FS, GS 0000 1111: 10 sreg3 001
POPA/POPAD ? Pop All General Registers 0110 0001
POPF/POPFD ? Pop Stack into FLAGS or
EFLAGS Register
1001 1101
PUSH ? Push Operand onto the Stack
register 1111 1111 : 11 110 reg
register (alternate encoding) 0101 0 reg
memory 1111 1111 : mod 110 r/m
immediate 0110 10s0 : immediate data
PUSH ? Push Segment Register onto the Stack
segment register CS,DS,ES,SS 000 sreg2 110
segment register FS,GS 0000 1111: 10 sreg3 000
PUSHA/PUSHAD ? Push All General Registers 0110 0000
表B-10. 汎用命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-14
命令フォーマットおよびエンコーディング
PUSHF/PUSHFD ? Push Flags Register onto the
Stack
1001 1100
RCL ? Rotate thru Carry Left
register by 1 1101 000w : 11 010 reg
memory by 1 1101 000w : mod 010 r/m
register by CL 1101 001w : 11 010 reg
memory by CL 1101 001w : mod 010 r/m
register by immediate count 1100 000w : 11 010 reg : imm8 data
memory by immediate count 1100 000w : mod 010 r/m : imm8 data
RCR ? Rotate thru Carry Right
register by 1 1101 000w : 11 011 reg
memory by 1 1101 000w : mod 011 r/m
register by CL 1101 001w : 11 011 reg
memory by CL 1101 001w : mod 011 r/m
register by immediate count 1100 000w : 11 011 reg : imm8 data
memory by immediate count 1100 000w : mod 011 r/m : imm8 data
RDMSR ? Read from Model-Specific Register 0000 1111 : 0011 0010
RDPMC ? Read Performance Monitoring
Counters
0000 1111 : 0011 0011
RDTSC ? Read Time-Stamp Counter 0000 1111 : 0011 0001
REP INS ? Input String 1111 0011 : 0110 110w
REP LODS ? Load String 1111 0011 : 1010 110w
REP MOVS ? Move String 1111 0011 : 1010 010w
REP OUTS ? Output String 1111 0011 : 0110 111w
REP STOS ? Store String 1111 0011 : 1010 101w
REPE CMPS ? Compare String 1111 0011 : 1010 011w
REPE SCAS ? Scan String 1111 0011 : 1010 111w
REPNE CMPS ? Compare String 1111 0010 : 1010 011w
REPNE SCAS ? Scan String 1111 0010 : 1010 111w
RET ? Return from Procedure (to same segment)
no argument 1100 0011
adding immediate to SP 1100 0010 : 16-bit displacement
RET ? Return from Procedure (to other segment)
intersegment 1100 1011
表B-10. 汎用命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-15
命令フォーマットおよびエンコーディング
adding immediate to SP 1100 1010 : 16-bit displacement
ROL ? Rotate Left
register by 1 1101 000w : 11 000 reg
memory by 1 1101 000w : mod 000 r/m
register by CL 1101 001w : 11 000 reg
memory by CL 1101 001w : mod 000 r/m
register by immediate count 1100 000w : 11 000 reg : imm8 data
memory by immediate count 1100 000w : mod 000 r/m : imm8 data
ROR ? Rotate Right
register by 1 1101 000w : 11 001 reg
memory by 1 1101 000w : mod 001 r/m
register by CL 1101 001w : 11 001 reg
memory by CL 1101 001w : mod 001 r/m
register by immediate count 1100 000w : 11 001 reg : imm8 data
memory by immediate count 1100 000w : mod 001 r/m : imm8 data
RSM ? Resume from System Management Mode 0000 1111 : 1010 1010
SAHF ? Store AH into Flags 1001 1110
SAL ? Shift Arithmetic Left same instruction as SHL
SAR ? Shift Arithmetic Right
register by 1 1101 000w : 11 111 reg
memory by 1 1101 000w : mod 111 r/m
register by CL 1101 001w : 11 111 reg
memory by CL 1101 001w : mod 111 r/m
register by immediate count 1100 000w : 11 111 reg : imm8 data
memory by immediate count 1100 000w : mod 111 r/m : imm8 data
SBB ? Integer Subtraction with Borrow
register1 to register2 0001 100w : 11 reg1 reg2
register2 to register1 0001 101w : 11 reg1 reg2
memory to register 0001 101w : mod reg r/m
register to memory 0001 100w : mod reg r/m
immediate to register 1000 00sw : 11 011 reg : immediate data
immediate to AL, AX, or EAX 0001 110w : immediate data
immediate to memory 1000 00sw : mod 011 r/m : immediate data
表B-10. 汎用命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-16
命令フォーマットおよびエンコーディング
SCAS/SCASB/SCASW/SCASD ? Scan String 1101 111w
SETcc ? Byte Set on Condition
register 0000 1111 : 1001 tttn : 11 000 reg
memory 0000 1111 : 1001 tttn : mod 000 r/m
SGDT ? Store Global Descriptor Table Register 0000 1111 : 0000 0001 : mod 000 r/m
SHL ? Shift Left
register by 1 1101 000w : 11 100 reg
memory by 1 1101 000w : mod 100 r/m
register by CL 1101 001w : 11 100 reg
memory by CL 1101 001w : mod 100 r/m
register by immediate count 1100 000w : 11 100 reg : imm8 data
memory by immediate count 1100 000w : mod 100 r/m : imm8 data
SHLD ? Double Precision Shift Left
register by immediate count 0000 1111 : 1010 0100 : 11 reg2 reg1 : imm8
memory by immediate count 0000 1111 : 1010 0100 : mod reg r/m : imm8
register by CL 0000 1111 : 1010 0101 : 11 reg2 reg1
memory by CL 0000 1111 : 1010 0101 : mod reg r/m
SHR ? Shift Right
register by 1 1101 000w : 11 101 reg
memory by 1 1101 000w : mod 101 r/m
register by CL 1101 001w : 11 101 reg
memory by CL 1101 001w : mod 101 r/m
register by immediate count 1100 000w : 11 101 reg : imm8 data
memory by immediate count 1100 000w : mod 101 r/m : imm8 data
SHRD ? Double Precision Shift Right
register by immediate count 0000 1111 : 1010 1100 : 11 reg2 reg1 : imm8
memory by immediate count 0000 1111 : 1010 1100 : mod reg r/m : imm8
register by CL 0000 1111 : 1010 1101 : 11 reg2 reg1
memory by CL 0000 1111 : 1010 1101 : mod reg r/m
SIDT ? Store Interrupt Descriptor Table Register 0000 1111 : 0000 0001 : mod 001 r/m
SLDT ? Store Local Descriptor Table Register
to register 0000 1111 : 0000 0000 : 11 000 reg
to memory 0000 1111 : 0000 0000 : mod 000 r/m
表B-10. 汎用命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-17
命令フォーマットおよびエンコーディング
SMSW ? Store Machine Status Word
to register 0000 1111 : 0000 0001 : 11 100 reg
to memory 0000 1111 : 0000 0001 : mod 100 r/m
STC ? Set Carry Flag 1111 1001
STD ? Set Direction Flag 1111 1101
STI ? Set Interrupt Flag 1111 1011
STOS/STOSB/STOSW/STOSD ? Store String
Data
1010 101w
STR ? Store Task Register
to register 0000 1111 : 0000 0000 : 11 001 reg
to memory 0000 1111 : 0000 0000 : mod 001 r/m
SUB ? Integer Subtraction
register1 to register2 0010 100w : 11 reg1 reg2
register2 to register1 0010 101w : 11 reg1 reg2
memory to register 0010 101w : mod reg r/m
register to memory 0010 100w : mod reg r/m
immediate to register 1000 00sw : 11 101 reg : immediate data
immediate to AL, AX, or EAX 0010 110w : immediate data
immediate to memory 1000 00sw : mod 101 r/m : immediate data
TEST ? Logical Compare
register1 and register2 1000 010w : 11 reg1 reg2
memory and register 1000 010w : mod reg r/m
immediate and register 1111 011w : 11 000 reg : immediate data
immediate and AL, AX, or EAX 1010 100w : immediate data
immediate and memory 1111 011w : mod 000 r/m : immediate data
UD2 ? Undefined instruction 0000 FFFF : 0000 1011
VERR ? Verify a Segment for Reading
register 0000 1111 : 0000 0000 : 11 100 reg
memory 0000 1111 : 0000 0000 : mod 100 r/m
VERW ? Verify a Segment for Writing
register 0000 1111 : 0000 0000 : 11 101 reg
memory 0000 1111 : 0000 0000 : mod 101 r/m
WAIT ? Wait 1001 1011
WBINVD ? Writeback and Invalidate Data Cache 0000 1111 : 0000 1001
表B-10. 汎用命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-18
命令フォーマットおよびエンコーディング
WRMSR ? Write to Model-Specific Register 0000 1111 : 0011 0000
XADD ? Exchange and Add
register1, register2 0000 1111 : 1100 000w : 11 reg2 reg1
memory, reg 0000 1111 : 1100 000w : mod reg r/m
XCHG ? Exchange Register/Memory with
Register
register1 with register2 1000 011w : 11 reg1 reg2
AL, AX, or EAX with reg 1001 0 reg
memory with reg 1000 011w : mod reg r/m
XLAT/XLATB ? Table Look-up Translation 1101 0111
XOR ? Logical Exclusive OR
register1 to register2 0011 000w : 11 reg1 reg2
register2 to register1 0011 001w : 11 reg1 reg2
memory to register 0011 001w : mod reg r/m
register to memory 0011 000w : mod reg r/m
immediate to register 1000 00sw : 11 110 reg : immediate data
immediate to AL, AX, or EAX 0011 010w : immediate data
immediate to memory 1000 00sw : mod 110 r/m : immediate data
Prefix Bytes
address size 0110 0111
LOCK 1111 0000
operand size 0110 0110
CS segment override 0010 1110
DS segment override 0011 1110
ES segment override 0010 0110
FS segment override 0110 0100
GS segment override 0110 0101
SS segment override 0011 0110
表B-10. 汎用命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-19
命令フォーマットおよびエンコーディング
B.3. MMX 命令のフォーマットおよびエンコーディング
EMMS命令を除くすべてのMMX命令は、2 バイトのインテル・アーキテクチャ整数フォーマットと
同様のフォーマットを使用する。これらのフォーマット内のサブフィールド・エンコーディングの
詳細について以下に説明する。
B.3.1. グラニュラリティ・フィールド(gg)
グラニュラリティ・フィールド(gg) では、命令が操作するパックド・オペランドのサイズを指定す
る。このフィールドは、使用するときは、第2 オペコード・バイトのビット1 と0 になる。表B-11.
に、このgg フィールドのエンコーディングを示す。
B.3.2. MMXR テクノロジおよび汎用レジスタ・フィールド(mmxreg およ
びreg)
MMXテクノロジ・レジスタ(mmxreg) は、オペランドとして使用すると、ModR/Mバイトのreg フィー
ルド( ビット5、4、3) またはR/Mフィールド( ビット2、1、0)、またはその両方にコード化される。
表2-1. と2-2. に、mmxreg フィールドに使用される3 ビットのエンコーディングを示す。
MMX命令が汎用レジスタ(reg) を操作する場合は、レジスタはModR/M バイトのR/Mフィールドに
コード化される。表2-1. と2-2. に、MMX命令で使用するときの汎用レジスタのエンコーディングを
示す。
B.3.3. MMXR 命令のフォーマットおよびエンコーディングの表
表B-12. に、整数命令のフォーマットとエンコーディングを示す。
.
表B-11. データ・フィールドのグラニュラリティ(gg) のエンコーディング
gg データのグラニュラリティ
00 パックド・バイト
01 パックド・ワード
10 パックド・ダブルワード
11 クワッドワード
表B-12. MMXR 命令のフォーマットおよびエンコーディング
命令およびフォーマットエンコーディング
EMMS - Empty MMX state 0000 1111:01110111
MOVD - Move doubleword
reg to mmreg 0000 1111:01101110: 11 mmxreg reg
reg from mmxreg 0000 1111:01111110: 11 mmxreg reg
B-20
命令フォーマットおよびエンコーディング
mem to mmxreg 0000 1111:01101110: mod mmxreg r/m
mem from mmxreg 0000 1111:01111110: mod mmxreg r/m
MOVQ - Move quadword
mmxreg2 to mmxreg1 0000 1111:01101111: 11 mmxreg1 mmxreg2
mmxreg2 from mmxreg1 0000 1111:01111111: 11 mmxreg1 mmxreg2
mem to mmxreg 0000 1111:01101111: mod mmxreg r/m
mem from mmxreg 0000 1111:01111111: mod mmxreg r/m
PACKSSDW1 - Pack dword to word data
(signed with saturation)
mmxreg2 to mmxreg1 0000 1111:01101011: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111:01101011: mod mmxreg r/m
PACKSSWB1 - Pack word to byte data (signed
with saturation)
mmxreg2 to mmxreg1 0000 1111:01100011: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111:01100011: mod mmxreg r/m
PACKUSWB1 - Pack word to byte data
(unsigned with saturation)
mmxreg2 to mmxreg1 0000 1111:01100111: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111:01100111: mod mmxreg r/m
PADD - Add with wrap-around
mmxreg2 to mmxreg1 0000 1111: 111111gg: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111: 111111gg: mod mmxreg r/m
PADDS - Add signed with saturation
mmxreg2 to mmxreg1 0000 1111: 111011gg: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111: 111011gg: mod mmxreg r/m
PADDUS - Add unsigned with saturation
mmxreg2 to mmxreg1 0000 1111: 110111gg: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111: 110111gg: mod mmxreg r/m
PAND - Bitwise And
mmxreg2 to mmxreg1 0000 1111:11011011: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111:11011011: mod mmxreg r/m
PANDN - Bitwise AndNot
mmxreg2 to mmxreg1 0000 1111:11011111: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111:11011111: mod mmxreg r/m
表B-12. MMXR 命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-21
命令フォーマットおよびエンコーディング
PCMPEQ - Packed compare for equality
mmxreg1 with mmxreg2 0000 1111:011101gg: 11 mmxreg1 mmxreg2
mmxreg with memory 0000 1111:011101gg: mod mmxreg r/m
PCMPGT - Packed compare greater (signed)
mmxreg1 with mmxreg2 0000 1111:011001gg: 11 mmxreg1 mmxreg2
mmxreg with memory 0000 1111:011001gg: mod mmxreg r/m
PMADD - Packed multiply add
mmxreg2 to mmxreg1 0000 1111:11110101: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111:11110101: mod mmxreg r/m
PMULH - Packed multiplication
mmxreg2 to mmxreg1 0000 1111:11100101: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111:11100101: mod mmxreg r/m
PMULL - Packed multiplication
mmxreg2 to mmxreg1 0000 1111:11010101: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111:11010101: mod mmxreg r/m
POR - Bitwise Or
mmxreg2 to mmxreg1 0000 1111:11101011: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111:11101011: mod mmxreg r/m
PSLL2 - Packed shift left logical
mmxreg1 by mmxreg2 0000 1111:111100gg: 11 mmxreg1 mmxreg2
mmxreg by memory 0000 1111:111100gg: mod mmxreg r/m
mmxreg by immediate 0000 1111:011100gg: 11 110 mmxreg: imm8 data
PSRA2 - Packed shift right arithmetic
mmxreg1 by mmxreg2 0000 1111:111000gg: 11 mmxreg1 mmxreg2
mmxreg by memory 0000 1111:111000gg: mod mmxreg r/m
mmxreg by immediate 0000 1111:011100gg: 11 100 mmxreg: imm8 data
PSRL2 - Packed shift right logical
mmxreg1 by mmxreg2 0000 1111:110100gg: 11 mmxreg1 mmxreg2
mmxreg by memory 0000 1111:110100gg: mod mmxreg r/m
mmxreg by immediate 0000 1111:011100gg: 11 010 mmxreg: imm8 data
PSUB - Subtract with wrap-around
mmxreg2 from mmxreg1 0000 1111:111110gg: 11 mmxreg1 mmxreg2
memory from mmxreg 0000 1111:111110gg: mod mmxreg r/m
表B-12. MMXR 命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-22
命令フォーマットおよびエンコーディング
注:
1. パック命令は、1 つの型の符号付きパックド・データを次に小さい型の符号付きまたは符号なしデータに飽
和させる。
2. シフト命令のフォーマットには、即値シフト・カウントによるシフトをサポートするためのもう1 つのフォー
マットがある。シフト操作は、すべてのデータ型に対して等しくサポートされているわけではない。
B.4. P6 ファミリ命令のフォーマットとエンコーディング
表B-13. に、P6ファミリ・プロセッサにおいてIA-32 アーキテクチャに導入された命令のいくつかに
ついて、そのフォーマットとエンコーディングを示す。
PSUBS - Subtract signed with saturation
mmxreg2 from mmxreg1 0000 1111:111010gg: 11 mmxreg1 mmxreg2
memory from mmxreg 0000 1111:111010gg: mod mmxreg r/m
PSUBUS - Subtract unsigned with saturation
mmxreg2 from mmxreg1 0000 1111:110110gg: 11 mmxreg1 mmxreg2
memory from mmxreg 0000 1111:110110gg: mod mmxreg r/m
PUNPCKH - Unpack high data to next larger
type
mmxreg2 to mmxreg1 0000 1111:011010gg: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111:011010gg: mod mmxreg r/m
PUNPCKL - Unpack low data to next larger
type
mmxreg2 to mmxreg1 0000 1111:011000gg: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111:011000gg: mod mmxreg r/m
PXOR - Bitwise Xor
mmxreg2 to mmxreg1 0000 1111:11101111: 11 mmxreg1 mmxreg2
memory to mmxreg 0000 1111:11101111: mod mmxreg r/m
表B-13. P6 ファミリ命令のフォーマットとエンコーディング
命令およびフォーマットエンコーディング
FXRSTOR?Restore x87 FPU, MMX, SSE,
and SSE2 State
00001111:10101110:01 m512
FXSAVE?Save x87 FPU, MMX, SSE, and
SSE2 State
00001111:10101110:00 m512
SYSENTER?Fast System Call 00001111:01011111:11
SYSEXIT?Fast Return from Fast System Call 00001111:01011111:11
表B-12. MMXR 命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-23
命令フォーマットおよびエンコーディング
B.5. SSE 命令のフォーマットとエンコーディング
SSE命令はModR/M フォーマットを使用し、先頭に0FHプリフィックス・バイトが付く。一般に、一
度の処理で二方向の動作( すなわち、ロード処理とストア処理) を実行することができる。
以下の3 つの表( 表B-14.、B-15.、B-16.) は、それぞれ、SSE SIMD浮動小数点命令、SSE SIMD整数
命令、SSE キャッシュ可能/ メモリ順序付け命令のフォーマットとエンコーディングを示している。
表B-14. SSE SIMD 浮動小数点命令のフォーマットとエンコーディング
命令およびフォーマットエンコーディング
ADDPS?Add Packed Single-Precision
Floating-Point Values
xmmreg to xmmreg 00001111:01011000:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01011000: mod xmmreg r/m
ADDSS?Add Scalar Single-Precision
Floating-Point Values
xmmreg to xmmreg 11110011:00001111:01011000:11 xmmreg1 xmmreg2
mem to xmmreg 11110011:00001111:01011000: mod xmmreg r/m
ANDNPS?Bitwise Logical AND NOT of
Packed Single-Precision Floating-Point Values
xmmreg to xmmreg 00001111:01010101:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01010101: mod xmmreg r/m
ANDPS?Bitwise Logical AND of Packed
Single-Precision Floating-Point Values
xmmreg to xmmreg 00001111:01010100:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01010100: mod xmmreg r/m
CMPPS?Compare Packed Single-Precision
Floating-Point Values
xmmreg to xmmreg, imm8 00001111:11000010:11 xmmreg1 xmmreg2: imm8
mem to xmmreg, imm8 00001111:11000010: mod xmmreg r/m: imm8
CMPSS?Compare Scalar Single-Precision
Floating-Point Values
xmmreg to xmmreg, imm8 11110011:00001111:11000010:11 xmmreg1 xmmreg2:
imm8
mem to xmmreg, imm8 11110011:00001111:11000010: mod xmmreg r/m:
imm8
COMISS?Compare Scalar Ordered Single-
Precision Floating-Point Values and Set
EFLAGS
xmmreg to xmmreg 00001111:00101111:11 xmmreg1 xmmreg2
B-24
命令フォーマットおよびエンコーディング
mem to xmmreg 00001111:00101111: mod xmmreg r/m
CVTPI2PS?Convert Packed Doubleword
Integers to Packed Single-Precision Floating-
Point Values
mmreg to xmmreg 00001111:00101010:11 xmmreg1 mmreg1
mem to xmmreg 00001111:00101010: mod xmmreg r/m
CVTPS2PI?Convert Packed Single-Precision
Floating-Point Values to Packed Doubleword
Integers
xmmreg to mmreg 00001111:00101101:11 mmreg1 xmmreg1
mem to mmreg 00001111:00101101: mod mmreg r/m
CVTSI2SS?Convert Doubleword Integer to
Scalar Single-Precision Floating-Point Value
r32 to xmmreg1 11110011:00001111:00101010:11 xmmreg r32
mem to xmmreg 11110011:00001111:00101010: mod xmmreg r/m
CVTSS2SI?Convert Scalar Single-Precision
Floating-Point Value to Doubleword Integer
xmmreg to r32 11110011:00001111:00101101:11 r32 xmmreg
mem to r32 11110011:00001111:00101101: mod r32 r/m
CVTTPS2PI?Convert with Truncation Packed
Single-Precision Floating-Point Values to
Packed Doubleword Integers
xmmreg to mmreg 00001111:00101100:11 mmreg1 xmmreg1
mem to mmreg 00001111:00101100: mod mmreg r/m
CVTTSS2SI?Convert with Truncation Scalar
Single-Precision Floating-Point Value to
Doubleword Integer
xmmreg to r32 11110011:00001111:00101100:11 r32 xmmreg1
mem to r32 11110011:00001111:00101100: mod r32 r/m
DIVPS?Divide Packed Single-Precision
Floating-Point Values
xmmreg to xmmreg 00001111:01011110:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01011110: mod xmmreg r/m
DIVSS?Divide Scalar Single-Precision
Floating-Point Values
xmmreg to xmmreg 11110011:00001111:01011110:11 xmmreg1 xmmreg2
mem to xmmreg 11110011:00001111:01011110: mod xmmreg r/m
LDMXCSR?Load MXCSR Register State
表B-14. SSE SIMD 浮動小数点命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-25
命令フォーマットおよびエンコーディング
m32 to MXCSR 00001111:10101110:10 m32
MAXPS?Return Maximum Packed Single-
Precision Floating-Point Values
xmmreg to xmmreg 00001111:01011111:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01011111: mod xmmreg r/m
MAXSS?Return Maximum Scalar Double-
Precision Floating-Point Value
xmmreg to xmmreg 11110011:00001111:01011111:11 xmmreg1 xmmreg2
mem to xmmreg 11110011:00001111:01011111: mod xmmreg r/m
MINPS?Return Minimum Packed Double-
Precision Floating-Point Values
xmmreg to xmmreg 00001111:01011101:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01011101: mod xmmreg r/m
MINSS?Return Minimum Scalar Double-
Precision Floating-Point Value
xmmreg to xmmreg 11110011:00001111:01011101:11 xmmreg1 xmmreg2
mem to xmmreg 11110011:00001111:01011101: mod xmmreg r/m
MOVAPS?Move Aligned Packed Single-
Precision Floating-Point Values
xmmreg2 to xmmreg1 00001111:00101000:11 xmmreg2 xmmreg1
mem to xmmreg1 00001111:00101000: mod xmmreg r/m
xmmreg1 to xmmreg2 00001111:00101001:11 xmmreg1 xmmreg2
xmmreg1 to mem 00001111:00101001: mod xmmreg r/m
MOVHLPS?Move Packed Single-Precision
Floating-Point Values High to Low
xmmreg to xmmreg 00001111:00010010:11 xmmreg1 xmmreg2
MOVHPS?Move High Packed Single-
Precision Floating-Point Values
mem to xmmreg 00001111:00010110: mod xmmreg r/m
xmmreg to mem 00001111:00010111: mod xmmreg r/m
MOVLHPS?Move Packed Single-Precision
Floating-Point Values Low to High
xmmreg to xmmreg 00001111:00010110:11 xmmreg1 xmmreg2
MOVLPS?Move Low Packed Single-Precision
Floating-Point Values
mem to xmmreg 00001111:00010010: mod xmmreg r/m
表B-14. SSE SIMD 浮動小数点命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-26
命令フォーマットおよびエンコーディング
xmmreg to mem 00001111:00010011: mod xmmreg r/m
MOVMSKPS?Extract Packed Single-
Precision Floating-Point Sign Mask
xmmreg to r32 00001111:01010000:11 r32 xmmreg
MOVSS?Move Scalar Single-Precision
Floating-Point Values
xmmreg2 to xmmreg1 11110011:00001111:00010000:11 xmmreg2 xmmreg1
mem to xmmreg1 11110011:00001111:00010000: mod xmmreg r/m
xmmreg1 to xmmreg2 11110011:00001111:00010000:11 xmmreg1 xmmreg2
xmmreg1 to mem 11110011:00001111:00010000: mod xmmreg r/m
MOVUPS?Move Unaligned Packed Single-
Precision Floating-Point Values
xmmreg2 to xmmreg1 00001111:00010000:11 xmmreg2 xmmreg1
mem to xmmreg1 00001111:00010000: mod xmmreg r/m
xmmreg1 to xmmreg2 00001111:00010001:11 xmmreg1 xmmreg2
xmmreg1 to mem 00001111:00010001: mod xmmreg r/m
MULPS?Multiply Packed Single-Precision
Floating-Point Values
xmmreg to xmmreg 00001111:01011001:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01011001: mod xmmreg rm
MULSS?Multiply Scalar Single-Precision
Floating-Point Values
xmmreg to xmmreg 11110011:00001111:010111001:11 xmmreg1 xmmreg2
mem to xmmreg 11110011:00001111:010111001: mod xmmreg r/m
ORPS?Bitwise Logical OR of Single-
Precision Floating-Point Values
xmmreg to xmmreg 00001111:01010110:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01010110 mod xmmreg r/m
RCPPS?Compute Reciprocals of Packed
Single-Precision Floating-Point Values
xmmreg to xmmreg 00001111:01010011:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01010011: mod xmmreg r/m
RCPSS?Compute Reciprocals of Scalar
Single-Precision Floating-Point Value
表B-14. SSE SIMD 浮動小数点命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-27
命令フォーマットおよびエンコーディング
xmmreg to xmmreg 11110011:00001111:01010011:11 xmmreg1 xmmreg2
mem to xmmreg 11110011:00001111:01010011: mod xmmreg r/m
RSQRTPS?Compute Reciprocals of Square
Roots of Packed Single-Precision Floating-
Point Values
xmmreg to xmmreg 00001111:01010010:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01010010 mode xmmreg r/m
RSQRTSS?Compute Reciprocals of Square
Roots of Scalar Single-Precision Floating-
Point Value
xmmreg to xmmreg 11110011:00001111:01010010:11 xmmreg1 xmmreg2
mem to xmmreg 11110011:00001111:01010010 mod xmmreg r/m
SHUFPS?Shuffle Packed Single-Precision
Floating-Point Values
xmmreg to xmmreg, imm8 00001111:11000110:11 xmmreg1 xmmreg2: imm8
mem to xmmreg, imm8 00001111:11000110: mod xmmreg r/m: imm8
SQRTPS?Compute Square Roots of Packed
Single-Precision Floating-Point Values
xmmreg to xmmreg 00001111:01010001:11 xmmreg1 xmmreg 2
mem to xmmreg 00001111:01010001 mod xmmreg r/m
SQRTSS?Compute Square Root of Scalar
Single-Precision Floating-Point Value
xmmreg to xmmreg 01010011:00001111:01010001:11 xmmreg1 xmmreg 2
mem to xmmreg 01010011:00001111:01010001 mod xmmreg r/m
STMXCSR?Store MXCSR Register State
MXCSR to mem 00001111:10101110:11 m32
SUBPS?Subtract Packed Single-Precision
Floating-Point Values
xmmreg to xmmreg 00001111:01011100:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01011100 mod xmmreg r/m
SUBSS?Subtract Scalar Single-Precision
Floating-Point Values
xmmreg to xmmreg 11110011:00001111:01011100:11 xmmreg1 xmmreg2
mem to xmmreg 11110011:00001111:01011100 mod xmmreg r/m
表B-14. SSE SIMD 浮動小数点命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-28
命令フォーマットおよびエンコーディング
UCOMISS?Unordered Compare Scalar
Ordered Single-Precision Floating-Point
Values and Set EFLAGS
xmmreg to xmmreg 00001111:00101110:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:00101110 mod xmmreg r/m
UNPCKHPS?Unpack and Interleave High
Packed Single-Precision Floating-Point Values
xmmreg to xmmreg 00001111:00010101:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:00010101 mod xmmreg r/m
UNPCKLPS?Unpack and Interleave Low
Packed Single-Precision Floating-Point Values
xmmreg to xmmreg 00001111:00010100:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:00010100 mod xmmreg r/m
XORPS?Bitwise Logical XOR of Single-
Precision Floating-Point Values
xmmreg to xmmreg 00001111:01010111:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01010111 mod xmmreg r/m
表B-14. SSE SIMD 浮動小数点命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-29
命令フォーマットおよびエンコーディング
表B-15. SSE SIMD 整数命令のフォーマットとエンコーディング
命令およびフォーマットエンコーディング
PAVGB/PAVGW?Average Packed Integers
mmreg to mmreg 00001111:11100000:11 mmreg1 mmreg2
00001111:11100011:11 mmreg1 mmreg2
mem to mmreg 00001111:11100000 mod mmreg r/m
00001111:11100011 mod mmreg r/m
PEXTRW?Extract Word
mmreg to reg32, imm8 00001111:11000101:11 mmreg r32: imm8
PINSRW - Insert Word
reg32 to mmreg, imm8 00001111:11000100:11 r32 mmreg1: imm8
m16 to mmreg, imm8 00001111:11000100 mod mmreg r/m: imm8
PMAXSW?Maximum of Packed Signed Word
Integers
mmreg to mmreg 00001111:11101110:11 mmreg1 mmreg2
mem to mmreg 00001111:11101110 mod mmreg r/m
PMAXUB?Maximum of Packed Unsigned
Byte Integers
mmreg to mmreg 00001111:11011110:11 mmreg1 mmreg2
mem to mmreg 00001111:11011110 mod mmreg r/m
PMINSW?Minimum of Packed Signed Word
Integers
mmreg to mmreg 00001111:11101010:11 mmreg1 mmreg2
mem to mmreg 00001111:11101010 mod mmreg r/m
PMINUB?Minimum of Packed Unsigned Byte
Integers
mmreg to mmreg 00001111:11011010:11 mmreg1 mmreg2
mem to mmreg 00001111:11011010 mod mmreg r/m
PMOVMSKB - Move Byte Mask To Integer
mmreg to reg32 00001111:11010111:11 mmreg1 r32
PMULHUW?Multiply Packed Unsigned
Integers and Store High Result
mmreg to mmreg 00001111:11100100:11 mmreg1 mmreg2
mem to mmreg 00001111:11100100 mod mmreg r/m
PSADBW?Compute Sum of Absolute
Differences
mmreg to mmreg 00001111:11110110:11 mmreg1 mmreg2
mem to mmreg 00001111:11110110 mod mmreg r/m
B-30
命令フォーマットおよびエンコーディング
PSHUFW?Shuffle Packed Words
mmreg to mmreg, imm8 00001111:01110000:11 mmreg1 mmreg2: imm8
mem to mmreg, imm8 00001111:01110000:11 mod mmreg r/m: imm8
表B-16. SSE キャッシュ可能/ メモリ順序付け命令のフォーマットとエンコーディング
命令およびフォーマットエンコーディング
MASKMOVQ?Store Selected Bytes of Quadword
mmreg to mmreg 00001111:11110111:11 mmreg1 mmreg2
MOVNTPS?Store Packed Single-Precision Floating-
Point Values Using Non-Temporal Hint
xmmreg to mem 00001111:00101011 mod xmmreg r/m
MOVNTQ?Store Quadword Using Non-Temporal Hint
mmreg to mem 00001111:11100111 mod mmreg r/m
PREFETCHT0?Prefetch Temporal to All Cache Levels 00001111:00011000:01 mem
PREFETCHT1?Prefetch Temporal to First Level
Cache
00001111:00011000:10 mem
PREFETCHT2?Prefetch Temporal to Second Level
Cache
00001111:00011000:11 mem
PREFETCHNTA?Prefetch Non-Temporal to All Cache
Levels
00001111:00011000:00 mem
SFENCE?Store Fence 00001111:10101110:11111000
表B-15. SSE SIMD 整数命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-31
命令フォーマットおよびエンコーディング
B.6. SSE2 命令のフォーマットとエンコーディング
SSE2 命令はModR/M フォーマットを使用し、先頭に0FH プリフィックス・バイトが付く。一般に、
一度の処理で二方向の動作( すなわち、ロード処理とストア処理) を実行することができる。
以下の3 つの表は、それぞれ、SSE2 SIMD浮動小数点命令、SSE2 SIMD整数命令、SSE2キャッシュ
可能命令のフォーマットとエンコーディングを示している。
B.6.1. グラニュラリティ・フィールド(gg)
グラニュラリティ・フィールド(gg) では、命令の操作対象となるパックド・オペランドのサイズを
指定する。このフィールドは、第2 オペコード・バイトのビット1 と0 である。表B-19. に、このgg
フィールドのエンコーディングを示す。
表B-17. データ・フィールドのグラニュラリティ(gg) のエンコーディング
gg データのグラニュラリティ
00 パックド・バイト
01 パックド・ワード
10 パックド・ダブルワード
11 クワッドワード
表B-18. SSE2 SIMD 浮動小数点命令のフォーマットとエンコーディング
命令およびフォーマットエンコーディング
ADDPD - Add Packed Double-Precision
Floating-Point Values
xmmreg to xmmreg 01100110:00001111:01011000:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:01011000: mod xmmreg r/m
ADDSD - Add Scalar Double-Precision
Floating-Point Values
xmmreg to xmmreg 11110010:00001111:01011000:11 xmmreg1 xmmreg2
mem to xmmreg 11110010:00001111:01011000: mod xmmreg r/m
ANDNPD?Bitwise Logical AND NOT of
Packed Double-Precision Floating-Point
Values
xmmreg to xmmreg 01100110:00001111:01010101:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:01010101: mod xmmreg r/m
ANDPD?Bitwise Logical AND of
Packed Double-Precision Floating-Point
Values
B-32
命令フォーマットおよびエンコーディング
xmmreg to xmmreg 01100110:00001111:01010100:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:01010100: mod xmmreg r/m
CMPPD?Compare Packed Double-
Precision Floating-Point Values
xmmreg to xmmreg, imm8 01100110:00001111:11000010:11 xmmreg1 xmmreg2: imm8
mem to xmmreg, imm8 01100110:00001111:11000010: mod xmmreg r/m: imm8
CMPSD?Compare Scalar Double-
Precision Floating-Point Values
xmmreg to xmmreg, imm8 11110010:00001111:11000010:11 xmmreg1 xmmreg2: imm8
mem to xmmreg, imm8 11110010:00001111:11000010: mod xmmreg r/m: imm8
COMISD?Compare Scalar Ordered
Double-Precision Floating-Point Values
and Set EFLAGS
xmmreg to xmmreg 01100110:00001111:00101111:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:00101111: mod xmmreg r/m
CVTPI2PD?Convert Packed
Doubleword Integers to Packed Double-
Precision Floating-Point Values
mmreg to xmmreg 01100110:00001111:00101010:11 xmmreg1 mmreg1
mem to xmmreg 01100110:00001111:00101010: mod xmmreg r/m
CVTPD2PI?Convert Packed Double-
Precision Floating-Point Values to
Packed Doubleword Integers
xmmreg to mmreg 01100110:00001111:00101101:11 mmreg1 xmmreg1
mem to mmreg 01100110:00001111:00101101: mod mmreg r/m
CVTSI2SD?Convert Doubleword
Integer to Scalar Double-Precision
Floating-Point Value
r32 to xmmreg1 11110010:00001111:00101010:11 xmmreg r32
mem to xmmreg 11110010:00001111:00101010: mod xmmreg r/m
CVTSD2SI?Convert Scalar Double-
Precision Floating-Point Value to
Doubleword Integer
xmmreg to r32 11110010:00001111:00101101:11 r32 xmmreg
mem to r32 11110010:00001111:00101101: mod r32 r/m
表B-18. SSE2 SIMD 浮動小数点命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-33
命令フォーマットおよびエンコーディング
CVTTPD2PI?Convert with Truncation
Packed Double-Precision Floating-Point
Values to Packed Doubleword Integers
xmmreg to mmreg 01100110:00001111:00101100:11 mmreg1 xmmreg1
mem to mmreg 01100110:00001111:00101100: mod mmreg r/m
CVTTSD2SI?Convert with Truncation
Scalar Double-Precision Floating-Point
Value to Doubleword Integer
xmmreg to r32 11110010:00001111:00101100:11 r32 xmmreg1
mem to r32 11110010:00001111:00101100: mod r32 r/m
CVTPD2PS?Covert Packed Double-
Precision Floating-Point Values to
Packed Single-Precision Floating-Point
Values
xmmreg to xmmreg 01100110:00001111:01011010:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:01011010: mod xmmreg r/m
CVTPS2PD?Covert Packed Single-
Precision Floating-Point Values to
Packed Double-Precision Floating-Point
Values
xmmreg to xmmreg 00001111:01011010:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01011010: mod xmmreg r/m
CVTSD2SS?Covert Scalar Double-
Precision Floating-Point Value to Scalar
Single-Precision Floating-Point Value
xmmreg to xmmreg 11110010:00001111:01011010:11 xmmreg1 xmmreg2
mem to xmmreg 11110010:00001111:01011010: mod xmmreg r/m
CVTSS2SD?Covert Scalar Single-
Precision Floating-Point Value to Scalar
Double-Precision Floating-Point Value
xmmreg to xmmreg 11110011:00001111:01011010:11 xmmreg1 xmmreg2
mem to xmmreg 11110011:00001111:01011010: mod xmmreg r/m
CVTPD2DQ?Convert Packed Double-
Precision Floating-Point Values to
Packed Doubleword Integers
xmmreg to xmmreg 11110010:00001111:11100110:11 xmmreg1 xmmreg2
mem to xmmreg 11110010:00001111:11100110: mod xmmreg r/m
CVTTPD2DQ?Convert With Truncation
Packed Double-Precision Floating-Point
Values to Packed Doubleword Integers
表B-18. SSE2 SIMD 浮動小数点命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-34
命令フォーマットおよびエンコーディング
xmmreg to xmmreg 01100110:00001111:11100110:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:11100110: mod xmmreg r/m
CVTDQ2PD?Convert Packed
Doubleword Integers to Packed Single-
Precision Floating-Point Values
xmmreg to xmmreg 11110011:00001111:11100110:11 xmmreg1 xmmreg2
mem to xmmreg 11110011:00001111:11100110: mod xmmreg r/m
CVTPS2DQ?Convert Packed Single-
Precision Floating-Point Values to
Packed Doubleword Integers
xmmreg to xmmreg 01100110:00001111:01011011:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:01011011: mod xmmreg r/m
CVTTPS2DQ?Convert With Truncation
Packed Single-Precision Floating-Point
Values to Packed Doubleword Integers
xmmreg to xmmreg 11110011:00001111:01011011:11 xmmreg1 xmmreg2
mem to xmmreg 11110011:00001111:01011011: mod xmmreg r/m
CVTDQ2PS?Convert Packed
Doubleword Integers to Packed Double-
Precision Floating-Point Values
xmmreg to xmmreg 00001111:01011011:11 xmmreg1 xmmreg2
mem to xmmreg 00001111:01011011: mod xmmreg r/m
DIVPD?Divide Packed Double-
Precision Floating-Point Values
xmmreg to xmmreg 01100110:00001111:01011110:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:01011110: mod xmmreg r/m
DIVSD?Divide Scalar Double-Precision
Floating-Point Values
xmmreg to xmmreg 11110010:00001111:01011110:11 xmmreg1 xmmreg2
mem to xmmreg 11110010:00001111:01011110: mod xmmreg r/m
MAXPD?Return Maximum Packed
Double-Precision Floating-Point Values
xmmreg to xmmreg 01100110:00001111:01011111:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:01011111: mod xmmreg r/m
MAXSD?Return Maximum Scalar
Double-Precision Floating-Point Value
xmmreg to xmmreg 11110010:00001111:01011111:11 xmmreg1 xmmreg2
mem to xmmreg 11110010:00001111:01011111: mod xmmreg r/m
表B-18. SSE2 SIMD 浮動小数点命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-35
命令フォーマットおよびエンコーディング
MINPD?Return Minimum Packed
Double-Precision Floating-Point Values
xmmreg to xmmreg 01100110:00001111:01011101:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:01011101: mod xmmreg r/m
MINSD?Return Minimum Scalar
Double-Precision Floating-Point Value
xmmreg to xmmreg 11110010:00001111:01011101:11 xmmreg1 xmmreg2
mem to xmmreg 11110010:00001111:01011101: mod xmmreg r/m
MOVAPD?Move Aligned Packed
Double-Precision Floating-Point Values
xmmreg2 to xmmreg1 01100110:00001111:00101001:11 xmmreg2 xmmreg1
mem to xmmreg1 01100110:00001111:00101001: mod xmmreg r/m
xmmreg1 to xmmreg2 01100110:00001111:00101000:11 xmmreg1 xmmreg2
xmmreg1 to mem 01100110:00001111:00101000: mod xmmreg r/m
MOVHPD?Move High Packed Double-
Precision Floating-Point Values
mem to xmmreg 01100110:00001111:00010111: mod xmmreg r/m
xmmreg to mem 01100110:00001111:00010110: mod xmmreg r/m
MOVLPD?Move Low Packed Double-
Precision Floating-Point Values
mem to xmmreg 01100110:00001111:00010011: mod xmmreg r/m
xmmreg to mem 01100110:00001111:00010010: mod xmmreg r/m
MOVMSKPD?Extract Packed Double-
Precision Floating-Point Sign Mask
xmmreg to r32 01100110:00001111:01010000:11 r32 xmmreg
MOVSD?Move Scalar Double-
Precision Floating-Point Values
xmmreg2 to xmmreg1 11110010:00001111:00010001:11 xmmreg2 xmmreg1
mem to xmmreg1 11110010:00001111:00010001: mod xmmreg r/m
xmmreg1 to xmmreg2 11110010:00001111:00010000:11 xmmreg1 xmmreg2
xmmreg1 to mem 11110010:00001111:00010000: mod xmmreg r/m
MOVUPD?Move Unaligned Packed
Double-Precision Floating-Point Values
xmmreg2 to xmmreg1 01100110:00001111:00010001:11 xmmreg2 xmmreg1
mem to xmmreg1 01100110:00001111:00010001: mod xmmreg r/m
xmmreg1 to xmmreg2 01100110:00001111:00010000:11 xmmreg1 xmmreg2
表B-18. SSE2 SIMD 浮動小数点命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-36
命令フォーマットおよびエンコーディング
xmmreg1 to mem 01100110:00001111:00010000: mod xmmreg r/m
MULPD?Multiply Packed Double-
Precision Floating-Point Values
xmmreg to xmmreg 01100110:00001111:01011001:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:01011001: mod xmmreg rm
MULSD?Multiply Scalar Double-
Precision Floating-Point Values
xmmreg to xmmreg 11110010:00001111:01011001:11 xmmreg1 xmmreg2
mem to xmmreg 11110010:00001111:01011001: mod xmmreg r/m
ORPD?Bitwise Logical OR of Double-
Precision Floating-Point Values
xmmreg to xmmreg 01100110:00001111:01010110:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:01010110: mod xmmreg r/m
SHUFPD?Shuffle Packed Double-
Precision Floating-Point Values
xmmreg to xmmreg, imm8 01100110:00001111:11000110:11 xmmreg1 xmmreg2: imm8
mem to xmmreg, imm8 01100110:00001111:11000110: mod xmmreg r/m: imm8
SQRTPD?Compute Square Roots of
Packed Double-Precision Floating-Point
Values
xmmreg to xmmreg 01100110:00001111:01010001:11 xmmreg1 xmmreg 2
mem to xmmreg 01100110:00001111:01010001: mod xmmreg r/m
SQRTSD?Compute Square Root of
Scalar Double-Precision Floating-Point
Value
xmmreg to xmmreg 11110010:00001111:01010001:11 xmmreg1 xmmreg 2
mem to xmmreg 11110010:00001111:01010001: mod xmmreg r/m
SUBPD?Subtract Packed Double-
Precision Floating-Point Values
xmmreg to xmmreg 01100110:00001111:01011100:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:01011100: mod xmmreg r/m
SUBSD?Subtract Scalar Double-
Precision Floating-Point Values
xmmreg to xmmreg 11110010:00001111:01011100:11 xmmreg1 xmmreg2
mem to xmmreg 11110010:00001111:01011100: mod xmmreg r/m
表B-18. SSE2 SIMD 浮動小数点命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-37
命令フォーマットおよびエンコーディング
UCOMISD?Unordered Compare
Scalar Ordered Double-Precision
Floating-Point Values and Set EFLAGS
xmmreg to xmmreg 01100110:00001111:00101110:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:00101110: mod xmmreg r/m
UNPCKHPD?Unpack and Interleave
High Packed Double-Precision Floating-
Point Values
xmmreg to xmmreg 01100110:00001111:00010101:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:00010101: mod xmmreg r/m
UNPCKLPD?Unpack and Interleave
Low Packed Double-Precision Floating-
Point Values
xmmreg to xmmreg 01100110:00001111:00010100:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:00010100: mod xmmreg r/m
XORPD?Bitwise Logical OR of Double-
Precision Floating-Point Values
xmmreg to xmmreg 01100110:00001111:01010111:11 xmmreg1 xmmreg2
mem to xmmreg 01100110:00001111:01010111: mod xmmreg r/m
表B-18. SSE2 SIMD 浮動小数点命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-38
命令フォーマットおよびエンコーディング
表B-19. SSE2 SIMD 整数命令のフォーマットとエンコーディング
命令およびフォーマットエンコーディング
MOVD - Move Doubleword
reg to xmmeg 01100110:0000 1111:01101110: 11 xmmreg reg
reg from xmmreg 01100110:0000 1111:01111110: 11 xmmreg reg
mem to xmmreg 01100110:0000 1111:01101110: mod xmmreg r/m
mem from xmmreg 01100110:0000 1111:01111110: mod xmmreg r/m
MOVDQA?Move Aligned Double Quadword
xmmreg to xmmreg 01100110:00001111:01101111:11 xmmreg1
xmmreg2
01100110:00001111:01111111:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:01101111: mod xmmreg r/m
mem from xmmreg 01100110:00001111:01111111: mod xmmreg r/m
MOVDQU?Move Unaligned Double Quadword
xmmreg to xmmreg 11110011:00001111:01101111:11 xmmreg1
xmmreg2
11110011:00001111:01111111:11 xmmreg1
xmmreg2
mem to xmmreg 11110011:00001111:01101111: mod xmmreg r/m
mem from xmmreg 11110011:00001111:01111111: mod xmmreg r/m
MOVQ2DQ?Move Quadword from MMX to XMM
Register
mmreg to xmmreg 11110011:00001111:11010110:11 mmreg1
mmreg2
MOVDQ2Q?Move Quadword from XMM to MMX
Register
xmmreg to mmreg 11110010:00001111:11010110:11 mmreg1
mmreg2
MOVQ - Move Quadword
mmxreg2 to mmxreg1 01100110:00001111:01111110: 11 xmmreg1
xmmreg2
mmxreg2 from mmxreg1 01100110:00001111:11010110: 11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:01111110: mod xmmreg r/m
mem from xmmreg 01100110:00001111:11010110: mod xmmreg r/m
PACKSSDW1 - Pack Dword To Word Data (signed
with saturation)
B-39
命令フォーマットおよびエンコーディング
xmmreg2 to xmmreg1 01100110:0000 1111:01101011: 11 xmmreg1
xmmreg2
memory to xmmreg 01100110:0000 1111:01101011: mod xmmreg r/m
PACKSSWB - Pack Word To Byte Data (signed
with saturation)
xmmreg2 to xmmreg1 01100110:0000 1111:01100011: 11 xmmreg1
xmmreg2
memory to xmmreg 01100110:0000 1111:01100011: mod xmmreg r/m
PACKUSWB - Pack Word To Byte Data (unsigned
with saturation)
xmmreg2 to xmmreg1 01100110:0000 1111:01100111: 11 xmmreg1
xmmreg2
memory to xmmreg 01100110:0000 1111:01100111: mod xmmreg r/m
PADDQ?Add Packed Quadword Integers
mmreg to mmreg 00001111:11010100:11 mmreg1 mmreg2
mem to mmreg 00001111:11010100: mod mmreg r/m
xmmreg to xmmreg 01100110:00001111:11010100:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:11010100: mod xmmreg r/m
PADD - Add With Wrap-around
xmmreg2 to xmmreg1 01100110:0000 1111: 111111gg: 11 xmmreg1
xmmreg2
memory to xmmreg 01100110:0000 1111: 111111gg: mod xmmreg r/m
PADDS - Add Signed With Saturation
xmmreg2 to xmmreg1 01100110:0000 1111: 111011gg: 11 xmmreg1
xmmreg2
memory to xmmreg 01100110:0000 1111: 111011gg: mod xmmreg r/m
PADDUS - Add Unsigned With Saturation
xmmreg2 to xmmreg1 01100110:0000 1111: 110111gg: 11 xmmreg1
xmmreg2
memory to xmmreg 01100110:0000 1111: 110111gg: mod xmmreg r/m
PAND - Bitwise And
xmmreg2 to xmmreg1 01100110:0000 1111:11011011: 11 xmmreg1
xmmreg2
表B-19. SSE2 SIMD 整数命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-40
命令フォーマットおよびエンコーディング
memory to xmmreg 01100110:0000 1111:11011011: mod xmmreg r/m
PANDN - Bitwise AndNot
xmmreg2 to xmmreg1 01100110:0000 1111:11011111: 11 xmmreg1
xmmreg2
memory to xmmreg 01100110:0000 1111:11011111: mod xmmreg r/m
PAVGB?Average Packed Integers
xmmreg to xmmreg 01100110:00001111:11100000:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:11100000 mod xmmreg r/m
PAVGW?Average Packed Integers
xmmreg to xmmreg 01100110:00001111:11100011:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:11100011 mod xmmreg r/m
PCMPEQ - Packed Compare For Equality
xmmreg1 with xmmreg2 01100110:0000 1111:011101gg: 11 xmmreg1
xmmreg2
xmmreg with memory 01100110:0000 1111:011101gg: mod xmmreg r/m
PCMPGT - Packed Compare Greater (signed)
xmmreg1 with xmmreg2 01100110:0000 1111:011001gg: 11 xmmreg1
xmmreg2
xmmreg with memory 01100110:0000 1111:011001gg: mod xmmreg r/m
PEXTRW?Extract Word
xmmreg to reg32, imm8 01100110:00001111:11000101:11 xmmreg r32:
imm8
PINSRW - Insert Word
reg32 to xmmreg, imm8 01100110:00001111:11000100:11 r32 xmmreg1:
imm8
m16 to xmmreg, imm8 01100110:00001111:11000100 mod xmmreg r/m:
imm8
PMADD - Packed Multiply Add
xmmreg2 to xmmreg1 01100110:0000 1111:11110101: 11 xmmreg1
xmmreg2
memory to xmmreg 01100110:0000 1111:11110101: mod xmmreg r/m
PMAXSW?Maximum of Packed Signed Word
Integers
表B-19. SSE2 SIMD 整数命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-41
命令フォーマットおよびエンコーディング
xmmreg to xmmreg 01100110:00001111:11101110:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:11101110 mod xmmreg r/m
PMAXUB?Maximum of Packed Unsigned Byte
Integers
xmmreg to xmmreg 01100110:00001111:11011110:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:11011110 mod xmmreg r/m
PMINSW?Minimum of Packed Signed Word
Integers
xmmreg to xmmreg 01100110:00001111:11101010:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:11101010 mod xmmreg r/m
PMINUB?Minimum of Packed Unsigned Byte
Integers
xmmreg to xmmreg 01100110:00001111:11011010:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:11011010 mod xmmreg r/m
PMOVMSKB - Move Byte Mask To Integer
xmmreg to reg32 01100110:00001111:11010111:11 xmmreg1 r32
PMULH - Packed Multiplication
xmmreg2 to xmmreg1 01100110:0000 1111:11100101: 11 xmmreg1
xmmreg2
memory to xmmreg 01100110:0000 1111:11100101: mod xmmreg r/m
PMULL - Packed Multiplication
xmmreg2 to xmmreg1 01100110:0000 1111:11010101: 11 xmmreg1
xmmreg2
memory to xmmreg 01100110:0000 1111:11010101: mod xmmreg r/m
PMULUDQ?Multiply Packed Unsigned
Doubleword Integers
mmreg to mmreg 00001111:11110100:11 mmreg1 mmreg2
mem to mmreg 00001111:11110100: mod mmreg r/m
xmmreg to xmmreg 01100110:00001111:11110100:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:11110100: mod xmmreg r/m
POR - Bitwise Or
表B-19. SSE2 SIMD 整数命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-42
命令フォーマットおよびエンコーディング
xmmreg2 to xmmreg1 01100110:0000 1111:11101011: 11 xmmreg1
xmmreg2
xmemory to xmmreg 01100110:0000 1111:11101011: mod xmmreg r/m
PSADBW?Compute Sum of Absolute Differences
xmmreg to xmmreg 01100110:00001111:11110110:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:11110110: mod xmmreg r/m
PSHUFLW?Shuffle Packed Low Words
xmmreg to xmmreg, imm8 11110010:00001111:01110000:11 xmmreg1
xmmreg2: imm8
mem to xmmreg, imm8 11110010:00001111:01110000:11 mod xmmreg
r/m: imm8
PSHUFHW?Shuffle Packed High Words
xmmreg to xmmreg, imm8 11110011:00001111:01110000:11 xmmreg1
xmmreg2: imm8
mem to xmmreg, imm8 11110011:00001111:01110000:11 mod xmmreg
r/m: imm8
PSHUFD?Shuffle Packed Doublewords
xmmreg to xmmreg, imm8 01100110:00001111:01110000:11 xmmreg1
xmmreg2: imm8
mem to xmmreg, imm8 01100110:00001111:01110000:11 mod xmmreg
r/m: imm8
PSLLDQ?Shift Double Quadword Left Logical
xmmreg, imm8 01100110:00001111:01110011:11 111 xmmreg:
imm8
PSLL - Packed Shift Left Logical
xmmreg1 by xmmreg2 01100110:0000 1111:111100gg: 11 xmmreg1
xmmreg2
xmmreg by memory 01100110:0000 1111:111100gg: mod xmmreg r/m
xmmreg by immediate 01100110:0000 1111:011100gg: 11 110 xmmreg:
imm8 data
PSRA - Packed Shift Right Arithmetic
xmmreg1 by xmmreg2 01100110:0000 1111:111000gg: 11 xmmreg1
xmmreg2
xmmreg by memory 01100110:0000 1111:111000gg: mod xmmreg r/m
xmmreg by immediate 01100110:0000 1111:011100gg: 11 100 xmmreg:
imm8 data
表B-19. SSE2 SIMD 整数命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-43
命令フォーマットおよびエンコーディング
PSRLDQ?Shift Double Quadword Right Logical
xmmreg, imm8 01100110:00001111:01110011:11 011 xmmreg:
imm8
PSRL - Packed Shift Right Logical
xmmxreg1 by xmmxreg2 01100110:0000 1111:110100gg: 11 xmmreg1
xmmreg2
xmmxreg by memory 01100110:0000 1111:110100gg: mod xmmreg r/m
xmmxreg by immediate 01100110:0000 1111:011100gg: 11 010 xmmreg:
imm8 data
PSUBQ?Subtract Packed Quadword Integers
mmreg to mmreg 00001111:11111011:11 mmreg1 mmreg2
mem to mmreg 00001111:11111011: mod mmreg r/m
xmmreg to xmmreg 01100110:00001111:11111011:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:11111011: mod xmmreg r/m
PSUB - Subtract With Wrap-around
xmmreg2 from xmmreg1 01100110:0000 1111:111110gg: 11 xmmreg1
xmmreg2
memory from xmmreg 01100110:0000 1111:111110gg: mod xmmreg r/m
PSUBS - Subtract Signed With Saturation
xmmreg2 from xmmreg1 01100110:0000 1111:111010gg: 11 xmmreg1
xmmreg2
memory from xmmreg 01100110:0000 1111:111010gg: mod xmmreg r/m
PSUBUS - Subtract Unsigned With Saturation
xmmreg2 from xmmreg1 0000 1111:110110gg: 11 xmmreg1 xmmreg2
memory from xmmreg 0000 1111:110110gg: mod xmmreg r/m
PUNPCKH?Unpack High Data To Next Larger
Type
xmmreg to xmmreg 01100110:00001111:011010gg:11 xmmreg1
Xmmreg2
mem to xmmreg 01100110:00001111:011010gg: mod xmmreg r/m
PUNPCKHQDQ?Unpack High Data
xmmreg to xmmreg 01100110:00001111:01101101:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:01101101: mod xmmreg r/m
表B-19. SSE2 SIMD 整数命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-44
命令フォーマットおよびエンコーディング
PUNPCKL?Unpack Low Data To Next Larger
Type
xmmreg to xmmreg 01100110:00001111:011000gg:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:011000gg: mod xmmreg r/m
PUNPCKLQDQ?Unpack Low Data
xmmreg to xmmreg 01100110:00001111:01101100:11 xmmreg1
xmmreg2
mem to xmmreg 01100110:00001111:01101100: mod xmmreg r/m
PXOR - Bitwise Xor
xmmreg2 to xmmreg1 01100110:0000 1111:11101111: 11 xmmreg1
xmmreg2
memory to xmmreg 01100110:0000 1111:11101111: mod xmmreg r/m
表B-20. SSE2 キャッシュ可能命令のフォーマットとエンコーディング
命令およびフォーマットエンコーディング
MASKMOVDQU?Store Selected Bytes of Double
Quadword
xmmreg to xmmreg 01100110:00001111:11110111:11 xmmreg1
xmmreg2
CLFLUSH?Flush Cache Line
mem 00001111:10101110:mod r/m
MOVNTPD?Store Packed Double-Precision Floating-
Point Values Using Non-Temporal Hint
xmmreg to mem 01100110:00001111:00101011: mod xmmreg
r/m
MOVNTDQ?Store Double Quadword Using Non-
Temporal Hint
xmmreg to mem 01100110:00001111:11100111: mod xmmreg
r/m
MOVNTI?Store Doubleword Using Non-Temporal Hint
reg to mem 00001111:11000011: mod reg r/m
PAUSE?Spin Loop Hint 11110011:10010000
LFENCE?Load Fence 00001111:10101110: 11 101 000
MFENCE?Memory Fence 00001111:10101110: 11 110 000
表B-19. SSE2 SIMD 整数命令のフォーマットとエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-45
命令フォーマットおよびエンコーディング
B.7. 浮動小数点命令のフォーマットおよびエンコーディング
表B-21. に、浮動小数点命令に使用される5 個の異なるフォーマットを示す。すべての場合に、命令
は少なくとも2 バイトの長さであり、ビット・パターン11011 で始まる。
MF = メモリ・フォーマット
00 -- 32 ビット実数
01 -- 32 ビット整数
10 -- 64 ビット実数
11 -- 16 ビット整数
P = ポップ
0 -- スタックをポップしない
1 -- 操作後にスタックをポップ
d = デスティネーション
0 -- デスティネーションはST(0)
1 -- デスティネーションはST(i)
R XOR d = 0 -- デスティネーション OP ソース
R XOR d = 1 -- ソース OP デスティネーション
ST(i) = レジスタ・スタック要素i
000 = スタックのトップ
001 = 2 番目のスタック要素
?
?
?
111 = 8 番目のスタック要素
ModR/M バイトのMod フィールドとR/Mフィールドは、整数命令の対応するフィールドと同じよう
に解釈される。SIBバイトとdisp( ディスプレースメント) は、Mod フィールドとR/Mフィールドをも
つ命令にオプションで存在する。それらの存在は、整数命令に対するのと同様に、Mod とR/Mの値
に依存する。
表B-22. に、浮動小数点命令のフォーマットおよびエンコーディングを示す。
表B-21. 汎用浮動小数点命令フォーマット
命令
オプションの
第1 バイト第2 バイトフィールド
1 11011 OPA 1 mod 1 OPB r/m s-i-b disp
2 11011 MF OPA mod OPB r/m s-i-b disp
3 11011 d P OPA 1 1 OPB R ST(i)
4 11011 0 0 1 1 1 1 OP
5 11011 0 1 1 1 1 1 OP
15?11 10 9 8 7 6 5 4 3 2 1 0
B-46
命令フォーマットおよびエンコーディング
表B-22. 浮動小数点命令のフォーマットおよびエンコーディング
命令およびフォーマットエンコーディング
F2XM1 ? Compute 2ST(0) ? 1 11011 001 : 1111 0000
FABS ? Absolute Value 11011 001 : 1110 0001
FADD ? Add
ST(0) ← ST(0) + 32-bit memory 11011 000 : mod 000 r/m
ST(0) ← ST(0) + 64-bit memory 11011 100 : mod 000 r/m
ST(d) ← ST(0) + ST(i) 11011 d00 : 11 000 ST(i)
FADDP ? Add and Pop
ST(0) ← ST(0) + ST(i) 11011 110 : 11 000 ST(i)
FBLD ? Load Binary Coded Decimal 11011 111 : mod 100 r/m
FBSTP ? Store Binary Coded Decimal and Pop 11011 111 : mod 110 r/m
FCHS ? Change Sign 11011 001 : 1110 0000
FCLEX ? Clear Exceptions 11011 011 : 1110 0010
FCMOVcc ? Conditional Move on EFLAG
Register Condition Codes
move if below (B) 11011 010 : 11 000 ST(i)
move if equal (E) 11011 010 : 11 001 ST(i)
move if below or equal (BE) 11011 010 : 11 010 ST(i)
move if unordered (U) 11011 010 : 11 011 ST(i)
move if not below (NB) 11011 011 : 11 000 ST(i)
move if not equal (NE) 11011 011 : 11 001 ST(i)
move if not below or equal (NBE) 11011 011 : 11 010 ST(i)
move if not unordered (NU) 11011 011 : 11 011 ST(i)
FCOM ? Compare Real
32-bit memory 11011 000 : mod 010 r/m
64-bit memory 11011 100 : mod 010 r/m
ST(i) 11011 000 : 11 010 ST(i)
FCOMP ? Compare Real and Pop
32-bit memory 11011 000 : mod 011 r/m
64-bit memory 11011 100 : mod 011 r/m
ST(i) 11011 000 : 11 011 ST(i)
FCOMPP ? Compare Real and Pop Twice 11011 110 : 11 011 001
FCOMI ? Compare Real and Set EFLAGS 11011 011 : 11 110 ST(i)
FCOMIP ? Compare Real, Set EFLAGS, and Pop 11011 111 : 11 110 ST(i)
B-47
命令フォーマットおよびエンコーディング
FCOS ? Cosine of ST(0) 11011 001 : 1111 1111
FDECSTP ? Decrement Stack-Top Pointer 11011 001 : 1111 0110
FDIV ? Divide
ST(0) ← ST(0) ÷ 32-bit memory 11011 000 : mod 110 r/m
ST(0) ← ST(0) ÷ 64-bit memory 11011 100 : mod 110 r/m
ST(d) ← ST(0) ÷ ST(i) 11011 d00 : 1111 R ST(i)
FDIVP ? Divide and Pop
ST(0) ← ST(0) ÷ ST(i) 11011 110 : 1111 1 ST(i)
FDIVR ? Reverse Divide
ST(0) ← 32-bit memory ÷ ST(0) 11011 000 : mod 111 r/m
ST(0) ← 64-bit memory ÷ ST(0) 11011 100 : mod 111 r/m
ST(d) ← ST(i) ÷ ST(0) 11011 d00 : 1111 R ST(i)
FDIVRP ? Reverse Divide and Pop
ST(0) ← ST(i) ÷ ST(0) 11011 110 : 1111 0 ST(i)
FFREE ? Free ST(i) Register 11011 101 : 1100 0 ST(i)
FIADD ? Add Integer
ST(0) ← ST(0) + 16-bit memory 11011 110 : mod 000 r/m
ST(0) ← ST(0) + 32-bit memory 11011 010 : mod 000 r/m
FICOM ? Compare Integer
16-bit memory 11011 110 : mod 010 r/m
32-bit memory 11011 010 : mod 010 r/m
FICOMP ? Compare Integer and Pop
16-bit memory 11011 110 : mod 011 r/m
32-bit memory 11011 010 : mod 011 r/m
FIDIV
ST(0) ← ST(0) + 16-bit memory 11011 110 : mod 110 r/m
ST(0) ← ST(0) + 32-bit memory 11011 010 : mod 110 r/m
FIDIVR
ST(0) ← ST(0) + 16-bit memory 11011 110 : mod 111 r/m
ST(0) ← ST(0) + 32-bit memory 11011 010 : mod 111 r/m
FILD ? Load Integer
16-bit memory 11011 111 : mod 000 r/m
32-bit memory 11011 011 : mod 000 r/m
表B-22. 浮動小数点命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-48
命令フォーマットおよびエンコーディング
64-bit memory 11011 111 : mod 101 r/m
FIMUL
ST(0) ← ST(0) + 16-bit memory 11011 110 : mod 001 r/m
ST(0) ← ST(0) + 32-bit memory 11011 010 : mod 001 r/m
FINCSTP ? Increment Stack Pointer 11011 001 : 1111 0111
FINIT ? Initialize Floating-Point Unit
FIST ? Store Integer
16-bit memory 11011 111 : mod 010 r/m
32-bit memory 11011 011 : mod 010 r/m
FISTP ? Store Integer and Pop
16-bit memory 11011 111 : mod 011 r/m
32-bit memory 11011 011 : mod 011 r/m
64-bit memory 11011 111 : mod 111 r/m
FISUB
ST(0) ← ST(0) + 16-bit memory 11011 110 : mod 100 r/m
ST(0) ← ST(0) + 32-bit memory 11011 010 : mod 100 r/m
FISUBR
ST(0) ← ST(0) + 16-bit memory 11011 110 : mod 101 r/m
ST(0) ← ST(0) + 32-bit memory 11011 010 : mod 101 r/m
FLD ? Load Real
32-bit memory 11011 001 : mod 000 r/m
64-bit memory 11011 101 : mod 000 r/m
80-bit memory 11011 011 : mod 101 r/m
ST(i) 11011 001 : 11 000 ST(i)
FLD1 ? Load +1.0 into ST(0) 11011 001 : 1110 1000
FLDCW ? Load Control Word 11011 001 : mod 101 r/m
FLDENV ? Load FPU Environment 11011 001 : mod 100 r/m
FLDL2E ? Load log2(e) into ST(0) 11011 001 : 1110 1010
FLDL2T ? Load log2(10) into ST(0) 11011 001 : 1110 1001
FLDLG2 ? Load log10(2) into ST(0) 11011 001 : 1110 1100
FLDLN2 ? Load loge(2) into ST(0) 11011 001 : 1110 1101
FLDPI ? Load p into ST(0) 11011 001 : 1110 1011
FLDZ ? Load +0.0 into ST(0) 11011 001 : 1110 1110
表B-22. 浮動小数点命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-49
命令フォーマットおよびエンコーディング
FMUL ? Multiply
ST(0) ← ST(0) \ 32-bit memory 11011 000 : mod 001 r/m
ST(0) ← ST(0) \ 64-bit memory 11011 100 : mod 001 r/m
ST(d) ← ST(0) \ ST(i) 11011 d00 : 1100 1 ST(i)
FMULP ? Multiply
ST(0) ← ST(0) \ ST(i) 11011 110 : 1100 1 ST(i)
FNOP ? No Operation 11011 001 : 1101 0000
FPATAN ? Partial Arctangent 11011 001 : 1111 0011
FPREM ? Partial Remainder 11011 001 : 1111 1000
FPREM1 ? Partial Remainder (IEEE) 11011 001 : 1111 0101
FPTAN ? Partial Tangent 11011 001 : 1111 0010
FRNDINT ? Round to Integer 11011 001 : 1111 1100
FRSTOR ? Restore FPU State 11011 101 : mod 100 r/m
FSAVE ? Store FPU State 11011 101 : mod 110 r/m
FSCALE ? Scale 11011 001 : 1111 1101
FSIN ? Sine 11011 001 : 1111 1110
FSINCOS ? Sine and Cosine 11011 001 : 1111 1011
FSQRT ? Square Root 11011 001 : 1111 1010
FST ? Store Real
32-bit memory 11011 001 : mod 010 r/m
64-bit memory 11011 101 : mod 010 r/m
ST(i) 11011 101 : 11 010 ST(i)
FSTCW ? Store Control Word 11011 001 : mod 111 r/m
FSTENV ? Store FPU Environment 11011 001 : mod 110 r/m
FSTP ? Store Real and Pop
32-bit memory 11011 001 : mod 011 r/m
64-bit memory 11011 101 : mod 011 r/m
80-bit memory 11011 011 : mod 111 r/m
ST(i) 11011 101 : 11 011 ST(i)
FSTSW ? Store Status Word into AX 11011 111 : 1110 0000
FSTSW ? Store Status Word into Memory 11011 101 : mod 111 r/m
FSUB ? Subtract
ST(0) ← ST(0) ? 32-bit memory 11011 000 : mod 100 r/m
表B-22. 浮動小数点命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
B-50
命令フォーマットおよびエンコーディング
ST(0) ← ST(0) ? 64-bit memory 11011 100 : mod 100 r/m
ST(d) ← ST(0) ? ST(i) 11011 d00 : 1110 R ST(i)
FSUBP ? Subtract and Pop
ST(0) ← ST(0) ? ST(i) 11011 110 : 1110 1 ST(i)
FSUBR ? Reverse Subtract
ST(0) ← 32-bit memory ? ST(0) 11011 000 : mod 101 r/m
ST(0) ← 64-bit memory ? ST(0) 11011 100 : mod 101 r/m
ST(d) ← ST(i) ? ST(0) 11011 d00 : 1110 R ST(i)
FSUBRP ? Reverse Subtract and Pop
ST(i) ← ST(i) ? ST(0) 11011 110 : 1110 0 ST(i)
FTST ? Test 11011 001 : 1110 0100
FUCOM ? Unordered Compare Real 11011 101 : 1110 0 ST(i)
FUCOMP ? Unordered Compare Real and Pop 11011 101 : 1110 1 ST(i)
FUCOMPP ? Unordered Compare Real and Pop
Twice
11011 010 : 1110 1001
FUCOMI ? Unorderd Compare Real and Set
EFLAGS
11011 011 : 11 101 ST(i)
FUCOMIP ? Unorderd Compare Real, Set
EFLAGS, and Pop
11011 111 : 11 101 ST(i)
FXAM ? Examine 11011 001 : 1110 0101
FXCH ? Exchange ST(0) and ST(i) 11011 001 : 1100 1 ST(i)
FXTRACT ? Extract Exponent and Significand 11011 001 : 1111 0100
FYL2X ? ST(1) × log2(ST(0)) 11011 001 : 1111 0001
FYL2XP1 ? ST(1) × log2(ST(0) + 1.0) 11011 001 : 1111 1001
FWAIT ? Wait until FPU Ready 1001 1011
表B-22. 浮動小数点命令のフォーマットおよびエンコーディング ( 続き)
命令およびフォーマットエンコーディング
C
機能的に同等の
インテルR C/C++
コンパイラ組み込み関数

C-1
付録C
機能的に同等のインテルR C/C++ コンパイラ
組み込み関数
本章の2 つの表は、インテルMMX テクノロジ命令、SSE およびSSE2 と機能的に同等のインテル
C/C++コンパイラ組み込み関数をまとめたものである。
対応する命令を持たない組み込み関数が存在する可能性があるため、コンパイラのマニュアルを参
照して、サポートしているすべての組み込み関数のリストを確認することを強くお勧めする。『Intel
C/C++ Compiler User’s Guide With Support for the Streaming SIMD Extensions 2』( 資料番号718195-2001)
を参照のこと。本章は、これらの組み込み関数の使用法を示している。
3.1.3. 項「インテルC/C++コンパイラ組み込み関数」には、本章の表に関するより一般的な基礎知識
が記載されている。
表C-1. は簡単な組み込み関数、表C-2. は複合組み込み関数を示す。「複合組み込み関数」とは、2 つ
以上の命令で構成される組み込み関数のことである。
インテルC/C++ コンパイラの組み込み関数名には、次の命名規則が適用される。
_mm_<intrin_op>_<suffix>
各要素の意味は以下のとおりである。
<intrin_op> 組み込み関数の基本動作を示す（例えば、加算の場合はadd、減算の場
合はsub）。
<suffix> 命令の操作対象となるデータ型を示す。各サフィックスの最初の1 文字
または2 文字は、パックド・データ（p）、パックド拡張データ（ep）ま
たはスカラ・データ（s）を表す。その他の文字は、以下のデータ型を示す。
s 単精度浮動小数点
d 倍精度浮動小数点
i128 符号付き128 ビット整数
i64 符号付き64 ビット整数
u64 符号なし64 ビット整数
i32 符号付き32 ビット整数
u32 符号なし32 ビット整数
C-2
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
i16 符号付き16 ビット整数
u16 符号なし16 ビット整数
i8 符号付き8 ビット整数
u8 符号なし8 ビット整数
変数r は、通常は組み込み関数の戻り値を示す。変数名に付加された数字は、パックド・オブジェク
トの要素を示す。例えば、r0 はr の最下位ワードである。一部の組み込み関数は、2 つ以上の命令を
必要とするため、「複合」組み込み関数と呼ばれる。
パックド値は右から左の順に表現され、スカラ操作には最下位の値が使用される。例えば、次の操
作の例を考える。
double a[2] = {1.0, 2.0};
__m128d t = _mm_load_pd(a);
この操作の結果は、次の各操作の結果と同じになる。
__m128d t = _mm_set_pd(2.0, 1.0);
__m128d t = _mm_setr_pd(1.0, 2.0);
つまり、値t を保持するXMMレジスタは、次の図のようになる。
127---------------------------------0
| 2.0 | 1.0 |
----------------------------------
「スカラ」要素は1.0 である。命令の性質上、一部の組み込み関数は、引数として即値（定数整数リ
テラル）を必要とする。
コード内で組み込み関数を使用するには、次の構文の行を挿入する。
data_type intrinsic_name (parameters)
各要素の意味は次のとおりである。
data_type 戻りデータ型。void、int、__m64、__m128、__m128d、または__m128i
である。void を返すのは、_mm_empty 組み込み関数だけである。
intrinsic_name 組み込み関数の名前。C/C++ コード内で、実際の命令の代わりに使用で
きる関数として機能する。
parameters 各組み込み関数が必要とするパラメータ。
C-3
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
C.1. 簡単な組み込み関数
表C-1. 簡単な組み込み関数
ニーモニック組み込み関数説明
ADDPD __m128d _mm_add_pd(__m128d a, __m128d b) a とb の2 つの倍精度浮動小数点(DP FP)
値を加算する。
ADDPS __m128 _mm_add_ps(__m128 a, __m128 b) a とb の4 つの単精度浮動小数点(SP FP)
値を加算する。
ADDSD __m128d _mm_add_sd(__m128d a, __m128d b) a とb の最下位の倍精度浮動小数点値(DP
FP) を加算する。上位の3 つの倍精度浮動
小数点値は、a からそのまま渡される。
ADDSS __m128 _mm_add_ss(__m128 a, __m128 b) a とb の最下位の単精度浮動小数点(SP FP)
値を加算する。上位の3 つの単精度浮動小
数点値は、a からそのまま渡される。
ANDNPD __m128d _mm_andnot_pd(__m128d a, __m128d b) a とb の2 つの倍精度浮動小数点値の間で
ビット単位のAND-NOT 演算を実行する。
ANDNPS __m128 _mm_andnot_ps(__m128 a, __m128 b) a とb の4 つの単精度浮動小数点値の間で
ビット単位のAND-NOT 演算を実行する。
ANDPD __m128d _mm_and_pd(__m128d a, __m128d b) a とb の2 つの倍精度浮動小数点値の間で
ビット単位のAND 演算を実行する。
ANDPS __m128 _mm_and_ps(__m128 a, __m128 b) a とb の4 つの単精度浮動小数点値の間で
ビット単位のAND 演算を実行する。
CLFLUSH void _mm_clflush(void const *p) コヒーレンシ・ドメイン内のすべての
キャッシュから、p が入っているキャッ
シュ・ラインをフラッシュし、無効化する。
CMPPD __m128d _mm_cmpeq_pd(__m128d a, __m128d b) 「等しい」の条件で比較する。
__m128d _mm_cmplt_pd(__m128d a, __m128d b) 「より小さい」の条件で比較する。
__m128d _mm_cmple_pd(__m128d a, __m128d b) 「より小さいか等しい」の条件で比較する。
__m128d _mm_cmpgt_pd(__m128d a, __m128d b) 「より大きい」の条件で比較する。
__m128d _mm_cmpge_pd(__m128d a, __m128d b) 「より大きいか等しい」の条件で比較する。
__m128d _mm_cmpneq_pd(__m128d a, __m128d b) 「等しくない」の条件で比較する。
__m128d _mm_cmpnlt_pd(__m128d a, __m128d b) 「より小さくない」の条件で比較する。
__m128d _mm_cmpngt_pd(__m128d a, __m128d b) 「より大きくない」の条件で比較する。
__m128d _mm_cmpnge_pd(__m128d a, __m128d b) 「より大きくなく等しくない」の条件で比較
する。
__m128d _mm_cmpord_pd(__m128d a, __m128d b) 「順序付けあり」の条件で比較する。
__m128d _mm_cmpunord_pd(__m128d a, __m128d b) 「順序付けなし」の条件で比較する。
__m128d _mm_cmpnle_pd(__m128d a, __m128d b) 「より小さくなく等しくない」の条件で比較
する。
CMPPS __m128 _mm_cmpeq_ps(__m128 a, __m128 b) 「等しい」の条件で比較する。
__m128 _mm_cmplt_ps(__m128 a, __m128 b) 「より小さい」の条件で比較する。
__m128 _mm_cmple_ps(__m128 a, __m128 b) 「より小さいか等しい」の条件で比較する。
__m128 _mm_cmpgt_ps(__m128 a, __m128 b) 「より大きい」の条件で比較する。
__m128 _mm_cmpge_ps(__m128 a, __m128 b) 「より大きいか等しい」の条件で比較する。
C-4
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
CMPPS __m128 _mm_cmpneq_ps(__m128 a, __m128 b) 「等しくない」の条件で比較する。
__m128 _mm_cmpnlt_ps(__m128 a, __m128 b) 「より小さくない」の条件で比較する。
__m128 _mm_cmpngt_ps(__m128 a, __m128 b) 「より大きくない」の条件で比較する。
__m128 _mm_cmpnge_ps(__m128 a, __m128 b) 「より大きくなく等しくない」の条件で比較
する。
__m128 _mm_cmpord_ps(__m128 a, __m128 b) 「順序付けあり」の条件で比較する。
__m128 _mm_cmpunord_ps(__m128 a, __m128 b) 「順序付けなし」の条件で比較する。
__m128 _mm_cmpnle_ps(__m128 a, __m128 b) 「より小さくなく等しくない」の条件で比較
する。
CMPSD __m128d _mm_cmpeq_sd(__m128d a, __m128d b) 「等しい」の条件で比較する。
__m128d _mm_cmplt_sd(__m128d a, __m128d b) 「より小さい」の条件で比較する。
__m128d _mm_cmple_sd(__m128d a, __m128d b) 「より小さいか等しい」の条件で比較する。
__m128d _mm_cmpgt_sd(__m128d a, __m128d b) 「より大きい」の条件で比較する。
__m128d _mm_cmpge_sd(__m128d a, __m128d b) 「より大きいか等しい」の条件で比較する。
__m128 _mm_cmpneq_sd(__m128d a, __m128d b) 「等しくない」の条件で比較する。
__m128 _mm_cmpnlt_sd(__m128d a, __m128d b) 「より小さくない」の条件で比較する。
__m128d _mm_cmpnle_sd(__m128d a, __m128d b) 「より大きくない」の条件で比較する。
__m128d _mm_cmpngt_sd(__m128d a, __m128d b) 「より大きくなく等しくない」の条件で比較
する。
__m128d _mm_cmpnge_sd(__m128d a, __m128d b) 「順序付けあり」の条件で比較する。
__m128d _mm_cmpord_sd(__m128d a, __m128d b) 「順序付けなし」の条件で比較する。
__m128d _mm_cmpunord_sd(__m128d a, __m128d b) 「より小さくなく等しくない」の条件で比較
する。
CMPSS __m128 _mm_cmpeq_ss(__m128 a, __m128 b) 「等しい」の条件で比較する。
__m128 _mm_cmplt_ss(__m128 a, __m128 b) 「より小さい」の条件で比較する。
__m128 _mm_cmple_ss(__m128 a, __m128 b) 「より小さいか等しい」の条件で比較する。
__m128 _mm_cmpgt_ss(__m128 a, __m128 b) 「より大きい」の条件で比較する。
__m128 _mm_cmpge_ss(__m128 a, __m128 b) 「より大きいか等しい」の条件で比較する。
__m128 _mm_cmpneq_ss(__m128 a, __m128 b) 「等しくない」の条件で比較する。
__m128 _mm_cmpnlt_ss(__m128 a, __m128 b) 「より小さくない」の条件で比較する。
__m128 _mm_cmpnle_ss(__m128 a, __m128 b) 「より大きくない」の条件で比較する。
__m128 _mm_cmpngt_ss(__m128 a, __m128 b) 「より大きくなく等しくない」の条件で比較
する。
__m128 _mm_cmpnge_ss(__m128 a, __m128 b) 「順序付けあり」の条件で比較する。
__m128 _mm_cmpord_ss(__m128 a, __m128 b) 「順序付けなし」の条件で比較する。
__m128 _mm_cmpunord_ss(__m128 a, __m128 b) 「より小さくなく等しくない」の条件で比較
する。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-5
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
COMISD int _mm_comieq_sd(__m128d a, __m128d b) 「a とb が等しい」という条件で、a とb の
最下位の倍精度浮動小数点値を比較する。a
とb が等しい場合は、1 が返される。それ
以外の場合は、0 が返される。
int _mm_comilt_sd(__m128d a, __m128d b) 「a がb より小さい」という条件で、a とb
の最下位の倍精度浮動小数点値を比較する。
a がb より小さい場合は、1 が返される。そ
れ以外の場合は、0 が返される。
int _mm_comile_sd(__m128d a, __m128d b) 「a がb より小さいか等しい」という条件
で、a とb の最下位の倍精度浮動小数点値
を比較する。a がb より小さいか等しい場
合は、1 が返される。それ以外の場合は、0
が返される。
int _mm_comigt_sd(__m128d a, __m128d b) 「a がb より大きい」という条件で、a とb
の最下位の倍精度浮動小数点値を比較する。
a がb より大きい場合は、1 が返される。そ
れ以外の場合は、0 が返される。
int _mm_comige_sd(__m128d a, __m128d b) 「a がb より大きいか等しい」という条件
で、a とb の最下位の倍精度浮動小数点値
を比較する。a がb より大きいか等しい場
合は、1 が返される。それ以外の場合は、0
が返される。
int _mm_comineq_sd(__m128d a, __m128d b) 「a とb が等しくない」という条件で、a と
b の最下位の倍精度浮動小数点値を比較す
る。a とb が等しくない場合は、1 が返され
る。それ以外の場合は、0 が返される。
COMISS int _mm_comieq_ss(__m128 a, __m128 b) 「a とb が等しい」という条件で、a とb の
最下位の単精度浮動小数点値を比較する。a
とb が等しい場合は、1 が返される。それ
以外の場合は、0 が返される。
int _mm_comilt_ss(__m128 a, __m128 b) 「a がb より小さい」という条件で、a とb
の最下位の単精度浮動小数点値を比較する。
a がb より小さい場合は、1 が返される。そ
れ以外の場合は、0 が返される。
int _mm_comile_ss(__m128 a, __m128 b) 「a がb より小さいか等しい」という条件
で、a とb の最下位の単精度浮動小数点値
を比較する。a がb より小さいか等しい場
合は、1 が返される。それ以外の場合は、0
が返される。
int _mm_comigt_ss(__m128 a, __m128 b) 「a がb より大きい」という条件で、a とb
の最下位の単精度浮動小数点値を比較する。
a がb より大きい場合は、1 が返される。そ
れ以外の場合は、0 が返される。
int _mm_comige_ss(__m128 a, __m128 b) 「a がb より大きいか等しい」という条件
で、a とb の最下位の単精度浮動小数点値
を比較する。a がb より大きいか等しい場
合は、1 が返される。それ以外の場合は、0
が返される。
int _mm_comineq_ss(__m128 a, __m128 b) 「a とb が等しくない」という条件で、a と
b の最下位の単精度浮動小数点値を比較す
る。a とb が等しくない場合は、1 が返され
る。それ以外の場合は、0 が返される。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-6
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
CVTDQ2PD __m128d _mm_cvtepi32_pd(__m128i a) a のパックド形式の最下位の2 つの32 ビッ
ト符号付き整数値を、2 つの倍精度浮動小
数点値に変換する。
CVTDQ2PS __m128 _mm_cvtepi32_ps(__m128i a) a のパックド形式の4 つの32 ビット符号付
き整数値を、4 つの単精度浮動小数点値に
変換する。
CVTPD2DQ __m128i _mm_cvtpd_epi32(__m128d a) a の2 つの倍精度浮動小数点値を、2 つの
32 ビット符号付き整数値に変換する。
CVTPD2PI __m64 _mm_cvtpd_pi32(__m128d a) a の2 つの倍精度浮動小数点値を、2 つの
32 ビット符号付き整数値に変換する。
CVTPD2PS __m128 _mm_cvtpd_ps(__m128d a) a の2 つの倍精度浮動小数点値を、2 つの倍
精度浮動小数点値に変換する。
CVTPI2PD __m128d _mm_cvtpi32_pd(__m64 a) a の2 つの32 ビット整数値を、2 つの単精
度浮動小数点値に変換する。
CVTPI2PS __m128 _mm_cvt_pi2ps(__m128 a, __m64 b)
__m128 _mm_cvtpi32_ps(__m128 a, __m64 b)
b のパックド形式の2 つの32 ビット整数値
を、2 つの単精度浮動小数点値に変換する。
上位の2 つの単精度浮動小数点値は、a か
らそのまま渡される。
CVTPS2DQ __m128i _mm_cvtps_epi32(__m128 a) 現在の丸めモードに従って、a の4 つの単
精度浮動小数点値を4 つの32 ビット符号付
き整数に変換する。
CVTPS2PD __m128d _mm_cvtps_pd(__m128 a) a の最下位の2 つの単精度浮動小数点値を、
倍精度浮動小数点値に変換する。
CVTPS2PI __m64 _mm_cvt_ps2pi(__m128 a)
__m64 _mm_cvtps_pi32(__m128 a)
現在の丸めモードに従って、a の下位の2
つの単精度浮動小数点値を32 ビット整数に
変換し、パックド形式の整数を返す。
CVTSD2SI int _mm_cvtsd_si32(__m128d a) a の最下位の倍精度浮動小数点値を、32
ビット整数値に変換する。
CVTSD2SS __m128 _mm_cvtsd_ss(__m128 a, __m128d b) b の最下位の倍精度浮動小数点値を、単精
度浮動小数点値に変換する。上位の3 つの
単精度浮動小数点値は、a からそのまま渡
される。
CVTSI2SD __m128d _mm_cvtsi32_sd(__m128d a, int b) 32 ビット整数値b を倍精度浮動小数点値に
変換する。上位の倍精度浮動小数点値は、a
からそのまま渡される。
CVTSI2SS __m128 _mm_cvt_si2ss(__m128 a, int b)
__m128 _mm_cvtsi32_ss(__m128a, int b)
32 ビット整数値b を単精度浮動小数点値に
変換する。上位の3 つの単精度浮動小数点
値は、a からそのまま渡される。
CVTSS2SD __m128d _mm_cvtss_sd(__m128d a, __m128 b) b の最下位の単精度浮動小数点値を、倍精
度浮動小数点値に変換する。上位の倍精度
浮動小数点値は、a からそのまま渡される。
CVTSS2SI int _mm_cvt_ss2si(__m128 a)
int _mm_cvtss_si32(__m128 a)
a の最下位の単精度浮動小数点値を32 ビッ
ト整数に変換する。
CVTTPD2DQ __m128i _mm_cvttpd_epi32(__m128d a) 切り捨てを使用して、a の2 つの倍精度浮
動小数点値を、2 つの32 ビット符号付き整
数値に変換する。上位の2 つの整数値は、0
である。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-7
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
CVTTPD2PI __m64 _mm_cvttpd_pi32(__m128d a) 切り捨てを使用して、a の2 つの倍精度浮
動小数点値を、32 ビット符号付き整数値に
変換する。
CVTTPS2DQ __m128i _mm_cvttps_epi32(__m128 a) 切り捨てを使用して、a の4 つの単精度浮
動小数点値を、4 つの32 ビット整数に変換
する。
CVTTPS2PI __m64 _mm_cvtt_ps2pi(__m128 a)
__m64 _mm_cvttps_pi32(__m128 a)
切り捨てを使用して、a の下位の2 つの単
精度浮動小数点値を2 つの32 ビット整数に
変換し、パックド形式の整数を返す。
CVTTSD2SI int _mm_cvttsd_si32(__m128d a) 切り捨てを使用して、a の最下位の倍精度
浮動小数点値を、32 ビット符号付き整数に
変換する。
CVTTSS2SI int _mm_cvtt_ss2si(__m128 a)
int _mm_cvttss_si32(__m128 a)
現在の丸めモードに従って、a の最下位の
単精度浮動小数点値を32 ビット整数に変換
する。
__m64 _mm_cvtsi32_si64(int i) 整数オブジェクトi を64 ビットの__m64
オブジェクトに変換する。整数値は64 ビッ
トにゼロ拡張される。
int _mm_cvtsi64_si32(__m64 m) __m64 オブジェクトm の下位の32 ビット
を整数に変換する。
DIVPD __m128d _mm_div_pd(__m128d a, __m128d b) a の2 つの倍精度浮動小数点値をb の2 つ
の倍精度浮動小数点値で割る。
DIVPS __m128 _mm_div_ps(__m128 a, __m128 b) a の4 つの単精度浮動小数点値をb の4 つ
の単精度浮動小数点値で割る。
DIVSD __m128d _mm_div_sd(__m128d a, __m128d b) a の最下位の倍精度浮動小数点値をb の最
下位の倍精度浮動小数点値で割る。上位の
3 つの倍精度浮動小数点値は、a からそのま
ま渡される。
DIVSS __m128 _mm_div_ss(__m128 a, __m128 b) a の最下位の単精度浮動小数点値をb の最
下位の単精度浮動小数点値で割る。上位の
3 つの単精度浮動小数点値は、a からそのま
ま渡される。
EMMS void _mm_empty() MMX テクノロジの状態をクリアする。
LDMXCSR _mm_setcsr(unsigned int i) 制御レジスタを指定された値に設定する。
LFENCE void _mm_lfence(void) プログラム順序でLFENCE 命令に先行する
すべてのロード命令が、そのLFENCE の後
( 後続) に実行されるどのロード命令よりも
前にグローバルにアクセス可能になること
を保証する。
MASKMOVDQU void _mm_maskmoveu_si128(__m128i d, __m128i n, char
*p)
d のバイト要素をアドレスp に条件付きで
ストアする。セレクタn の各バイトの最上
位ビットによって、それに対応するd のバ
イトがストアされるかどうかが決まる。
MASKMOVQ void _mm_maskmove_si64(__m64 d, __m64 n, char *p) d のバイト要素をアドレスp に条件付きで
ストアする。セレクタn の各バイトの最上
位ビットによって、それに対応するd のバ
イトがストアされるかどうかが決まる。
MAXPD __m128d _mm_max_pd(__m128d a, __m128d b) a とb の2 つの倍精度浮動小数点値の最大
値を計算する。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-8
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
MAXPS __m128 _mm_max_ps(__m128 a, __m128 b) a とb の4 つの単精度浮動小数点値の最大
値を計算する。
MAXSD __m128d _mm_max_sd(__m128d a, __m128d b) a とb の最下位の倍精度浮動小数点値の最
大値を計算する。上位の倍精度浮動小数点
値は、a からそのまま渡される。
MAXSS __m128 _mm_max_ss(__m128 a, __m128 b) a とb の最下位の単精度浮動小数点値の最
大値を計算する。上位の3 つの単精度浮動
小数点値は、a からそのまま渡される。
MFENCE void _mm_mfence(void) プログラムの順序でメモリ・フェンス命令
に先行するすべてのメモリ・アクセスが、
フェンスに後続するメモリ・アクセス命令
より前に、グローバルにアクセス可能にな
ることを保証する。
MINPD __m128d _mm_min_pd(__m128d a, __m128d b) a とb の2 つの倍精度浮動小数点値の最小
値を計算する。
MINPS __m128 _mm_min_ps(__m128 a, __m128 b) a とb の4 つの単精度浮動小数点値の最小
値を計算する。
MINSD __m128d _mm_min_sd(__m128d a, __m128d b) a とb の最下位の倍精度浮動小数点値の最
小値を計算する。上位の倍精度浮動小数点
値は、a からそのまま渡される。
MINSS __m128 _mm_min_ss(__m128 a, __m128 b) a とb の最下位の単精度浮動小数点値の最
小値を計算する。上位の3 つの単精度浮動
小数点値は、a からそのまま渡される。
MOVAPD __m128d _mm_load_pd(double * p) 2 つの倍精度浮動小数点値をロードする。
アドレスp は16 バイト・アライメントでな
ければならない。
void_mm_store_pd(double *p, __m128d a) 2 つの倍精度浮動小数点値をアドレスp に
ストアする。アドレスp は16 バイト・アラ
イメントでなければならない。
MOVAPS __m128 _mm_load_ps(float * p) 4 つの単精度浮動小数点値をロードする。
アドレスp は16 バイト・アライメントでな
ければならない。
void_mm_store_ps(float *p, __m128 a) 4 つの単精度浮動小数点値をストアする。
アドレスp は16 バイト・アライメントでな
ければならない。
MOVD __m128i _mm_cvtsi32_si128(int a) 32 ビット整数a を128 ビット・デスティ
ネーションの最下位32 ビットに移動し、上
位ビットをゼロ拡張する。
int _mm_cvtsi128_si32( __m128i a) a の最下位の32 ビット整数を32 ビット符
号付き整数に移動する。
__m64 _mm_cvtsi32_si64(int a) 32 ビット整数a を64 ビット・デスティ
ネーションの下位32 ビットに移動し、上位
ビットをゼロ拡張する。
int _mm_cvtsi64_si32( __m64 a) a の下位の32 ビット整数を32 ビット符号
付き整数に移動する。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-9
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
MOVDQA __m128i _mm_load_si128(__m128i * p) p から128 ビット値をロードする。アドレ
スp は16 バイト・アライメントでなければ
ならない。
void_mm_store_si128(__m128i *p, __m128i a) a の128 ビット値をアドレスp にストアす
る。アドレスp は16 バイト・アライメント
でなければならない。
MOVDQU __m128i _mm_loadu_si128(__m128i * p) p から128 ビット値をロードする。アドレ
スp は16 バイト・アライメントである必要
はない。
void_mm_storeu_si128(__m128i *p, __m128i a) a の128 ビット値をアドレスp にストアす
る。アドレスp は16 バイト・アライメント
である必要はない。
MOVDQ2Q __m64 _mm_movepi64_pi64(__m128i a) a の最下位の64 ビットを__m64 タイプに
返す。
MOVHLPS __m128 _mm_movehl_ps(__m128 a, __m128 b) b の上位の2 つの単精度浮動小数点値を、
結果の下位の2 つの単精度浮動小数点値に
移動する。a の上位の2 つの単精度浮動小
数点値は、そのまま結果に渡される。
MOVHPD __m128d _mm_loadh_pd(__m128d a, double * p) 倍精度浮動小数点値を、アドレスp からデ
スティネーションの上位の64 ビットにロー
ドする。下位の64 ビットは、a からそのま
ま渡される。
void _mm_storeh_pd(double * p, __m128d a) a の上位の倍精度浮動小数点値をアドレスp
にストアする。
MOVHPS __m128 _mm_loadh_pi(__m128 a, __m64 * p) 上位の2 つの単精度浮動小数点値として、
アドレスp から64 ビットのデータをロード
する。下位の2 つの値は、a からそのまま
渡される。
void _mm_storeh_pi(__m64 * p, __m128 a) a の上位の2 つの単精度浮動小数点値をア
ドレスp にストアする。
MOVLPD __m128d _mm_loadl_pd(__m128d a, double * p) 倍精度浮動小数点値を、アドレスp からデ
スティネーションの下位の64 ビットにロー
ドする。上位の64 ビットは、a からそのま
ま渡される。
void _mm_storel_pd(double * p, __m128d a) a の下位の倍精度浮動小数点値をアドレスp
にストアする。
MOVLPS __m128 _mm_loadl_pi(__m128 a, __m64 *p) 下位の2 つの単精度浮動小数点値として、
アドレスp から64 ビットのデータをロード
する。上位の2 つの値は、a からそのまま
渡される。
void_mm_storel_pi(__m64 * p, __m128 a) a の下位の2 つの単精度浮動小数点値をア
ドレスp にストアする。
MOVLHPS __m128 _mm_movelh_ps(__m128 a, __m128 b) b の下位の2 つの単精度浮動小数点値を、
結果の上位の2 つの単精度浮動小数点値に
移動する。a の下位の2 つの単精度浮動小
数点値は、そのまま結果に渡される。
MOVMSKPD int _mm_movemask_pd(__m128d a) a の2 つの倍精度浮動小数点値の符号付き
ビットから2 ビット・マスクを作成する。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-10
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
MOVMSKPS int _mm_movemask_ps(__m128 a) 4 つの単精度浮動小数点値の最上位ビット
から4 ビット・マスクを作成する。
MOVNTDQ void_mm_stream_si128(__m128i * p, __m128i a) キャッシュを汚染せずに、a のデータをア
ドレスp にストアする。p が入っている
キャッシュ・ラインが既にキャッシュ内に
ある場合は、キャッシュは更新される。ア
ドレスは16 バイト・アライメントでなけれ
ばならない。
MOVNTPD void_mm_stream_pd(double * p, __m128d a) キャッシュを汚染せずに、a のデータをア
ドレスp にストアする。アドレスは16 バイ
ト・アライメントでなければならない。
MOVNTPS void_mm_stream_ps(float * p, __m128 a) キャッシュを汚染せずに、a のデータをア
ドレスp にストアする。アドレスは16 バイ
ト・アライメントでなければならない。
MOVNTI void_mm_stream_si32(int * p, int a) キャッシュを汚染せずに、a のデータをア
ドレスp にストアする。
MOVNTQ void_mm_stream_pi(__m64 * p, __m64 a) キャッシュを汚染せずに、a のデータをア
ドレスp にストアする。
MOVQ __m128i _mm_loadl_epi64(__m128i * p) p から下位64 ビットをデスティネーション
の下位64 ビットにロードし、上位64 ビッ
トをゼロ拡張する。
void_mm_storel_epi64(_m128i * p, __m128i a) a の下位64 ビットをp の下位64 ビットに
ストアする。
__m128i _mm_move_epi64(__m128i a) a の下位64 ビットをデスティネーションの
下位64 ビットに移動する。上位64 ビット
はクリアされる。
MOVQ2DQ __m128i _mm_movpi64_epi64(__m64 a) a の64 ビットをデスティネーションの下位
64 ビットに移動し、上位ビットをゼロ拡張
する。
MOVSD __m128d _mm_load_sd(double * p) 倍精度浮動小数点値をp から最下位の倍精
度浮動小数点値にロードし、上位の倍精度
浮動小数点値をクリアする。アドレスp は
16 バイト・アライメントである必要はな
い。
void_mm_store_sd(double * p, __m128d a) 最下位の倍精度浮動小数点値をアドレスp
にストアする。アドレスｐ は16 バイト・
アライメントである必要はない。
__m128d _mm_move_sd(__m128d a, __m128d b) b の最下位の倍精度浮動小数点値をデス
ティネーションに設定する。上位の倍精度
浮動小数点値は、a からそのまま渡される。
MOVSS __m128 _mm_load_ss(float * p) 単精度浮動小数点値を最下位ワードにロー
ドし、上位の3 ワードをクリアする。
void_mm_store_ss(float * p, __m128 a) 最下位の単精度浮動小数点値をストアする。
__m128 _mm_move_ss(__m128 a, __m128 b) 最下位ワードをb の単精度浮動小数点値に
設定する。上位の3 つの単精度浮動小数点
値は、a からそのまま渡される。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-11
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
MOVUPD __m128d _mm_loadu_pd(double * p) p から2 つの倍精度浮動小数点値をロード
する。アドレスp が16 バイト・アライメン
トである必要はない。
void_mm_storeu_pd(double *p, __m128d a) a の2 つの倍精度浮動小数点値をp にスト
アする。アドレスp が16 バイト・アライメ
ントである必要はない。
MOVUPS __m128 _mm_loadu_ps(float * p) 4 つの単精度浮動小数点値をロードする。
アドレスが16 バイト・アライメントである
必要はない。
void_mm_storeu_ps(float *p, __m128 a) 4 つの単精度浮動小数点値をストアする。
アドレスが16 バイト・アライメントである
必要はない。
MULPD __m128d _mm_mul_pd(__m128d a, __m128d b) a の2 つの倍精度浮動小数点値にb の2 つ
の倍精度浮動小数点値を掛ける。
MULPS __m128 _mm_mul_ss(__m128 a, __m128 b) a の4 つの単精度浮動小数点値にb の4 つ
の単精度浮動小数点値を掛ける。
MULSD __m128d _mm_mul_sd(__m128d a, __m128d b) a の最下位の倍精度浮動小数点値にb の最
下位の倍精度浮動小数点値を掛ける。上位
の倍精度浮動小数点値は、a からそのまま
渡される。
MULSS __m128 _mm_mul_ss(__m128 a, __m128 b) a の最下位の単精度浮動小数点値にb の最
下位の単精度浮動小数点値を掛ける。上位
の3 つの単精度浮動小数点値は、a からそ
のまま渡される。
ORPD __m128d _mm_or_pd(__m128d a, __m128d b) a とb の2 つの倍精度浮動小数点値の間で
ビット単位のOR 演算を実行する。
ORPS __m128 _mm_or_ps(__m128 a, __m128 b) a とb の4 つの単精度浮動小数点値の間で
ビット単位のOR 演算を実行する。
PACKSSWB __m128i _mm_packs_epi16(__m128i m1, __m128i m2) 符号付きの飽和を使用して、m1 の8 つの
16 ビット値を結果の下位の8 つの8 ビット
値にパックし、m2 の8 つの16 ビット値を
結果の上位の8 つの8 ビット値にパックす
る。
PACKSSWB __m64 _mm_packs_pi16(__m64 m1, __m64 m2) 符号付きの飽和を使用して、m1 の4 つの
16 ビット値を結果の下位の4 つの8 ビット
値にパックし、m2 の4 つの16 ビット値を
結果の上位の4 つの8 ビット値にパックす
る。
PACKSSDW __m128i _mm_packs_epi32 (__m128i m1, __m128i m2) 符号付きの飽和を使用して、m1 の4 つの
32 ビット値を結果の下位の4 つの16 ビッ
ト値にパックし、m2 の4 つの32 ビット値
を結果の上位の4 つの16 ビット値にパック
する。
PACKSSDW __m64 _mm_packs_pi32 (__m64 m1, __m64 m2) 符号付きの飽和を使用して、m1 の2 つの
32 ビット値を結果の下位の2 つの16 ビッ
ト値にパックし、m2 の2 つの32 ビット値
を結果の上位の2 つの16 ビット値にパック
する。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-12
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
PACKUSWB __m128i _mm_packus_epi16(__m128i m1, __m128i m2) 符号なしの飽和を使用して、m1 の8 つの
16 ビット値を結果の下位の8 つの8 ビット
値にパックし、m2 の8 つの16 ビット値を
結果の上位の8 つの8 ビット値にパックす
る。
PACKUSWB __m64 _mm_packs_pu16(__m64 m1, __m64 m2) 符号なしの飽和を使用して、m1 の4 つの
16 ビット値を結果の下位の4 つの8 ビット
値にパックし、m2 の4 つの16 ビット値を
結果の上位の4 つの8 ビット値にパックす
る。
PADDB __m128i _mm_add_epi8(__m128i m1, __m128i m2) m1 の16 個の8 ビット値を、m2 の16 個の
8 ビット値に加算する。
PADDB __m64 _mm_add_pi8(__m64 m1, __m64 m2) m1 の8 つの8 ビット値を、m2 の8 つの8
ビット値に加算する。
PADDW __m128i _mm_addw_epi16(__m128i m1, __m128i m2) m1 の8 つの16 ビット値を、m2 の8 つの
16 ビット値に加算する。
PADDW __m64 _mm_addw_pi16(__m64 m1, __m64 m2) m1 の4 つの16 ビット値を、m2 の4 つの
16 ビット値に加算する。
PADDD __m128i _mm_add_epi32(__m128i m1, __m128i m2) m1 の4 つの32 ビット値を、m2 の4 つの
32 ビット値に加算する。
PADDD __m64 _mm_add_pi32(__m64 m1, __m64 m2) m1 の2 つの32 ビット値を、m2 の2 つの
32 ビット値に加算する。
PADDQ __m128i _mm_add_epi64(__m128i m1, __m128i m2) m1 の2 つの64 ビット値を、m2 の2 つの
64 ビット値に加算する。
PADDQ __m64 _mm_add_si64(__m64 m1, __m64 m2) m1 の64 ビット値を、m2 の64 ビット値に
加算する。
PADDSB __m128i _mm_adds_epi8(__m128i m1, __m128i m2) m1 の16 個の符号付き8 ビット値を、m2
の16 個の符号付き8 ビット値に加算し、飽
和させる。
PADDSB __m64 _mm_adds_pi8(__m64 m1, __m64 m2) m1 の8 つの符号付き8 ビット値を、m2 の
8 つの符号付き8 ビット値に加算し、飽和
させる。
PADDSW __m128i _mm_adds_epi16(__m128i m1, __m128i m2) m1 の8 つの符号付き16 ビット値を、m2
の8 つの符号付き16 ビット値に加算し、飽
和させる。
PADDSW __m64 _mm_adds_pi16(__m64 m1, __m64 m2) m1 の4 つの符号付き16 ビット値を、m2
の4 つの符号付き16 ビット値に加算し、飽
和させる。
PADDUSB __m128i _mm_adds_epu8(__m128i m1, __m128i m2) m1 の16 個の符号なし8 ビット値を、m2
の16 個の符号なし8 ビット値に加算し、飽
和させる。
PADDUSB __m64 _mm_adds_pu8(__m64 m1, __m64 m2) m1 の8 つの符号なし8 ビット値を、m2 の
8 つの符号なし8 ビット値に加算し、飽和
させる。
PADDUSW __m128i _mm_adds_epu16(__m128i m1, __m128i m2) m1 の8 つの符号なし16 ビット値を、m2
の8 つの符号なし16 ビット値に加算し、飽
和させる。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-13
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
PADDUSW __m64 _mm_adds_pu16(__m64 m1, __m64 m2) m1 の4 つの符号なし16 ビット値を、m2
の4 つの符号なし16 ビット値に加算し、飽
和させる。
PAND __m128i _mm_and_si128(__m128i m1, __m128i m2) m1 の128 ビット値とm2 の128 ビット値
の間でビット単位のAND 演算を実行する。
PAND __m64 _mm_and_si64(__m64 m1, __m64 m2) m1 の64 ビット値とm2 の64 ビット値の
間でビット単位のAND 演算を実行する。
PANDN __m128i _mm_andnot_si128(__m128i m1, __m128i m2) m1 の128 ビット値に対してNOT 演算を実
行し、その結果とm2 の128 ビット値の間
でビット単位のAND 演算を実行する。
PANDN __m64 _mm_andnot_si64(__m64 m1, __m64 m2) m1 の64 ビット値に対してNOT 演算を実
行し、その結果とm2 の64 ビット値の間で
ビット単位のAND 演算を実行する。
PAUSE void _mm_pause(void) 次の命令の実行をプロセッサ固有の時間だ
け遅らせる。アーキテクチャ上の状態は変
更されない。
PAVGB __m128i _mm_avg_epu8(__m128i a, __m128i b) 2 つのオペランドの16 個の8 ビット値の
パックド平均を計算する。
PAVGB __m64 _mm_avg_pu8(__m64 a, __m64 b) 2 つのオペランドの8 つの8 ビット値の
パックド平均を計算する。
PAVGW __m128i _mm_avg_epu16(__m128i a, __m128i b) 2 つのオペランドの8 つの16 ビット値の
パックド平均を計算する。
PAVGW __m64 _mm_avg_pu16(__m64 a, __m64 b) 2 つのオペランドの4 つの16 ビット値の
パックド平均を計算する。
PCMPEQB __m128i _mm_cmpeq_epi8(__m128i m1, __m128i m2) m1 の8 ビット値とm2 の8 ビット値がすべ
て等しい場合は、結果の8 ビット値をすべ
て1 にセットする。それ以外の場合は、す
べて0 にセットする。
PCMPEQB __m64 _mm_cmpeq_pi8(__m64 m1, __m64 m2) m1 の8 ビット値とm2 の8 ビット値がすべ
て等しい場合は、結果の8 ビット値をすべ
て1 にセットする。それ以外の場合は、す
べて0 にセットする。
PCMPEQW __m128i _mm_cmpeq_epi16 (__m128i m1, __m128i m2) m1 の16 ビット値とm2 の16 ビット値が
すべて等しい場合は、結果の62 ビット値を
すべて1 にセットする。それ以外の場合は、
すべて0 にセットする。
PCMPEQW __m64 _mm_cmpeq_pi16 (__m64 m1, __m64 m2) m1 の16 ビット値とm2 の16 ビット値が
すべて等しい場合は、結果の16 ビット値を
すべて1 にセットする。それ以外の場合は、
すべて0 にセットする。
PCMPEQD __m128i _mm_cmpeq_epi32(__m128i m1, __m128i m2) m1 の32 ビット値とm2 の32 ビット値が
すべて等しい場合は、結果の32 ビット値を
すべて1 にセットする。それ以外の場合は、
すべて0 にセットする。
PCMPEQD __m64 _mm_cmpeq_pi32(__m64 m1, __m64 m2) m1 の32 ビット値とm2 の32 ビット値が
すべて等しい場合は、結果の32 ビット値を
すべて1 にセットする。それ以外の場合は、
すべて0 にセットする。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-14
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
PCMPGTB __m128i _mm_cmpgt_epi8 (__m128i m1, __m128i m2) m1 の8 ビット値がすべてm2 の8 ビット値
より大きい場合は、結果の8 ビット値をす
べて1 にセットする。それ以外の場合は、
すべて0 にセットする。
PCMPGTB __m64 _mm_cmpgt_pi8 (__m64 m1, __m64 m2) m1 の8 ビット値がすべてm2 の8 ビット値
より大きい場合は、結果の8 ビット値をす
べて1 にセットする。それ以外の場合は、
すべて0 にセットする。
PCMPGTW __m128i _mm_cmpgt_epi16(__m128i m1, __m128i m2) m1 の16 ビット値がすべてm2 の16 ビッ
ト値より大きい場合は、結果の16 ビット値
をすべて1 にセットする。それ以外の場合
は、すべて0 にセットする。
PCMPGTW __m64 _mm_cmpgt_pi16 (__m64 m1, __m64 m2) m1 の16 ビット値がすべてm2 の16 ビッ
ト値より大きい場合は、結果の16 ビット値
をすべて1 にセットする。それ以外の場合
は、すべて0 にセットする。
PCMPGTD __m128i _mm_cmpgt_epi32(__m128i m1, __m128i m2) m1 の32 ビット値がすべてm2 の32 ビッ
ト値より大きい場合は、結果の32 ビット値
をすべて1 にセットする。それ以外の場合
は、すべて0 にセットする。
PCMPGTD __m64 _mm_cmpgt_pi32(__m64 m1, __m64 m2) m1 の32 ビット値がすべてm2 の32 ビッ
ト値より大きい場合は、結果の32 ビット値
をすべて1 にセットする。それ以外の場合
は、すべて0 にセットする。
PEXTRW int _mm_extract_epi16(__m128i a, int n) a の8 ワードのうち1 つを抽出する。セレ
クタn は即値でなければならない。
PEXTRW int _mm_extract_pi16(__m64 a, int n) a の4 ワードのうち1 つを抽出する。セレ
クタn は即値でなければならない。
PINSRW __m128i _mm_insert_epi16(__m128i a, int d, int n) a の8 ワードのうち1 つにワードd を挿入
する。セレクタn は即値でなければならな
い。
PINSRW __m64 _mm_insert_pi16(__m64 a, int d, int n) a の4 ワードのうち1 つにワードd を挿入
する。セレクタn は即値でなければならな
い。
PMADDWD __m128i _mm_madd_epi16(__m128i m1, __m128i m2) m1 の8 つの16 ビット値にm2 の8 つの16
ビット値を掛けて、8 つの32 ビットの中間
結果を求める。次に、これらの値を2 つず
つ合計して、4 つの32 ビットの結果を求め
る。
PMADDWD __m64 _mm_madd_pi16(__m64 m1, __m64 m2) m1 の4 つの16 ビット値にm2 の4 つの16
ビット値を掛けて、4 つの32 ビットの中間
結果を求める。次に、これらの値を2 つず
つ合計して、2 つの32 ビットの結果を求め
る。
PMAXSW __m128i _mm_max_epi16(__m128i a, __m128i b) a とb の16 ビット整数を比較して、要素ご
とに最大値を求める。
PMAXSW __m64 _mm_max_pi16(__m64 a, __m64 b) a とb のワードを比較して、要素ごとに最
大値を求める。
PMAXUB __m128i _mm_max_epu8(__m128i a, __m128i b) a とb の符号なしバイトを比較して、要素
ごとに最大値を求める。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-15
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
PMAXUB __m64 _mm_max_pu8(__m64 a, __m64 b) a とb の符号なしバイトを比較して、要素
ごとに最大値を求める。
PMINSW __m128i _mm_min_epi16(__m128i a, __m128i b) a とb の16 ビット整数を比較して、要素ご
とに最小値を求める。
PMINSW __m64 _mm_min_pi16(__m64 a, __m64 b) a とb のワードを比較して、要素ごとに最
小値を求める。
PMINUB __m128i _mm_min_epu8(__m128i a, __m128i b) a とb の符号なしバイトを比較して、要素
ごとに最小値を求める。
PMINUB __m64 _mm_min_pu8(__m64 a, __m64 b) a とb の符号なしバイトを比較して、要素
ごとに最小値を求める。
PMOVMSKB int _mm_movemask_epi8(__m128i a) a の各バイトの最上位ビットから16 ビッ
ト・マスクを作成する。
PMOVMSKB int _mm_movemask_pi8(__m64 a) a の各バイトの最上位ビットから8 ビット・
マスクを作成する。
PMULHUW __m128i _mm_mulhi_epu16(__m128i a, __m128i b) a の8 つの符号なしワードにb の8 つの符
号なしワードを掛けて、パックド形式の8
つの32 ビットの中間結果の上位16 ビット
を返す。
PMULHUW __m64 _mm_mulhi_pu16(__m64 a, __m64 b) a の4 つの符号なしワードにb の4 つの符
号なしワードを掛けて、パックド形式の4
つの32 ビットの中間結果の上位16 ビット
を返す。
PMULHW __m128i _mm_mulhi_epi16(__m128i m1, __m128i m2) m1 の8 つの符号付き16 ビット値にm2 の
8 つの符号付き16 ビット値を掛けて、8 つ
の結果の上位16 ビットを返す。
PMULHW __m64 _mm_mulhi_pi16(__m64 m1, __m64 m2) m1 の4 つの符号付き16 ビット値にm2 の
4 つの符号付き16 ビット値を掛けて、4 つ
の結果の上位16 ビットを返す。
PMULLW __m128i _mm_mullo_epi16(__m128i m1, __m128i m2) m1 の8 つの符号付き16 ビット値にm2 の
8 つの符号付き16 ビット値を掛けて、8 つ
の結果の下位16 ビットを返す。
PMULLW __m64 _mm_mullo_pi16(__m64 m1, __m64 m2) m1 の4 つの符号付き16 ビット値にm2 の
4 つの符号付き16 ビット値を掛けて、4 つ
の結果の下位16 ビットを返す。
PMULUDQ __m64 _mm_mul_su32(__m64 m1, __m64 m2) m1 の下位の符号なし32 ビット値にm2 の
下位の符号なし32 ビット値を掛けて、64
ビットの結果をストアする。
__m128i _mm_mul_epu32(__m128i m1, __m128i m2) m1 の下位の2 つの符号なし32 ビット値に
m2 の下位の2 つの符号なし32 ビット値を
掛けて、2 つの64 ビットの結果をストアす
る。
POR __m64 _mm_or_si64(__m64 m1, __m64 m2) m1 の64 ビット値とm2 の64 ビット値の
間でビット単位のOR 演算を実行する。
POR __m128i _mm_or_si128(__m128i m1, __m128i m2) m1 の128 ビット値とm2 の128 ビット値
の間でビット単位のOR 演算を実行する。
PREFETCHh void _mm_prefetch(char *a, int sel) 1 キャッシュ・ラインのデータを、アドレ
スp からプロセッサに「より近い」位置に
ロードする。値sel は、プリフェッチ操作
のタイプを指定する。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-16
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
PSADBW __m128i _mm_sad_epu8(__m128i a, __m128i b) a とb の16 個の符号なし8 ビット値の差の
絶対値を計算して、上位の8 つの差と下位
の8 つの差をそれぞれ合計し、2 つの16
ビットの結果を上位64 ビットと下位64
ビットに格納する。
PSADBW __m64 _mm_sad_pu8(__m64 a, __m64 b) a とb の8 つの符号なし8 ビット値の差の
絶対値を計算して、8 つの差を合計し、16
ビットの結果を格納する。上位3 ワードは
クリアされる。
PSHUFD __m128i _mm_shuffle_epi32(__m128i a, int n) a の4 つのdword の組み合わせを返す。セ
レクタn は即値でなければならない。
PSHUFHW __m128i _mm_shufflehi_epi16(__m128i a, int n) n で指定された、a の上位4 つの16 ビッ
ト・ワードをシャッフルする。セレクタn
は即値でなければならない。
PSHUFLW __m128i _mm_shufflelo_epi16(__m128i a, int n) n で指定された、a の下位4 つの16 ビッ
ト・ワードをシャッフルする。セレクタn
は即値でなければならない。
PSHUFW __m64 _mm_shuffle_pi16(__m64 a, int n) a の4 ワードの組み合わせを返す。セレク
タn は即値でなければならない。
PSLLW __m128i _mm_sll_epi16(__m128i m, __m128i count) m の8 つの各16 ビット値を、count で指定
された量だけ左にシフトし、下位はゼロで
埋める。
PSLLW __m128i _mm_slli_epi16(__m128i m, int count) m の8 つの各16 ビット値を、count で指定
された量だけ左にシフトし、下位はゼロで
埋める。
PSLLW __m64 _mm_sll_pi16(__m64 m, __m64 count) m の4 つの16 ビット値を、count で指定さ
れた量だけ左にシフトし、下位はゼロで埋
める。最高のパフォーマンスを得るために
は、count は定数でなければならない。
__m64 _mm_slli_pi16(__m64 m, int count) m の4 つの16 ビット値を、count で指定さ
れた量だけ左にシフトし、下位はゼロで埋
める。最高のパフォーマンスを得るために
は、count は定数でなければならない。
PSLLD __m128i _mm_slli_epi32(__m128i m, int count) m の4 つの各32 ビット値を、count で指定
された量だけ左にシフトし、下位はゼロで
埋める。
__m128i _mm_sll_epi32(__m128i m, __m128i count) m の4 つの各32 ビット値を、count で指定
された量だけ左にシフトし、下位はゼロで
埋める。最高のパフォーマンスを得るため
には、count は定数でなければならない。
PSLLD __m64 _mm_slli_pi32(__m64 m, int count) m の2 つの32 ビット値を、count で指定さ
れた量だけ左にシフトし、下位はゼロで埋
める。
__m64 _mm_sll_pi32(__m64 m, __m64 count) m の2 つの32 ビット値を、count で指定さ
れた量だけ左にシフトし、下位はゼロで埋
める。最高のパフォーマンスを得るために
は、count は定数でなければならない。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-17
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
PSLLQ __m64 _mm_sll_si64(__m64 m, __m64 count) m の64 ビット値を、count で指定された量
だけ左にシフトし、下位はゼロで埋める。
__m64 _mm_slli_si64(__m64 m, int count) m の64 ビット値を、count で指定された量
だけ左にシフトし、下位はゼロで埋める。
最高のパフォーマンスを得るためには、
count は定数でなければならない。
PSLLQ __m128i _mm_sll_epi64(__m128i m, __m128i count) m の2 つの各64 ビット値を、count で指定
された量だけ左にシフトし、下位はゼロで
埋める。
__m128i _mm_slli_epi64(__m128i m, int count) m の2 つの各64 ビット値を、count で指定
された量だけ左にシフトし、下位はゼロで
埋める。最高のパフォーマンスを得るため
には、count は定数でなければならない。
PSLLDQ __m128i _mm_slli_si128(__m128i m, int imm) m の128 ビット値を、imm バイトで左にシ
フトし、下位はゼロで埋める。
PSRAW __m128i _mm_sra_epi16(__m128i m, __m128i count) m の8 つの各16 ビット値を、count で指定
された量だけ右にシフトし、上位は符号
ビットで埋める。
__m128i _mm_srai_epi16(__m128i m, int count) m の8 つの各16 ビット値を、count で指定
された量だけ右にシフトし、上位は符号
ビットで埋める。最高のパフォーマンスを
得るためには、count は定数でなければな
らない。
PSRAW __m64 _mm_sra_pi16(__m64 m, __m64 count) m の4 つの16 ビット値を、count で指定さ
れた量だけ右にシフトし、上位は符号ビッ
トで埋める。
__m64 _mm_srai_pi16(__m64 m, int count) m の4 つの16 ビット値を、count で指定さ
れた量だけ右にシフトし、上位は符号ビッ
トで埋める。最高のパフォーマンスを得る
ためには、count は定数でなければならな
い。
PSRAD __m128i _mm_sra_epi32 (__m128i m, __m128i count) m の4 つの各32 ビット値を、count で指定
された量だけ右にシフトし、上位は符号
ビットで埋める。
__m128i _mm_srai_epi32 (__m128i m, int count) m の4 つの各32 ビット値を、count で指定
された量だけ右にシフトし、上位は符号
ビットで埋める。最高のパフォーマンスを
得るためには、count は定数でなければな
らない。
PSRAD __m64 _mm_sra_pi32 (__m64 m, __m64 count) m の2 つの32 ビット値を、count で指定さ
れた量だけ右にシフトし、上位は符号ビッ
トで埋める。
__m64 _mm_srai_pi32 (__m64 m, int count) m の2 つの32 ビット値を、count で指定さ
れた量だけ右にシフトし、上位は符号ビッ
トで埋める。最高のパフォーマンスを得る
ためには、count は定数でなければならな
い。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-18
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
PSRLW _m128i _mm_srl_epi16 (__m128i m, __m128i count) m の8 つの各16 ビット値を、count で指定
された量だけ右にシフトし、上位はゼロで
埋める。
__m128i _mm_srli_epi16 (__m128i m, int count) m の8 つの各16 ビット値を、count で指定
された量だけ右にシフトし、上位はゼロで
埋める。
PSRLW __m64 _mm_srl_pi16 (__m64 m, __m64 count) m の4 つの16 ビット値を、count で指定さ
れた量だけ右にシフトし、上位はゼロで埋
める。
__m64 _mm_srli_pi16(__m64 m, int count) m の4 つの16 ビット値を、count で指定さ
れた量だけ右にシフトし、上位はゼロで埋
める。最高のパフォーマンスを得るために
は、count は定数でなければならない。
PSRLD __m128i _mm_srl_epi32 (__m128i m, __m128i count) m の4 つの各32 ビット値を、count で指定
された量だけ右にシフトし、上位はゼロで
埋める。
__m128i _mm_srli_epi32 (__m128i m, int count) m の4 つの各32 ビット値を、count で指定
された量だけ右にシフトし、上位はゼロで
埋める。最高のパフォーマンスを得るため
には、count は定数でなければならない。
PSRLD __m64 _mm_srl_pi32 (__m64 m, __m64 count) m の2 つの32 ビット値を、count で指定さ
れた量だけ右にシフトし、上位はゼロで埋
める。
__m64 _mm_srli_pi32 (__m64 m, int count) m の2 つの32 ビット値を、count で指定さ
れた量だけ右にシフトし、上位はゼロで埋
める。最高のパフォーマンスを得るために
は、count は定数でなければならない。
PSRLQ __m128i _mm_srl_epi64 (__m128i m, __m128i count) m の2 つの各64 ビット値を、count で指定
された量だけ右にシフトし、上位はゼロで
埋める。
__m128i _mm_srli_epi64 (__m128i m, int count) m の2 つの各64 ビット値を、count で指定
された量だけ右にシフトし、上位はゼロで
埋める。最高のパフォーマンスを得るため
には、count は定数でなければならない。
PSRLQ __m64 _mm_srl_si64 (__m64 m, __m64 count) m の64 ビット値を、count で指定された量
だけ右にシフトし、上位はゼロで埋める。
__m64 _mm_srli_si64 (__m64 m, int count) m の64 ビット値を、count で指定された量
だけ右にシフトし、上位はゼロで埋める。
最高のパフォーマンスを得るためには、
count は定数でなければならない。
PSRLDQ __m128i _mm_srli_si128(__m128i m, int imm) m の128 ビット値を、imm バイトで右にシ
フトし、下位はゼロで埋める。
PSUBB __m128i _mm_sub_epi8(__m128i m1, __m128i m2) m1 の16 個の8 ビット値からm2 の16 個
の8 ビット値を引く。
PSUBB __m64 _mm_sub_pi8(__m64 m1, __m64 m2) m1 の8 つの8 ビット値からm2 の8 つの8
ビット値を引く。
PSUBW __m128i _mm_sub_epi16(__m128i m1, __m128i m2) m1 の8 つの16 ビット値からm2 の8 つの
16 ビット値を引く。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-19
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
PSUBW __m64 _mm_sub_pi16(__m64 m1, __m64 m2) m1 の4 つの16 ビット値からm2 の4 つの
16 ビット値を引く。
PSUBD __m128i _mm_sub_epi32(__m128i m1, __m128i m2) m1 の4 つの32 ビット値からm2 の4 つの
32 ビット値を引く。
PSUBD __m64 _mm_sub_pi32(__m64 m1, __m64 m2) m1 の2 つの32 ビット値からm2 の2 つの
32 ビット値を引く。
PSUBQ __m128i _mm_sub_epi64(__m128i m1, __m128i m2) m1 の2 つの64 ビット値からm2 の2 つの
64 ビット値を引く。
PSUBQ __m64 _mm_sub_si64(__m64 m1, __m64 m2) m1 の64 ビット値からm2 の64 ビット値
を引く。
PSUBSB __m128i _mm_subs_epi8(__m128i m1, __m128i m2) m1 の16 個の符号付き8 ビット値からm2
の16 個の符号付き8 ビット値を引き、飽和
させる。
PSUBSB __m64 _mm_subs_pi8(__m64 m1, __m64 m2) m1 の8 つの符号付き8 ビット値からm2 の
8 つの符号付き8 ビット値を引き、飽和さ
せる。
PSUBSW __m128i _mm_subs_epi16(__m128i m1, __m128i m2) m1 の8 つの符号付き16 ビット値からm2
の8 つの符号付き16 ビット値を引き、飽和
させる。
PSUBSW __m64 _mm_subs_pi16(__m64 m1, __m64 m2) m1 の4 つの符号付き16 ビット値からm2
の4 つの符号付き16 ビット値を引き、飽和
させる。
PSUBUSB __m128i _mm_sub_epu8(__m128i m1, __m128i m2) m1 の16 個の符号なし8 ビット値からm2
の16 個の符号なし8 ビット値を引き、飽和
させる。
PSUBUSB __m64 _mm_sub_pu8(__m64 m1, __m64 m2) m1 の8 つの符号なし8 ビット値からm2 の
8 つの符号なし8 ビット値を引き、飽和さ
せる。
PSUBUSW __m128i _mm_sub_epu16(__m128i m1, __m128i m2) m1 の8 つの符号なし16 ビット値からm2
の8 つの符号なし16 ビット値を引き、飽和
させる。
PSUBUSW __m64 _mm_sub_pu16(__m64 m1, __m64 m2) m1 の4 つの符号なし16 ビット値からm2
の4 つの符号なし16 ビット値を引き、飽和
させる。
PUNPCKHBW __m64 _mm_unpackhi_pi8(__m64 m1, __m64 m2) m1 の上位半分の4 つの8 ビット値とm2 の
上位半分の4 つの8 ビット値をインタリー
ブし、m1 の最下位の要素をとる。
PUNPCKHBW __m128i _mm_unpackhi_epi8(__m128i m1, __m128i m2) m1 の上位半分の8 つの8 ビット値とm2 の
上位半分の8 つの8 ビット値をインタリー
ブする。
PUNPCKHWD __m64 _mm_unpackhi_pi16(__m64 m1,__m64 m2) m1 の上位半分の2 つの16 ビット値とm2
の上位半分の2 つの16 ビット値をインタ
リーブし、m1 の最下位の要素をとる。
PUNPCKHWD __m128i _mm_unpackhi_epi16(__m128i m1,__m128i m2) m1 の上位半分の4 つの16 ビット値とm2
の上位半分の4 つの16 ビット値をインタ
リーブする。
PUNPCKHDQ ___m64 _mm_unpackhi_pi32(__m64 m1, __m64 m2) m1 の上位半分の32 ビット値とm2 の上位
半分の32 ビット値をインタリーブし、m1
の最下位の要素をとる。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-20
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
PUNPCKHDQ __m128i _mm_unpackhi_epi32(__m128i m1, __m128i m2) m1 の上位半分の2 つの32 ビット値とm2
の上位半分の2 つの32 ビット値をインタ
リーブする。
PUNPCKHQDQ __m128i _mm_unpackhi_epi64(__m128i m1, __m128i m2) m1 の上位半分の64 ビット値とm2 の上位
半分の64 ビット値をインタリーブする。
PUNPCKLBW __m64 _mm_unpacklo_pi8 (__m64 m1, __m64 m2) m1 の下位半分の4 つの8 ビット値とm2 の
下位半分の4 つの8 ビット値をインタリー
ブし、m1 の最下位の要素をとる。
PUNPCKLBW __m128i _mm_unpacklo_epi8 (__m128i m1, __m128i m2) m1 の下位半分の8 つの8 ビット値とm2 の
下位半分の8 つの8 ビット値をインタリー
ブする。
PUNPCKLWD __m64 _mm_unpacklo_pi16(__m64 m1, __m64 m2) m1 の下位半分の2 つの16 ビット値とm2
の下位半分の2 つの16 ビット値をインタ
リーブし、m1 の最下位の要素をとる。
PUNPCKLWD __m128i _mm_unpacklo_epi16(__m128i m1, __m128i m2) m1 の下位半分の4 つの16 ビット値とm2
の下位半分の4 つの16 ビット値をインタ
リーブする。
PUNPCKLDQ __m64 _mm_unpacklo_pi32(__m64 m1, __m64 m2) m1 の下位半分の32 ビット値とm2 の下位
半分の32 ビット値をインタリーブし、m1
の最下位の要素をとる。
PUNPCKLDQ __m128i _mm_unpacklo_epi32(__m128i m1, __m128i m2) m1 の下位半分の2 つの32 ビット値とm2
の下位半分の2 つの32 ビット値をインタ
リーブする。
PUNPCKLQDQ __m128i _mm_unpacklo_epi64(__m128i m1, __m128i m2) m1 の下位半分の64 ビット値とm2 の下位
半分の64 ビット値をインタリーブする。
PXOR __m64 _mm_xor_si64(__m64 m1, __m64 m2) m1 の64 ビット値とm2 の64 ビット値の
間でビット単位のXOR 演算を実行する。
PXOR __m128i _mm_xor_si128(__m128i m1, __m128i m2) m1 の128 ビット値とm2 の128 ビット値
の間でビット単位のXOR 演算を実行する。
RCPPS __m128 _mm_rcp_ps(__m128 a) a の4 つの単精度浮動小数点値の逆数の近
似値を計算する。
RCPSS __m128 _mm_rcp_ss(__m128 a) a の最下位の単精度浮動小数点値の逆数の
近似値を計算する。上位の3 つの単精度浮
動小数点値はそのまま渡される。
RSQRTPS __m128 _mm_rsqrt_ps(__m128 a) a の4 つの単精度浮動小数点値の平方根の
逆数の近似値を計算する。
RSQRTSS __m128 _mm_rsqrt_ss(__m128 a) a の最下位の単精度浮動小数点値の平方根
の逆数の近似値を計算する。上位の3 つの
単精度浮動小数点値はそのまま渡される。
SFENCE void_mm_sfence(void) フェンスより前にあるすべてのストア命令
が、フェンスより後にあるストア命令より
前に、グローバルにアクセス可能になるこ
とを保証する。
SHUFPD __m128d _mm_shuffle_pd(__m128d a, __m128d b,
unsigned int imm8)
マスクimm8 に基づいて、a とb から2 つ
の倍精度浮動小数点値を選択する。マスク
は即値でなければならない。
SHUFPS __m128 _mm_shuffle_ps(__m128 a, __m128 b,
unsigned int imm8)
マスクimm8 に基づいて、a とb から4 つ
の単精度浮動小数点値を選択する。マスク
は即値でなければならない。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-21
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
SQRTPD __m128d _mm_sqrt_pd(__m128d a) a の2 つの倍精度浮動小数点値の平方根を
計算する。
SQRTPS __m128 _mm_sqrt_ps(__m128 a) a の4 つの単精度浮動小数点値の平方根を
計算する。
SQRTSD __m128d _mm_sqrt_sd(__m128d a) a の最下位の倍精度浮動小数点値の平方根
を計算する。上位の倍精度浮動小数点値は
そのまま渡される。
SQRTSS __m128 _mm_sqrt_ss(__m128 a) a の最下位の単精度浮動小数点値の平方根
を計算する。上位の3 つの単精度浮動小数
点値はそのまま渡される。
STMXCSR _mm_getcsr(void) 制御レジスタの内容を返す。
SUBPD __m128d _mm_sub_pd(__m128d a, __m128d b) a の2 つの倍精度浮動小数点値からb の2
つの倍精度浮動小数点値を引く。
SUBPS __m128 _mm_sub_ps(__m128 a, __m128 b) a の4 つの単精度浮動小数点値からb の4
つの単精度浮動小数点値を引く。
SUBSD __m128d _mm_sub_sd(__m128d a, __m128d b) a の最下位の倍精度浮動小数点値からb の
最下位の倍精度浮動小数点値を引く。上位
の倍精度浮動小数点値は、a からそのまま
渡される。
SUBSS __m128 _mm_sub_ss(__m128 a, __m128 b) a の最下位の単精度浮動小数点値からb の
最下位の単精度浮動小数点値を引く。上位
の3 つの単精度浮動小数点値は、a からそ
のまま渡される。
UCOMISD int _mm_ucomieq_sd(__m128d a, __m128d b) 「a とb が等しい」という条件で、a とb の
最下位の倍精度浮動小数点値を比較する。a
とb が等しい場合は、1 が返される。それ
以外の場合は、0 が返される。
int _mm_ucomilt_sd(__m128d a, __m128d b) 「a がb より小さい」という条件で、a とb
の最下位の倍精度浮動小数点値を比較する。
a がb より小さい場合は、1 が返される。そ
れ以外の場合は、0 が返される。
int _mm_ucomile_sd(__m128d a, __m128d b) 「a がb より小さいか等しい」という条件
で、a とb の最下位の倍精度浮動小数点値
を比較する。a がb より小さいか等しい場
合は、1 が返される。それ以外の場合は、0
が返される。
int _mm_ucomigt_sd(__m128d a, __m128d b) 「a がb より大きい」という条件で、a とb
の最下位の倍精度浮動小数点値を比較する。
a がb より大きい場合は、1 が返される。そ
れ以外の場合は、0 が返される。
int _mm_ucomige_sd(__m128d a, __m128d b) 「a がb より大きいか等しい」という条件
で、a とb の最下位の倍精度浮動小数点値
を比較する。a がb より大きいか等しい場
合は、1 が返される。それ以外の場合は、0
が返される。
int _mm_ucomineq_sd(__m128d a, __m128d b) 「a とb が等しくない」という条件で、a と
b の最下位の倍精度浮動小数点値を比較す
る。a とb が等しくない場合は、1 が返され
る。それ以外の場合は、0 が返される。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-22
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
UCOMISS int _mm_ucomieq_ss(__m128 a, __m128 b) 「a とb が等しい」という条件で、a とb の
最下位の単精度浮動小数点値を比較する。a
とb が等しい場合は、1 が返される。それ
以外の場合は、0 が返される。
int _mm_ucomilt_ss(__m128 a, __m128 b) 「a がb より小さい」という条件で、a とb
の最下位の単精度浮動小数点値を比較する。
a がb より小さい場合は、1 が返される。そ
れ以外の場合は、0 が返される。
int _mm_ucomile_ss(__m128 a, __m128 b) 「a がb より小さいか等しい」という条件
で、a とb の最下位の単精度浮動小数点値
を比較する。a がb より小さいか等しい場
合は、1 が返される。それ以外の場合は、0
が返される。
int _mm_ucomigt_ss(__m128 a, __m128 b) 「a がb より大きい」という条件で、a とb
の最下位の単精度浮動小数点値を比較する。
a がb より大きい場合は、1 が返される。そ
れ以外の場合は、0 が返される。
int _mm_ucomige_ss(__m128 a, __m128 b) 「a がb より大きいか等しい」という条件
で、a とb の最下位の単精度浮動小数点値
を比較する。a がb より大きいか等しい場
合は、1 が返される。それ以外の場合は、0
が返される。
int _mm_ucomineq_ss(__m128 a, __m128 b) 「a とb が等しくない」という条件で、a と
b の最下位の単精度浮動小数点値を比較す
る。a とb が等しくない場合は、1 が返され
る。それ以外の場合は、0 が返される。
UNPCKHPD __m128d _mm_unpackhi_pd(__m128d a, __m128d b) a とb の上位の倍精度浮動小数点値を選択
し、インタリーブする。
UNPCKHPS __m128 _mm_unpackhi_ps(__m128 a, __m128 b) a とb の上位の2 つの単精度浮動小数点値
を選択し、インタリーブする。
UNPCKLPD __m128d _mm_unpacklo_pd(__m128d a, __m128d b) a とb の下位の倍精度浮動小数点値を選択
し、インタリーブする。
UNPCKLPS __m128 _mm_unpacklo_ps(__m128 a, __m128 b) a とb の下位の2 つの単精度浮動小数点値
を選択し、インタリーブする。
XORPD __m128d _mm_xor_pd(__m128d a, __m128d b) a とb の2 つの倍精度浮動小数点値の間で
ビット単位のEXOR( 排他的論理和) 演算
を実行する。
XORPS __m128 _mm_xor_ps(__m128 a, __m128 b) a とb の4 つの単精度浮動小数点値の間で
ビット単位のEXOR( 排他的論理和) 演算
を実行する。
表C-1. 簡単な組み込み関数 ( 続き)
ニーモニック組み込み関数説明
C-23
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
C.2. 複合組み込み関数
表C-2. 複合組み込み関数
ニーモニック組み込み関数説明
(composite) __m128i _mm_set_epi64(__m64 q1, __m64 q0) 2 つの64 ビット値を2 つの入力値に設定す
る。
(composite) __m128i _mm_set_epi32(int i3, int i2, int i1, int i0) 4 つの32 ビット値を4 つの入力値に設定す
る。
(composite) __m128i _mm_set_epi16(short w7,short w6,short w5, short
w4, short w3, short w2,short w1,short w0)
8 つの16 ビット値を8 つの入力値に設定す
る。
(composite) __m128i _mm_set_epi8(char w15,char w14,char w13, char
w12, char w11, char w10,char w9,char w8,char w7,char
w6,char w5, char w4, char w3, char w2,char w1,char w0)
16 個の8 ビット値を16 個の入力値に設定
する。
(composite) __m128i _mm_set1_epi64(__m64 q) 2 つの64 ビット値を入力値に設定する。
(composite) __m128i _mm_set1_epi32(int a) 4 つの32 ビット値を入力値に設定する。
(composite) __m128i _mm_set1_epi16(short a) 8 つの16 ビット値を入力値に設定する。
(composite) __m128i _mm_set1_epi8(char a) 16 個の8 ビット値を入力値に設定する。
(composite) __m128i _mm_setr_epi64(__m64 q1, __m64 q0) 2 つの64 ビット値を、逆の順番で2 つの入
力値に設定する。
(composite) __m128i _mm_setr_epi32(int i3, int i2, int i1, int i0) 4 つの32 ビット値を、逆の順番で4 つの入
力値に設定する。
(composite) __m128i _mm_setr_epi16(short w7,short w6,short w5,
short w4, short w3, short w2,short w1,short w0)
8 つの16 ビット値を、逆の順番で8 つの入
力値に設定する。
(composite) __m128i _mm_setr_epi8(char w15,char w14,char w13,
char w12, char w11, char w10,char w9,char w8,char
w7,char w6,char w5, char w4, char w3, char w2,char
w1,char w0)
16 個の8 ビット値を、逆の順番で16 個の
入力値に設定する。
(composite) __m128i _mm_setzero_si128() すべてのビットを0 に設定する。
(composite) __m128 _mm_set_ps1(float w)
__m128 _mm_set1_ps(float w)
4 つの単精度浮動小数点値をw に設定する。
(composite) __m128d _mm_set1_pd(double w) 2 つの倍精度浮動小数点値をw に設定する。
(composite) __m128d _mm_set_sd(double w) 下位の倍精度浮動小数点値をw に設定す
る。
(composite) __m128d _mm_set_pd(double z, double y) 2 つの倍精度浮動小数点値を2 つの入力値
に設定する。
(composite) __m128 _mm_set_ps(float z, float y, float x, float w) 4 つの単精度浮動小数点値を4 つの入力値
に設定する。
(composite) __m128d _mm_setr_pd(double z, double y) 2 つの倍精度浮動小数点値を、逆の順番で2
つの入力値に設定する。
(composite) __m128 _mm_setr_ps(float z, float y, float x, float w) 4 つの単精度浮動小数点値を、逆の順番で4
つの入力値に設定する。
(composite) __m128d _mm_setzero_pd(void) 2 つの倍精度浮動小数点値をクリアする。
(composite) __m128 _mm_setzero_ps(void) 4 つの単精度浮動小数点値をクリアする。
C-24
機能的に同等のインテルR C/C++ コンパイラ組み込み関数
MOVSD +
shuffle
__m128d _mm_load_pd(double * p)
__m128d _mm_load1_pd(double *p)
1 つの倍精度浮動小数点値をロードし、両
方の倍精度浮動小数点値にコピーする。
MOVSS +
shuffle
__m128 _mm_load_ps1(float * p)
__m128 _mm_load1_ps(float *p)
1 つの単精度浮動小数点値をロードし、4
ワードすべてにコピーする。
MOVAPD +
shuffle
__m128d _mm_loadr_pd(double * p) 2 つの倍精度浮動小数点値を逆の順番で
ロードする。アドレスは16 バイト・アライ
メントでなければならない。
MOVAPS +
shuffle
__m128 _mm_loadr_ps(float * p) 4 つの単精度浮動小数点値を逆の順番で
ロードする。アドレスは16 バイト・アライ
メントでなければならない。
MOVSD +
shuffle
void _mm_store1_pd(double *p, __m128d a) 最下位の倍精度浮動小数点値を両方の倍精
度浮動小数点値にストアする。
MOVSS +
shuffle
void _mm_store_ps1(float * p, __m128 a)
void _mm_store1_ps(float *p, __m128 a)
最下位の単精度浮動小数点値を4 ワードに
ストアする。
MOVAPD +
shuffle
_mm_storer_pd(double * p, __m128d a) 2 つの倍精度浮動小数点値を逆の順番でス
トアする。アドレスは16 バイト・アライメ
ントでなければならない。
MOVAPS +
shuffle
_mm_storer_ps(float * p, __m128 a) 4 つの単精度浮動小数点値を逆の順番でス
トアする。アドレスは16 バイト・アライメ
ントでなければならない。
表C-2. 複合組み込み関数 ( 続き)
ニーモニック組み込み関数説明
索引

索引-1
索引
数字
16 進数....................................................... 1-7
2 進化10 進(BCD を参照)
2 進数......................................................... 1-7
A
AAA 命令.................................................. 3-15
AAD 命令.................................................. 3-16
AAM 命令.................................................. 3-17
AAS 命令.................................................. 3-18
ADC 命令........................................ 3-19, 3-387
ADDPD 命令............................................. 3-23
ADDPS 命令.............................................. 3-25
ADDSD 命令............................................. 3-27
ADDSS 命令.............................................. 3-29
ADD 命令............. 3-15, 3-19, 3-21, 3-174, 3-387
ANDNPD 命令........................................... 3-37
ANDNPS 命令........................................... 3-39
ANDPD 命令............................................. 3-33
ANDPS 命令.............................................. 3-35
AND 命令........................................ 3-31, 3-387
ARPL 命令................................................ 3-41
B
BCD 整数
アンパック.................. 3-15, 3-16, 3-17, 3-18
パックド.............. 3-174, 3-176, 3-201, 3-203
BOUND 範囲外例外(#BR) .......................... 3-43
BOUND 命令............................................. 3-43
BSF 命令.................................................. 3-45
BSR 命令.................................................. 3-47
BSWAP 命令............................................. 3-49
BTC 命令........................................ 3-52, 3-387
BTR 命令........................................ 3-54, 3-387
BTS 命令........................................ 3-56, 3-387
BT 命令.................................................... 3-50
B( デフォルト・スタック・サイズ) フラグ、セグ
メント記述子.................. 3-573, 3-632
C
CALL 命令................................................. 3-58
CBW 命令................................................. 3-69
CDQ 命令............................................... 3-172
CF( キャリー) フラグ、EFLAGS レジスタ.. 3-19,
3-50, 3-52, 3-54, 3-56, 3-71, 3-78,
3-177, 3-320, 3-325, 3-480, 3-642,
3-674, 3-686, 3-688, 3-709, 3-719
CLC 命令.................................................. 3-71
CLD 命令.................................................. 3-72
CLFLUSH 命令.......................................... 3-73
CLI 命令.................................................... 3-75
CLTS 命令................................................ 3-77
CMC 命令................................................. 3-78
CMOVcc 命令............................................ 3-79
CMPPD 命令............................................. 3-85
CMPPS 命令............................................. 3-89
CMPSB 命令............................................. 3-93
CMPSD 命令.................................... 3-93, 3-96
CMPSS 命令............ 3-100, 3-101, 3-102, 3-103
CMPSW 命令............................................ 3-93
CMPS 命令..................................... 3-93, 3-654
CMPXCHG8B 命令.................................. 3-106
CMPXCHG 命令............................ 3-104, 3-387
CMP 命令.................................................. 3-83
COMISD 命令.......................................... 3-108
COMISS 命令.......................................... 3-111
CPL........................................................ 3-751
CPUID 命令............................................. 3-114
CLFLUSH 命令キャッシュ・ライン・
サイズ........................................... 3-117
CPUID 拡張機能情報........................... 3-115
機能情報............................................ 3-118
キャッシュおよびTLB の特性.... 3-115, 3-121
初期APIC ID ...................................... 3-117
バージョン情報......................... 3-115, 3-116
ブランドの識別................................... 3-123
ブランド・インデックス...................... 3-117
プロセッサ・タイプ・フィールド......... 3-117
プロセッサ・ブランド・ストリング...... 3-115
CR0 制御レジスタ................................... 3-699
CS レジスタ.... 3-58, 3-330, 3-344, 3-356, 3-422,
3-574
CVTDQ2PD 命令..................................... 3-128
CVTDQ2PS 命令..................................... 3-130
CVTPD2DQ 命令..................................... 3-132
CVTPD2PI 命令....................................... 3-134
CVTPD2PS 命令...................................... 3-136
CVTPI2PD 命令....................................... 3-138
CVTPI2PS 命令....................................... 3-140
CVTPS2DQ 命令..................................... 3-142
CVTPS2PD 命令...................................... 3-144
CVTPS2PI 命令....................................... 3-146
CVTSD2SI 命令....................................... 3-148
CVTSD2SS 命令...................................... 3-150
CVTSI2SD 命令....................................... 3-152
CVTSI2SS 命令....................................... 3-154
CVTSS2SD 命令...................................... 3-156
CVTSS2SI 命令....................................... 3-158
CVTTPD2DQ 命令................................... 3-162
CVTTPD2PI 命令..................................... 3-160
CVTTPS2DQ 命令................................... 3-164
CVTTPS2PI 命令..................................... 3-166
CVTTSD2SI 命令..................................... 3-168
CVTTSS2SI 命令..................................... 3-170
CWDE 命令............................................... 3-69
索引
索引-2
CWD 命令............................................... 3-172
C/C++ コンパイラ組み込み関数
一覧...................................................... C-1
簡単な.................................................. C-3
機能的に同等なコンパイラ...................... C-1
説明....................................................... 3-8
複合.................................................... C-23
D
DAA 命令................................................ 3-174
DAS 命令................................................ 3-176
DEC 命令...................................... 3-177, 3-387
DF( 方向) フラグ、EFLAGS レジスタ........ 3-72,
3-94, 3-328, 3-389, 3-467, 3-504, 3-676,
3-710
DIVPD 命令............................................. 3-182
DIVPS 命令............................................. 3-184
DIVSD 命令............................................. 3-186
DIVSS 命令............................................. 3-188
DIV 命令................................................. 3-179
DS レジスタ..... 3-93, 3-369, 3-389, 3-467, 3-503
D( デフォルト演算サイズ) フラグ、セグメント
記述子.................. 3-573, 3-578, 3-632
E
EDI レジスタ....................... 3-676, 3-710, 3-715
EFLAGS レジスタ
条件コード....................... 3-80, 3-210, 3-215
ステータス・フラグ................... 3-83, 3-353,
3-679, 3-736
セーブ............................................... 3-669
プッシュ............................................ 3-637
ポップ............................................... 3-580
命令によって影響を受けるフラグ........... 3-10
ロード............................................... 3-363
割り込みからのリターン時のポップ...... 3-344
割り込み時のプッシュ......................... 3-330
EIP レジスタ.............. 3-58, 3-330, 3-344, 3-357
EMMS 命令............................................. 3-190
ENTER 命令............................................ 3-191
ESI レジスタ.... 3-93, 3-389, 3-467, 3-503, 3-710
ESP レジスタ.................................. 3-59, 3-574
ES レジスタ........................ 3-369, 3-676, 3-715
F
F2XM1 命令.................................. 3-194, 3-310
FADDP 命令............................................ 3-198
FADD 命令.............................................. 3-198
far コール、CALL 命令............................... 3-58
far ポインタ、ロード................................ 3-369
far リターン、RET 命令............................ 3-657
FBLD 命令.............................................. 3-201
FBSTP 命令............................................ 3-203
FCHS 命令.............................................. 3-206
FCLEX/FNCLEX 命令............................... 3-208
FCMOVcc 命令........................................ 3-210
FCOMIP 命令.......................................... 3-215
FCOMI 命令............................................ 3-215
FCOMPP 命令......................................... 3-212
FCOMP 命令........................................... 3-212
FCOM 命令............................................. 3-212
FCOS 命令.............................................. 3-218
FDECSTP 命令........................................ 3-220
FDIVP 命令............................................. 3-221
FDIVRP 命令........................................... 3-225
FDIVR 命令............................................. 3-225
FDIV 命令............................................... 3-221
FFREE 命令............................................ 3-229
FIADD 命令............................................. 3-198
FICOMP 命令.......................................... 3-230
FICOM 命令............................................ 3-230
FIDIVR 命令............................................ 3-225
FIDIV 命令.............................................. 3-221
FILD 命令................................................ 3-232
FIMUL 命令............................................. 3-248
FINCSTP 命令......................................... 3-234
FINIT/FNINIT 命令......................... 3-235, 3-265
FISTP 命令.............................................. 3-237
FIST 命令................................................ 3-237
FISUBR 命令........................................... 3-286
FISUB 命令............................................. 3-286
FLD1 命令............................................... 3-242
FLDCW 命令........................................... 3-244
FLDENV 命令.......................................... 3-246
FLDL2E 命令........................................... 3-242
FLDL2T 命令........................................... 3-242
FLDLG2 命令........................................... 3-242
FLDLN2 命令........................................... 3-242
FLDPI 命令.............................................. 3-242
FLDZ 命令............................................... 3-242
FLD 命令................................................. 3-240
FMULP 命令............................................ 3-248
FMUL 命令.............................................. 3-248
FNOP 命令.............................................. 3-251
FNSTENV 命令........................................ 3-246
FPATAN 命令.......................................... 3-252
FPREM1 命令.......................................... 3-257
FPTAN 命令............................................ 3-260
FRNDINT 命令......................................... 3-262
FRSTOR 命令......................................... 3-263
FSAVE/FNSAVE 命令.................... 3-263, 3-265
FSCALE 命令.......................................... 3-268
FSINCOS 命令........................................ 3-272
FSIN 命令............................................... 3-270
FSQRT 命令............................................ 3-274
FSTCW/FNSTCW 命令............................. 3-279
FSTENV/FNSTENV 命令.......................... 3-281
FSTP 命令.............................................. 3-276
FSTSW/FNSTSW 命令............................. 3-284
FST 命令................................................. 3-276
FSUBP 命令............................................ 3-286
FSUBRP 命令.......................................... 3-286
FSUBR 命令............................................ 3-286
FSUB 命令.............................................. 3-286
索引-3
索引
FS レジスタ............................................ 3-369
FTST 命令............................................... 3-292
FUCOMIP 命令........................................ 3-215
FUCOMI 命令.......................................... 3-215
FUCOMPP 命令....................................... 3-294
FUCOMP 命令......................................... 3-294
FUCOM 命令........................................... 3-294
FXAM 命令.............................................. 3-298
FXCH 命令.............................................. 3-300
FXRSTOR 命令....................................... 3-302
FXSAVE 命令.......................................... 3-304
FXTRACT 命令.............................. 3-268, 3-310
FYL2XP1 命令......................................... 3-314
FYL2X 命令............................................. 3-312
G
GDTR( グローバル記述子テーブル・
レジスタ)....................... 3-379, 3-683
GDT( グローバル記述子テーブル) ... 3-379, 3-382
GS レジスタ............................................ 3-369
H
HLT 命令................................................ 3-316
I
IDIV 命令................................................ 3-317
IDTR( 割り込み記述子テーブル・レジスタ) ........
3-379, 3-683
IDT( 割り込み記述子テーブル)........ 3-331, 3-379
IF( 割り込みイネーブル) フラグ、EFLAGS
レジスタ........................... 3-75, 3-711
IMUL 命令............................................... 3-320
INC 命令....................................... 3-325, 3-387
INSB 命令............................................... 3-327
INSD 命令............................................... 3-327
INSW 命令.............................................. 3-327
INS 命令....................................... 3-327, 3-654
INT 3 命令............................................... 3-330
INTn 命令................................................ 3-330
INTO 命令............................................... 3-330
INVD 命令............................................... 3-342
INVLPG 命令........................................... 3-343
IN 命令................................................... 3-323
IOPL(I/O 特権レベル) フィールド、EFLAGS
レジスタ................. 3-75, 3-637, 3-711
IRETD 命令............................................. 3-344
IRET 命令............................................... 3-344
I/O 特権レベル(IOPL を参照)
J
Jcc 命令.................................................. 3-352
JMP 命令................................................ 3-356
L
LAHF 命令.............................................. 3-363
LAR 命令................................................ 3-364
LDMXCSR 命令....................................... 3-367
LDS 命令................................................ 3-369
LDTR( ローカル記述子テーブル・
レジスタ)....................... 3-382, 3-697
LDT( ローカル記述子テーブル) ................. 3-382
LEAVE 命令............................................ 3-374
LEA 命令................................................. 3-372
LES 命令................................................. 3-369
LFENCE 命令.......................................... 3-377
LFS 命令................................................. 3-369
LGDT 命令.............................................. 3-379
LGS 命令................................................ 3-369
LIDT 命令................................................ 3-379
LLDT 命令............................................... 3-382
LMSW 命令............................................. 3-385
LOCK プリフィックス...... 3-19, 3-21, 3-31, 3-52,
3-54, 3-56, 3-104, 3-106, 3-177, 3-325,
3-387, 3-490, 3-493, 3-495, 3-674,
3-719, 3-758, 3-760, 3-764
LODSB 命令............................................ 3-389
LODSD 命令............................................ 3-389
LODSW 命令........................................... 3-389
LODS 命令.................................... 3-389, 3-654
LOOPcc 命令........................................... 3-392
LOOP 命令.............................................. 3-392
LSL 命令................................................. 3-394
LSS 命令................................................. 3-369
LTR 命令................................................. 3-398
M
MASKMOVDQU 命令............................... 3-400
MASKMOVQ 命令.................................... 3-402
MAXPD 命令........................................... 3-405
MAXPS 命令........................................... 3-407
MAXSD 命令........................................... 3-409
MAXSS 命令........................................... 3-411
MFENCE 命令......................................... 3-413
MINPD 命令............................................ 3-414
MINPS.................................................... 3-416
MINPS 命令............................................. 3-416
MINSD 命令............................................ 3-418
MINSS 命令............................................. 3-420
ModR/M バイト
16 ビット・アドレス指定形式.................. 2-5
32 ビット・アドレス指定形式.................. 2-6
説明....................................................... 2-3
フォーマット.......................................... 2-1
Mod フィールド、命令フォーマット.............. 2-3
MOVAPD 命令......................................... 3-431
MOVAPS 命令......................................... 3-433
MOVDQ2Q 命令...................................... 3-441
MOVDQA 命令........................................ 3-437
MOVDQU 命令........................................ 3-439
MOVD 命令............................................. 3-435
索引
索引-4
MOVHLPS 命令....................................... 3-442
MOVHPD 命令........................................ 3-443
MOVHPS 命令......................................... 3-445
MOVLHPS 命令....................................... 3-447
MOVLPD 命令......................................... 3-448
MOVLPS 命令......................................... 3-450
MOVMSKPD 命令.................................... 3-452
MOVMSKPS 命令.................................... 3-453
MOVNTDQ 命令...................................... 3-454
MOVNTI 命令.......................................... 3-456
MOVNTPD 命令....................................... 3-458
MOVNTPS 命令....................................... 3-460
MOVNTQ 命令........................................ 3-462
MOVQ2DQ 命令...................................... 3-466
MOVQ 命令............................................. 3-464
MOVSB 命令........................................... 3-467
MOVSD 命令................................. 3-467, 3-470
MOVSS 命令........................................... 3-472
MOVSW 命令.......................................... 3-467
MOVSX 命令........................................... 3-474
MOVS 命令................................... 3-467, 3-654
MOVUPD 命令........................................ 3-475
MOVUPS 命令......................................... 3-477
MOVZX 命令........................................... 3-479
MOV 命令............................................... 3-422
MOV 命令( 制御レジスタ) ....................... 3-427
MOV 命令( デバッグ・レジスタ) .............. 3-429
MSR( モデル固有レジスタ)
書き込み............................................ 3-756
読み取り............................................ 3-649
MULPD 命令........................................... 3-482
MULPS 命令............................................ 3-484
MULSD 命令........................................... 3-486
MULSS 命令............................................ 3-488
MUL 命令........................................ 3-17, 3-480
N
NaN テスト............................................. 3-292
near
コール、CALL 命令............................... 3-58
リターン、RET 命令........................... 3-657
NEG 命令...................................... 3-387, 3-490
NOP 命令................................................ 3-492
NOT 命令...................................... 3-387, 3-493
NT( ネストされたタスク) フラグ、EFLAGS
レジスタ................................... 3-344
O
OF( オーバーフロー) フラグ、EFLAGS
レジスタ.... 3-330, 3-480, 3-674, 3-686,
3-688, 3-719
OF( キャリー) フラグ、EFLAGS レジスタ. 3-320
ORPD 命令............................................. 3-497
ORPS 命令............................................. 3-499
OR 命令........................................ 3-387, 3-495
OUTSB 命令............................................ 3-503
OUTSD 命令........................................... 3-503
OUTSW 命令........................................... 3-503
OUTS 命令.................................... 3-503, 3-654
OUT 命令................................................ 3-501
P
PACKSSDW 命令..... 3-506, 3-507, 3-508, 3-509
PACKSSWB 命令...... 3-506, 3-507, 3-508, 3-509
PACKUSWB 命令................ 3-510, 3-511, 3-512
PADDQ 命令........................................... 3-516
PADDSB 命令......................................... 3-518
PADDSW 命令......................................... 3-518
PADDUSB 命令....................................... 3-521
PADDUSW 命令...................................... 3-521
PANDN 命令........................................... 3-526
PAND 命令.............................................. 3-524
PAUSE 命令............................................ 3-528
PAVGB 命令............................................ 3-529
PAVGW 命令........................................... 3-529
PCMPEQB 命令....................................... 3-532
PCMPEQD 命令...................................... 3-532
PCMPEQW 命令...................................... 3-532
PCMPGTB 命令....................................... 3-536
PCMPGTD 命令....................................... 3-536
PCMPGTW 命令...................................... 3-536
PEXTRW 命令............................... 3-540, 3-541
PE( 保護イネーブル) フラグ、CR0
レジスタ................................... 3-385
Pi
ロード............................................... 3-242
PINSRW 命令...................... 3-542, 3-543, 3-544
PMADDWD 命令.................. 3-545, 3-546, 3-547
PMAXSW 命令........................................ 3-548
PMAXUB 命令......................................... 3-551
PMINSW 命令..................... 3-554, 3-555, 3-556
PMINUB 命令.......................................... 3-557
PMOVMSKB 命令.................................... 3-560
PMULHUW 命令...................................... 3-562
PMULHW 命令........................................ 3-565
PMULLW 命令......................................... 3-568
PMULUDQ 命令....................................... 3-571
POPAD 命令........................................... 3-578
POPA 命令.............................................. 3-578
POPFD 命令............................................ 3-580
POPF 命令.............................................. 3-580
POP 命令................................................ 3-573
POR 命令................................................ 3-583
PREFETCHh 命令.................................... 3-585
PSADBW 命令......................................... 3-587
PSHUFD 命令......................................... 3-590
PSHUFHW 命令...................................... 3-592
PSHUFW 命令......................................... 3-596
PSLLD 命令............................................. 3-599
PSLLQ 命令............................................ 3-599
PSLLW 命令............................................ 3-599
PSRAD 命令............................................ 3-603
PSRAW 命令........................................... 3-603
索引-5
索引
PSRLDQ 命令......................................... 3-607
PSRLD 命令............................................ 3-608
PSRLQ 命令............................................ 3-608
PSRLW 命令........................................... 3-608
PSUBB 命令............................................ 3-613
PSUBD 命令............................................ 3-613
PSUBQ 命令........................................... 3-616
PSUBSB 命令.......................................... 3-618
PSUBSW 命令......................................... 3-618
PSUBUSB 命令....................................... 3-621
PSUBUSW 命令...................................... 3-621
PSUBW 命令........................................... 3-613
PUNPCKHBW 命令.... 3-624, 3-625, 3-626, 3-627
PUNPCKHDQ 命令.... 3-624, 3-625, 3-626, 3-627
PUNPCKHWD 命令.... 3-624, 3-625, 3-626, 3-627
PUNPCKLBW 命令.................................. 3-628
PUNPCKLDQ 命令................................... 3-628
PUNPCKLWD 命令.................................. 3-628
PUSHAD 命令......................................... 3-635
PUSHA 命令............................................ 3-635
PUSHFD 命令......................................... 3-637
PUSHF 命令............................................ 3-637
PUSH 命令.............................................. 3-632
PXOR 命令............................................. 3-639
R
RCL 命令................................................ 3-641
RCPPS instruction ................................... 3-645
RCPPS 命令............................................ 3-645
RCPSS 命令............................................ 3-647
RCR 命令................................................ 3-641
RC( 丸め制御) フィールド、x87 FPU 制御
ワード.................. 3-238, 3-242, 3-276
RDMSR 命令................................. 3-649, 3-653
RDPMC 命令........................................... 3-651
RDTSC 命令............................................ 3-653
REP/REPE/REPZ/REPNE/REPNZ
プリフィックス...... 3-94, 3-328, 3-504,
3-654
RET 命令................................................ 3-657
ROL 命令................................................ 3-641
ROR 命令............................................... 3-641
RPL フィールド......................................... 3-41
RSM 命令............................................... 3-664
RSQRTPS 命令....................................... 3-665
RSQRTSS 命令....................................... 3-667
R/m フィールド、命令フォーマット.............. 2-3
S
SAL 命令................................................ 3-670
SAR 命令................................................ 3-670
SBB 命令...................................... 3-387, 3-674
SCASB 命令............................................ 3-676
SCASD 命令............................................ 3-676
SCASW 命令........................................... 3-676
SCAS 命令.................................... 3-654, 3-676
SETcc 命令............................................. 3-679
SFENCE 命令.......................................... 3-682
SF( 符号) フラグ、EFLAGS レジスタ.......... 3-21
SGDT 命令.............................................. 3-683
SHAF 命令.............................................. 3-669
SHLD 命令.............................................. 3-686
SHL 命令................................................ 3-670
SHRD 命令.............................................. 3-688
SHR 命令................................................ 3-670
SHUFPD 命令......................................... 3-690
SHUFPS 命令.......................................... 3-693
SIB バイト
32 ビット・アドレス指定形式.................. 2-7
説明....................................................... 2-3
フォーマット.......................................... 2-1
SIDT 命令............................................... 3-683
SIMD 浮動小数点数例外、マスクされていない、
影響......................................... 3-367
SLDT 命令.............................................. 3-697
SMSW 命令............................................. 3-699
SQRTPD 命令......................................... 3-701
SQRTPS 命令......................................... 3-703
SQRTSD 命令......................................... 3-705
SQRTSS 命令......................................... 3-707
SSE2 拡張命令
SIMD 整数レジスタ・フィールドの
エンコーディング............................ B-38
キャッシュ可能命令のエンコーディング B-44
SSE 拡張命令
SIMD 整数レジスタ・フィールドの
エンコーディング............................ B-29
キャッシュ可能/ メモリ順序付け命令の
エンコーディング............................ B-30
SS レジスタ........................ 3-369, 3-423, 3-574
STC 命令................................................ 3-709
STD 命令................................................ 3-710
STI 命令.................................................. 3-711
STMXCSR 命令....................................... 3-713
STOSB 命令............................................ 3-715
STOSD 命令............................................ 3-715
STOSW 命令........................................... 3-715
STOS 命令.................................... 3-654, 3-715
STR 命令................................................ 3-718
SUBPD 命令............................................ 3-721
SUBSS 命令............................................ 3-727
SUB 命令................... 3-18, 3-176, 3-387, 3-719
SYSENTER 命令..................................... 3-729
SYSEXIT 命令......................................... 3-733
T
TEST 命令.............................................. 3-736
TLB エントリ、無効化( フラッシュ) ......... 3-343
TSD フラグ、CR4 レジスタ...................... 3-653
TSS、タスク・レジスタとの関係.............. 3-718
TS( タスク・スイッチ) フラグ、CR0
レジスタ..................................... 3-77
索引
索引-6
U
UCOMISD 命令....................................... 3-738
UCOMISS 命令........................................ 3-740
UD2 命令................................................ 3-742
UNPCKHPD 命令..................................... 3-743
UNPCKHPS 命令..................................... 3-745
UNPCKLPD 命令..................................... 3-747
UNPCKLPS 命令..................................... 3-749
V
VERR 命令.............................................. 3-751
VERW 命令............................................. 3-751
VM( 仮想8086 モード) フラグ、EFLAGS
レジスタ................................... 3-344
W
WAIT/FWAIT 命令.................................... 3-753
WBINVD 命令.......................................... 3-754
WRMSR 命令.......................................... 3-756
X
x87 FPU
初期化............................................... 3-235
定数................................................... 3-242
未処理のx87 FPU 例外の有無を
チェック....................................... 3-753
x87 FPU 制御ワード
RC フィールド................ 3-238, 3-242, 3-276
ストア............................................... 3-279
セーブ..................................... 3-265, 3-281
復元................................................... 3-263
ロード..................................... 3-244, 3-246
x87 FPU タグ・ワード........ 3-246, 3-263, 3-265,
3-281
x87 FPU の最後のオペコード......... 3-246, 3-263,
3-265, 3-281
x87 FPU のステータス・ワード
TOP フィールド.................................. 3-234
条件コード・フラグ....... 3-212, 3-230, 3-292,
3-294, 3-298
セーブ........................... 3-265, 3-281, 3-284
復元................................................... 3-263
命令によって影響を受けるx87 FPU
フラグ............................................. 3-11
ロード............................................... 3-246
x87 FPU のデータ・ポインタ......... 3-246, 3-263,
3-265, 3-281
x87 FPU の命令ポインタ..... 3-246, 3-263, 3-265,
3-281
x87 FPU を初期化.................................... 3-235
XADD 命令.................................... 3-387, 3-758
XCHG 命令................................... 3-387, 3-760
XLAT/XLATB 命令.................................... 3-762
XORPD 命令........................................... 3-766
XORPS 命令........................................... 3-768
XOR 命令...................................... 3-387, 3-764
Z
ZF( ゼロ) フラグ、EFLAGS レジスタ....... 3-104,
3-106, 3-364, 3-392, 3-394, 3-654,
3-751
あ
アクセス権、セグメント記述子................. 3-364
アドバンスト・プログラム可能割り込みコント
ローラ(APIC を参照)
アドレス指定方式
オペランド・コード............................... A-3
コード.................................................. A-1
レジスタ・コード.................................. A-3
アドレス指定、セグメント........................... 1-8
アンダーフロー、FPU 例外( 数値アンダーフロー
例外を参照)
い
インデックス( オペランドのアドレス指定).... 2-3
え
エンコーディング
SIMD- 整数レジスタ・フィールド.. B-29, B-38
キャッシュ可能命令............................. B-44
キャッシュ可能/ メモリ順序付け命令.... B-30
お
オーバーフロー例外(#OF) ........................ 3-330
オーバーフロー、FPU 例外( 数値オーバーフロー
例外を参照)
オペコード
エスケープ命令.................................... A-12
マップ.................................................. A-1
オペコード拡張
説明.................................................... A-10
表....................................................... A-11
オペコード整数命令
1 バイト................................................ A-4
1 バイト・オペコード・マップ......... A-6, A-7
2 バイト................................................ A-4
2 バイト・オペコード・マップ......... A-8, A-9
オペコードのフォーマット........................... 2-3
オペコード・キーの略語.............................. A-1
オペランド、命令........................................ 1-7
か
回転操作................................................. 3-641
仮数、浮動小数点数からの抽出................. 3-310
索引-7
索引
き
機能情報、プロセッサ.................... 3-114, 3-119
機能的に同等なコンパイラ............................ 51
逆正接、x87 FPU 操作............................. 3-252
キャッシュをライトバックおよび無効化.... 3-754
キャッシュ、無効化( フラッシュ) .. 3-342, 3-754
く
組み込み関数................................................ 51
一覧...................................................... C-1
簡単な.................................................. C-3
機能的に同等なコンパイラ...................... C-1
説明....................................................... 3-8
複合.................................................... C-23
クワイエット型NaN(QNaN を参照)
け
現行特権レベル(CPL を参照)
こ
コール( プロシージャ・コールを参照)
コール・ゲート....................................... 3-360
互換性
ソフトウェア.......................................... 1-6
コンパイラ組み込み関数................................ 51
コンフォーミング・コード・セグメント... 3-359,
3-364
さ
参考文献..................................................... 1-9
し
シグナル型NaN(SNaN を参照)
指数および仮数の抽出、x87 FPU 操作....... 3-310
指数、浮動小数点数からの抽出................. 3-310
実効アドレス........................................... 3-372
実効アドレスのロード操作....................... 3-372
ジャンプ操作........................................... 3-356
順序化不可能な値...... 3-212, 3-215, 3-292, 3-294
条件コード・フラグ、EFLAGS レジスタ..... 3-79
条件コード・フラグ、x87 FPU ステータス・ワー
ド
設定............................... 3-292, 3-294, 3-298
命令によって影響を受けるフラグ........... 3-11
条件付きジャンプ.................................... 3-352
剰余、x87 FPU 操作................................ 3-257
除算エラー例外(#DE) .............................. 3-179
す
スケール( オペランドのアドレス指定) .......... 2-3
スケール、x87 FPU 操作.......................... 3-268
スタック( プロシージャ・スタックを参照)
スタック、値をプッシュ........................... 3-632
ステータス・フラグ、EFLAGS レジスタ..... 3-80,
3-83, 3-210, 3-215, 3-353, 3-679, 3-736
ストリング命令......... 3-93, 3-327, 3-389, 3-467,
3-503, 3-676, 3-715
せ
制御レジスタ、値を移動........................... 3-427
正弦、x87 FPU 操作....................... 3-270, 3-272
整数、ストア、x87 FPU データ・タイプ.... 3-237
正接、x87 FPU 操作................................. 3-260
性能モニタリング・カウンタ
読み取り............................................ 3-651
セグメント
記述子、セグメント制限...................... 3-394
制限................................................... 3-394
セレクタ、RPL フィールド.................... 3-41
レジスタ、値を移動............................ 3-422
セグメント化アドレス指定........................... 1-8
そ
即値オペランド........................................... 2-4
た
対数イプシロン、x87 FPU 操作................. 3-312
対数( 底2)、x87 FPU 操作....................... 3-314
タイム・スタンプ・カウンタ、読み取り.... 3-653
タスク状態セグメント(TSS を参照)
タスク・ゲート....................................... 3-360
タスク・スイッチ
CALL 命令............................................ 3-58
ネストされたタスクからのリターン、IRET
命令.............................................. 3-344
タスク・レジスタ
ストア............................................... 3-718
ロード............................................... 3-398
て
定数( 浮動小数点)、ロード...................... 3-242
ディスプレースメント( オペランドのアドレス
指定) ........................................... 2-4
デノーマル数( デノーマル有限数を参照)
デノーマル有限数.................................... 3-298
デバッグ・レジスタ、値を移動................. 3-429
と
特権レベル間
コール、CALL 命令............................... 3-58
リターン、RET 命令........................... 3-657
に
入出力(I/O を参照)
索引
索引-8
は
バージョン情報、プロセッサ.......... 3-114, 3-119
バイト・オーダ........................................... 1-6
汎用レジスタ
値を移動............................................ 3-422
すべてをプッシュ............................... 3-635
すべてをポップ................................... 3-578
ひ
非コンフォーミング・コード・セグメント. 3-360
ビット・オーダ........................................... 1-6
表記
16 進数および2 進数............................... 1-7
ビット・オーダおよびバイト・オーダ....... 1-6
命令オペランド....................................... 1-7
予約ビット............................................. 1-6
例外....................................................... 1-8
表記法........................................................ 1-6
ふ
浮動小数点値を分類、x87 FPU 操作.......... 3-298
浮動小数点例外
SSE/SSE2 SIMD.......................... 3-13, 3-14
x87 FPU .............................................. 3-13
フラッシュ
TLB エントリ..................................... 3-343
キャッシュ............................... 3-342, 3-754
プリフィックス
LOCK ................................................ 3-387
REP/REPE/REPZ/REPNE/REPNZ........ 3-654
分岐のヒント.......................................... 2-2
命令、説明............................................. 2-1
分岐のヒント............................................... 2-2
へ
平方根、x87 FPU 操作............................. 3-274
ベース( オペランドのアドレス指定) ............. 2-3
ベクタ( 割り込みベクタを参照)
ま
マシン・ステータス・ワード、CR0 レジスタ......
3-385, 3-699
丸め、整数への丸め、x87 FPU 操作.......... 3-262
み
未定義、フォーマット・オペコード........... 3-292
め
命令オペランド........................................... 1-7
命令セット、リファレンス........................... 3-1
命令フォーマット
ModR/M バイト...................................... 2-3
Mod フィールド...................................... 2-3
R/M フィールド...................................... 2-3
SIB バイト............................................. 2-3
インデックス・フィールド....................... 2-3
オペコード............................................. 2-3
参照情報の説明....................................... 3-1
図.......................................................... 2-1
スケール・フィールド............................. 2-3
即値....................................................... 2-4
ディスプレースメント............................. 2-4
プリフィックス....................................... 2-1
ベース・フィールド................................ 2-3
レジスタ/ オペコード・フィールド........... 2-3
命令プリフィックス( プリフィックスを参照)
命令リファレンス、名称............................... 3-1
よ
余弦、x87 FPU 操作....................... 3-218, 3-272
予約ビット.................................................. 1-6
り
略語、オペコード・キー.............................. A-1
れ
例外
BOUND 範囲外(#BR) ............................ 3-43
オーバーフロー例外(#OF) ................... 3-330
表記....................................................... 1-8
リターン............................................ 3-344
レジスタ/ オペコード・フィールド、命令
フォーマット................................ 2-3
ろ
ロック操作.............................................. 3-387
わ
割り込み
ソフトウェア...................................... 3-330
リターン............................................ 3-344
割り込みベクタ4 ................................ 3-330