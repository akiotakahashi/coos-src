using System;
using System.IO;
using System.Xml;
using System.Text;
using System.Collections;
using System.Text.RegularExpressions;
using System.Reflection;
using System.Reflection.Emit;

namespace IA32Toolkit.Assembler {

	enum CodeType {
		Literal,
		ib,			//	ib
		iw,			//	iw
		id,			//	id
		cb,			//	cb
		cw,			//	cw
		cd,			//	cd
		cp,			//	cp
		cwcd,		//	cw/cd
		r,			//	/r
		RegOp,		//	/[0-7]
	}

	enum ModifyFlag {
		None = 0,
		rb,			//	+rb
		rw,			//	+rw
		rd,			//	+rd
		i,			//	+i
	}

	class CodeByte {
		public CodeType Type;
		public byte Value;
		public ModifyFlag Flag = ModifyFlag.None;
		public CodeByte(byte value) {
			this.Value = value;
			this.Type = CodeType.Literal;
		}
		public CodeByte(string embedded) {
			if(embedded=="/r") {
				this.Value = 0;
				this.Type = CodeType.r;
			} else if(embedded[0]=='/') {
				this.Value = byte.Parse(embedded.Substring(1));
				this.Type = CodeType.RegOp;
			} else {
				this.Value = 0;
				this.Type = (CodeType)Enum.Parse(typeof(CodeType), embedded.Replace("/",""), true);
			}
		}
	}

	public class IA32Generator {

		static Regex reExpression = new Regex(Utility.OpCodeExpression+Utility.MnemonicExpression);
		static Regex reTailNum = new Regex("(?<=[^0-9])[0-9]+$");

		public IA32Generator(string filename) {
		}

		public static void GenerateAssembler(XmlDocument xdoc) {
			Console.WriteLine(
@"// This is automatically generated by CooS IA32 Utility.
using System;

namespace IA32Toolkit.Assembler {
	public class IA32Assembler : IA32AssemblerBase {
		public IA32Assembler() {
		}
		public IA32Assembler(System.IO.Stream stream) : base(stream) {
		}
");
			int passed = 0;
			/*
			AssemblyName an = new AssemblyName();
			AssemblyBuilder asmbuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(an, AssemblyBuilderAccess.Save);
			ModuleBuilder modbuilder = asmbuilder.DefineDynamicModule("IA32Assembler");
			TypeBuilder tbuilder = modbuilder.DefineType("IA32Toolkit.Assembler.IA32Assembler", TypeAttributes.Public);
			*/
			foreach(XmlElement xop in xdoc.SelectNodes("//operation")) {
				string mnemonic = xop.Attributes["mnemonic"].Value;
				mnemonic = mnemonic.Substring(0,1).ToUpper()+mnemonic.Substring(1).ToLower();
				foreach(XmlElement xin in xop.SelectNodes("instruction")) {
					ArrayList codes = new ArrayList();
					string opcode = xin.Attributes["opcode"].Value;
					foreach(string op in opcode.Split(' ')) {
						switch(op[0]) {
						case '+':
							((CodeByte)codes[codes.Count-1]).Flag = (ModifyFlag)Enum.Parse(typeof(ModifyFlag), op.Substring(1), true);
							break;
						case '/':
						case 'i':
						case 'c':
							codes.Add(new CodeByte(op));
							break;
						default:
							codes.Add(new CodeByte(Convert.ToByte(op,16)));
							break;
						}
					}
					StringBuilder headargs = new StringBuilder();
					StringBuilder tailargs = new StringBuilder();
					int bits_reg = 0;
					int bits_imm = 0;
					string operands = xin.Attributes["operands"].Value;
					string suffix = "";
					bool use_rm = false;
					bool use_rel = false;
					bool use_reg = false;
					bool use_imm = false;
					if(operands.Length>0) {
						bool skip = false;
						foreach(string _op in operands.Split(',')) {
							Match m = reTailNum.Match(_op);
							int bits = -1;
							string op;
							string priu, pris;
							if(m.Success && m.Index>0) {
								bits = int.Parse(m.Value);
								op = _op.Substring(0,m.Index);
								switch(bits) {
								case 8:
									pris = "sbyte";
									priu = "byte";
									break;
								case 16:
									pris = "short";
									priu = "ushort";
									break;
								case 32:
									pris = "int";
									priu = "int";
									break;
								case 64:
									pris = "long";
									priu = "long";
									break;
								default:
									//NOP
									pris = "Int"+bits;
									priu = "UInt"+bits;
									break;
								}
							} else {
								op = _op;
								pris = "void";
								priu = "void";
							}
							switch(op.ToLower()) {
							case "al":
							case "ah":
							case "bl":
							case "bh":
							case "cl":
							case "ch":
							case "dl":
							case "dh":
								suffix += "_"+op.ToUpper();
								bits_reg = 8;
								break;
							case "ax":
							case "bx":
							case "cx":
							case "dx":
							case "sp":
							case "bp":
							case "si":
							case "di":
								suffix += "_"+op.ToUpper();
								bits_reg = 16;
								break;
							case "eax":
							case "ecx":
							case "edx":
							case "ebx":
							case "esp":
							case "ebp":
							case "esi":
							case "edi":
							case "cr":
								suffix += "_"+_op.ToUpper();
								bits_reg = 32;
								break;
							case "cs":
							case "ds":
							case "ss":
							case "es":
							case "fs":
							case "gs":
								suffix += "_"+op.ToUpper();
								bits_reg = 16;
								break;
							case "imm":
								tailargs.Append(", "+priu+" imm");
								use_imm = true;
								bits_imm = bits;
								break;
							case "r":
								tailargs.Append(", Register"+bits+" reg");
								use_reg = true;
								bits_reg = bits;
								break;
							case "r/m":
								tailargs.Append(", RegMem"+bits+" rm");
								use_rm = true;
								bits_reg = bits;
								break;
							case "rel16/":
							case "rel":
								tailargs.Append(", "+pris+" rel");
								use_rel = true;
								bits_reg = bits;
								break;
							case "m":
								if(bits>0) {
									// rep movs m32,m32
									suffix += "_"+_op.ToLower();
								} else {
									tailargs.Append(", RegMem rm");
									use_rm = true;
									break;
								}
								break;
							case "m32fp":
								tailargs.Append(", Mem32F rm");
								use_rm = true;
								break;
							case "m64fp":
								tailargs.Append(", Mem64F rm");
								use_rm = true;
								break;
							case "m80fp":
							case "mm":
							case "mm/m":
							case "mm2/m":
							case "m16:":
							case "m16&":
							case "m32&":
							case "ptr16:":
							case "xmm":
							case "xmm/m":
							case "xmm2/m":
							case "st(0)":
							case "st(1)":
							case "st(i)":
							case "st":
							case "m16int":
							case "m32int":
							case "m64int":
							case "moffs":
							case "r32/m":
							case "sreg":
							case "dr0-dr":
								skip = true;
								continue;
							case "1":
								//NOP
								break;
							default:
								throw new NotImplementedException(_op);
							}
						}
						if(skip) {
							Console.Error.WriteLine("Skip: {0} {1} | {2}", mnemonic, operands, xin.InnerText);
							continue;
						}
					}
					string immediate = use_imm ? "imm" : (use_rel ? "rel" : null);
					StringBuilder opcoding = new StringBuilder();
					bool use_modrm = false;
					int reg = -1;
					foreach(CodeByte code in codes) {
						switch(code.Type) {
						case CodeType.Literal:
							opcoding.AppendFormat(", 0x{0:X2}", code.Value);
							switch(code.Flag) {
							case ModifyFlag.None:
								break;
							case ModifyFlag.rb:
							case ModifyFlag.rw:
							case ModifyFlag.rd:
								switch(code.Flag) {
								case ModifyFlag.rb:
									bits_reg = 8;
									break;
								case ModifyFlag.rw:
									bits_reg = 16;
									break;
								case ModifyFlag.rd:
									bits_reg = 32;
									break;
								}
								opcoding.Append("+(int)reg");
								use_reg = false;
								break;
							case ModifyFlag.i:
								Console.Error.WriteLine("Not supported: {0} {1}", mnemonic, operands);
								continue;
							default:
								throw new ApplicationException();
							}
							break;
						case CodeType.r:
							use_modrm = true;
							break;
						case CodeType.RegOp:
							use_modrm = true;
							reg = code.Value;
							break;
						case CodeType.ib:
						case CodeType.iw:
						case CodeType.id:
							switch(code.Type) {
							case CodeType.ib:
								bits_imm = 8;
								break;
							case CodeType.iw:
								bits_imm = 16;
								break;
							case CodeType.id:
								bits_imm = 32;
								break;
							}
							immediate = "imm";
							break;
						case CodeType.cb:
						case CodeType.cw:
						case CodeType.cd:
						case CodeType.cp:
							switch(code.Type) {
							case CodeType.cb:
								bits_imm = 8;
								break;
							case CodeType.cw:
								bits_imm = 16;
								break;
							case CodeType.cd:
								bits_imm = 32;
								break;
							case CodeType.cp:
								bits_imm = 48;
								break;
							}
							immediate = "rel";
							break;
						default:
							break;
						}
					}
					opcoding.Remove(0, 2);
					if(headargs.Length>0) headargs.Remove(0, 2);
					if(tailargs.Length>0) tailargs.Remove(0, 2);
					string arguments = JoinArgs(headargs, tailargs);
					//
					//
					switch(mnemonic.ToUpper()) {
					case "MOV":
						switch(operands) {
						case "r32,CR0":
						case "r32,CR2":
						case "r32,CR3":
						case "r32,CR4":
							continue;
						case "CR0":
						case "CR2":
						case "CR3":
						case "CR4":
							continue;
						}
						break;
					}
					/*
					Type[] parameters = new Type[0];
					MethodBuilder mbuilder = tbuilder.DefineMethod(xop.Attributes["mnemonic"].Value, MethodAttributes.Public, typeof(void), parameters);
					*/
					string desc = string.Format("{0}/// <summary>({1})({2}) {3}</summary>{0}", Environment.NewLine
						, xin.Attributes["opcode"].Value, xin.Attributes["operands"].Value, xin.InnerText);
					if(!use_modrm && !use_rm && !use_reg) {
						Console.Write(desc);
						WriteMethodBeginTemplate(mnemonic+suffix, arguments);
						WriteMethodBodyTemplate(opcoding.ToString());
						WriteMethodEndTemplate(immediate);
					} else {
						Console.Write(desc);
						WriteMethodBeginTemplate(mnemonic+suffix, JoinArgs(headargs, tailargs));
						WriteMethodBodyTemplate(opcoding.ToString());
						Console.WriteLine("this.WriteModifiers({0}, {1});"
							, use_rm ? "rm.Value" : "RegMem.Empty"
							, use_reg ? "(int)reg" : (reg<0 ? "0" : reg.ToString()));
						WriteMethodEndTemplate(immediate);
					}
					++passed;
				}
			}
			Console.WriteLine("}}");
			Console.Error.WriteLine("Successfully generated {0} methods.", passed);
		}

		private static string JoinArgs(params object[] args) {
			StringBuilder buf = new StringBuilder();
			foreach(object o in args) {
				string s = o.ToString();
				if(s.Length>0) {
					if(buf.Length>0) buf.Append(", ");
					buf.Append(s);
				}
			}
			return buf.ToString();
		}

		private static void WriteMethodBeginTemplate(string mnemonic, string arguments) {
			Console.WriteLine("public void {0}({1}) {{", mnemonic, arguments);
		}

		private static void WriteMethodBodyTemplate(string opcoding) {
			Console.WriteLine("this.WriteOpCode({0});", opcoding);
		}

		private static void WriteMethodEndTemplate(string immediate) {
			if(immediate!=null) {
				Console.WriteLine("this.WriteImmediate({0});", immediate);
			}
			Console.WriteLine("}");
		}

		public static void GenerateInstructionSet(TextReader reader) {
			SortedList insts = new SortedList();
			string line, prev="";
			bool opcodedesc = false;
			int failedcount = 0;
			while((line=reader.ReadLine())!=null) {
				if(line.IndexOf("オペコード命令説明")>=0) {
					opcodedesc = true;
					failedcount = 0;
				} else if(opcodedesc) {
					Match m = reExpression.Match(prev);
					if(m.Success && prev.EndsWith(",")) {
						m = reExpression.Match(prev+line);
					}
					if(m.Success) {
						if(!insts.ContainsKey(m.Groups["name"].Value)) {
							insts[m.Groups["name"].Value] = new ArrayList();
						}
						ArrayList list = (ArrayList)insts[m.Groups["name"].Value];
						list.Add(m);
						failedcount = 0;
					} else {
						++failedcount;
						if(failedcount>4) {
							opcodedesc = false;
						}
					}
				}
				prev = line;
			}
			Console.WriteLine("<?xml version=\"1.0\" encoding=\"{0}\" ?>", Console.Out.Encoding.WebName);
			Console.WriteLine("<instructionset>");
			int c = 0;
			foreach(DictionaryEntry e in insts) {
				Console.WriteLine("\t<operation mnemonic=\"{0}\">", ((string)e.Key).Replace(" ","_"));
				foreach(Match m in (ArrayList)e.Value) {
					string opcode = m.Groups["fmt"].Value.Trim();
					opcode = opcode.Replace("+ ","+").Replace("+"," +");
					Console.WriteLine("\t\t<instruction opcode=\"{0}\" operands=\"{1}\">{2}</instruction>"
						, opcode.Replace("&","&amp;")
						, m.Groups["operands"].Value.Replace(" ","").Replace("*","").Replace("&","&amp;")
						, m.Groups["desc"].Value.Trim().Replace("&","&amp;").Replace("<","&lt;").Replace(">","&gt;"));
					c++;
				}
				Console.WriteLine("\t</operation>");
			}
			Console.WriteLine("</instructionset>");
			Console.Error.WriteLine("{0} instructions, {1} formats were parsed successfully.", insts.Count, c);
		}

	}

}
