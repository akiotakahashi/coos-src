using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections.Generic;

static class CliUtil {

	class Table {
		public string Name;
		public int Value;
		public StringBuilder Contents = new StringBuilder();
		public Field[] Fields;
	}

	class Field {
		public string Name;
		public string Type;
		public string Desc;
		public int Size = 0;
	}

	static void Main(string[] args) {
		if(args.Length!=2) { return; }
		Table[] tables;
		using(TextReader reader = new StreamReader(args[0], true)) {
			tables = BuildTables(reader);
		}
		using(TextWriter writer = new StreamWriter(@"CLI\Metadata\TableId.cs")) {
				writer.WriteLine(@"/* This file is automatically generated by cliutil.exe */
using System;

namespace CooS.Formats.CLI.Metadata {

	public enum TableId {");
			int maxtableid = 0;
			foreach(Table table in tables) {
				maxtableid = Math.Max(maxtableid, table.Value);
				writer.WriteLine(@"		{0} = 0x{1:X2},", table.Name, table.Value);
			}
			writer.WriteLine(@"		INVALID = -1,
		MAXVALUE = {0},
	}}

}}", maxtableid);
		}
		foreach(Table table in tables) {
			Console.WriteLine("{0} (0x{1:X2})", table.Name, table.Value);
			BuildFields(table);
			BuildEachField(table);
			using(TextWriter writer = new StreamWriter(@"CLI\Metadata\Rows\"+table.Name+"Row.cs")) {
				writer.WriteLine(@"/* This file is automatically generated by cliutil.exe */
using System;
using CooS.Formats.CLI.Metadata.Heaps;
using CooS.Formats.CLI.Metadata.Indexes;

namespace CooS.Formats.CLI.Metadata.Rows {{

	public struct {0}Row : IRow {{

		public const TableId TableId = CooS.Formats.CLI.Metadata.TableId.{0};

		public int Index;", table.Name);
				foreach(Field field in table.Fields) {
					if(string.IsNullOrEmpty(field.Type)) { continue; }
					Console.WriteLine("   {0} ({1})", field.Name, field.Type);
					writer.WriteLine(@"		public {0} {1};", field.Type, field.Name);
				}
				writer.WriteLine(@"
		public int RowIndex {{
			get {{
				return this.Index;
			}}
			set {{
				this.Index = value;
			}}
		}}

	}}

	public struct {1} : IRowIndex {{

		public readonly int Value;

		int IRowIndex.RawIndex {{
			get {{
				return this.Value;
			}}
		}}

		internal {1}(int value) {{
			this.Value = value;
		}}

		public static explicit operator {1}(RowIndex rowIndex) {{
			return new {1}(rowIndex.Value);
		}}

		public static implicit operator RowIndex({1} rowIndex) {{
			return new RowIndex(rowIndex.Value);
		}}

	}}", table.Name+"Row", table.Name+"RowIndex");
				writer.WriteLine(@"
	internal class {1} : RowFactory<{0}> {{

		public {1}(TablesHeap heap) : base(heap) {{
		}}

		public override TableId TableId {{ get {{ return {0}.TableId; }} }}

		public override int GetPhysicalSize() {{
			return 0", table.Name+"Row", table.Name+"RowFactory");
				foreach(Field field in table.Fields) {
					if(string.IsNullOrEmpty(field.Type)) { continue; }
					writer.Write("\t\t\t\t");
					if(!field.Type.EndsWith("Index")) {
						if(field.Size<=0) { throw new ApplicationException(field.Type); }
						writer.WriteLine("+ {0}", field.Size);
					} else {
						if(field.Type.EndsWith("RowIndex")) {
							writer.WriteLine("+ Heap.GetPhysicalSizeOfIndex({0}.TableId)", field.Type.Substring(0, field.Type.Length-5));
						} else if(field.Type.EndsWith("CodedIndex")) {
							writer.WriteLine("+ Heap.GetPhysicalSizeOfIndex(CodedIndexes.{0})", field.Type.Substring(0, field.Type.Length-10));
						} else if(field.Type.EndsWith("HeapIndex")) {
							writer.WriteLine("+ Heap.GetPhysicalSizeOfIndex(HeapIndexes.{0})", field.Type.Substring(0, field.Type.Length-9));
						} else {
							throw new ApplicationException(field.Type);
						}
					}
				}
				writer.WriteLine(@"				;
		}}

		public override {0} Parse(byte[] buf, ref int position) {{
			{0} value;
			value.Index = 0;", table.Name+"Row");
				foreach(Field field in table.Fields) {
					if(string.IsNullOrEmpty(field.Type)) { continue; }
					writer.Write("\t\t\t");
					switch(field.Type) {
					case "Byte":
					case "UInt16":
					case "UInt32":
					case "UInt64":
						writer.WriteLine("value.{0} = Heap.Read{1}(buf, ref position);", field.Name, field.Type);
						break;
					default:
						if(field.Type.EndsWith("Attributes") || field.Type.EndsWith("Flags")) {
							writer.WriteLine("value.{0} = ({1})Heap.ReadEnum{2}(buf, ref position);", field.Name, field.Type, field.Size*8);
						} else if(field.Type.EndsWith("RowIndex")) {
							writer.WriteLine("value.{0} = ({1}RowIndex)Heap.ReadRowIndex({1}Row.TableId, buf, ref position);", field.Name, field.Type.Substring(0, field.Type.Length-8));
						} else if(field.Type.EndsWith("CodedIndex")) {
							writer.WriteLine("value.{0} = ({1}CodedIndex)Heap.ReadCodedIndex(CodedIndexes.{1}, buf, ref position);", field.Name, field.Type.Substring(0, field.Type.Length-10));
						} else if(field.Type.EndsWith("HeapIndex")) {
							writer.WriteLine("value.{0} = Heap.Read{1}(buf, ref position);", field.Name, field.Type);
						} else {
							throw new ApplicationException(field.Type);
						}
						break;
					}
				}
				writer.WriteLine(@"			return value;
		}

	}

}");
			}
		}
		Dictionary<string,List<string>> codedindexes = new Dictionary<string,List<string>>();
		using(TextReader reader = new StreamReader(args[1], true)) {
			List<string> curlist = null;
			string line;
			while(!string.IsNullOrEmpty(line=reader.ReadLine())) {
				if(line.StartsWith(":")) {
					codedindexes.Add(line.Substring(1), curlist = new List<string>());
				} else {
					string[] parts = line.Split(' ');
					if(parts.Length==2) {
						while(curlist.Count<=int.Parse(parts[1])) {
							curlist.Add(null);
						}
						curlist[int.Parse(parts[1])] = parts[0];
					}
				}
			}
		}
		foreach(string codedindex in codedindexes.Keys) {
			using(TextWriter writer = new StreamWriter(@"CLI\Metadata\Indexes\"+codedindex+"CodedIndex.cs")) {
				writer.Write(@"using System;
using CooS.Formats.CLI.Metadata.Heaps;

namespace CooS.Formats.CLI.Metadata.Indexes {{

	public struct {0}CodedIndex {{

		public static TableId[] Mapping = new TableId[] {{
", codedindex);
				foreach(string reftbl in codedindexes[codedindex]) {
					writer.WriteLine(@"			TableId.{0},", reftbl==null ? "INVALID" : reftbl);
				}
				writer.Write(@"		}};

		public const int TagBits = {1};
		public const uint TagMask = (1<<TagBits)-1;

		private readonly int Value;

		internal {0}CodedIndex(int value) {{
			this.Value = value;
		}}

		public TableId TableId {{
			get {{
				return Mapping[this.Value&TagMask];
			}}
		}}

		public RowIndex RowIndex {{
			get {{
				return new RowIndex(this.Value >> TagBits);
			}}
		}}

		public static int GetPhysicalSize(TablesHeap heap) {{
			return heap.GetCodedIndexPhysicalSize(", codedindex, (int)Math.Ceiling(Math.Log(codedindexes[codedindex].Count, 2)));
				bool first = true;
				foreach(string reftbl in codedindexes[codedindex]) {
					if(reftbl==null) { continue; }
					if(first) {
						first = false;
					} else {
						writer.Write(", ");
					}
					writer.Write(@"TableId.{0}", reftbl);
				}
				writer.WriteLine(@");
		}}

		public static explicit operator {0}CodedIndex(CodedIndex codedIndex) {{
			return new {0}CodedIndex(codedIndex.Value);
		}}

	}}

}}", codedindex);
			}
		}
	}

	static Regex reTable = new Regex(@"^22\.\d+ (?<name>\w+) : 0x(?<value>[0-9a-fA-F]+)+$");

	static Table[] BuildTables(TextReader reader) {
		List<Table> tables = new List<Table>();
		Table table = null;
		string line;
		while(!string.IsNullOrEmpty(line=reader.ReadLine())) {
			Match m = reTable.Match(line);
			if(m.Success) {
				table = new Table();
				table.Name = m.Groups["name"].Value;
				table.Value = Convert.ToInt32(m.Groups["value"].Value, 16);
				tables.Add(table);
			} else {
				table.Contents.Append(line);
				table.Contents.Append(" ");
			}
		}
		return tables.ToArray();
	}

	static Regex reField = new Regex(@"• (?<name>\w+(, \w+)*) \(");

	static bool IsSymmetric(string s) {
		return s.Replace("(","").Length == s.Replace(")","").Length;
	}

	static void BuildFields(Table table) {
		List<Field> fields = new List<Field>();
		foreach(Match m in reField.Matches(table.Contents.ToString())) {
			Field field = new Field();
			field.Name = m.Groups["name"].Value;
			field.Desc = "(";
			int p = m.Index+m.Length;
			while(!IsSymmetric(field.Desc)) {
				field.Desc += table.Contents[p++];
			}
			fields.Add(field);
		}
		for(int i=fields.Count-1; i>=0; --i) {
			Field field = fields[i];
			string[] names = field.Name.Split(',');
			if(names.Length>0) {
				Array.Reverse(names);
				foreach(string name in names) {
					Field f = new Field();
					f.Name = name.Trim();
					f.Desc = field.Desc;
					fields.Insert(i+1, f);
				}
				fields.RemoveAt(i);
			}
		}
		table.Fields = fields.ToArray();
	}

	static Regex reSectionRefer = new Regex(@"\s+\(§\d+(\.\d+)*\)");

	static void BuildEachField(Table table) {
		foreach(Field field in table.Fields) {
			int i = field.Desc.LastIndexOf(')');
			if(i<0) { throw new ApplicationException(field.Desc); }
			field.Desc = field.Desc.Substring(0, i).Trim('(', ')');
			field.Type = DetectType(field, reSectionRefer.Replace(field.Desc,""));
		}
	}

	static Regex reIgnorePrefix = new Regex(@"^(a|an|each being)\b", RegexOptions.IgnoreCase);
	static Regex re1 = new Regex(@"^(?<size>\d)-byte (constant|value)", RegexOptions.IgnoreCase);
	static Regex re2 = new Regex(@"^(?<size>\d)-byte bitmask of type (?<enum>\w+)", RegexOptions.IgnoreCase);
	static Regex re3 = new Regex(@"^(non-null )?index into the (?<heap>Blob|String|Guid) heap", RegexOptions.IgnoreCase);
	static Regex re4 = new Regex(@"^((?<size>\d)-byte )?index into( the| a)? (?<table>\w+) table", RegexOptions.IgnoreCase);
	static Regex re5 = new Regex(@"; more precisely, a (?<name>\w+) coded index", RegexOptions.IgnoreCase);
	static Regex re6 = new Regex(@"^the (?<size>\d)-byte index of the generic parameter", RegexOptions.IgnoreCase);

	static int ParseSize(Match m) {
		if(m.Groups["size"].Success) {
			return int.Parse(m.Groups["size"].Value);
		} else {
			return -1;
		}
	}

	static string DetectType(Field field, string desc) {
		desc = reIgnorePrefix.Replace(desc, "").TrimStart();
		if(re1.IsMatch(desc)) {
			Match m = re1.Match(desc);
			field.Size = ParseSize(m);
			switch(field.Size) {
			case 1:
				return "Byte";
			case 2:
				return "UInt16";
			case 4:
				return "UInt32";
			case 8:
				return "UInt64";
			default:
				throw new ApplicationException("Unrecognized description: "+desc);
			}
		} else if(re2.IsMatch(desc)) {
			Match m = re2.Match(desc);
			field.Size = ParseSize(m);
			return m.Groups["enum"].Value;
		} else if(re3.IsMatch(desc)) {
			Match m = re3.Match(desc);
			field.Size = ParseSize(m);
			return m.Groups["heap"].Value+"HeapIndex";
		} else if(re4.IsMatch(desc)) {
			Match m = re4.Match(desc);
			field.Size = ParseSize(m);
			return m.Groups["table"].Value+"RowIndex";
		} else if(re5.IsMatch(desc)) {
			Match m = re5.Match(desc);
			field.Size = ParseSize(m);
			return m.Groups["name"].Value+"CodedIndex";
		} else if(re6.IsMatch(desc)) {
			Match m = re6.Match(desc);
			field.Size = ParseSize(m);
			switch(int.Parse(m.Groups["size"].Value)) {
			case 1:
				return "Byte";
			case 2:
				return "UInt16";
			case 4:
				return "UInt32";
			case 8:
				return "UInt64";
			default:
				throw new ApplicationException("Unrecognized description: "+desc);
			}
		} else {
			return null;
		}
	}

}
