// This is automatically generated by CooS IA32 Utility.
using System;

namespace IA32Toolkit.Assembler {
	public class IA32Assembler : IA32AssemblerBase {
		public IA32Assembler() {
		}
		public IA32Assembler(System.IO.Stream stream) : base(stream) {
		}


/// <summary>(37)() 加算後にAL をASCII 調整する。</summary>
public void Aaa() {
this.WriteOpCode(0x37);
}

/// <summary>(D5 0A)() 除算前にAX をASCII 調整する。</summary>
public void Aad() {
this.WriteOpCode(0xD5, 0x0A);
}

/// <summary>(D4 0A)() 乗算後にAX をASCII 調整する。</summary>
public void Aam() {
this.WriteOpCode(0xD4, 0x0A);
}

/// <summary>(3F)() 減算後にAL をASCII 調整する。</summary>
public void Aas() {
this.WriteOpCode(0x3F);
}

/// <summary>(14 ib)(AL,imm8) キャリーを加えてimm8 をAL に加算する。</summary>
public void Adc_AL(byte imm) {
this.WriteOpCode(0x14);
this.WriteImmediate(imm);
}

/// <summary>(15 iw)(AX,imm16) キャリーを加えてimm16 をAX に加算する。</summary>
public void Adc_AX(ushort imm) {
this.WriteOpCode(0x15);
this.WriteImmediate(imm);
}

/// <summary>(15 id)(EAX,imm32) キャリーを加えてimm32 をEAX に加算する。</summary>
public void Adc_EAX(int imm) {
this.WriteOpCode(0x15);
this.WriteImmediate(imm);
}

/// <summary>(80 /2 ib)(r/m8,imm8) キャリーを加えてimm8 をr/m8 に加算する。</summary>
public void Adc(RegMem8 rm, byte imm) {
this.WriteOpCode(0x80);
this.WriteModifiers(rm.Value, 2);
this.WriteImmediate(imm);
}

/// <summary>(81 /2 iw)(r/m16,imm16) キャリーを加えてimm16 をr/m16 に加算する。</summary>
public void Adc(RegMem16 rm, ushort imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 2);
this.WriteImmediate(imm);
}

/// <summary>(81 /2 id)(r/m32,imm32) CF を加えてimm32 をr/m32 に加算する。</summary>
public void Adc(RegMem32 rm, int imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 2);
this.WriteImmediate(imm);
}

/// <summary>(83 /2 ib)(r/m16,imm8) CF を加えて符号拡張imm8 をr/m16 に加算する。</summary>
public void Adc(RegMem16 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 2);
this.WriteImmediate(imm);
}

/// <summary>(83 /2 ib)(r/m32,imm8) CF を加えて符号拡張imm8 をr/m32 に加算する。</summary>
public void Adc(RegMem32 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 2);
this.WriteImmediate(imm);
}

/// <summary>(10 /r)(r/m8,r8) キャリーを加えてバイト・レジスタをr/m8 に加算する。</summary>
public void Adc(RegMem8 rm, Register8 reg) {
this.WriteOpCode(0x10);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(11 /r)(r/m16,r16) キャリーを加えてr16 をr/m16 に加算する。</summary>
public void Adc(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x11);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(11 /r)(r/m32,r32) CF を加えてr32 をr/m32 に加算する。</summary>
public void Adc(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x11);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(12 /r)(r8,r/m8) キャリーを加えてr/m8 をバイト・レジスタに加算する。</summary>
public void Adc(Register8 reg, RegMem8 rm) {
this.WriteOpCode(0x12);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(13 /r)(r16,r/m16) キャリーを加えてr/m16 をr16 に加算する。</summary>
public void Adc(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x13);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(13 /r)(r32,r/m32) CF を加えてr/m32 をr32 に加算する。</summary>
public void Adc(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x13);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(04 ib)(AL,imm8) imm8 をAL に加算する。</summary>
public void Add_AL(byte imm) {
this.WriteOpCode(0x04);
this.WriteImmediate(imm);
}

/// <summary>(05 iw)(AX,imm16) imm16 をAX に加算する。</summary>
public void Add_AX(ushort imm) {
this.WriteOpCode(0x05);
this.WriteImmediate(imm);
}

/// <summary>(05 id)(EAX,imm32) imm32 をEAX に加算する。</summary>
public void Add_EAX(int imm) {
this.WriteOpCode(0x05);
this.WriteImmediate(imm);
}

/// <summary>(80 /0 ib)(r/m8,imm8) imm8 をr/m8 に加算する。</summary>
public void Add(RegMem8 rm, byte imm) {
this.WriteOpCode(0x80);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(81 /0 iw)(r/m16,imm16) imm16 をr/m16 に加算する。</summary>
public void Add(RegMem16 rm, ushort imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(81 /0 id)(r/m32,imm32) imm32 をr/m32 に加算する。</summary>
public void Add(RegMem32 rm, int imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(83 /0 ib)(r/m16,imm8) 符号拡張imm8 をrm16 に加算する。</summary>
public void Add(RegMem16 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(83 /0 ib)(r/m32,imm8) 符号拡張imm8 をrm32 に加算する。</summary>
public void Add(RegMem32 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(00 /r)(r/m8,r8) r8 をr/m8 に加算する。</summary>
public void Add(RegMem8 rm, Register8 reg) {
this.WriteOpCode(0x00);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(01 /r)(r/m16,r16) r16 をr/m16 に加算する。</summary>
public void Add(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x01);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(01 /r)(r/m32,r32) r32 をr/m32 に加算する。</summary>
public void Add(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x01);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(02 /r)(r8,r/m8) r/m8 をr8 に加算する。</summary>
public void Add(Register8 reg, RegMem8 rm) {
this.WriteOpCode(0x02);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(03 /r)(r16,r/m16) r/m16 をr16 に加算する。</summary>
public void Add(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x03);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(03 /r)(r32,r/m32) r/m32 をr32 に加算する。</summary>
public void Add(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x03);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(24 ib)(AL,imm8) AL とimm8 とのAND をとる。</summary>
public void And_AL(byte imm) {
this.WriteOpCode(0x24);
this.WriteImmediate(imm);
}

/// <summary>(25 iw)(AX,imm16) AX とimm16 とのAND をとる。</summary>
public void And_AX(ushort imm) {
this.WriteOpCode(0x25);
this.WriteImmediate(imm);
}

/// <summary>(25 id)(EAX,imm32) EAX とimm32 とのAND をとる。</summary>
public void And_EAX(int imm) {
this.WriteOpCode(0x25);
this.WriteImmediate(imm);
}

/// <summary>(80 /4 ib)(r/m8,imm8) r/m8 とimm8 とのAND をとる。</summary>
public void And(RegMem8 rm, byte imm) {
this.WriteOpCode(0x80);
this.WriteModifiers(rm.Value, 4);
this.WriteImmediate(imm);
}

/// <summary>(81 /4 iw)(r/m16,imm16) r/m16 とimm16 とのAND をとる。</summary>
public void And(RegMem16 rm, ushort imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 4);
this.WriteImmediate(imm);
}

/// <summary>(81 /4 id)(r/m32,imm32) r/m32 とimm32 とのAND をとる。</summary>
public void And(RegMem32 rm, int imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 4);
this.WriteImmediate(imm);
}

/// <summary>(83 /4 ib)(r/m16,imm8) r/m16 とimm8 ( 符号拡張) とのAND をとる。</summary>
public void And(RegMem16 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 4);
this.WriteImmediate(imm);
}

/// <summary>(83 /4 ib)(r/m32,imm8) r/m32 とimm8 ( 符号拡張) とのAND をとる。</summary>
public void And(RegMem32 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 4);
this.WriteImmediate(imm);
}

/// <summary>(20 /r)(r/m8,r8) r/m8 とr8 とのAND をとる。</summary>
public void And(RegMem8 rm, Register8 reg) {
this.WriteOpCode(0x20);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(21 /r)(r/m16,r16) r/m16 とr16 とのAND をとる。</summary>
public void And(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x21);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(21 /r)(r/m32,r32) r/m32 とr32 とのAND をとる。</summary>
public void And(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x21);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(22 /r)(r8,r/m8) r8 とr/m8 とのAND をとる。</summary>
public void And(Register8 reg, RegMem8 rm) {
this.WriteOpCode(0x22);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(23 /r)(r16,r/m16) r16 とr/m16 とのAND をとる。</summary>
public void And(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x23);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(23 /r)(r32,r/m32) r32 とr/m32 とのAND をとる。</summary>
public void And(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x23);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(63 /r)(r/m16,r16) r/m16 のRPL をr16 のRPL 未満に調整する。</summary>
public void Arpl(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x63);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F BC)(r16,r/m16) r/m16 を順方向にビット・スキャンする。</summary>
public void Bsf(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0xBC);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F BC)(r32,r/m32) r/m32 を順方向にビット・スキャンする。</summary>
public void Bsf(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0xBC);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F BD)(r16,r/m16) r/m16 を逆方向にビット・スキャンする。</summary>
public void Bsr(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0xBD);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F BD)(r32,r/m32) r/m32 を逆方向にビット・スキャンする。</summary>
public void Bsr(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0xBD);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F C8 +rd)(r32) 32 ビット・レジスタのバイト順序を逆にする。</summary>
public void Bswap(Register32 reg) {
this.WriteOpCode(0x0F, 0xC8+(int)reg);
}

/// <summary>(0F A3)(r/m16,r16) 選択したビットをCF フラグにストアする。</summary>
public void Bt(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x0F, 0xA3);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F A3)(r/m32,r32) 選択したビットをCF フラグにストアする。</summary>
public void Bt(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x0F, 0xA3);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F BA /4 ib)(r/m16,imm8) 選択したビットをCF フラグにストアする。</summary>
public void Bt(RegMem16 rm, byte imm) {
this.WriteOpCode(0x0F, 0xBA);
this.WriteModifiers(rm.Value, 4);
this.WriteImmediate(imm);
}

/// <summary>(0F BA /4 ib)(r/m32,imm8) 選択したビットをCF フラグにストアする。</summary>
public void Bt(RegMem32 rm, byte imm) {
this.WriteOpCode(0x0F, 0xBA);
this.WriteModifiers(rm.Value, 4);
this.WriteImmediate(imm);
}

/// <summary>(0F BB)(r/m16,r16) 選択したビットをCF フラグにストアし、補数をとる。</summary>
public void Btc(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x0F, 0xBB);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F BB)(r/m32,r32) 選択したビットをCF フラグにストアし、補数をとる。</summary>
public void Btc(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x0F, 0xBB);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F BA /7 ib)(r/m16,imm8) 選択したビットをCF フラグにストアし、補数をとる。</summary>
public void Btc(RegMem16 rm, byte imm) {
this.WriteOpCode(0x0F, 0xBA);
this.WriteModifiers(rm.Value, 7);
this.WriteImmediate(imm);
}

/// <summary>(0F BA /7 ib)(r/m32,imm8) 選択したビットをCF フラグにストアし、補数をとる。</summary>
public void Btc(RegMem32 rm, byte imm) {
this.WriteOpCode(0x0F, 0xBA);
this.WriteModifiers(rm.Value, 7);
this.WriteImmediate(imm);
}

/// <summary>(0F B3)(r/m16,r16) 選択したビットをCF フラグにストアし、クリアする。</summary>
public void Btr(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x0F, 0xB3);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F B3)(r/m32,r32) 選択したビットをCF フラグにストアし、クリアする。</summary>
public void Btr(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x0F, 0xB3);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F BA /6 ib)(r/m16,imm8) 選択したビットをCF フラグにストアし、クリアする。</summary>
public void Btr(RegMem16 rm, byte imm) {
this.WriteOpCode(0x0F, 0xBA);
this.WriteModifiers(rm.Value, 6);
this.WriteImmediate(imm);
}

/// <summary>(0F BA /6 ib)(r/m32,imm8) 選択したビットをCF フラグにストアし、クリアする。</summary>
public void Btr(RegMem32 rm, byte imm) {
this.WriteOpCode(0x0F, 0xBA);
this.WriteModifiers(rm.Value, 6);
this.WriteImmediate(imm);
}

/// <summary>(0F AB)(r/m16,r16) 選択したビットをCF フラグにストアし、セットする。</summary>
public void Bts(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x0F, 0xAB);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F AB)(r/m32,r32) 選択したビットをCF フラグにストアし、セットする。</summary>
public void Bts(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x0F, 0xAB);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F BA /5 ib)(r/m16,imm8) 選択したビットをCF フラグにストアし、セットする。</summary>
public void Bts(RegMem16 rm, byte imm) {
this.WriteOpCode(0x0F, 0xBA);
this.WriteModifiers(rm.Value, 5);
this.WriteImmediate(imm);
}

/// <summary>(0F BA /5 ib)(r/m32,imm8) 選択したビットをCF フラグにストアし、セットする。</summary>
public void Bts(RegMem32 rm, byte imm) {
this.WriteOpCode(0x0F, 0xBA);
this.WriteModifiers(rm.Value, 5);
this.WriteImmediate(imm);
}

/// <summary>(0F)() /1 m64 CMPXCHG8B m64 EDX:EAX をm64 と比較し、等しい場合はZF をセットし、</summary>
public void C7() {
this.WriteOpCode(0x0F);
}

/// <summary>(E8 cw)(rel16) 相対near コール、次の命令とディスプレースメント相対。</summary>
public void Call(short rel) {
this.WriteOpCode(0xE8);
this.WriteImmediate(rel);
}

/// <summary>(E8 cd)(rel32) 相対near コール、次の命令とディスプレースメント相対。</summary>
public void Call(int rel) {
this.WriteOpCode(0xE8);
this.WriteImmediate(rel);
}

/// <summary>(FF /2)(r/m16) 絶対間接near コール、r/m16 でアドレスを指定。</summary>
public void Call(RegMem16 rm) {
this.WriteOpCode(0xFF);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(FF /2)(r/m32) 絶対間接near コール、r/m32 でアドレスを指定。</summary>
public void Call(RegMem32 rm) {
this.WriteOpCode(0xFF);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(98)(AX) ← AL の符号拡張</summary>
public void Cbw_AX() {
this.WriteOpCode(0x98);
}

/// <summary>(99)() EDX:EAX ← EAX の符号拡張</summary>
public void Cdq() {
this.WriteOpCode(0x99);
}

/// <summary>(F8)() CF フラグをクリアする。</summary>
public void Clc() {
this.WriteOpCode(0xF8);
}

/// <summary>(FC)() DF フラグをクリアする。</summary>
public void Cld() {
this.WriteOpCode(0xFC);
}

/// <summary>(0F AE /7)(m8) m8 が入っているキャッシュ・ラインをフラッシュする。</summary>
public void Clflush_m8() {
this.WriteOpCode(0x0F, 0xAE);
this.WriteModifiers(RegMem.Empty, 7);
}

/// <summary>(FA)() 割り込みフラグをクリアする。割り込みフラグがクリアさ</summary>
public void Cli() {
this.WriteOpCode(0xFA);
}

/// <summary>(0F 06)(CR0) のTS フラグをクリアする。</summary>
public void Clts_CR0() {
this.WriteOpCode(0x0F, 0x06);
}

/// <summary>(F5)() CF フラグの状態を反転する。</summary>
public void Cmc() {
this.WriteOpCode(0xF5);
}

/// <summary>(0F 47 /r)(r16,r/m16) より上 (CF=0 およびZF=0) の場合転送する。</summary>
public void Cmova(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x47);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 47 /r)(r32,r/m32) より上 (CF=0 およびZF=0) の場合転送する。</summary>
public void Cmova(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x47);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 43 /r)(r16,r/m16) より上か等しい (CF=0) 場合転送する。</summary>
public void Cmovae(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x43);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 43 /r)(r32,r/m32) より上か等しい (CF=0) 場合転送する。</summary>
public void Cmovae(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x43);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 42 /r)(r16,r/m16) より下 (CF=1) の場合転送する。</summary>
public void Cmovb(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x42);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 42 /r)(r32,r/m32) より下 (CF=1) の場合転送する。</summary>
public void Cmovb(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x42);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 46 /r)(r16,r/m16) より下か等しい (CF=1 またはZF=1) 場合転送する。</summary>
public void Cmovbe(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x46);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 46 /r)(r32,r/m32) より下か等しい (CF=1 またはZF=1) 場合転送する。</summary>
public void Cmovbe(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x46);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 42 /r)(r16,r/m16) キャリーがある (CF=1) 場合転送する。</summary>
public void Cmovc(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x42);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 42 /r)(r32,r/m32) キャリーがある (CF=1) 場合転送する。</summary>
public void Cmovc(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x42);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 44 /r)(r16,r/m16) 等しい (ZF=1) 場合転送する。</summary>
public void Cmove(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x44);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 44 /r)(r32,r/m32) 等しい (ZF=1) 場合転送する。</summary>
public void Cmove(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x44);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4F /r)(r16,r/m16) より大きい (ZF=0 およびSF=OF) 場合転送する。</summary>
public void Cmovg(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x4F);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4F /r)(r32,r/m32) より大きい (ZF=0 およびSF=OF) 場合転送する。</summary>
public void Cmovg(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x4F);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4D /r)(r16,r/m16) より大きいか等しい (SF=OF) 場合転送する。</summary>
public void Cmovge(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x4D);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4D /r)(r32,r/m32) より大きいか等しい (SF=OF) 場合転送する。</summary>
public void Cmovge(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x4D);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4C /r)(r16,r/m16) より小さい (SF<>OF) 場合転送する。</summary>
public void Cmovl(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x4C);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4C /r)(r32,r/m32) より小さい (SF<>OF) 場合転送する。</summary>
public void Cmovl(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x4C);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4E /r)(r16,r/m16) より小さいか等しい (ZF=1 またはSF<>OF) 場合転送する。</summary>
public void Cmovle(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x4E);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4E /r)(r32,r/m32) より小さいか等しい (ZF=1 またはSF<>OF) 場合転送する。</summary>
public void Cmovle(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x4E);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 46 /r)(r16,r/m16) より上でない (CF=1 またはZF=1) 場合転送する。</summary>
public void Cmovna(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x46);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 46 /r)(r32,r/m32) より上でない (CF=1 またはZF=1) 場合転送する。</summary>
public void Cmovna(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x46);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 42 /r)(r16,r/m16) より上でなく等しくない (CF=1) 場合転送する。</summary>
public void Cmovnae(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x42);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 42 /r)(r32,r/m32) より上でなく等しくない (CF=1) 場合転送する。</summary>
public void Cmovnae(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x42);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 43 /r)(r16,r/m16) より下でない (CF=0) 場合転送する。</summary>
public void Cmovnb(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x43);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 43 /r)(r32,r/m32) より下でない (CF=0) 場合転送する。</summary>
public void Cmovnb(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x43);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 47 /r)(r16,r/m16) より下でなく等しくない (CF=0 およびZF=0) 場合転送する。</summary>
public void Cmovnbe(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x47);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 47 /r)(r32,r/m32) より下でなく等しくない (CF=0 およびZF=0) 場合転送する。</summary>
public void Cmovnbe(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x47);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 43 /r)(r16,r/m16) キャリーがない (CF=0) 場合転送する。</summary>
public void Cmovnc(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x43);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 43 /r)(r32,r/m32) キャリーがない (CF=0) 場合転送する。</summary>
public void Cmovnc(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x43);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 45 /r)(r16,r/m16) 等しくない (ZF=0) 場合転送する。</summary>
public void Cmovne(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x45);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 45 /r)(r32,r/m32) 等しくない (ZF=0) 場合転送する。</summary>
public void Cmovne(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x45);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4E /r)(r16,r/m16) より大きくない (ZF=1 またはSF<>OF) 場合転送する。</summary>
public void Cmovng(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x4E);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4E /r)(r32,r/m32) より大きくない (ZF=1 またはSF<>OF) 場合転送する。</summary>
public void Cmovng(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x4E);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4C /r)(r16,r/m16) より大きくなく等しくない (SF<>OF) 場合転送する。</summary>
public void Cmovnge(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x4C);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4C /r)(r32,r/m32) より大きくなく等しくない (SF<>OF) 場合転送する。</summary>
public void Cmovnge(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x4C);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4D /r)(r16,r/m16) より小さくない (SF=OF) 場合転送する。</summary>
public void Cmovnl(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x4D);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4D /r)(r32,r/m32) より小さくない (SF=OF) 場合転送する。</summary>
public void Cmovnl(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x4D);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4F /r)(r16,r/m16) より小さくなく等しくない (ZF=0 およびSF=OF) 場合転送する。</summary>
public void Cmovnle(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x4F);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4F /r)(r32,r/m32) より小さくなく等しくない (ZF=0 およびSF=OF) 場合転送する。</summary>
public void Cmovnle(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x4F);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 41 /r)(r16,r/m16) オーバフローがない (OF=0) 場合転送する。</summary>
public void Cmovno(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x41);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 41 /r)(r32,r/m32) オーバフローがない (OF=0) 場合転送する。</summary>
public void Cmovno(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x41);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4B /r)(r16,r/m16) パリティがない (PF=0) 場合転送する。</summary>
public void Cmovnp(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x4B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4B /r)(r32,r/m32) パリティがない (PF=0) 場合転送する。</summary>
public void Cmovnp(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x4B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 49 /r)(r16,r/m16) 符号がない (SF=0) 場合転送する。</summary>
public void Cmovns(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x49);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 49 /r)(r32,r/m32) 符号がない (SF=0) 場合転送する。</summary>
public void Cmovns(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x49);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 45 /r)(r16,r/m16) ゼロでない (ZF=0) 場合転送する。</summary>
public void Cmovnz(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x45);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 45 /r)(r32,r/m32) ゼロでない (ZF=0) 場合転送する。</summary>
public void Cmovnz(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x45);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 40 /r)(r16,r/m16) オーバフローがある (OF=0) 場合転送する。</summary>
public void Cmovo(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x40);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 40 /r)(r32,r/m32) オーバフローがある (OF=0 場合転送する。</summary>
public void Cmovo(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x40);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4A /r)(r16,r/m16) パリティがある (PF=1) 場合転送する。</summary>
public void Cmovp(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x4A);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4A /r)(r32,r/m32) パリティがある (PF=1) 場合転送する。</summary>
public void Cmovp(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x4A);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4A /r)(r16,r/m16) パリティが偶数 (PF=1) の場合転送する。</summary>
public void Cmovpe(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x4A);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4A /r)(r32,r/m32) パリティが偶数 (PF=1) の場合転送する。</summary>
public void Cmovpe(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x4A);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4B /r)(r16,r/m16) パリティが奇数 (PF=0) の場合転送する。</summary>
public void Cmovpo(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x4B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 4B /r)(r32,r/m32) パリティが奇数 (PF=0) の場合転送する。</summary>
public void Cmovpo(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x4B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 48 /r)(r16,r/m16) 符号がある (SF=1) 場合転送する。</summary>
public void Cmovs(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x48);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 48 /r)(r32,r/m32) 符号がある (SF=1) 場合転送する。</summary>
public void Cmovs(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x48);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 44 /r)(r16,r/m16) ゼロ (ZF=1) の場合転送する。</summary>
public void Cmovz(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x44);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 44 /r)(r32,r/m32) ゼロ (ZF=1) の場合転送する。</summary>
public void Cmovz(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x44);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(3C ib)(AL,imm8) imm8 をAL と比較する。</summary>
public void Cmp_AL(byte imm) {
this.WriteOpCode(0x3C);
this.WriteImmediate(imm);
}

/// <summary>(3D iw)(AX,imm16) imm16 をAX と比較する。</summary>
public void Cmp_AX(ushort imm) {
this.WriteOpCode(0x3D);
this.WriteImmediate(imm);
}

/// <summary>(3D id)(EAX,imm32) imm32 をEAX と比較する。</summary>
public void Cmp_EAX(int imm) {
this.WriteOpCode(0x3D);
this.WriteImmediate(imm);
}

/// <summary>(80 /7 ib)(r/m8,imm8) imm8 をr/m8 と比較する。</summary>
public void Cmp(RegMem8 rm, byte imm) {
this.WriteOpCode(0x80);
this.WriteModifiers(rm.Value, 7);
this.WriteImmediate(imm);
}

/// <summary>(81 /7 iw)(r/m16,imm16) imm16 をr/m16 と比較する。</summary>
public void Cmp(RegMem16 rm, ushort imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 7);
this.WriteImmediate(imm);
}

/// <summary>(81 /7 id)(r/m32,imm32) imm32 をr/m32 と比較する。</summary>
public void Cmp(RegMem32 rm, int imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 7);
this.WriteImmediate(imm);
}

/// <summary>(83 /7 ib)(r/m16,imm8) imm8 をr/m16 と比較する。</summary>
public void Cmp(RegMem16 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 7);
this.WriteImmediate(imm);
}

/// <summary>(83 /7 ib)(r/m32,imm8) imm8 をr/m32 と比較する。</summary>
public void Cmp(RegMem32 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 7);
this.WriteImmediate(imm);
}

/// <summary>(38 /r)(r/m8,r8) r8 をr/m8 と比較する。</summary>
public void Cmp(RegMem8 rm, Register8 reg) {
this.WriteOpCode(0x38);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(39 /r)(r/m16,r16) r16 をr/m16 と比較する。</summary>
public void Cmp(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x39);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(39 /r)(r/m32,r32) r32 をr/m32 と比較する。</summary>
public void Cmp(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x39);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(3A /r)(r8,r/m8) r/m8 をr8 と比較する。</summary>
public void Cmp(Register8 reg, RegMem8 rm) {
this.WriteOpCode(0x3A);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(3B /r)(r16,r/m16) r/m16 をr16 と比較する。</summary>
public void Cmp(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x3B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(3B /r)(r32,r/m32) r/m32 をr32 と比較する。</summary>
public void Cmp(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x3B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(A6)(m8,m8) アドレスDS:(E)SI のバイトをアドレスES:(E)DI のバイト</summary>
public void Cmps_m8_m8() {
this.WriteOpCode(0xA6);
}

/// <summary>(A7)(m16,m16) アドレスDS:(E)SI のワードをアドレスES:(E)DI のワード</summary>
public void Cmps_m16_m16() {
this.WriteOpCode(0xA7);
}

/// <summary>(A7)(m32,m32) アドレスDS:(E)SI のダブルワードをアドレスES:(E)DI の</summary>
public void Cmps_m32_m32() {
this.WriteOpCode(0xA7);
}

/// <summary>(A6)() アドレスDS:(E)SI のバイトをアドレスES:(E)DI のバイト</summary>
public void Cmpsb() {
this.WriteOpCode(0xA6);
}

/// <summary>(A7)() アドレスDS:(E)SI のダブルワードをアドレスES:(E)DI の</summary>
public void Cmpsd() {
this.WriteOpCode(0xA7);
}

/// <summary>(A7)() アドレスDS:(E)SI のワードをアドレスES:(E)DI のワード</summary>
public void Cmpsw() {
this.WriteOpCode(0xA7);
}

/// <summary>(0F A2)(EAX) レジスタに最初に入力された値に応じて、プロセッサ</summary>
public void Cpuid_EAX() {
this.WriteOpCode(0x0F, 0xA2);
}

/// <summary>(99)() DX:AX ← AX の符号拡張</summary>
public void Cwd() {
this.WriteOpCode(0x99);
}

/// <summary>(98)(EAX) ← AX の符号拡張</summary>
public void Cwde_EAX() {
this.WriteOpCode(0x98);
}

/// <summary>(27)() 加算後にAL を10 進調整する。</summary>
public void Daa() {
this.WriteOpCode(0x27);
}

/// <summary>(2F)() 減算後にAL を10 進調整する。</summary>
public void Das() {
this.WriteOpCode(0x2F);
}

/// <summary>(FE /1)(r/m8) r/m8 を1 デクリメントする。</summary>
public void Dec(RegMem8 rm) {
this.WriteOpCode(0xFE);
this.WriteModifiers(rm.Value, 1);
}

/// <summary>(FF /1)(r/m16) r/m16 を1 デクリメントする。</summary>
public void Dec(RegMem16 rm) {
this.WriteOpCode(0xFF);
this.WriteModifiers(rm.Value, 1);
}

/// <summary>(FF /1)(r/m32) r/m32 を1 デクリメントする。</summary>
public void Dec(RegMem32 rm) {
this.WriteOpCode(0xFF);
this.WriteModifiers(rm.Value, 1);
}

/// <summary>(48 +rw)(r16) r16 を1 デクリメントする。</summary>
public void Dec(Register16 reg) {
this.WriteOpCode(0x48+(int)reg);
}

/// <summary>(48 +rd)(r32) r32 を1 デクリメントする。</summary>
public void Dec(Register32 reg) {
this.WriteOpCode(0x48+(int)reg);
}

/// <summary>(F6 /6)(r/m8) AX をr/m8 で符号なし除算する。結果は次のようにストア</summary>
public void Div(RegMem8 rm) {
this.WriteOpCode(0xF6);
this.WriteModifiers(rm.Value, 6);
}

/// <summary>(F7 /6)(r/m16) DX:AX をr/m16 で符号なし除算する。結果は次のようにス</summary>
public void Div(RegMem16 rm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 6);
}

/// <summary>(F7 /6)(r/m32) EDX:EAX をr/m32 で符号なし除算する。結果は次のよう</summary>
public void Div(RegMem32 rm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 6);
}

/// <summary>(DB)() FNCLEX* 未処理のマスクされていない浮動小数点例外の有無を</summary>
public void E2() {
this.WriteOpCode(0xDB);
}

/// <summary>(DB)() FNINIT* 未処理のマスクされていない浮動小数点例外の有無を</summary>
public void E3() {
this.WriteOpCode(0xDB);
}

/// <summary>(0F 77)() x87 FP タグ・ワードを空に設定する。</summary>
public void Emms() {
this.WriteOpCode(0x0F, 0x77);
}

/// <summary>(C8 iw ib)(imm16,imm8) プロシージャのネストされたスタック・フレームを作成す</summary>
public void Enter(ushort imm, byte imm2) {
this.WriteOpCode(0xC8);
this.WriteImmediate(imm);
this.WriteImmediate(imm2);
}

/// <summary>(D8 /0)(m32fp) m32fp をST(0) に加え、結果をST(0) にストアする。</summary>
public void Fadd(Mem32F rm) {
this.WriteOpCode(0xD8);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(DC /0)(m64fp) m64fp をST(0) に加え、結果をST(0) にストアする。</summary>
public void Fadd(Mem64F rm) {
this.WriteOpCode(0xDC);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(DF /4)() m80 dec BCD 値を浮動小数点に変換し、FPU スタックにプッシュ</summary>
public void Fbld() {
this.WriteOpCode(0xDF);
this.WriteModifiers(RegMem.Empty, 4);
}

/// <summary>(DF /6)() m80bcd ST(0) をm80bcd にストアし、ST(0) をポップする。</summary>
public void Fbstp() {
this.WriteOpCode(0xDF);
this.WriteModifiers(RegMem.Empty, 6);
}

/// <summary>(9B DB E2)() 未処理のマスクされていない浮動小数点例外の有無を</summary>
public void Fclex() {
this.WriteOpCode(0x9B, 0xDB, 0xE2);
}

/// <summary>(D8 /2)(m32fp) ST(0) をm32fp と比較する。</summary>
public void Fcom(Mem32F rm) {
this.WriteOpCode(0xD8);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(DC /2)(m64fp) ST(0) をm64fp と比較する。</summary>
public void Fcom(Mem64F rm) {
this.WriteOpCode(0xDC);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(D8 /3)(m32fp) ST(0) をm32fp と比較し、レジスタ・スタックをポップする。</summary>
public void Fcomp(Mem32F rm) {
this.WriteOpCode(0xD8);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(DC /3)(m64fp) ST(0) をm64fp と比較し、レジスタ・スタックをポップする。</summary>
public void Fcomp(Mem64F rm) {
this.WriteOpCode(0xDC);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(D9 F6)() FPU ステータス・ワードのTOP フィールドをデクリメン</summary>
public void Fdecstp() {
this.WriteOpCode(0xD9, 0xF6);
}

/// <summary>(D8 /6)(m32fp) ST(0) をm32fp で割り、結果をST(0) にストアする。</summary>
public void Fdiv(Mem32F rm) {
this.WriteOpCode(0xD8);
this.WriteModifiers(rm.Value, 6);
}

/// <summary>(DC /6)(m64fp) ST(0) をm64fp で割り、結果をST(0) にストアする。</summary>
public void Fdiv(Mem64F rm) {
this.WriteOpCode(0xDC);
this.WriteModifiers(rm.Value, 6);
}

/// <summary>(D8 /7)(m32fp) m32fp をST(0) で割り、結果をST(0) にストアする。</summary>
public void Fdivr(Mem32F rm) {
this.WriteOpCode(0xD8);
this.WriteModifiers(rm.Value, 7);
}

/// <summary>(DC /7)(m64fp) m64fp をST(0) で割り、結果をST(0) にストアする。</summary>
public void Fdivr(Mem64F rm) {
this.WriteOpCode(0xDC);
this.WriteModifiers(rm.Value, 7);
}

/// <summary>(D9 F7)() FPU ステータス・レジスタのTOP フィールドをインクリ</summary>
public void Fincstp() {
this.WriteOpCode(0xD9, 0xF7);
}

/// <summary>(9B DB E3)() 未処理のマスクされていない浮動小数点例外の有無を</summary>
public void Finit() {
this.WriteOpCode(0x9B, 0xDB, 0xE3);
}

/// <summary>(D9 /0)(m32fp) m32fp をFPU レジスタ・スタックにプッシュする。</summary>
public void Fld(Mem32F rm) {
this.WriteOpCode(0xD9);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(DD /0)(m64fp) m64fp をFPU レジスタ・スタックにプッシュする。</summary>
public void Fld(Mem64F rm) {
this.WriteOpCode(0xDD);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(D9 E8)() +1.0 をFPU レジスタ・スタックにプッシュする。</summary>
public void Fld1() {
this.WriteOpCode(0xD9, 0xE8);
}

/// <summary>(D9 /5)() m2byte m2byte からFPU 制御ワードをロードする。</summary>
public void Fldcw() {
this.WriteOpCode(0xD9);
this.WriteModifiers(RegMem.Empty, 5);
}

/// <summary>(D9 /4)() m14/28byte m14byte またはm28byte からFPU 環境をロードする。</summary>
public void Fldenv() {
this.WriteOpCode(0xD9);
this.WriteModifiers(RegMem.Empty, 4);
}

/// <summary>(D9 EA)() log2e をFPU レジスタ・スタックにプッシュする。</summary>
public void Fldl2e() {
this.WriteOpCode(0xD9, 0xEA);
}

/// <summary>(D9 E9)() log210 をFPU レジスタ・スタックにプッシュする。</summary>
public void Fldl2t() {
this.WriteOpCode(0xD9, 0xE9);
}

/// <summary>(D9 EC)() log102 をFPU レジスタ・スタックにプッシュする。</summary>
public void Fldlg2() {
this.WriteOpCode(0xD9, 0xEC);
}

/// <summary>(D9 ED)() loge2 をFPU レジスタ・スタックにプッシュする。</summary>
public void Fldln2() {
this.WriteOpCode(0xD9, 0xED);
}

/// <summary>(D9 EB)() π をFPU レジスタ・スタックにプッシュする。</summary>
public void Fldpi() {
this.WriteOpCode(0xD9, 0xEB);
}

/// <summary>(D9 EE)() +0.0 をFPU レジスタ・スタックにプッシュする。</summary>
public void Fldz() {
this.WriteOpCode(0xD9, 0xEE);
}

/// <summary>(D8 /1)(m32fp) ST(0) にm32fp を掛け、結果をST(0) にストアする。</summary>
public void Fmul(Mem32F rm) {
this.WriteOpCode(0xD8);
this.WriteModifiers(rm.Value, 1);
}

/// <summary>(DC /1)(m64fp) ST(0) にm64fp を掛け、結果をST(0) にストアする。</summary>
public void Fmul(Mem64F rm) {
this.WriteOpCode(0xDC);
this.WriteModifiers(rm.Value, 1);
}

/// <summary>(D9 D0)() 何の操作も実行されない。</summary>
public void Fnop() {
this.WriteOpCode(0xD9, 0xD0);
}

/// <summary>(DD /4)() m94/108byte m94byte またはm108byte からFPU 状態をロードする。</summary>
public void Frstor() {
this.WriteOpCode(0xDD);
this.WriteModifiers(RegMem.Empty, 4);
}

/// <summary>(9B DD /6)() m94/108byte 未処理のマスクされていない浮動小数点例外の有無を</summary>
public void Fsave() {
this.WriteOpCode(0x9B, 0xDD);
this.WriteModifiers(RegMem.Empty, 6);
}

/// <summary>(D9 /2)(m32fp) ST(0) をm32fp にコピーする。</summary>
public void Fst(Mem32F rm) {
this.WriteOpCode(0xD9);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(DD /2)(m64fp) ST(0) をm64fp にコピーする。</summary>
public void Fst(Mem64F rm) {
this.WriteOpCode(0xDD);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(9B D9 /7)() m2byte 未処理のマスクされていない浮動小数点定例外の有無をチェック</summary>
public void Fstcw() {
this.WriteOpCode(0x9B, 0xD9);
this.WriteModifiers(RegMem.Empty, 7);
}

/// <summary>(9B D9 /6)() m14/28byte 未処理のマスクされていない浮動小数点例外の有無を</summary>
public void Fstenv() {
this.WriteOpCode(0x9B, 0xD9);
this.WriteModifiers(RegMem.Empty, 6);
}

/// <summary>(D9 /3)(m32fp) ST(0) をm32fp にコピーし、レジスタ・スタックをポップする。</summary>
public void Fstp(Mem32F rm) {
this.WriteOpCode(0xD9);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(DD /3)(m64fp) ST(0) をm64fp にコピーし、レジスタ・スタックをポップする。</summary>
public void Fstp(Mem64F rm) {
this.WriteOpCode(0xDD);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(9B DD /7)() m2byte 未処理のマスクされていない浮動小数点例外の有無を</summary>
public void Fstsw() {
this.WriteOpCode(0x9B, 0xDD);
this.WriteModifiers(RegMem.Empty, 7);
}

/// <summary>(9B DF E0)(AX) 未処理のマスクされていない浮動小数点例外の有無を</summary>
public void Fstsw_AX() {
this.WriteOpCode(0x9B, 0xDF, 0xE0);
}

/// <summary>(D8 /4)(m32fp) ST(0) からm32fp を引き、結果をST(0) にストアする。</summary>
public void Fsub(Mem32F rm) {
this.WriteOpCode(0xD8);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(DC /4)(m64fp) ST(0) からm64fp を引き、結果をST(0) にストアする。</summary>
public void Fsub(Mem64F rm) {
this.WriteOpCode(0xDC);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(D8 /5)(m32fp) m32fp からST(0) を引き、結果をST(0) にストアする。</summary>
public void Fsubr(Mem32F rm) {
this.WriteOpCode(0xD8);
this.WriteModifiers(rm.Value, 5);
}

/// <summary>(DC /5)(m64fp) m64fp からST(0) を引き、結果をST(0) にストアする。</summary>
public void Fsubr(Mem64F rm) {
this.WriteOpCode(0xDC);
this.WriteModifiers(rm.Value, 5);
}

/// <summary>(9B)() 未処理のマスクされていない浮動小数点例外をチェックする。</summary>
public void Fwait() {
this.WriteOpCode(0x9B);
}

/// <summary>(0F AE /1)() m512byte x87 FPU レジスタ状態、MMX テクノロジ・レジスタ状態、</summary>
public void Fxrstor() {
this.WriteOpCode(0x0F, 0xAE);
this.WriteModifiers(RegMem.Empty, 1);
}

/// <summary>(0F AE /0)() m512byte x87 FPU レジスタ状態、MMX テクノロジ・レジスタ状態、XMM レ</summary>
public void Fxsave() {
this.WriteOpCode(0x0F, 0xAE);
this.WriteModifiers(RegMem.Empty, 0);
}

/// <summary>(F4)() Halt</summary>
public void Hlt() {
this.WriteOpCode(0xF4);
}

/// <summary>(F6 /7)(r/m8) AX をr/m8 で符号付き除算する。結果は次のようにストアされ</summary>
public void Idiv(RegMem8 rm) {
this.WriteOpCode(0xF6);
this.WriteModifiers(rm.Value, 7);
}

/// <summary>(F7 /7)(r/m16) DX:AX をr/m16 で符号付き除算する。結果は次のようにストアさ</summary>
public void Idiv(RegMem16 rm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 7);
}

/// <summary>(F7 /7)(r/m32) EDX:EAX をr/m32 で符号付き除算する。結果は次のようにスト</summary>
public void Idiv(RegMem32 rm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 7);
}

/// <summary>(F6 /5)(r/m8) AX← AL? r/m バイト</summary>
public void Imul(RegMem8 rm) {
this.WriteOpCode(0xF6);
this.WriteModifiers(rm.Value, 5);
}

/// <summary>(F7 /5)(r/m16) DX:AX ← AX ? r/m ワード</summary>
public void Imul(RegMem16 rm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 5);
}

/// <summary>(F7 /5)(r/m32) EDX:EAX ← EAX ? r/m ダブルワード</summary>
public void Imul(RegMem32 rm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 5);
}

/// <summary>(0F AF /r)(r16,r/m16) ワード・レジスタ ← ワード・レジスタ ?r/m ワード</summary>
public void Imul(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0xAF);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F AF /r)(r32,r/m32) ダブルワード・レジスタ ← ダブルワード・レジスタ ? r/m ダ</summary>
public void Imul(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0xAF);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(6B /r ib)(r16,r/m16,imm8) ワード・レジスタ ← r/m16 ? 符号拡張即値バイト</summary>
public void Imul(Register16 reg, RegMem16 rm, byte imm) {
this.WriteOpCode(0x6B);
this.WriteModifiers(rm.Value, (int)reg);
this.WriteImmediate(imm);
}

/// <summary>(6B /r ib)(r32,r/m32,imm8) ダブルワード・レジスタ ← r/m32 ? 符号拡張即値バイト</summary>
public void Imul(Register32 reg, RegMem32 rm, byte imm) {
this.WriteOpCode(0x6B);
this.WriteModifiers(rm.Value, (int)reg);
this.WriteImmediate(imm);
}

/// <summary>(6B /r ib)(r16,imm8) ワード・レジスタ ← ワード・レジスタ ? 符号拡張即値バイト</summary>
public void Imul(Register16 reg, byte imm) {
this.WriteOpCode(0x6B);
this.WriteModifiers(RegMem.Empty, (int)reg);
this.WriteImmediate(imm);
}

/// <summary>(6B /r ib)(r32,imm8) ダブルワード・レジスタ ← ダブルワード・レジスタ ? 符号拡</summary>
public void Imul(Register32 reg, byte imm) {
this.WriteOpCode(0x6B);
this.WriteModifiers(RegMem.Empty, (int)reg);
this.WriteImmediate(imm);
}

/// <summary>(69 /r iw)(r16,r/m16,imm16) ワード・レジスタ ← r/m16 ? 即値ワード</summary>
public void Imul(Register16 reg, RegMem16 rm, ushort imm) {
this.WriteOpCode(0x69);
this.WriteModifiers(rm.Value, (int)reg);
this.WriteImmediate(imm);
}

/// <summary>(69 /r id)(r32,r/m32,imm32) ダブルワード・レジスタ ← r/m32 ? 即値ダブルワード</summary>
public void Imul(Register32 reg, RegMem32 rm, int imm) {
this.WriteOpCode(0x69);
this.WriteModifiers(rm.Value, (int)reg);
this.WriteImmediate(imm);
}

/// <summary>(69 /r iw)(r16,imm16) ワード・レジスタ ← r/m16 ? 即値ワード</summary>
public void Imul(Register16 reg, ushort imm) {
this.WriteOpCode(0x69);
this.WriteModifiers(RegMem.Empty, (int)reg);
this.WriteImmediate(imm);
}

/// <summary>(69 /r id)(r32,imm32) ダブルワード・レジスタ ← r/m32 ? 即値ダブルワード</summary>
public void Imul(Register32 reg, int imm) {
this.WriteOpCode(0x69);
this.WriteModifiers(RegMem.Empty, (int)reg);
this.WriteImmediate(imm);
}

/// <summary>(E4 ib)(AL,imm8) I/O ポート・アドレスimm8 からAL にバイトを入力する。</summary>
public void In_AL(byte imm) {
this.WriteOpCode(0xE4);
this.WriteImmediate(imm);
}

/// <summary>(E5 ib)(AX,imm8) I/O ポート・アドレスimm8 からAX にバイトを入力する。</summary>
public void In_AX(byte imm) {
this.WriteOpCode(0xE5);
this.WriteImmediate(imm);
}

/// <summary>(E5 ib)(EAX,imm8) I/O ポート・アドレスimm8 からEAX にバイトを入力する。</summary>
public void In_EAX(byte imm) {
this.WriteOpCode(0xE5);
this.WriteImmediate(imm);
}

/// <summary>(EC)(AL,DX) DX 内のI/O ポートからAL にバイトを入力する。</summary>
public void In_AL_DX() {
this.WriteOpCode(0xEC);
}

/// <summary>(ED)(AX,DX) DX 内のI/O ポートからAX にワードを入力する。</summary>
public void In_AX_DX() {
this.WriteOpCode(0xED);
}

/// <summary>(ED)(EAX,DX) DX 内のI/O ポートからEAX にダブルワードを入力する。</summary>
public void In_EAX_DX() {
this.WriteOpCode(0xED);
}

/// <summary>(FE /0)(r/m8) r/m バイトを1 インクリメントする。</summary>
public void Inc(RegMem8 rm) {
this.WriteOpCode(0xFE);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(FF /0)(r/m16) r/m ワードを1 インクリメントする。</summary>
public void Inc(RegMem16 rm) {
this.WriteOpCode(0xFF);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(FF /0)(r/m32) r/m ダブルワードを1 インクリメントする。</summary>
public void Inc(RegMem32 rm) {
this.WriteOpCode(0xFF);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(40 +rw)(r16) ワード・レジスタを1 インクリメントする。</summary>
public void Inc(Register16 reg) {
this.WriteOpCode(0x40+(int)reg);
}

/// <summary>(40 +rd)(r32) ダブルワード・レジスタを1 インクリメントする。</summary>
public void Inc(Register32 reg) {
this.WriteOpCode(0x40+(int)reg);
}

/// <summary>(6C)(m8,DX) バイトをDX で指定された I/O ポートからES:(E)DI で指定</summary>
public void Ins_m8_DX() {
this.WriteOpCode(0x6C);
}

/// <summary>(6D)(m16,DX) ワードをDX で指定された I/O ポートからES:(E)DI で指定</summary>
public void Ins_m16_DX() {
this.WriteOpCode(0x6D);
}

/// <summary>(6D)(m32,DX) ダブルワードをDX で指定された I/O ポートからES:(E)DI</summary>
public void Ins_m32_DX() {
this.WriteOpCode(0x6D);
}

/// <summary>(6C)() バイトをDX で指定された I/O ポートからES:(E)DI で指定</summary>
public void Insb() {
this.WriteOpCode(0x6C);
}

/// <summary>(6D)() ダブルワードをDX で指定された I/O ポートからES:(E)DI</summary>
public void Insd() {
this.WriteOpCode(0x6D);
}

/// <summary>(6D)() ワードをDX で指定された I/O ポートからES:(E)DI で指定</summary>
public void Insw() {
this.WriteOpCode(0x6D);
}

/// <summary>(CC)() 3 割り込み3 - デバッガへのトラップ。</summary>
public void Int() {
this.WriteOpCode(0xCC);
}

/// <summary>(CD ib)(imm8) 割り込みベクタ番号の即値バイトによる指定。</summary>
public void Int(byte imm) {
this.WriteOpCode(0xCD);
this.WriteImmediate(imm);
}

/// <summary>(CE)() 割り込み4 - オーバフロー・フラグが1 である場合。</summary>
public void Into() {
this.WriteOpCode(0xCE);
}

/// <summary>(0F 08)() 内部キャッシュをフラッシュする。外部キャッシュのフ</summary>
public void Invd() {
this.WriteOpCode(0x0F, 0x08);
}

/// <summary>(CF)() 割り込みリターン ( オペランド・サイズ: 16 ビット)。</summary>
public void Iret() {
this.WriteOpCode(0xCF);
}

/// <summary>(CF)() 割り込みリターン ( オペランド・サイズ: 32 ビット)。</summary>
public void Iretd() {
this.WriteOpCode(0xCF);
}

/// <summary>(77 cb)(rel8) より上 (CF=0 およびZF=0) の場合short ジャンプする。</summary>
public void Ja(sbyte rel) {
this.WriteOpCode(0x77);
this.WriteImmediate(rel);
}

/// <summary>(0F 87 cw/cd)(rel16/32) より上 (CF=0 およびZF=0) の場合near ジャンプ。</summary>
public void Ja(int rel) {
this.WriteOpCode(0x0F, 0x87);
this.WriteImmediate(rel);
}

/// <summary>(73 cb)(rel8) より上か等しい (CF=0) 場合short ジャンプする。</summary>
public void Jae(sbyte rel) {
this.WriteOpCode(0x73);
this.WriteImmediate(rel);
}

/// <summary>(0F 83 cw/cd)(rel16/32) より上か等しい (CF=0) 場合near ジャンプする。</summary>
public void Jae(int rel) {
this.WriteOpCode(0x0F, 0x83);
this.WriteImmediate(rel);
}

/// <summary>(72 cb)(rel8) より下 (CF=1) の場合short ジャンプする。</summary>
public void Jb(sbyte rel) {
this.WriteOpCode(0x72);
this.WriteImmediate(rel);
}

/// <summary>(0F 82 cw/cd)(rel16/32) より下 (CF=1) の場合near ジャンプする。</summary>
public void Jb(int rel) {
this.WriteOpCode(0x0F, 0x82);
this.WriteImmediate(rel);
}

/// <summary>(76 cb)(rel8) より下か等しい (CF=1 またはZF=1) 場合short ジャンプする。</summary>
public void Jbe(sbyte rel) {
this.WriteOpCode(0x76);
this.WriteImmediate(rel);
}

/// <summary>(0F 86 cw/cd)(rel16/32) より下か等しい (CF=1 またはZF=1) 場合near ジャンプする。</summary>
public void Jbe(int rel) {
this.WriteOpCode(0x0F, 0x86);
this.WriteImmediate(rel);
}

/// <summary>(72 cb)(rel8) キャリーがある (CF=1) 場合short ジャンプする。</summary>
public void Jc(sbyte rel) {
this.WriteOpCode(0x72);
this.WriteImmediate(rel);
}

/// <summary>(0F 82 cw/cd)(rel16/32) キャリーがある (CF=1) 場合near ジャンプする。</summary>
public void Jc(int rel) {
this.WriteOpCode(0x0F, 0x82);
this.WriteImmediate(rel);
}

/// <summary>(E3 cb)(rel8) CX レジスタが0 の場合short ジャンプする。</summary>
public void Jcxz(sbyte rel) {
this.WriteOpCode(0xE3);
this.WriteImmediate(rel);
}

/// <summary>(74 cb)(rel8) 等しい (ZF=1) 場合short ジャンプする。</summary>
public void Je(sbyte rel) {
this.WriteOpCode(0x74);
this.WriteImmediate(rel);
}

/// <summary>(0F 84 cw/cd)(rel16/32) 等しい (ZF=1) 場合near ジャンプする。</summary>
public void Je(int rel) {
this.WriteOpCode(0x0F, 0x84);
this.WriteImmediate(rel);
}

/// <summary>(E3 cb)(rel8) ECX レジスタが0 の場合short ジャンプする。</summary>
public void Jecxz(sbyte rel) {
this.WriteOpCode(0xE3);
this.WriteImmediate(rel);
}

/// <summary>(7F cb)(rel8) より大きい (ZF=0 およびSF=OF) 場合short ジャンプする。</summary>
public void Jg(sbyte rel) {
this.WriteOpCode(0x7F);
this.WriteImmediate(rel);
}

/// <summary>(0F 8F cw/cd)(rel16/32) より大きい (ZF=0 およびSF=OF) 場合near ジャンプする。</summary>
public void Jg(int rel) {
this.WriteOpCode(0x0F, 0x8F);
this.WriteImmediate(rel);
}

/// <summary>(7D cb)(rel8) より大きいか等しい (SF=OF) 場合short ジャンプする。</summary>
public void Jge(sbyte rel) {
this.WriteOpCode(0x7D);
this.WriteImmediate(rel);
}

/// <summary>(0F 8D cw/cd)(rel16/32) より大きいか等しい (SF=OF) 場合near ジャンプする。</summary>
public void Jge(int rel) {
this.WriteOpCode(0x0F, 0x8D);
this.WriteImmediate(rel);
}

/// <summary>(7C cb)(rel8) より小さい (SF<>OF) 場合short ジャンプする。</summary>
public void Jl(sbyte rel) {
this.WriteOpCode(0x7C);
this.WriteImmediate(rel);
}

/// <summary>(0F 8C cw/cd)(rel16/32) より小さい (SF<>OF) 場合near ジャンプする。</summary>
public void Jl(int rel) {
this.WriteOpCode(0x0F, 0x8C);
this.WriteImmediate(rel);
}

/// <summary>(7E cb)(rel8) より小さいか等しい (ZF=1 またはSF<>OF) 場合short ジャンプする。</summary>
public void Jle(sbyte rel) {
this.WriteOpCode(0x7E);
this.WriteImmediate(rel);
}

/// <summary>(0F 8E cw/cd)(rel16/32) より小さいか等しい (ZF=1 またはSF<>OF) 場合near ジャンプする。</summary>
public void Jle(int rel) {
this.WriteOpCode(0x0F, 0x8E);
this.WriteImmediate(rel);
}

/// <summary>(EB cb)(rel8) 次の命令との相対分量分だけ相対short ジャンプする。</summary>
public void Jmp(sbyte rel) {
this.WriteOpCode(0xEB);
this.WriteImmediate(rel);
}

/// <summary>(E9 cw)(rel16) 次の命令との相対分量分だけ相対near ジャンプする。</summary>
public void Jmp(short rel) {
this.WriteOpCode(0xE9);
this.WriteImmediate(rel);
}

/// <summary>(E9 cd)(rel32) 次の命令との相対分量分だけ相対near ジャンプする。</summary>
public void Jmp(int rel) {
this.WriteOpCode(0xE9);
this.WriteImmediate(rel);
}

/// <summary>(FF /4)(r/m16) r/m16 で指定されるアドレスに絶対間接near ジャンプする。</summary>
public void Jmp(RegMem16 rm) {
this.WriteOpCode(0xFF);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(FF /4)(r/m32) r/m32 で指定されるアドレスに絶対間接near ジャンプする。</summary>
public void Jmp(RegMem32 rm) {
this.WriteOpCode(0xFF);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(76 cb)(rel8) より上でない (CF=1 またはZF=1) 場合short ジャンプする。</summary>
public void Jna(sbyte rel) {
this.WriteOpCode(0x76);
this.WriteImmediate(rel);
}

/// <summary>(0F 86 cw/cd)(rel16/32) より上でない (CF=1 またはZF=1) 場合near ジャンプする。</summary>
public void Jna(int rel) {
this.WriteOpCode(0x0F, 0x86);
this.WriteImmediate(rel);
}

/// <summary>(72 cb)(rel8) より上でなく等しくない (CF=1) 場合short ジャンプする。</summary>
public void Jnae(sbyte rel) {
this.WriteOpCode(0x72);
this.WriteImmediate(rel);
}

/// <summary>(0F 82 cw/cd)(rel16/32) より上でなく等しくない (CF=1) 場合near ジャンプする。</summary>
public void Jnae(int rel) {
this.WriteOpCode(0x0F, 0x82);
this.WriteImmediate(rel);
}

/// <summary>(73 cb)(rel8) より下でない (CF=0) 場合short ジャンプする。</summary>
public void Jnb(sbyte rel) {
this.WriteOpCode(0x73);
this.WriteImmediate(rel);
}

/// <summary>(0F 83 cw/cd)(rel16/32) より下でない (CF=0) 場合near ジャンプする。</summary>
public void Jnb(int rel) {
this.WriteOpCode(0x0F, 0x83);
this.WriteImmediate(rel);
}

/// <summary>(77 cb)(rel8) より下でなく等しくない(CF=0 およびZF=0) 場合short ジャンプする。</summary>
public void Jnbe(sbyte rel) {
this.WriteOpCode(0x77);
this.WriteImmediate(rel);
}

/// <summary>(0F 87 cw/cd)(rel16/32) より下でなく等しくない (CF=0 およびZF=0) 場合near ジャンプする。</summary>
public void Jnbe(int rel) {
this.WriteOpCode(0x0F, 0x87);
this.WriteImmediate(rel);
}

/// <summary>(73 cb)(rel8) キャリーがない (CF=0) 場合short ジャンプする。</summary>
public void Jnc(sbyte rel) {
this.WriteOpCode(0x73);
this.WriteImmediate(rel);
}

/// <summary>(0F 83 cw/cd)(rel16/32) キャリーがない (CF=0) 場合near ジャンプする。</summary>
public void Jnc(int rel) {
this.WriteOpCode(0x0F, 0x83);
this.WriteImmediate(rel);
}

/// <summary>(75 cb)(rel8) 等しくない (ZF=0) 場合short ジャンプする。</summary>
public void Jne(sbyte rel) {
this.WriteOpCode(0x75);
this.WriteImmediate(rel);
}

/// <summary>(0F 85 cw/cd)(rel16/32) 等しくない (ZF=0) 場合near ジャンプする。</summary>
public void Jne(int rel) {
this.WriteOpCode(0x0F, 0x85);
this.WriteImmediate(rel);
}

/// <summary>(7E cb)(rel8) より大きくない (ZF=1 またはSF<>OF) 場合short ジャンプする。</summary>
public void Jng(sbyte rel) {
this.WriteOpCode(0x7E);
this.WriteImmediate(rel);
}

/// <summary>(0F 8E cw/cd)(rel16/32) より大きくない (ZF=1 またはSF<>OF) 場合near ジャンプする。</summary>
public void Jng(int rel) {
this.WriteOpCode(0x0F, 0x8E);
this.WriteImmediate(rel);
}

/// <summary>(7C cb)(rel8) より大きくなく等しくない (SF<>OF) 場合short ジャンプする。</summary>
public void Jnge(sbyte rel) {
this.WriteOpCode(0x7C);
this.WriteImmediate(rel);
}

/// <summary>(0F 8C cw/cd)(rel16/32) より大きくなく等しくない (SF<>OF) 場合near ジャンプする。</summary>
public void Jnge(int rel) {
this.WriteOpCode(0x0F, 0x8C);
this.WriteImmediate(rel);
}

/// <summary>(7D cb)(rel8) より小さくない (SF=OF) 場合short ジャンプする。</summary>
public void Jnl(sbyte rel) {
this.WriteOpCode(0x7D);
this.WriteImmediate(rel);
}

/// <summary>(0F 8D cw/cd)(rel16/32) より小さくない (SF=OF) 場合near ジャンプする。</summary>
public void Jnl(int rel) {
this.WriteOpCode(0x0F, 0x8D);
this.WriteImmediate(rel);
}

/// <summary>(7F cb)(rel8) より小さくなく等しくない (ZF=0 およびSF=OF) 場合short ジャンプす</summary>
public void Jnle(sbyte rel) {
this.WriteOpCode(0x7F);
this.WriteImmediate(rel);
}

/// <summary>(0F 8F cw/cd)(rel16/32) より小さくなく等しくない (ZF=0 およびSF=OF) 場合near ジャンプする。</summary>
public void Jnle(int rel) {
this.WriteOpCode(0x0F, 0x8F);
this.WriteImmediate(rel);
}

/// <summary>(71 cb)(rel8) オーバフローがない (OF=0) 場合short ジャンプする。</summary>
public void Jno(sbyte rel) {
this.WriteOpCode(0x71);
this.WriteImmediate(rel);
}

/// <summary>(0F 81 cw/cd)(rel16/32) オーバフローがない (OF=0) 場合near ジャンプする。</summary>
public void Jno(int rel) {
this.WriteOpCode(0x0F, 0x81);
this.WriteImmediate(rel);
}

/// <summary>(7B cb)(rel8) パリティがない (PF=0) 場合short ジャンプする。</summary>
public void Jnp(sbyte rel) {
this.WriteOpCode(0x7B);
this.WriteImmediate(rel);
}

/// <summary>(0F 8B cw/cd)(rel16/32) パリティがない (PF=0) 場合near ジャンプする。</summary>
public void Jnp(int rel) {
this.WriteOpCode(0x0F, 0x8B);
this.WriteImmediate(rel);
}

/// <summary>(79 cb)(rel8) 符号がない (SF=0) 場合short ジャンプする。</summary>
public void Jns(sbyte rel) {
this.WriteOpCode(0x79);
this.WriteImmediate(rel);
}

/// <summary>(0F 89 cw/cd)(rel16/32) 符号がない (SF=0) 場合near ジャンプする。</summary>
public void Jns(int rel) {
this.WriteOpCode(0x0F, 0x89);
this.WriteImmediate(rel);
}

/// <summary>(75 cb)(rel8) ゼロでない (ZF=0) 場合short ジャンプする。</summary>
public void Jnz(sbyte rel) {
this.WriteOpCode(0x75);
this.WriteImmediate(rel);
}

/// <summary>(0F 85 cw/cd)(rel16/32) ゼロでない (ZF=0) 場合near ジャンプする。</summary>
public void Jnz(int rel) {
this.WriteOpCode(0x0F, 0x85);
this.WriteImmediate(rel);
}

/// <summary>(70 cb)(rel8) オーバフローがある (OF=1) 場合short ジャンプする。</summary>
public void Jo(sbyte rel) {
this.WriteOpCode(0x70);
this.WriteImmediate(rel);
}

/// <summary>(0F 80 cw/cd)(rel16/32) オーバフローがある (OF=1) 場合near ジャンプする。</summary>
public void Jo(int rel) {
this.WriteOpCode(0x0F, 0x80);
this.WriteImmediate(rel);
}

/// <summary>(7A cb)(rel8) パリティがある (PF=1) 場合short ジャンプする。</summary>
public void Jp(sbyte rel) {
this.WriteOpCode(0x7A);
this.WriteImmediate(rel);
}

/// <summary>(0F 8A cw/cd)(rel16/32) パリティがある (PF=1) 場合near ジャンプする。</summary>
public void Jp(int rel) {
this.WriteOpCode(0x0F, 0x8A);
this.WriteImmediate(rel);
}

/// <summary>(7A cb)(rel8) パリティが偶数 (PF=1) の場合short ジャンプする。</summary>
public void Jpe(sbyte rel) {
this.WriteOpCode(0x7A);
this.WriteImmediate(rel);
}

/// <summary>(0F 8A cw/cd)(rel16/32) パリティが偶数 (PF=1) の場合near ジャンプする。</summary>
public void Jpe(int rel) {
this.WriteOpCode(0x0F, 0x8A);
this.WriteImmediate(rel);
}

/// <summary>(7B cb)(rel8) パリティが奇数 (PF=0) の場合short ジャンプする。</summary>
public void Jpo(sbyte rel) {
this.WriteOpCode(0x7B);
this.WriteImmediate(rel);
}

/// <summary>(0F 8B cw/cd)(rel16/32) パリティが奇数 (PF=0) の場合near ジャンプする。</summary>
public void Jpo(int rel) {
this.WriteOpCode(0x0F, 0x8B);
this.WriteImmediate(rel);
}

/// <summary>(78 cb)(rel8) 符号がある (SF=1) 場合short ジャンプする。</summary>
public void Js(sbyte rel) {
this.WriteOpCode(0x78);
this.WriteImmediate(rel);
}

/// <summary>(0F 88 cw/cd)(rel16/32) 符号がある (SF=1) 場合near ジャンプする。</summary>
public void Js(int rel) {
this.WriteOpCode(0x0F, 0x88);
this.WriteImmediate(rel);
}

/// <summary>(74 cb)(rel8) ゼロ (ZF=1) の場合short ジャンプする。</summary>
public void Jz(sbyte rel) {
this.WriteOpCode(0x74);
this.WriteImmediate(rel);
}

/// <summary>(0F 84 cw/cd)(rel16/32) ゼロ (ZF=1) の場合near ジャンプする。</summary>
public void Jz(int rel) {
this.WriteOpCode(0x0F, 0x84);
this.WriteImmediate(rel);
}

/// <summary>(9F)(AH) ← EFLAGS(SF:ZF:0:AF:0:PF:1:CF) をロードする。</summary>
public void Lahf_AH() {
this.WriteOpCode(0x9F);
}

/// <summary>(0F 02 /r)(r16,r/m16) r16 ← FF00H でマスクされたr/m16。</summary>
public void Lar(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x02);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 02 /r)(r32,r/m32) r32 ← 00FxFF00H でマスクされたr/m32。</summary>
public void Lar(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x02);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(8D /r)(r16,m) m の実効アドレスをレジスタr16 にストアする。</summary>
public void Lea(Register16 reg, RegMem rm) {
this.WriteOpCode(0x8D);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(8D /r)(r32,m) m の実効アドレスをレジスタr32 にストアする。</summary>
public void Lea(Register32 reg, RegMem rm) {
this.WriteOpCode(0x8D);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(C9)(SP) をBP に設定し、次にBP をポップする。</summary>
public void Leave_SP() {
this.WriteOpCode(0xC9);
}

/// <summary>(C9)(ESP) をEBP に設定し、次にEBP をポップする。</summary>
public void Leave_ESP() {
this.WriteOpCode(0xC9);
}

/// <summary>(0F AE /5)() ロード操作をシリアル化する。</summary>
public void Lfence() {
this.WriteOpCode(0x0F, 0xAE);
this.WriteModifiers(RegMem.Empty, 5);
}

/// <summary>(0F 00 /2)(r/m16) セグメント・セレクタr/m16 をLDTR にロードする。</summary>
public void Lldt(RegMem16 rm) {
this.WriteOpCode(0x0F, 0x00);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(0F 01 /6)(r/m16) r/m16 をCR0 のマシン・ステータス・ワードにロードす</summary>
public void Lmsw(RegMem16 rm) {
this.WriteOpCode(0x0F, 0x01);
this.WriteModifiers(rm.Value, 6);
}

/// <summary>(F0)() 後の命令の実行中LOCK# 信号をアサートする。</summary>
public void Lock() {
this.WriteOpCode(0xF0);
}

/// <summary>(AC)(m8) アドレスDS:(E)SI のバイトをAL にロードする。</summary>
public void Lods_m8() {
this.WriteOpCode(0xAC);
}

/// <summary>(AD)(m16) アドレスDS:(E)SI のワードをAX にロードする。</summary>
public void Lods_m16() {
this.WriteOpCode(0xAD);
}

/// <summary>(AD)(m32) アドレスDS:(E)SI のダブルワードをEAX にロードする。</summary>
public void Lods_m32() {
this.WriteOpCode(0xAD);
}

/// <summary>(AC)() アドレスDS:(E)SI のバイトをAL にロードする。</summary>
public void Lodsb() {
this.WriteOpCode(0xAC);
}

/// <summary>(AD)() アドレスDS:(E)SI のダブルワードをEAX にロードする。</summary>
public void Lodsd() {
this.WriteOpCode(0xAD);
}

/// <summary>(AD)() アドレスDS:(E)SI のワードをAX にロードする。</summary>
public void Lodsw() {
this.WriteOpCode(0xAD);
}

/// <summary>(E2 cb)(rel8) カウントをデクリメントし、カウント ≠ 0 の場合short</summary>
public void Loop(sbyte rel) {
this.WriteOpCode(0xE2);
this.WriteImmediate(rel);
}

/// <summary>(E1 cb)(rel8) カウントをデクリメントし、カウント ≠ 0 でかつZF=1 の</summary>
public void Loope(sbyte rel) {
this.WriteOpCode(0xE1);
this.WriteImmediate(rel);
}

/// <summary>(E0 cb)(rel8) カウントをデクリメントし、カウント ≠ 0 でかつZF=0 の</summary>
public void Loopne(sbyte rel) {
this.WriteOpCode(0xE0);
this.WriteImmediate(rel);
}

/// <summary>(E0 cb)(rel8) カウントをデクリメントし、カウント ≠ 0 でかつZF=0 の</summary>
public void Loopnz(sbyte rel) {
this.WriteOpCode(0xE0);
this.WriteImmediate(rel);
}

/// <summary>(E1 cb)(rel8) カウントをデクリメントし、カウント ≠ 0 でかつZF=1 の</summary>
public void Loopz(sbyte rel) {
this.WriteOpCode(0xE1);
this.WriteImmediate(rel);
}

/// <summary>(0F 03 /r)(r16,r/m16) "r16 ← セグメント範囲、セレクタr/m16 " のロードを行う。</summary>
public void Lsl(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0x03);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 03 /r)(r32,r/m32) "r32 ← セグメント範囲、セレクタr/m32 " のロードを行う。</summary>
public void Lsl(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0F, 0x03);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 00 /3)(r/m16) r/m16 をタスク・レジスタにロードする。</summary>
public void Ltr(RegMem16 rm) {
this.WriteOpCode(0x0F, 0x00);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(0F AE /6)() ロード操作とストア操作をシリアル化する。</summary>
public void Mfence() {
this.WriteOpCode(0x0F, 0xAE);
this.WriteModifiers(RegMem.Empty, 6);
}

/// <summary>(88 /r)(r/m8,r8) r8 をr/m8 に転送する。</summary>
public void Mov(RegMem8 rm, Register8 reg) {
this.WriteOpCode(0x88);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(89 /r)(r/m16,r16) r16 をr/m16 に転送する。</summary>
public void Mov(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x89);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(89 /r)(r/m32,r32) r32 をr/m32 に転送する。</summary>
public void Mov(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x89);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(8A /r)(r8,r/m8) r/m8 をr8 に転送する。</summary>
public void Mov(Register8 reg, RegMem8 rm) {
this.WriteOpCode(0x8A);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(8B /r)(r16,r/m16) r/m16 をr16 に転送する。</summary>
public void Mov(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x8B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(8B /r)(r32,r/m32) r/m32 をr32 に転送する。</summary>
public void Mov(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x8B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(B0 +rb)(r8,imm8) imm8 をr8 に転送する。</summary>
public void Mov(Register8 reg, byte imm) {
this.WriteOpCode(0xB0+(int)reg);
this.WriteImmediate(imm);
}

/// <summary>(B8 +rw)(r16,imm16) imm16 をr16 に転送する。</summary>
public void Mov(Register16 reg, ushort imm) {
this.WriteOpCode(0xB8+(int)reg);
this.WriteImmediate(imm);
}

/// <summary>(B8 +rd)(r32,imm32) imm32 をr32 に転送する。</summary>
public void Mov(Register32 reg, int imm) {
this.WriteOpCode(0xB8+(int)reg);
this.WriteImmediate(imm);
}

/// <summary>(C6 /0)(r/m8,imm8) imm8 をr/m8 に転送する。</summary>
public void Mov(RegMem8 rm, byte imm) {
this.WriteOpCode(0xC6);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(C7 /0)(r/m16,imm16) imm16 をr/m16 に転送する。</summary>
public void Mov(RegMem16 rm, ushort imm) {
this.WriteOpCode(0xC7);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(C7 /0)(r/m32,imm32) imm32 をr/m32 に転送する。</summary>
public void Mov(RegMem32 rm, int imm) {
this.WriteOpCode(0xC7);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(0F 22 /r)(CR0,r32) 0F 22 r32 をCR0 に転送する。</summary>
public void Mov_CR0(Register32 reg) {
this.WriteOpCode(0x0F, 0x22);
this.WriteModifiers(RegMem.Empty, (int)reg);
}

/// <summary>(0F 22 /r)(CR2,r32) 0F 22 r32 をCR2 に転送する。</summary>
public void Mov_CR2(Register32 reg) {
this.WriteOpCode(0x0F, 0x22);
this.WriteModifiers(RegMem.Empty, (int)reg);
}

/// <summary>(0F 22 /r)(CR3,r32) 0F 22 r32 をCR3 に転送する。</summary>
public void Mov_CR3(Register32 reg) {
this.WriteOpCode(0x0F, 0x22);
this.WriteModifiers(RegMem.Empty, (int)reg);
}

/// <summary>(0F 22 /r)(CR4,r32) 0F 22 r32 をCR4 に転送する。</summary>
public void Mov_CR4(Register32 reg) {
this.WriteOpCode(0x0F, 0x22);
this.WriteModifiers(RegMem.Empty, (int)reg);
}

/// <summary>(0F C3 /r)(m32,r32) 非テンポラルなヒントを使用して、r32 からm32 にダブル</summary>
public void Movni_m32(Register32 reg) {
this.WriteOpCode(0x0F, 0xC3);
this.WriteModifiers(RegMem.Empty, (int)reg);
}

/// <summary>(A4)(m8,m8) アドレスDS:(E)SI のバイトをアドレスES:(E)DI に転送する。</summary>
public void Movs_m8_m8() {
this.WriteOpCode(0xA4);
}

/// <summary>(A5)(m16,m16) アドレスDS:(E)SI のワードをアドレスES:(E)DI に転送する。</summary>
public void Movs_m16_m16() {
this.WriteOpCode(0xA5);
}

/// <summary>(A5)(m32,m32) アドレスDS:(E)SI のダブルワードをアドレスES:(E)DI に転送</summary>
public void Movs_m32_m32() {
this.WriteOpCode(0xA5);
}

/// <summary>(A4)() アドレスDS:(E)SI のバイトをアドレスES:(E)DI に転送する。</summary>
public void Movsb() {
this.WriteOpCode(0xA4);
}

/// <summary>(A5)() アドレスDS:(E)SI のダブルワードをアドレスES:(E)DI に転送</summary>
public void Movsd() {
this.WriteOpCode(0xA5);
}

/// <summary>(A5)() アドレスDS:(E)SI のワードをアドレスES:(E)DI に転送する。</summary>
public void Movsw() {
this.WriteOpCode(0xA5);
}

/// <summary>(0F BE /r)(r16,r/m8) バイトをワードに符号拡張して転送する。</summary>
public void Movsx(Register16 reg, RegMem8 rm) {
this.WriteOpCode(0x0F, 0xBE);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F BE /r)(r32,r/m8) バイトをダブルワードに符号拡張して転送する。</summary>
public void Movsx(Register32 reg, RegMem8 rm) {
this.WriteOpCode(0x0F, 0xBE);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F BF /r)(r32,r/m16) ワードをダブルワードに符号拡張して転送する。</summary>
public void Movsx(Register32 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0xBF);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F B6 /r)(r16,r/m8) バイトをワードにゼロ拡張して転送する。</summary>
public void Movzx(Register16 reg, RegMem8 rm) {
this.WriteOpCode(0x0F, 0xB6);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F B6 /r)(r32,r/m8) バイトをダブルワードにゼロ拡張して転送する。</summary>
public void Movzx(Register32 reg, RegMem8 rm) {
this.WriteOpCode(0x0F, 0xB6);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F B7 /r)(r32,r/m16) ワードをダブルワードにゼロ拡張して転送する。</summary>
public void Movzx(Register32 reg, RegMem16 rm) {
this.WriteOpCode(0x0F, 0xB7);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(F6 /4)(r/m8) 符号なし乗算(AX ← AL? r/m8)</summary>
public void Mul(RegMem8 rm) {
this.WriteOpCode(0xF6);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(F7 /4)(r/m16) 符号なし乗算(DX:AX ← AX ? r/m16)</summary>
public void Mul(RegMem16 rm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(F7 /4)(r/m32) 符号なし乗算(EDX:EAX ← EAX? r/m32)</summary>
public void Mul(RegMem32 rm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(F6 /3)(r/m8) 2 の補数がr/m8 をネゲートする。</summary>
public void Neg(RegMem8 rm) {
this.WriteOpCode(0xF6);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(F7 /3)(r/m16) 2 の補数がr/m16 をネゲートする。</summary>
public void Neg(RegMem16 rm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(F7 /3)(r/m32) 2 の補数がr/m32 をネゲートする。</summary>
public void Neg(RegMem32 rm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(90)() 操作なし</summary>
public void Nop() {
this.WriteOpCode(0x90);
}

/// <summary>(F6 /2)(r/m8) r/m8 の各ビットを反転する。</summary>
public void Not(RegMem8 rm) {
this.WriteOpCode(0xF6);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(F7 /2)(r/m16) r/m16 の各ビットを反転する。</summary>
public void Not(RegMem16 rm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(F7 /2)(r/m32) r/m32 の各ビットを反転する。</summary>
public void Not(RegMem32 rm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(66)() F4 /r PMULUDQ xmm1, xmm2/m128 xmm1 のパックド符号なしダブルワード整数に</summary>
public void Of() {
this.WriteOpCode(0x66);
}

/// <summary>(0C ib)(AL,imm8) AL とimm8 とのOR をとる。</summary>
public void Or_AL(byte imm) {
this.WriteOpCode(0x0C);
this.WriteImmediate(imm);
}

/// <summary>(0D iw)(AX,imm16) AX とimm16 とのOR をとる。</summary>
public void Or_AX(ushort imm) {
this.WriteOpCode(0x0D);
this.WriteImmediate(imm);
}

/// <summary>(0D id)(EAX,imm32) EAX とimm32 とのOR をとる。</summary>
public void Or_EAX(int imm) {
this.WriteOpCode(0x0D);
this.WriteImmediate(imm);
}

/// <summary>(80 /1 ib)(r/m8,imm8) r/m8 とimm8 とのOR をとる。</summary>
public void Or(RegMem8 rm, byte imm) {
this.WriteOpCode(0x80);
this.WriteModifiers(rm.Value, 1);
this.WriteImmediate(imm);
}

/// <summary>(81 /1 iw)(r/m16,imm16) r/m16 とimm16 とのOR をとる。</summary>
public void Or(RegMem16 rm, ushort imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 1);
this.WriteImmediate(imm);
}

/// <summary>(81 /1 id)(r/m32,imm32) r/m32 とimm32 とのOR をとる。</summary>
public void Or(RegMem32 rm, int imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 1);
this.WriteImmediate(imm);
}

/// <summary>(83 /1 ib)(r/m16,imm8) r/m16 とimm8( 符号拡張) とのOR をとる。</summary>
public void Or(RegMem16 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 1);
this.WriteImmediate(imm);
}

/// <summary>(83 /1 ib)(r/m32,imm8) r/m32 とimm8( 符号拡張) とのOR をとる。</summary>
public void Or(RegMem32 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 1);
this.WriteImmediate(imm);
}

/// <summary>(08 /r)(r/m8,r8) r/m8 とr8 とのOR をとる。</summary>
public void Or(RegMem8 rm, Register8 reg) {
this.WriteOpCode(0x08);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(09 /r)(r/m16,r16) r/m16 とr16 とのOR をとる。</summary>
public void Or(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x09);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(09 /r)(r/m32,r32) r/m32 とr32 とのOR をとる。</summary>
public void Or(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x09);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0A /r)(r8,r/m8) r8 とr/m8 とのOR をとる。</summary>
public void Or(Register8 reg, RegMem8 rm) {
this.WriteOpCode(0x0A);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0B /r)(r16,r/m16) r16 とr/m16 とのOR をとる。</summary>
public void Or(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x0B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0B /r)(r32,r/m32) r32 とr/m32 とのOR をとる。</summary>
public void Or(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x0B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(E6 ib)(imm8,AL) AL にあるバイトをI/O ポート・アドレスimm8 に出力する。</summary>
public void Out_AL(byte imm) {
this.WriteOpCode(0xE6);
this.WriteImmediate(imm);
}

/// <summary>(E7 ib)(imm8,AX) AX にあるワードをI/O ポート・アドレスimm8 に出力する。</summary>
public void Out_AX(byte imm) {
this.WriteOpCode(0xE7);
this.WriteImmediate(imm);
}

/// <summary>(E7 ib)(imm8,EAX) EAX にあるダブルワードをI/O ポート・アドレスimm8 に出力する。</summary>
public void Out_EAX(byte imm) {
this.WriteOpCode(0xE7);
this.WriteImmediate(imm);
}

/// <summary>(EE)(DX,AL) AL にあるバイトをDX にあるI/O ポート・アドレスに出力する。</summary>
public void Out_DX_AL() {
this.WriteOpCode(0xEE);
}

/// <summary>(EF)(DX,AX) AX にあるワードをDX にあるI/O ポート・アドレスに出力する。</summary>
public void Out_DX_AX() {
this.WriteOpCode(0xEF);
}

/// <summary>(EF)(DX,EAX) EAX にあるダブルワードをDX にあるI/O ポート・アドレスに出力する。</summary>
public void Out_DX_EAX() {
this.WriteOpCode(0xEF);
}

/// <summary>(6E)(DX,m8) バイトをDS:(E)SI に指定されたメモリ・ロケーションから</summary>
public void Outs_DX_m8() {
this.WriteOpCode(0x6E);
}

/// <summary>(6F)(DX,m16) ワードをDS:(E)SI に指定されたメモリ・ロケーションから</summary>
public void Outs_DX_m16() {
this.WriteOpCode(0x6F);
}

/// <summary>(6F)(DX,m32) ダブルワードをDS:(E)SI に指定されたメモリ・ロケーショ</summary>
public void Outs_DX_m32() {
this.WriteOpCode(0x6F);
}

/// <summary>(6E)() バイトをDS:(E)SI に指定されたメモリ・ロケーションから</summary>
public void Outsb() {
this.WriteOpCode(0x6E);
}

/// <summary>(6F)() ダブルワードをDS:(E)SI に指定されたメモリ・ロケーショ</summary>
public void Outsd() {
this.WriteOpCode(0x6F);
}

/// <summary>(6F)() ワードをDS:(E)SI に指定されたメモリ・ロケーションから</summary>
public void Outsw() {
this.WriteOpCode(0x6F);
}

/// <summary>(F3 90)() spin-wait ループのパフォーマンスを向上させるためのヒン</summary>
public void Pause() {
this.WriteOpCode(0xF3, 0x90);
}

/// <summary>(8F /0)(m16) スタックのトップをm16 にポップし、スタック・ポインタをイン</summary>
public void Pop_m16() {
this.WriteOpCode(0x8F);
this.WriteModifiers(RegMem.Empty, 0);
}

/// <summary>(8F /0)(m32) スタックのトップをm32 にポップし、スタック・ポインタをイン</summary>
public void Pop_m32() {
this.WriteOpCode(0x8F);
this.WriteModifiers(RegMem.Empty, 0);
}

/// <summary>(58 +rw)(r16) スタックのトップをr16 にポップし、スタック・ポインタをインク</summary>
public void Pop(Register16 reg) {
this.WriteOpCode(0x58+(int)reg);
}

/// <summary>(58 +rd)(r32) スタックのトップをr32 にポップし、スタック・ポインタをインク</summary>
public void Pop(Register32 reg) {
this.WriteOpCode(0x58+(int)reg);
}

/// <summary>(1F)(DS) スタックのトップをDS にポップし、スタック・ポインタをインク</summary>
public void Pop_DS() {
this.WriteOpCode(0x1F);
}

/// <summary>(07)(ES) スタックのトップをES にポップし、スタック・ポインタをインク</summary>
public void Pop_ES() {
this.WriteOpCode(0x07);
}

/// <summary>(17)(SS) スタックのトップをSS にポップし、スタック・ポインタをインク</summary>
public void Pop_SS() {
this.WriteOpCode(0x17);
}

/// <summary>(0F A1)(FS) スタックのトップをFS にポップし、スタック・ポインタをインク</summary>
public void Pop_FS() {
this.WriteOpCode(0x0F, 0xA1);
}

/// <summary>(0F A9)(GS) スタックのトップをGS にポップし、スタック・ポインタをインク</summary>
public void Pop_GS() {
this.WriteOpCode(0x0F, 0xA9);
}

/// <summary>(61)() DI、SI、BP、BX、DX、CX、およびAX をポップする。</summary>
public void Popa() {
this.WriteOpCode(0x61);
}

/// <summary>(61)() EDI、ESI、EBP、EBX、EDX、ECX、およびEAX をポップする。</summary>
public void Popad() {
this.WriteOpCode(0x61);
}

/// <summary>(9D)() スタックのトップをEFLAGS の下位16 ビットにポップする。</summary>
public void Popf() {
this.WriteOpCode(0x9D);
}

/// <summary>(9D)() スタックのトップをEFLAGS にポップする。</summary>
public void Popfd() {
this.WriteOpCode(0x9D);
}

/// <summary>(0F 18 /0)(m8) NTA ヒントを使用して、m8 のデータをプロセッサの近く</summary>
public void Prefetchnta_m8() {
this.WriteOpCode(0x0F, 0x18);
this.WriteModifiers(RegMem.Empty, 0);
}

/// <summary>(0F 18 /1)(m8) T0 ヒントを使用して、m8 のデータをプロセッサの近くに</summary>
public void Prefetcht0_m8() {
this.WriteOpCode(0x0F, 0x18);
this.WriteModifiers(RegMem.Empty, 1);
}

/// <summary>(0F 18 /2)(m8) T1 ヒントを使用して、m8 のデータをプロセッサの近くに</summary>
public void Prefetcht1_m8() {
this.WriteOpCode(0x0F, 0x18);
this.WriteModifiers(RegMem.Empty, 2);
}

/// <summary>(0F 18 /3)(m8) T2 ヒントを使用して、m8 のデータをプロセッサの近くに</summary>
public void Prefetcht2_m8() {
this.WriteOpCode(0x0F, 0x18);
this.WriteModifiers(RegMem.Empty, 3);
}

/// <summary>(FF /6)(r/m16) r/m16 をプッシュする。</summary>
public void Push(RegMem16 rm) {
this.WriteOpCode(0xFF);
this.WriteModifiers(rm.Value, 6);
}

/// <summary>(FF /6)(r/m32) r/m32 をプッシュする。</summary>
public void Push(RegMem32 rm) {
this.WriteOpCode(0xFF);
this.WriteModifiers(rm.Value, 6);
}

/// <summary>(50 +rw)(r16) r16 をプッシュする。</summary>
public void Push(Register16 reg) {
this.WriteOpCode(0x50+(int)reg);
}

/// <summary>(50 +rd)(r32) r32 をプッシュする。</summary>
public void Push(Register32 reg) {
this.WriteOpCode(0x50+(int)reg);
}

/// <summary>(6A)(imm8) imm8 をプッシュする。</summary>
public void Push(byte imm) {
this.WriteOpCode(0x6A);
this.WriteImmediate(imm);
}

/// <summary>(68)(imm16) imm16 をプッシュする。</summary>
public void Push(ushort imm) {
this.WriteOpCode(0x68);
this.WriteImmediate(imm);
}

/// <summary>(68)(imm32) imm32 をプッシュする。</summary>
public void Push(int imm) {
this.WriteOpCode(0x68);
this.WriteImmediate(imm);
}

/// <summary>(0E)(CS) CS をプッシュする。</summary>
public void Push_CS() {
this.WriteOpCode(0x0E);
}

/// <summary>(16)(SS) SS をプッシュする。</summary>
public void Push_SS() {
this.WriteOpCode(0x16);
}

/// <summary>(1E)(DS) DS をプッシュする。</summary>
public void Push_DS() {
this.WriteOpCode(0x1E);
}

/// <summary>(06)(ES) ES をプッシュする。</summary>
public void Push_ES() {
this.WriteOpCode(0x06);
}

/// <summary>(0F A0)(FS) FS をプッシュする。</summary>
public void Push_FS() {
this.WriteOpCode(0x0F, 0xA0);
}

/// <summary>(0F A8)(GS) GS をプッシュする。</summary>
public void Push_GS() {
this.WriteOpCode(0x0F, 0xA8);
}

/// <summary>(60)() AX、CX、DX、BX、元のSP、BP、SI、およびDI をプッ</summary>
public void Pusha() {
this.WriteOpCode(0x60);
}

/// <summary>(60)() EAX、ECX、EDX、EBX、元のESP、EBP、ESI、および</summary>
public void Pushad() {
this.WriteOpCode(0x60);
}

/// <summary>(9C)() EFLAGS の下位16 ビットをプッシュする。</summary>
public void Pushf() {
this.WriteOpCode(0x9C);
}

/// <summary>(9C)() EFLAGS をプッシュする。</summary>
public void Pushfd() {
this.WriteOpCode(0x9C);
}

/// <summary>(D0 /2)(r/m8,1) 9 ビット(CF、r/m8) を左に1 回回転させる。</summary>
public void Rcl(RegMem8 rm) {
this.WriteOpCode(0xD0);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(D2 /2)(r/m8,CL) 9 ビット(CF、r/m8) を左にCL 回回転させる。</summary>
public void Rcl_CL(RegMem8 rm) {
this.WriteOpCode(0xD2);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(C0 /2 ib)(r/m8,imm8) 9 ビット(CF、r/m8) を左にimm8 回回転させる。</summary>
public void Rcl(RegMem8 rm, byte imm) {
this.WriteOpCode(0xC0);
this.WriteModifiers(rm.Value, 2);
this.WriteImmediate(imm);
}

/// <summary>(D1 /2)(r/m16,1) 17 ビット(CF、r/m16) を左に1 回回転させる。</summary>
public void Rcl(RegMem16 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(D3 /2)(r/m16,CL) 17 ビット(CF、r/m16) を左にCL 回回転させる。</summary>
public void Rcl_CL(RegMem16 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(C1 /2 ib)(r/m16,imm8) 17 ビット(CF、r/m16) を左にimm8 回回転させる。</summary>
public void Rcl(RegMem16 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 2);
this.WriteImmediate(imm);
}

/// <summary>(D1 /2)(r/m32,1) 33 ビット(CF、r/m32) を左に1 回回転させる。</summary>
public void Rcl(RegMem32 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(D3 /2)(r/m32,CL) 33 ビット(CF、r/m32) を左にCL 回回転させる。</summary>
public void Rcl_CL(RegMem32 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 2);
}

/// <summary>(C1 /2 ib)(r/m32,imm8) 33 ビット(CF、r/m32) を左にimm8 回回転させる。</summary>
public void Rcl(RegMem32 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 2);
this.WriteImmediate(imm);
}

/// <summary>(D0 /3)(r/m8,1) 9 ビット(CF、r/m8) を右に1 回回転させる。</summary>
public void Rcr(RegMem8 rm) {
this.WriteOpCode(0xD0);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(D2 /3)(r/m8,CL) 9 ビット(CF、r/m8) を右にCL 回回転させる。</summary>
public void Rcr_CL(RegMem8 rm) {
this.WriteOpCode(0xD2);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(C0 /3 ib)(r/m8,imm8) 9 ビット(CF、r/m8) を右にimm8 回回転させる。</summary>
public void Rcr(RegMem8 rm, byte imm) {
this.WriteOpCode(0xC0);
this.WriteModifiers(rm.Value, 3);
this.WriteImmediate(imm);
}

/// <summary>(D1 /3)(r/m16,1) 17 ビット(CF、r/m16) を右に1 回回転させる。</summary>
public void Rcr(RegMem16 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(D3 /3)(r/m16,CL) 17 ビット(CF、r/m16) を右にCL 回回転させる。</summary>
public void Rcr_CL(RegMem16 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(C1 /3 ib)(r/m16,imm8) 17 ビット(CF、r/m16) を右にimm8 回回転させる。</summary>
public void Rcr(RegMem16 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 3);
this.WriteImmediate(imm);
}

/// <summary>(D1 /3)(r/m32,1) 33 ビット(CF、r/m32) を右に1 回回転させる。</summary>
public void Rcr(RegMem32 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(D3 /3)(r/m32,CL) 33 ビット(CF、r/m32) を右にCL 回回転させる。</summary>
public void Rcr_CL(RegMem32 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 3);
}

/// <summary>(C1 /3 ib)(r/m32,imm8) 33 ビット(CF、r/m32) を右にimm8 回回転させる。</summary>
public void Rcr(RegMem32 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 3);
this.WriteImmediate(imm);
}

/// <summary>(0F 32)(ECX) によって指定されるMSR をEDX:EAX にロードする。</summary>
public void Rdmsr_ECX() {
this.WriteOpCode(0x0F, 0x32);
}

/// <summary>(0F 33)(ECX) によって指定される性能モニタリング・カウンタを</summary>
public void Rdpmc_ECX() {
this.WriteOpCode(0x0F, 0x33);
}

/// <summary>(0F 31)() タイムスタンプ・カウンタをEDX:EAX に読み込む。</summary>
public void Rdtsc() {
this.WriteOpCode(0x0F, 0x31);
}

/// <summary>(F3 6C)(r/m8,DX) (E)CX のバイトをポートDX からES:[(E)DI] に入力する。</summary>
public void Rep_ins_DX(RegMem8 rm) {
this.WriteOpCode(0xF3, 0x6C);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(F3 6D)(r/m16,DX) (E)CX のワードをポートDX からES:[(E)DI] に入力する。</summary>
public void Rep_ins_DX(RegMem16 rm) {
this.WriteOpCode(0xF3, 0x6D);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(F3 6D)(r/m32,DX) (E)CX のダブルワードをポートDX からES:[(E)DI] に入力する。</summary>
public void Rep_ins_DX(RegMem32 rm) {
this.WriteOpCode(0xF3, 0x6D);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(F3 AC)(AL) (E)CX のバイトをDS:[(E)SI] からAL にロードする。</summary>
public void Rep_lods_AL() {
this.WriteOpCode(0xF3, 0xAC);
}

/// <summary>(F3 AD)(AX) (E)CX のワードをDS:[(E)SI] からAX にロードする。</summary>
public void Rep_lods_AX() {
this.WriteOpCode(0xF3, 0xAD);
}

/// <summary>(F3 AD)(EAX) (E)CX のダブルワードをDS:[(E)SI] からEAX にロードする。</summary>
public void Rep_lods_EAX() {
this.WriteOpCode(0xF3, 0xAD);
}

/// <summary>(F3 A4)(m8,m8) (E)CX のバイトをDS:[(E)SI] からES:[(E)DI] に転送する。</summary>
public void Rep_movs_m8_m8() {
this.WriteOpCode(0xF3, 0xA4);
}

/// <summary>(F3 A5)(m16,m16) (E)CX のワードをDS:[(E)SI] からES:[(E)DI] に転送する。</summary>
public void Rep_movs_m16_m16() {
this.WriteOpCode(0xF3, 0xA5);
}

/// <summary>(F3 A5)(m32,m32) (E)CX のダブルワードをDS:[(E)SI] からES:[(E)DI] に転送す</summary>
public void Rep_movs_m32_m32() {
this.WriteOpCode(0xF3, 0xA5);
}

/// <summary>(F3 6E)(DX,r/m8) (E)CX のバイトをDS:[(E)SI] からポートDX に出力する。</summary>
public void Rep_outs_DX(RegMem8 rm) {
this.WriteOpCode(0xF3, 0x6E);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(F3 6F)(DX,r/m16) (E)CX のワードをDS:[(E)SI] からポートDX に出力する。</summary>
public void Rep_outs_DX(RegMem16 rm) {
this.WriteOpCode(0xF3, 0x6F);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(F3 6F)(DX,r/m32) (E)CX のダブルワードをDS:[(E)SI] からポートDX に出力する。</summary>
public void Rep_outs_DX(RegMem32 rm) {
this.WriteOpCode(0xF3, 0x6F);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(F3 AA)(m8) ES:[(E)DI] にある(E)CX のバイトをAL で埋める。</summary>
public void Rep_stos_m8() {
this.WriteOpCode(0xF3, 0xAA);
}

/// <summary>(F3 AB)(m16) ES:[(E)DI] にある(E)CX のワードをAX で埋める。</summary>
public void Rep_stos_m16() {
this.WriteOpCode(0xF3, 0xAB);
}

/// <summary>(F3 AB)(m32) ES:[(E)DI] にある(E)CX のダブルワードをEAX で埋める。</summary>
public void Rep_stos_m32() {
this.WriteOpCode(0xF3, 0xAB);
}

/// <summary>(F3 A6)(m8,m8) ES:[(E)DI] とDS:[(E)SI] にある一致していないバイトを探す。</summary>
public void Repe_cmps_m8_m8() {
this.WriteOpCode(0xF3, 0xA6);
}

/// <summary>(F3 A7)(m16,m16) ES:[(E)DI] とDS:[(E)SI] にある一致していないワードを探す。</summary>
public void Repe_cmps_m16_m16() {
this.WriteOpCode(0xF3, 0xA7);
}

/// <summary>(F3 A7)(m32,m32) ES:[(E)DI] とDS:[(E)SI] にある一致していないダブルワードを</summary>
public void Repe_cmps_m32_m32() {
this.WriteOpCode(0xF3, 0xA7);
}

/// <summary>(F3 AE)(m8) ES:[(E)DI] で始まるAL でないバイトを探す。</summary>
public void Repe_scas_m8() {
this.WriteOpCode(0xF3, 0xAE);
}

/// <summary>(F3 AF)(m16) ES:[(E)DI] で始まるAX でないワードを探す。</summary>
public void Repe_scas_m16() {
this.WriteOpCode(0xF3, 0xAF);
}

/// <summary>(F3 AF)(m32) ES:[(E)DI] で始まるEAX でないダブルワードを探す。</summary>
public void Repe_scas_m32() {
this.WriteOpCode(0xF3, 0xAF);
}

/// <summary>(F2 A6)(m8,m8) ES:[(E)DI] とDS:[(E)SI] にある一致しているバイトを探す。</summary>
public void Repne_cmps_m8_m8() {
this.WriteOpCode(0xF2, 0xA6);
}

/// <summary>(F2 A7)(m16,m16) ES:[(E)DI] とDS:[(E)SI] にある一致しているワードを探す。</summary>
public void Repne_cmps_m16_m16() {
this.WriteOpCode(0xF2, 0xA7);
}

/// <summary>(F2 A7)(m32,m32) ES:[(E)DI] とDS:[(E)SI] にある一致しているダブルワードを探</summary>
public void Repne_cmps_m32_m32() {
this.WriteOpCode(0xF2, 0xA7);
}

/// <summary>(F2 AE)(m8) ES:[(E)DI] で始まるAL を探す。</summary>
public void Repne_scas_m8() {
this.WriteOpCode(0xF2, 0xAE);
}

/// <summary>(F2 AF)(m16) ES:[(E)DI] で始まるAX を探す。</summary>
public void Repne_scas_m16() {
this.WriteOpCode(0xF2, 0xAF);
}

/// <summary>(F2 AF)(m32) ES:[(E)DI] で始まるEAX を探す。</summary>
public void Repne_scas_m32() {
this.WriteOpCode(0xF2, 0xAF);
}

/// <summary>(C3)() コール元プロシージャにnear リターンする。</summary>
public void Ret() {
this.WriteOpCode(0xC3);
}

/// <summary>(C2 iw)(imm16) コール元プロシージャにnear リターンし、imm16 バイト</summary>
public void Ret(ushort imm) {
this.WriteOpCode(0xC2);
this.WriteImmediate(imm);
}

/// <summary>(CB)() コール元プロシージャにfar リターンする。</summary>
public void Retf() {
this.WriteOpCode(0xCB);
}

/// <summary>(CA iw)(imm16) コール元プロシージャにfar リターンし、imm16 バイトを</summary>
public void Retf(ushort imm) {
this.WriteOpCode(0xCA);
this.WriteImmediate(imm);
}

/// <summary>(D0 /0)(r/m8,1) 8 ビットr/m8 を左に1 回回転させる。</summary>
public void Rol(RegMem8 rm) {
this.WriteOpCode(0xD0);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(D2 /0)(r/m8,CL) 8 ビットr/m8 を左にCL 回回転させる。</summary>
public void Rol_CL(RegMem8 rm) {
this.WriteOpCode(0xD2);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(C0 /0 ib)(r/m8,imm8) 8 ビットr/m8 を左にimm8 回回転させる。</summary>
public void Rol(RegMem8 rm, byte imm) {
this.WriteOpCode(0xC0);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(D1 /0)(r/m16,1) 16 ビットr/m16 を左に1 回回転させる。</summary>
public void Rol(RegMem16 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(D3 /0)(r/m16,CL) 16 ビットr/m16 を左にCL 回回転させる。</summary>
public void Rol_CL(RegMem16 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(C1 /0 ib)(r/m16,imm8) 16 ビットr/m16 を左にimm8 回回転させる。</summary>
public void Rol(RegMem16 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(D1 /0)(r/m32,1) 32 ビットr/m32 を左に1 回回転させる。</summary>
public void Rol(RegMem32 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(D3 /0)(r/m32,CL) 32 ビットr/m32 を左にCL 回回転させる。</summary>
public void Rol_CL(RegMem32 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(C1 /0 ib)(r/m32,imm8) 32 ビットr/m32 を左にimm8 回回転させる。</summary>
public void Rol(RegMem32 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(D0 /1)(r/m8,1) 8 ビットr/m8 を右に1 回回転させる。</summary>
public void Ror(RegMem8 rm) {
this.WriteOpCode(0xD0);
this.WriteModifiers(rm.Value, 1);
}

/// <summary>(D2 /1)(r/m8,CL) 8 ビットr/m8 を右にCL 回回転させる。</summary>
public void Ror_CL(RegMem8 rm) {
this.WriteOpCode(0xD2);
this.WriteModifiers(rm.Value, 1);
}

/// <summary>(C0 /1 ib)(r/m8,imm8) 8 ビットr/m8 を右にimm8 回回転させる。</summary>
public void Ror(RegMem8 rm, byte imm) {
this.WriteOpCode(0xC0);
this.WriteModifiers(rm.Value, 1);
this.WriteImmediate(imm);
}

/// <summary>(D1 /1)(r/m16,1) 16 ビットr/m16 を右に1 回回転させる。</summary>
public void Ror(RegMem16 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 1);
}

/// <summary>(D3 /1)(r/m16,CL) 16 ビットr/m16 を右にCL 回回転させる。</summary>
public void Ror_CL(RegMem16 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 1);
}

/// <summary>(C1 /1 ib)(r/m16,imm8) 16 ビットr/m16 を右にimm8 回回転させる。</summary>
public void Ror(RegMem16 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 1);
this.WriteImmediate(imm);
}

/// <summary>(D1 /1)(r/m32,1) 32 ビットr/m32 を右に1 回回転させる。</summary>
public void Ror(RegMem32 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 1);
}

/// <summary>(D3 /1)(r/m32,CL) 32 ビットr/m32 を右にCL 回回転させる。</summary>
public void Ror_CL(RegMem32 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 1);
}

/// <summary>(C1 /1 ib)(r/m32,imm8) 32 ビットr/m32 を右にimm8 回回転させる。</summary>
public void Ror(RegMem32 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 1);
this.WriteImmediate(imm);
}

/// <summary>(0F AA)() 割り込まれたプログラムの動作を再開する。</summary>
public void Rsm() {
this.WriteOpCode(0x0F, 0xAA);
}

/// <summary>(D0 /4)(r/m8,1) r/m8 に2 を1 回掛ける。</summary>
public void Sal(RegMem8 rm) {
this.WriteOpCode(0xD0);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(D2 /4)(r/m8,CL) r/m8 に2 をCL 回掛ける。</summary>
public void Sal_CL(RegMem8 rm) {
this.WriteOpCode(0xD2);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(C0 /4 ib)(r/m8,imm8) r/m8 に2 をimm8 回掛ける。</summary>
public void Sal(RegMem8 rm, byte imm) {
this.WriteOpCode(0xC0);
this.WriteModifiers(rm.Value, 4);
this.WriteImmediate(imm);
}

/// <summary>(D1 /4)(r/m16,1) r/m16 に2 を1 回掛ける。</summary>
public void Sal(RegMem16 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(D3 /4)(r/m16,CL) r/m16 に2 をCL 回掛ける。</summary>
public void Sal_CL(RegMem16 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(C1 /4 ib)(r/m16,imm8) r/m16 に2 をimm8 回掛ける。</summary>
public void Sal(RegMem16 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 4);
this.WriteImmediate(imm);
}

/// <summary>(D1 /4)(r/m32,1) r/m32 に2 を1 回掛ける。</summary>
public void Sal(RegMem32 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(D3 /4)(r/m32,CL) r/m32 に2 をCL 回掛ける。</summary>
public void Sal_CL(RegMem32 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(C1 /4 ib)(r/m32,imm8) r/m32 に2 をimm8 回掛ける。</summary>
public void Sal(RegMem32 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 4);
this.WriteImmediate(imm);
}

/// <summary>(D0 /7)(r/m8,1) r/m8 を2 で1 回符号付き除算する。*</summary>
public void Sar(RegMem8 rm) {
this.WriteOpCode(0xD0);
this.WriteModifiers(rm.Value, 7);
}

/// <summary>(D2 /7)(r/m8,CL) r/m8 を2 でCL 回符号付き除算する。*</summary>
public void Sar_CL(RegMem8 rm) {
this.WriteOpCode(0xD2);
this.WriteModifiers(rm.Value, 7);
}

/// <summary>(C0 /7 ib)(r/m8,imm8) r/m8 を2 でimm8 回符号付き除算する。*</summary>
public void Sar(RegMem8 rm, byte imm) {
this.WriteOpCode(0xC0);
this.WriteModifiers(rm.Value, 7);
this.WriteImmediate(imm);
}

/// <summary>(D1 /7)(r/m16,1) r/m16 を2 で1 回符号付き除算する。*</summary>
public void Sar(RegMem16 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 7);
}

/// <summary>(D3 /7)(r/m16,CL) r/m16 を2 でCL 回符号付き除算する。*</summary>
public void Sar_CL(RegMem16 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 7);
}

/// <summary>(C1 /7 ib)(r/m16,imm8) r/m16 を2 でimm8 回符号付き除算する。*</summary>
public void Sar(RegMem16 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 7);
this.WriteImmediate(imm);
}

/// <summary>(D1 /7)(r/m32,1) r/m32 を2 で1 回符号付き除算する。*</summary>
public void Sar(RegMem32 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 7);
}

/// <summary>(D3 /7)(r/m32,CL) r/m32 を2 でCL 回符号付き除算する。*</summary>
public void Sar_CL(RegMem32 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 7);
}

/// <summary>(C1 /7 ib)(r/m32,imm8) r/m32 を2 でimm8 回符号付き除算する。*</summary>
public void Sar(RegMem32 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 7);
this.WriteImmediate(imm);
}

/// <summary>(1C ib)(AL,imm8) AL から imm8 をボローありで引く。</summary>
public void Sbb_AL(byte imm) {
this.WriteOpCode(0x1C);
this.WriteImmediate(imm);
}

/// <summary>(1D iw)(AX,imm16) AX から imm16 をボローありで引く。</summary>
public void Sbb_AX(ushort imm) {
this.WriteOpCode(0x1D);
this.WriteImmediate(imm);
}

/// <summary>(1D id)(EAX,imm32) EAX から imm32 をボローありで引く。</summary>
public void Sbb_EAX(int imm) {
this.WriteOpCode(0x1D);
this.WriteImmediate(imm);
}

/// <summary>(80 /3 ib)(r/m8,imm8) r/m8 からimm8 をボローありで引く。</summary>
public void Sbb(RegMem8 rm, byte imm) {
this.WriteOpCode(0x80);
this.WriteModifiers(rm.Value, 3);
this.WriteImmediate(imm);
}

/// <summary>(81 /3 iw)(r/m16,imm16) r/m16 からimm16 をボローありで引く。</summary>
public void Sbb(RegMem16 rm, ushort imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 3);
this.WriteImmediate(imm);
}

/// <summary>(81 /3 id)(r/m32,imm32) r/m32 からimm32 をボローありで引く。</summary>
public void Sbb(RegMem32 rm, int imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 3);
this.WriteImmediate(imm);
}

/// <summary>(83 /3 ib)(r/m16,imm8) r/m16 から符号拡張されたimm8 をボローありで引く。</summary>
public void Sbb(RegMem16 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 3);
this.WriteImmediate(imm);
}

/// <summary>(83 /3 ib)(r/m32,imm8) r/m32 から符号拡張されたimm8 をボローありで引く。</summary>
public void Sbb(RegMem32 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 3);
this.WriteImmediate(imm);
}

/// <summary>(18 /r)(r/m8,r8) r/m8 からr8 をボローありで引く。</summary>
public void Sbb(RegMem8 rm, Register8 reg) {
this.WriteOpCode(0x18);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(19 /r)(r/m16,r16) r/m16 からr16 をボローありで引く。</summary>
public void Sbb(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x19);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(19 /r)(r/m32,r32) r/m32 からr32 をボローありで引く。</summary>
public void Sbb(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x19);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(1A /r)(r8,r/m8) r8 からr/m8 をボローありで引く。</summary>
public void Sbb(Register8 reg, RegMem8 rm) {
this.WriteOpCode(0x1A);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(1B /r)(r16,r/m16) r16 からr/m16 をボローありで引く。</summary>
public void Sbb(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x1B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(1B /r)(r32,r/m32) r32 からr/m32 をボローありで引く。</summary>
public void Sbb(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x1B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(AE)(m8) AL をES:(E)DI のバイトと比較し、ステータス・フラグを設定する。</summary>
public void Scas_m8() {
this.WriteOpCode(0xAE);
}

/// <summary>(AF)(m16) AX をES:(E)DI のワードと比較し、ステータス・フラグを設定する。</summary>
public void Scas_m16() {
this.WriteOpCode(0xAF);
}

/// <summary>(AF)(m32) EAX をES:(E)DI のダブルワードと比較し、ステータス・フラグを設定</summary>
public void Scas_m32() {
this.WriteOpCode(0xAF);
}

/// <summary>(AE)(AL) をES:(E)DI のバイトと比較し、ステータス・フラグを設定する。</summary>
public void Scasb_AL() {
this.WriteOpCode(0xAE);
}

/// <summary>(AF)(EAX) をES:(E)DI のダブルワードと比較し、ステータス・フラグを設定</summary>
public void Scasd_EAX() {
this.WriteOpCode(0xAF);
}

/// <summary>(AF)(AX) をES:(E)DI のワードと比較し、ステータス・フラグを設定する。</summary>
public void Scasw_AX() {
this.WriteOpCode(0xAF);
}

/// <summary>(0F 97)(r/m8) より上(CF=0 およびZF=0) の場合バイトを設定する。</summary>
public void Seta(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x97);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 93)(r/m8) より上か等しい(CF=0) 場合バイトを設定する。</summary>
public void Setae(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x93);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 92)(r/m8) より下(CF=1) の場合バイトを設定する。</summary>
public void Setb(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x92);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 96)(r/m8) より下か等しい(CF=1 またはZF=1) 場合バイトを設定する。</summary>
public void Setbe(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x96);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 92)(r/m8) キャリーがある(CF=1) 場合設定する。</summary>
public void Setc(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x92);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 94)(r/m8) 等しい(ZF=1) 場合バイトを設定する。</summary>
public void Sete(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x94);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 9F)(r/m8) より大きい(ZF=0 およびSF=OF) 場合バイトを設定する。</summary>
public void Setg(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x9F);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 9D)(r/m8) より大きいか等しい(SF=OF) 場合バイトを設定する。</summary>
public void Setge(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x9D);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 9C)(r/m8) より小さい(SF<>OF) 場合バイトを設定する。</summary>
public void Setl(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x9C);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 9E)(r/m8) より小さいか等しい(ZF=1 またはSF<>OF) 場合バイトを設定す</summary>
public void Setle(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x9E);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 96)(r/m8) より上でない(CF=1 またはZF=1) 場合バイトを設定する。</summary>
public void Setna(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x96);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 92)(r/m8) より上でなく等しくない(CF=1) 場合バイトを設定する。</summary>
public void Setnae(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x92);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 93)(r/m8) より下でない(CF=0) 場合バイトを設定する。</summary>
public void Setnb(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x93);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 97)(r/m8) より下でなく等しくない(CF=0 およびZF=0) 場合バイトを設定</summary>
public void Setnbe(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x97);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 93)(r/m8) キャリーがない(CF=0) 場合バイトを設定する。</summary>
public void Setnc(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x93);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 95)(r/m8) 等しくない(ZF=0) 場合バイトを設定する。</summary>
public void Setne(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x95);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 9E)(r/m8) より大きくない(ZF=1 またはSF<>OF) 場合バイトを設定する。</summary>
public void Setng(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x9E);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 9C)(r/m8) より大きくなく等しくない(SF<>OF) 場合設定する。</summary>
public void Setnge(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x9C);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 9D)(r/m8) より小さくない(SF=OF) 場合バイトを設定する。</summary>
public void Setnl(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x9D);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 9F)(r/m8) より小さくなく等しくない(ZF=0 およびSF=OF) 場合バイトを</summary>
public void Setnle(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x9F);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 91)(r/m8) オーバフローがない(OF=0) 場合バイトを設定する。</summary>
public void Setno(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x91);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 9B)(r/m8) パリティがない(PF=0) 場合バイトを設定する。</summary>
public void Setnp(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x9B);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 99)(r/m8) 符号がない(SF=0) 場合バイトを設定する。</summary>
public void Setns(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x99);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 95)(r/m8) ゼロでない(ZF=0) 場合バイトを設定する。</summary>
public void Setnz(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x95);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 90)(r/m8) オーバフローがある(OF=1) 場合バイトを設定する。</summary>
public void Seto(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x90);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 9A)(r/m8) パリティがある(PF=1) 場合バイトを設定する。</summary>
public void Setp(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x9A);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 9A)(r/m8) パリティが偶数(PF=1) の場合バイトを設定する。</summary>
public void Setpe(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x9A);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 9B)(r/m8) パリティが奇数(PF=0) の場合バイトを設定する。</summary>
public void Setpo(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x9B);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 98)(r/m8) 符号がある(SF=1) 場合バイトを設定する。</summary>
public void Sets(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x98);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 94)(r/m8) ゼロ(ZF=1) の場合バイトを設定する。</summary>
public void Setz(RegMem8 rm) {
this.WriteOpCode(0x0F, 0x94);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F AE /7)() ストア操作をシリアル化する。</summary>
public void Sfence() {
this.WriteOpCode(0x0F, 0xAE);
this.WriteModifiers(RegMem.Empty, 7);
}

/// <summary>(0F 01 /0)(m) GDTR をm にストアする。</summary>
public void Sgdt(RegMem rm) {
this.WriteOpCode(0x0F, 0x01);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(D0 /4)(r/m8,1) r/m8 に2 を1 回掛ける。</summary>
public void Shl(RegMem8 rm) {
this.WriteOpCode(0xD0);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(D2 /4)(r/m8,CL) r/m8 に2 をCL 回掛ける。</summary>
public void Shl_CL(RegMem8 rm) {
this.WriteOpCode(0xD2);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(C0 /4 ib)(r/m8,imm8) r/m8 に2 をimm8 回掛ける。</summary>
public void Shl(RegMem8 rm, byte imm) {
this.WriteOpCode(0xC0);
this.WriteModifiers(rm.Value, 4);
this.WriteImmediate(imm);
}

/// <summary>(D1 /4)(r/m16,1) r/m16 に2 を1 回掛ける。</summary>
public void Shl(RegMem16 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(D3 /4)(r/m16,CL) r/m16 に2 をCL 回掛ける。</summary>
public void Shl_CL(RegMem16 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(C1 /4 ib)(r/m16,imm8) r/m16 に2 をimm8 回掛ける。</summary>
public void Shl(RegMem16 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 4);
this.WriteImmediate(imm);
}

/// <summary>(D1 /4)(r/m32,1) r/m32 に2 を1 回掛ける。</summary>
public void Shl(RegMem32 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(D3 /4)(r/m32,CL) r/m32 に2 をCL 回掛ける。</summary>
public void Shl_CL(RegMem32 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(C1 /4 ib)(r/m32,imm8) r/m32 に2 をimm8 回掛ける。</summary>
public void Shl(RegMem32 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 4);
this.WriteImmediate(imm);
}

/// <summary>(0F A4)(r/m16,r16,imm8) r/m16 を左にimm8 位置シフトし、r16 からのビットを右か</summary>
public void Shld(RegMem16 rm, Register16 reg, byte imm) {
this.WriteOpCode(0x0F, 0xA4);
this.WriteModifiers(rm.Value, (int)reg);
this.WriteImmediate(imm);
}

/// <summary>(0F A5)(r/m16,r16,CL) r/m16 を左にCL 位置シフトし、r16 からのビットを右から</summary>
public void Shld_CL(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x0F, 0xA5);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F A4)(r/m32,r32,imm8) r/m32 を左にimm8 位置シフトし、r32 からのビットを右か</summary>
public void Shld(RegMem32 rm, Register32 reg, byte imm) {
this.WriteOpCode(0x0F, 0xA4);
this.WriteModifiers(rm.Value, (int)reg);
this.WriteImmediate(imm);
}

/// <summary>(0F A5)(r/m32,r32,CL) r/m32 を左にCL 位置シフトし、r32 からのビットを右から</summary>
public void Shld_CL(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x0F, 0xA5);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(D0 /5)(r/m8,1) r/m8 を2 で1 回符号なし除算する。</summary>
public void Shr(RegMem8 rm) {
this.WriteOpCode(0xD0);
this.WriteModifiers(rm.Value, 5);
}

/// <summary>(D2 /5)(r/m8,CL) r/m8 を2 でCL 回符号なし除算する。</summary>
public void Shr_CL(RegMem8 rm) {
this.WriteOpCode(0xD2);
this.WriteModifiers(rm.Value, 5);
}

/// <summary>(C0 /5 ib)(r/m8,imm8) r/m8 を2 でimm8 回符号なし除算する。</summary>
public void Shr(RegMem8 rm, byte imm) {
this.WriteOpCode(0xC0);
this.WriteModifiers(rm.Value, 5);
this.WriteImmediate(imm);
}

/// <summary>(D1 /5)(r/m16,1) r/m16 を2 で1 回符号なし除算する。</summary>
public void Shr(RegMem16 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 5);
}

/// <summary>(D3 /5)(r/m16,CL) r/m16 を2 でCL 回符号なし除算する。</summary>
public void Shr_CL(RegMem16 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 5);
}

/// <summary>(C1 /5 ib)(r/m16,imm8) r/m16 を2 でimm8 回符号なし除算する。</summary>
public void Shr(RegMem16 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 5);
this.WriteImmediate(imm);
}

/// <summary>(D1 /5)(r/m32,1) r/m32 を2 で1 回符号なし除算する。</summary>
public void Shr(RegMem32 rm) {
this.WriteOpCode(0xD1);
this.WriteModifiers(rm.Value, 5);
}

/// <summary>(D3 /5)(r/m32,CL) r/m32 を2 でCL 回符号なし除算する。</summary>
public void Shr_CL(RegMem32 rm) {
this.WriteOpCode(0xD3);
this.WriteModifiers(rm.Value, 5);
}

/// <summary>(C1 /5 ib)(r/m32,imm8) r/m32 を2 でimm8 回符号なし除算する。</summary>
public void Shr(RegMem32 rm, byte imm) {
this.WriteOpCode(0xC1);
this.WriteModifiers(rm.Value, 5);
this.WriteImmediate(imm);
}

/// <summary>(0F AC)(r/m16,r16,imm8) r/m16 を右にimm8 位置シフトし、r16 からのビットを左か</summary>
public void Shrd(RegMem16 rm, Register16 reg, byte imm) {
this.WriteOpCode(0x0F, 0xAC);
this.WriteModifiers(rm.Value, (int)reg);
this.WriteImmediate(imm);
}

/// <summary>(0F AD)(r/m16,r16,CL) r/m16 を右にCL 位置シフトし、r16 からのビットを左から</summary>
public void Shrd_CL(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x0F, 0xAD);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F AC)(r/m32,r32,imm8) r/m32 を右にimm8 位置シフトし、r32 からのビットを左か</summary>
public void Shrd(RegMem32 rm, Register32 reg, byte imm) {
this.WriteOpCode(0x0F, 0xAC);
this.WriteModifiers(rm.Value, (int)reg);
this.WriteImmediate(imm);
}

/// <summary>(0F AD)(r/m32,r32,CL) r/m32 を右にCL 位置シフトし、r32 からのビットを左から</summary>
public void Shrd_CL(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x0F, 0xAD);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 01 /1)(m) IDTR をm にストアする。</summary>
public void Sidt(RegMem rm) {
this.WriteOpCode(0x0F, 0x01);
this.WriteModifiers(rm.Value, 1);
}

/// <summary>(0F 00 /0)(r/m16) セグメント・セレクタをLDTR からr/m16 にストアする。</summary>
public void Sldt(RegMem16 rm) {
this.WriteOpCode(0x0F, 0x00);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 00 /0)(r/m32) セグメント・セレクタをLDTR からr/m32 の下位16 ビッ</summary>
public void Sldt(RegMem32 rm) {
this.WriteOpCode(0x0F, 0x00);
this.WriteModifiers(rm.Value, 0);
}

/// <summary>(0F 01 /4)(r/m16) マシン・ステータス・ワードをr/m16 にストアする。</summary>
public void Smsw(RegMem16 rm) {
this.WriteOpCode(0x0F, 0x01);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(F9)() CF フラグをセットする。</summary>
public void Stc() {
this.WriteOpCode(0xF9);
}

/// <summary>(FD)() DF フラグをセットする。</summary>
public void Std() {
this.WriteOpCode(0xFD);
}

/// <summary>(FB)() 割り込みフラグをセットする。次の命令の最後で、外部マ</summary>
public void Sti() {
this.WriteOpCode(0xFB);
}

/// <summary>(0F AE /3)(m32) MXCSR レジスタの内容をm32 にストアする。</summary>
public void Stmxcsr_m32() {
this.WriteOpCode(0x0F, 0xAE);
this.WriteModifiers(RegMem.Empty, 3);
}

/// <summary>(AA)(m8) AL をアドレスES:(E)DI にストアする。</summary>
public void Stos_m8() {
this.WriteOpCode(0xAA);
}

/// <summary>(AB)(m16) AX をアドレスES:(E)DI にストアする。</summary>
public void Stos_m16() {
this.WriteOpCode(0xAB);
}

/// <summary>(AB)(m32) EAX をアドレスES:(E)DI にストアする。</summary>
public void Stos_m32() {
this.WriteOpCode(0xAB);
}

/// <summary>(AA)(AL) をアドレスES:(E)DI にストアする。</summary>
public void Stosb_AL() {
this.WriteOpCode(0xAA);
}

/// <summary>(AB)(EAX) をアドレスES:(E)DI にストアする。</summary>
public void Stosd_EAX() {
this.WriteOpCode(0xAB);
}

/// <summary>(AB)(AX) をアドレスES:(E)DI にストアする。</summary>
public void Stosw_AX() {
this.WriteOpCode(0xAB);
}

/// <summary>(0F 00 /1)(r/m16) セグメント・セレクタをTR からr/m16 にストアする。</summary>
public void Str(RegMem16 rm) {
this.WriteOpCode(0x0F, 0x00);
this.WriteModifiers(rm.Value, 1);
}

/// <summary>(2C ib)(AL,imm8) AL からimm8 を引く。</summary>
public void Sub_AL(byte imm) {
this.WriteOpCode(0x2C);
this.WriteImmediate(imm);
}

/// <summary>(2D iw)(AX,imm16) AX からimm16 を引く。</summary>
public void Sub_AX(ushort imm) {
this.WriteOpCode(0x2D);
this.WriteImmediate(imm);
}

/// <summary>(2D id)(EAX,imm32) EAX からimm32 を引く。</summary>
public void Sub_EAX(int imm) {
this.WriteOpCode(0x2D);
this.WriteImmediate(imm);
}

/// <summary>(80 /5 ib)(r/m8,imm8) r/m8 からimm8 を引く。</summary>
public void Sub(RegMem8 rm, byte imm) {
this.WriteOpCode(0x80);
this.WriteModifiers(rm.Value, 5);
this.WriteImmediate(imm);
}

/// <summary>(81 /5 iw)(r/m16,imm16) r/m16 からimm16 を引く。</summary>
public void Sub(RegMem16 rm, ushort imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 5);
this.WriteImmediate(imm);
}

/// <summary>(81 /5 id)(r/m32,imm32) r/m32 からimm32 を引く。</summary>
public void Sub(RegMem32 rm, int imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 5);
this.WriteImmediate(imm);
}

/// <summary>(83 /5 ib)(r/m16,imm8) r/m16 から符号拡張されたimm8 を引く。</summary>
public void Sub(RegMem16 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 5);
this.WriteImmediate(imm);
}

/// <summary>(83 /5 ib)(r/m32,imm8) r/m32 から符号拡張されたimm8 を引く。</summary>
public void Sub(RegMem32 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 5);
this.WriteImmediate(imm);
}

/// <summary>(28 /r)(r/m8,r8) r/m8 からr8 を引く。</summary>
public void Sub(RegMem8 rm, Register8 reg) {
this.WriteOpCode(0x28);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(29 /r)(r/m16,r16) r/m16 からr16 を引く。</summary>
public void Sub(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x29);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(29 /r)(r/m32,r32) r/m32 からr32 を引く。</summary>
public void Sub(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x29);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(2A /r)(r8,r/m8) r8 からr/m8 を引く。</summary>
public void Sub(Register8 reg, RegMem8 rm) {
this.WriteOpCode(0x2A);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(2B /r)(r16,r/m16) r16 からr/m16 を引く。</summary>
public void Sub(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x2B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(2B /r)(r32,r/m32) r32 からr/m32 を引く。</summary>
public void Sub(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x2B);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 34)() 特権レベル0 のシステム・プロシージャへの高速コール</summary>
public void Sysenter() {
this.WriteOpCode(0x0F, 0x34);
}

/// <summary>(0F 35)() 特権レベル3 のユーザ・コードに高速リターンする。</summary>
public void Sysexit() {
this.WriteOpCode(0x0F, 0x35);
}

/// <summary>(A8 ib)(AL,imm8) imm8 とAL とのADN をとり、結果に従ってSF、ZF、PF を設定す</summary>
public void Test_AL(byte imm) {
this.WriteOpCode(0xA8);
this.WriteImmediate(imm);
}

/// <summary>(A9 iw)(AX,imm16) imm16 とAX とのADN をとり、結果に従ってSF、ZF、PF を設定</summary>
public void Test_AX(ushort imm) {
this.WriteOpCode(0xA9);
this.WriteImmediate(imm);
}

/// <summary>(A9 id)(EAX,imm32) imm32 とEAX とのADN をとり、結果に従ってSF、ZF、PF を設</summary>
public void Test_EAX(int imm) {
this.WriteOpCode(0xA9);
this.WriteImmediate(imm);
}

/// <summary>(F6 /0 ib)(r/m8,imm8) imm8 とr/m8 とのADN をとり、結果に従ってSF、ZF、PF を設定</summary>
public void Test(RegMem8 rm, byte imm) {
this.WriteOpCode(0xF6);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(F7 /0 iw)(r/m16,imm16) imm16 とr/m16 とのADN をとり、結果に従ってSF、ZF、PF を設</summary>
public void Test(RegMem16 rm, ushort imm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(F7 /0 id)(r/m32,imm32) imm32 とr/m32 とのADN をとり、結果に従ってSF、ZF、PF を設</summary>
public void Test(RegMem32 rm, int imm) {
this.WriteOpCode(0xF7);
this.WriteModifiers(rm.Value, 0);
this.WriteImmediate(imm);
}

/// <summary>(84 /r)(r/m8,r8) r8 とr/m8 とのADN をとり、結果に従ってSF、ZF、PF を設定す</summary>
public void Test(RegMem8 rm, Register8 reg) {
this.WriteOpCode(0x84);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(85 /r)(r/m16,r16) r16 とr/m16 とのADN をとり、結果に従ってSF、ZF、PF を設定</summary>
public void Test(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x85);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(85 /r)(r/m32,r32) r32 とr/m32 とのADN をとり、結果に従ってSF、ZF、PF を設定</summary>
public void Test(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x85);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(0F 0B)() 無効オペコード例外を発生させる。</summary>
public void Ud2() {
this.WriteOpCode(0x0F, 0x0B);
}

/// <summary>(0F 00 /4)(r/m16) r/m16 で指定されたセグメントを読み取りできる場合ZF=1</summary>
public void Verr(RegMem16 rm) {
this.WriteOpCode(0x0F, 0x00);
this.WriteModifiers(rm.Value, 4);
}

/// <summary>(0F 00 /5)(r/m16) r/m16 で指定されたセグメントに書き込みできる場合ZF=1</summary>
public void Verw(RegMem16 rm) {
this.WriteOpCode(0x0F, 0x00);
this.WriteModifiers(rm.Value, 5);
}

/// <summary>(9B)() 未処理のマスクされていない浮動小数点例外をチェックする。</summary>
public void Wait() {
this.WriteOpCode(0x9B);
}

/// <summary>(0F 09)() ライトバックして内部キャッシュをフラッシュする。外部</summary>
public void Wbinvd() {
this.WriteOpCode(0x0F, 0x09);
}

/// <summary>(0F 30)() EDX:EAX の値をECX で指定されるMSR に書き込む。</summary>
public void Wrmsr() {
this.WriteOpCode(0x0F, 0x30);
}

/// <summary>(90 +rw)(r16,AX) AX をr16 と交換する。</summary>
public void Xchg_AX(Register16 reg) {
this.WriteOpCode(0x90+(int)reg);
}

/// <summary>(90 +rd)(r32,EAX) EAX をr32 と交換する。</summary>
public void Xchg_EAX(Register32 reg) {
this.WriteOpCode(0x90+(int)reg);
}

/// <summary>(86 /r)(r/m8,r8) r8( バイト・レジスタ) をr/m8 からのバイトと交換する。</summary>
public void Xchg(RegMem8 rm, Register8 reg) {
this.WriteOpCode(0x86);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(86 /r)(r8,r/m8) r/m8 からのバイトをr8( バイト・レジスタ) と交換する。</summary>
public void Xchg(Register8 reg, RegMem8 rm) {
this.WriteOpCode(0x86);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(87 /r)(r/m16,r16) r16 をr/m16 からのワードと交換する。</summary>
public void Xchg(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x87);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(87 /r)(r16,r/m16) r/m16 からのワードをr16 と交換する。</summary>
public void Xchg(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x87);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(87 /r)(r/m32,r32) r32 をr/m32 からのダブルワードと交換する。</summary>
public void Xchg(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x87);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(87 /r)(r32,r/m32) r/m32 からのダブルワードをr32 と交換する。</summary>
public void Xchg(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x87);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(D7)(m8) AL をメモリ・バイトDS:[(E)BX+ 符号なしAL] に設定する。</summary>
public void Xlat_m8() {
this.WriteOpCode(0xD7);
}

/// <summary>(D7)(AL) をメモリ・バイトDS:[(E)BX+ 符号なしAL] に設定する。</summary>
public void Xlatb_AL() {
this.WriteOpCode(0xD7);
}

/// <summary>(34 ib)(AL,imm8) AL とimm8 とのXOR をとる。</summary>
public void Xor_AL(byte imm) {
this.WriteOpCode(0x34);
this.WriteImmediate(imm);
}

/// <summary>(35 iw)(AX,imm16) AX とimm16 とのXOR をとる。</summary>
public void Xor_AX(ushort imm) {
this.WriteOpCode(0x35);
this.WriteImmediate(imm);
}

/// <summary>(35 id)(EAX,imm32) EAX とimm32 とのXOR をとる。</summary>
public void Xor_EAX(int imm) {
this.WriteOpCode(0x35);
this.WriteImmediate(imm);
}

/// <summary>(80 /6 ib)(r/m8,imm8) r/m8 とimm8 とのXOR をとる。</summary>
public void Xor(RegMem8 rm, byte imm) {
this.WriteOpCode(0x80);
this.WriteModifiers(rm.Value, 6);
this.WriteImmediate(imm);
}

/// <summary>(81 /6 iw)(r/m16,imm16) r/m16 とimm16 とのXOR をとる。</summary>
public void Xor(RegMem16 rm, ushort imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 6);
this.WriteImmediate(imm);
}

/// <summary>(81 /6 id)(r/m32,imm32) r/m32 とimm32 とのXOR をとる。</summary>
public void Xor(RegMem32 rm, int imm) {
this.WriteOpCode(0x81);
this.WriteModifiers(rm.Value, 6);
this.WriteImmediate(imm);
}

/// <summary>(83 /6 ib)(r/m16,imm8) r/m16 とimm8( 符号拡張) とのXOR をとる。</summary>
public void Xor(RegMem16 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 6);
this.WriteImmediate(imm);
}

/// <summary>(83 /6 ib)(r/m32,imm8) r/m32 とimm8( 符号拡張) とのXOR をとる。</summary>
public void Xor(RegMem32 rm, byte imm) {
this.WriteOpCode(0x83);
this.WriteModifiers(rm.Value, 6);
this.WriteImmediate(imm);
}

/// <summary>(30 /r)(r/m8,r8) r/m8 とr8 とのXOR をとる。</summary>
public void Xor(RegMem8 rm, Register8 reg) {
this.WriteOpCode(0x30);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(31 /r)(r/m16,r16) r/m16 とr16 とのXOR をとる。</summary>
public void Xor(RegMem16 rm, Register16 reg) {
this.WriteOpCode(0x31);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(31 /r)(r/m32,r32) r/m32 とr32 とのXOR をとる。</summary>
public void Xor(RegMem32 rm, Register32 reg) {
this.WriteOpCode(0x31);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(32 /r)(r8,r/m8) r8 とr/m8 とのXOR をとる。</summary>
public void Xor(Register8 reg, RegMem8 rm) {
this.WriteOpCode(0x32);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(33 /r)(r16,r/m16) r16 とr/m16 とのXOR をとる。</summary>
public void Xor(Register16 reg, RegMem16 rm) {
this.WriteOpCode(0x33);
this.WriteModifiers(rm.Value, (int)reg);
}

/// <summary>(33 /r)(r32,r/m32) r32 とr/m32 とのXOR をとる。</summary>
public void Xor(Register32 reg, RegMem32 rm) {
this.WriteOpCode(0x33);
this.WriteModifiers(rm.Value, (int)reg);
}
}}
